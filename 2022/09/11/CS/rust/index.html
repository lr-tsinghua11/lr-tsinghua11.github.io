

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Tony">
  <meta name="keywords" content="">
  
    <meta name="description" content="2022年夏季学期 rust 语言课堂笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust Notes">
<meta property="og:url" content="https://lr-tsinghua11.github.io/2022/09/11/CS/rust/index.html">
<meta property="og:site_name" content="Tony">
<meta property="og:description" content="2022年夏季学期 rust 语言课堂笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lr-tsinghua11.github.io/img/%E6%BA%AA%E4%B8%AD%E5%B0%8F%E8%88%9F.jpg">
<meta property="article:published_time" content="2022-09-11T11:33:27.000Z">
<meta property="article:modified_time" content="2023-01-21T03:26:13.000Z">
<meta property="article:author" content="Tony">
<meta property="article:tag" content="rust">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lr-tsinghua11.github.io/img/%E6%BA%AA%E4%B8%AD%E5%B0%8F%E8%88%9F.jpg">
  
  
  <title>Rust Notes - Tony</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lr-tsinghua11.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":80,"cursorChar":".","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"2d5b78dfbf046ab610d306e42da0ed37","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.1"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong> Learning_rate&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/%E6%BA%AA%E4%B8%AD%E5%B0%8F%E8%88%9F.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          <span id="subtitle" title="Rust Notes">
            
          </span>
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-11 19:33" pubdate>
          2022年9月11日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          198 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Rust Notes</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年1月21日 上午
                  
                
              </p>
            
            <div class="markdown-body">
              
              <h1 id="lecture-1">Lecture 1</h1>
<h2 id="语言特性">语言特性</h2>
<p><strong>高效：</strong>Python 解释器，java 虚拟机，而 rust
<strong>没有运行时</strong>，在 bare metal（裸机）上运行。</p>
<p>安卓基于 java，苹果 swift，有相应的垃圾回收机制，易卡顿，而 rust
没有垃圾收集机制。</p>
<p><strong>可靠：</strong>用<strong>类型系统和所有权模型</strong>来确保内存安全性和线程安全性，在编译时消除各种潜在的问题。</p>
<p><strong>好用：</strong>文档丰富，编译器（提供更改方法）。</p>
<h2 id="rust-语言应用">Rust 语言应用</h2>
<ul>
<li><p>Servo 浏览器引擎，Redox 操作系统，Linux
操作系统驱动和模块的支持</p></li>
<li><p>清华大学：操作系统教学 rCore，性能所 MadFS 文件系统，IO 500
遥遥领先</p></li>
<li><p>Cargo 能够大规模添加依赖（第三方库），不需要像 C++
花时间去寻找并下载源码</p></li>
</ul>
<h2 id="rust-基础语法">rust 基础语法</h2>
<p>C++ cin cout 读取失败时，将流转换为非法，而 rust
则会显式地处理异常</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">io::<span class="hljs-title function_ invoke__">stdin</span>()<br>  .<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess)<br>  .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"Failed to read line"</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"You guessed: {guess}"</span>);<br></code></pre></td></tr></table></figure>
<p>猜数获取数字以及猜测语句</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// (1..=100) 代表 1-100 左闭右闭</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">secret_number</span> = rand::<span class="hljs-title function_ invoke__">thread_rng</span>().<span class="hljs-title function_ invoke__">gen_range</span>(<span class="hljs-number">1</span>..=<span class="hljs-number">100</span>);<br><span class="hljs-comment">// trim()前后处理空格，parse() 解析（转换类型）</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>: <span class="hljs-type">u32</span> = guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"Please type a number!"</span>);<br></code></pre></td></tr></table></figure>
<p>变量绑定</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">17</span>; <span class="hljs-comment">// 变量绑定，且隐式推断类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i16</span> = <span class="hljs-number">17</span>; <span class="hljs-comment">// 显式绑定类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>x += <span class="hljs-number">1</span>; <span class="hljs-comment">// error: re-assignment of immutable variable x</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span> = <span class="hljs-number">5</span>;<br>y += <span class="hljs-number">1</span>; <span class="hljs-comment">// OK!</span><br></code></pre></td></tr></table></figure>
<p>变量类型</p>
<ul>
<li>布尔 bool：两个值 true/false。</li>
<li>字符 char：用单引号，例如 'R'、' 计', 是 Unicode 的。</li>
<li>数值：分为整数和浮点数，有不同的大小和符号属性。
<ul>
<li>i8、i16、i32、i64、isize</li>
<li>u8、u16、u32、u64、usize</li>
<li>f32、f64</li>
</ul></li>
<li>其中 isize 和 usize
是指针大小的整数，因此它们的大小与机器架构相关。</li>
<li>字面值 (literals) 写为 10i8、10u16、10.0f32、10usize 等。</li>
<li>字面值如果不指定类型，则默认整数为 i32，浮点数为 f64。</li>
<li>数组 (arrays)、切片 (slices)、str 字符串 (strings)、元组
(tuples)。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr1</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// (array of 3 elements)</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr2</span> = [<span class="hljs-number">2</span>; <span class="hljs-number">32</span>]; <span class="hljs-comment">// (array of 32 `2`s)</span><br><span class="hljs-comment">// 切片</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">total_slice</span> = &amp;arr; <span class="hljs-comment">// Slice all of `arr`</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">total_slice</span> = &amp;arr[..]; <span class="hljs-comment">// Same, but more explicit</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">partial_slice</span> = &amp;arr[<span class="hljs-number">2</span>..<span class="hljs-number">5</span>]; <span class="hljs-comment">// [2, 3, 4]</span><br><span class="hljs-comment">// 字符 String 和 &amp;str，可以分别当做 C++ 中的 string 和 const char*</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">"galaxy"</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>: <span class="hljs-type">String</span> = <span class="hljs-string">"galaxy"</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span>: <span class="hljs-type">String</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"galaxy"</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s4</span>: &amp;<span class="hljs-type">str</span> = &amp;s3;<br><span class="hljs-comment">// 向量</span><br><span class="hljs-comment">// Explicit typing</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v0</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = Vec::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-comment">// v1 and v2 are equal</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>v1.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br>v1.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2</span>);<br>v1.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// v3 and v4 are equal</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v3</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v4</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-comment">// 输出向量中的所有元素</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"Task 10: The array is {:?}"</span>, v2);<br></code></pre></td></tr></table></figure>
<p>类型转换</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 as 进行类型转换 (cast)</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">u32</span> = x <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br><span class="hljs-comment">// 一般来说只能在可以安全转换的类型之间进行转换操作</span><br></code></pre></td></tr></table></figure>
<p>引用</p>
<ul>
<li>在类型前面写 &amp; 表示引用类型： &amp;i32。</li>
<li>用 &amp; 来取引用（和 C++ 类似）。</li>
<li>用 * 来解引用（和 C++ 类似）。</li>
<li>rust 中引用和一般意义的指针是不一样的。</li>
</ul>
<p>条件语句</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> {<br>	<span class="hljs-number">10</span><br>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span> {<br>	<span class="hljs-number">0</span><br>} <span class="hljs-keyword">else</span> {<br>	<span class="hljs-built_in">println!</span>(<span class="hljs-string">"Not greater than zero!"</span>);<br>	-<span class="hljs-number">10</span><br>}<br></code></pre></td></tr></table></figure>
<p>循环语句，三种循环 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -3.281ex;" xmlns="http://www.w3.org/2000/svg" width="19.367ex" height="7.692ex" role="img" focusable="false" viewBox="0 -1950 8560 3400"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="23A7" d="M712 899L718 893V876V865Q718 854 704 846Q627 793 577 710T510 525Q510 524 509 521Q505 493 504 349Q504 345 504 334Q504 277 504 240Q504 -2 503 -4Q502 -8 494 -9T444 -10Q392 -10 390 -9Q387 -8 386 -5Q384 5 384 230Q384 262 384 312T383 382Q383 481 392 535T434 656Q510 806 664 892L677 899H712Z" transform="translate(0,1051)"></path><path data-c="23A9" d="M718 -893L712 -899H677L666 -893Q542 -825 468 -714T385 -476Q384 -466 384 -282Q384 3 385 5L389 9Q392 10 444 10Q486 10 494 9T503 4Q504 2 504 -239V-310V-366Q504 -470 508 -513T530 -609Q546 -657 569 -698T617 -767T661 -812T699 -843T717 -856T718 -876V-893Z" transform="translate(0,-551)"></path><path data-c="23A8" d="M389 1159Q391 1160 455 1160Q496 1160 498 1159Q501 1158 502 1155Q504 1145 504 924Q504 691 503 682Q494 549 425 439T243 259L229 250L243 241Q349 175 421 66T503 -182Q504 -191 504 -424Q504 -600 504 -629T499 -659H498Q496 -660 444 -660T390 -659Q387 -658 386 -655Q384 -645 384 -425V-282Q384 -176 377 -116T342 10Q325 54 301 92T255 155T214 196T183 222T171 232Q170 233 170 250T171 268Q171 269 191 284T240 331T300 407T354 524T383 679Q384 691 384 925Q384 1152 385 1155L389 1159Z" transform="translate(0,0)"></path><svg width="889" height="81" y="1060" x="0" viewBox="0 14.3 889 81"><path data-c="23AA" d="M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z" transform="scale(1,0.398)"></path></svg><svg width="889" height="81" y="-641" x="0" viewBox="0 14.3 889 81"><path data-c="23AA" d="M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z" transform="scale(1,0.398)"></path></svg></g><g data-mml-node="mtable" transform="translate(889,0)"><g data-mml-node="mtr" transform="translate(0,1200)"><g data-mml-node="mtd"><g data-mml-node="mtext"><path data-c="77" d="M90 368Q84 378 76 380T40 385H18V431H24L43 430Q62 430 84 429T116 428Q206 428 221 431H229V385H215Q177 383 177 368Q177 367 221 239L265 113L339 328L333 345Q323 374 316 379Q308 384 278 385H258V431H264Q270 428 348 428Q439 428 454 431H461V385H452Q404 385 404 369Q404 366 418 324T449 234T481 143L496 100L537 219Q579 341 579 347Q579 363 564 373T530 385H522V431H529Q541 428 624 428Q692 428 698 431H703V385H697Q696 385 691 385T682 384Q635 377 619 334L559 161Q546 124 528 71Q508 12 503 1T487 -11H479Q460 -11 456 -4Q455 -3 407 133L361 267Q359 263 266 -4Q261 -11 243 -11H238Q225 -11 220 -3L90 368Z"></path><path data-c="68" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 124T102 167T103 217T103 272T103 329Q103 366 103 407T103 482T102 542T102 586T102 603Q99 622 88 628T43 637H25V660Q25 683 27 683L37 684Q47 685 66 686T103 688Q120 689 140 690T170 693T181 694H184V367Q244 442 328 442Q451 442 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(722,0)"></path><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(1278,0)"></path><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z" transform="translate(1556,0)"></path><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(1834,0)"></path></g></g></g><g data-mml-node="mtr" transform="translate(0,0)"><g data-mml-node="mtd"><g data-mml-node="mtext"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(778,0)"></path><path data-c="70" d="M36 -148H50Q89 -148 97 -134V-126Q97 -119 97 -107T97 -77T98 -38T98 6T98 55T98 106Q98 140 98 177T98 243T98 296T97 335T97 351Q94 370 83 376T38 385H20V408Q20 431 22 431L32 432Q42 433 61 434T98 436Q115 437 135 438T165 441T176 442H179V416L180 390L188 397Q247 441 326 441Q407 441 464 377T522 216Q522 115 457 52T310 -11Q242 -11 190 33L182 40V-45V-101Q182 -128 184 -134T195 -145Q216 -148 244 -148H260V-194H252L228 -193Q205 -192 178 -192T140 -191Q37 -191 28 -194H20V-148H36ZM424 218Q424 292 390 347T305 402Q234 402 182 337V98Q222 26 294 26Q345 26 384 80T424 218Z" transform="translate(1278,0)"></path><path data-c="20" d="" transform="translate(1834,0)"></path><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z" transform="translate(2084,0)"></path><path data-c="20" d="" transform="translate(2862,0)"></path><path data-c="77" d="M90 368Q84 378 76 380T40 385H18V431H24L43 430Q62 430 84 429T116 428Q206 428 221 431H229V385H215Q177 383 177 368Q177 367 221 239L265 113L339 328L333 345Q323 374 316 379Q308 384 278 385H258V431H264Q270 428 348 428Q439 428 454 431H461V385H452Q404 385 404 369Q404 366 418 324T449 234T481 143L496 100L537 219Q579 341 579 347Q579 363 564 373T530 385H522V431H529Q541 428 624 428Q692 428 698 431H703V385H697Q696 385 691 385T682 384Q635 377 619 334L559 161Q546 124 528 71Q508 12 503 1T487 -11H479Q460 -11 456 -4Q455 -3 407 133L361 267Q359 263 266 -4Q261 -11 243 -11H238Q225 -11 220 -3L90 368Z" transform="translate(3112,0)"></path><path data-c="68" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 124T102 167T103 217T103 272T103 329Q103 366 103 407T103 482T102 542T102 586T102 603Q99 622 88 628T43 637H25V660Q25 683 27 683L37 684Q47 685 66 686T103 688Q120 689 140 690T170 693T181 694H184V367Q244 442 328 442Q451 442 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(3834,0)"></path><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(4390,0)"></path><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z" transform="translate(4668,0)"></path><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(4946,0)"></path><path data-c="20" d="" transform="translate(5390,0)"></path><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z" transform="translate(5640,0)"></path><path data-c="72" d="M36 46H50Q89 46 97 60V68Q97 77 97 91T98 122T98 161T98 203Q98 234 98 269T98 328L97 351Q94 370 83 376T38 385H20V408Q20 431 22 431L32 432Q42 433 60 434T96 436Q112 437 131 438T160 441T171 442H174V373Q213 441 271 441H277Q322 441 343 419T364 373Q364 352 351 337T313 322Q288 322 276 338T263 372Q263 381 265 388T270 400T273 405Q271 407 250 401Q234 393 226 386Q179 341 179 207V154Q179 141 179 127T179 101T180 81T180 66V61Q181 59 183 57T188 54T193 51T200 49T207 48T216 47T225 47T235 46T245 46H276V0H267Q249 3 140 3Q37 3 28 0H20V46H36Z" transform="translate(6029,0)"></path><path data-c="75" d="M383 58Q327 -10 256 -10H249Q124 -10 105 89Q104 96 103 226Q102 335 102 348T96 369Q86 385 36 385H25V408Q25 431 27 431L38 432Q48 433 67 434T105 436Q122 437 142 438T172 441T184 442H187V261Q188 77 190 64Q193 49 204 40Q224 26 264 26Q290 26 311 35T343 58T363 90T375 120T379 144Q379 145 379 161T380 201T380 248V315Q380 361 370 372T320 385H302V431Q304 431 378 436T457 442H464V264Q464 84 465 81Q468 61 479 55T524 46H542V0Q540 0 467 -5T390 -11H383V58Z" transform="translate(6421,0)"></path><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(6977,0)"></path><path data-c="A0" d="" transform="translate(7421,0)"></path></g></g></g><g data-mml-node="mtr" transform="translate(0,-1200)"><g data-mml-node="mtd"><g data-mml-node="mtext"><path data-c="66" d="M273 0Q255 3 146 3Q43 3 34 0H26V46H42Q70 46 91 49Q99 52 103 60Q104 62 104 224V385H33V431H104V497L105 564L107 574Q126 639 171 668T266 704Q267 704 275 704T289 705Q330 702 351 679T372 627Q372 604 358 590T321 576T284 590T270 627Q270 647 288 667H284Q280 668 273 668Q245 668 223 647T189 592Q183 572 182 497V431H293V385H185V225Q185 63 186 61T189 57T194 54T199 51T206 49T213 48T222 47T231 47T241 46T251 46H282V0H273Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(306,0)"></path><path data-c="72" d="M36 46H50Q89 46 97 60V68Q97 77 97 91T98 122T98 161T98 203Q98 234 98 269T98 328L97 351Q94 370 83 376T38 385H20V408Q20 431 22 431L32 432Q42 433 60 434T96 436Q112 437 131 438T160 441T171 442H174V373Q213 441 271 441H277Q322 441 343 419T364 373Q364 352 351 337T313 322Q288 322 276 338T263 372Q263 381 265 388T270 400T273 405Q271 407 250 401Q234 393 226 386Q179 341 179 207V154Q179 141 179 127T179 101T180 81T180 66V61Q181 59 183 57T188 54T193 51T200 49T207 48T216 47T225 47T235 46T245 46H276V0H267Q249 3 140 3Q37 3 28 0H20V46H36Z" transform="translate(806,0)"></path></g></g></g></g><g data-mml-node="mo" transform="translate(8560,0) translate(0 250)"></g></g></g></g></svg></mjx-container></span></p>
<p>迭代器</p>
<ul>
<li>n..m 创建一个从 n 到 m 半闭半开区间的迭代器。</li>
<li>n..=m 创建一个从 n 到 m 闭区间的迭代器。</li>
<li>很多数据结构可以当做迭代器来使用，比如数组、切片，还有向量 Vec
等等。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">xs</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-comment">// Loop through elements in a slice of `xs`.</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> &amp;xs {<br>	<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x);<br>}<br></code></pre></td></tr></table></figure>
<p>匹配语句，其中 <code>_</code> 匹配所有情况</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 单变量版本</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">match</span> x {<br>  <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"one fish"</span>), <span class="hljs-comment">// &lt;- comma required</span><br>  <span class="hljs-number">2</span> =&gt; {<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"two fish"</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"two fish"</span>);<br>  }, <span class="hljs-comment">// &lt;- comma optional when using braces</span><br>  _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"no fish for you"</span>), <span class="hljs-comment">// "otherwise" case</span><br>}<br><span class="hljs-comment">// 元组版本</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = -<span class="hljs-number">3</span>;<br><span class="hljs-title function_ invoke__">match</span> (x, y) {<br>  (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"one"</span>),<br>  (<span class="hljs-number">2</span>, j) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"two, {}"</span>, j),<br>  (_, <span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"three"</span>),<br>  (i, j) <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">5</span> &amp;&amp; j &lt; <span class="hljs-number">0</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"On guard!"</span>),<br>  (_, _) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">":&lt;"</span>),<br>}<br></code></pre></td></tr></table></figure>
<p>模式绑定</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (a, b) = (<span class="hljs-string">"foo"</span>, <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure>
<p>函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 函数头</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(x: T, y: U, z: V) <span class="hljs-punctuation">-&gt;</span> T {<br>	<span class="hljs-comment">// ...</span><br>}<br><span class="hljs-comment">// T 类型参数 x ，U 类型参数 y ，V 类型参数 z，返回 T 类型</span><br><span class="hljs-comment">// Rust 必须显式定义函数的参数和返回值的类型。</span><br><span class="hljs-comment">// 实际上编译器是可以推断函数的参数和返回值的类型的，但是 Rust 的设计者认为显式指定更好</span><br><br><span class="hljs-comment">// 函数返回</span><br><span class="hljs-comment">// 函数最后一个表达式是其返回值，可以使用 return 提前返回</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">square</span>(n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> {<br>	n * n<br>}<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">squareish</span>(n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> {<br>	<span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">5</span> { <span class="hljs-keyword">return</span> n; }<br>	n * n<br>}<br></code></pre></td></tr></table></figure>
<p>print! 和 println!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-string">"foo"</span>;<br><span class="hljs-built_in">print!</span>(<span class="hljs-string">"{}, {}, {}"</span>, x, <span class="hljs-number">3</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// =&gt; foo, 3, true</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}, {:?}"</span>, x, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-comment">// =&gt; "foo", [1, 2, 3]</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{0}, {y}, {0}"</span>, x);<br><span class="hljs-comment">// =&gt; foo, 1, foo</span><br><br></code></pre></td></tr></table></figure>
<p>format!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">fmted</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}, {:x}, {:?}"</span>, <span class="hljs-number">12</span>, <span class="hljs-number">155</span>, <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">"Hello"</span>));<br><span class="hljs-comment">// fmted == "12, 9b, Some("Hello")"</span><br></code></pre></td></tr></table></figure>
<p>panic! 处理错误的方式，并不优雅</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> {<br>	<span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Kaboom!"</span>);<br>}<br></code></pre></td></tr></table></figure>
<p>assert! 和 assert_eq!</p>
<ul>
<li>如果条件 condition 不成立， assert!(condition)
会导致<strong>恐慌</strong>。</li>
<li>如果 left != right， assert_eq!(left, right)
会导致<strong>恐慌</strong>。</li>
</ul>
<p>unreachable!
用于表达不会达到的分支，如果达到就会导致<strong>恐慌</strong></p>
<p>unimplemented! 标注没有实现的功能，panic!("not yet implemented")
的简写</p>
<h1 id="lecture-2">lecture 2</h1>
<p>Rust 语言最 core 的语法，语言 = 核心语法 + 标准库</p>
<h2 id="所有权">所有权</h2>
<ul>
<li><p>资源管理的需求：内存使用的安全和性能</p>
<p>内存资源：<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -3.281ex;" xmlns="http://www.w3.org/2000/svg" width="63.097ex" height="7.692ex" role="img" focusable="false" viewBox="0 -1950 27889 3400"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="23A7" d="M712 899L718 893V876V865Q718 854 704 846Q627 793 577 710T510 525Q510 524 509 521Q505 493 504 349Q504 345 504 334Q504 277 504 240Q504 -2 503 -4Q502 -8 494 -9T444 -10Q392 -10 390 -9Q387 -8 386 -5Q384 5 384 230Q384 262 384 312T383 382Q383 481 392 535T434 656Q510 806 664 892L677 899H712Z" transform="translate(0,1051)"></path><path data-c="23A9" d="M718 -893L712 -899H677L666 -893Q542 -825 468 -714T385 -476Q384 -466 384 -282Q384 3 385 5L389 9Q392 10 444 10Q486 10 494 9T503 4Q504 2 504 -239V-310V-366Q504 -470 508 -513T530 -609Q546 -657 569 -698T617 -767T661 -812T699 -843T717 -856T718 -876V-893Z" transform="translate(0,-551)"></path><path data-c="23A8" d="M389 1159Q391 1160 455 1160Q496 1160 498 1159Q501 1158 502 1155Q504 1145 504 924Q504 691 503 682Q494 549 425 439T243 259L229 250L243 241Q349 175 421 66T503 -182Q504 -191 504 -424Q504 -600 504 -629T499 -659H498Q496 -660 444 -660T390 -659Q387 -658 386 -655Q384 -645 384 -425V-282Q384 -176 377 -116T342 10Q325 54 301 92T255 155T214 196T183 222T171 232Q170 233 170 250T171 268Q171 269 191 284T240 331T300 407T354 524T383 679Q384 691 384 925Q384 1152 385 1155L389 1159Z" transform="translate(0,0)"></path><svg width="889" height="81" y="1060" x="0" viewBox="0 14.3 889 81"><path data-c="23AA" d="M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z" transform="scale(1,0.398)"></path></svg><svg width="889" height="81" y="-641" x="0" viewBox="0 14.3 889 81"><path data-c="23AA" d="M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z" transform="scale(1,0.398)"></path></svg></g><g data-mml-node="mtable" transform="translate(889,0)"><g data-mml-node="mtr" transform="translate(0,1200)"><g data-mml-node="mtd"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">全</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">局</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">对</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">象</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">：</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">事</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">先</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">分</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">配</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">内</text></g><g data-mml-node="mi" transform="translate(11000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">存</text></g><g data-mml-node="mi" transform="translate(12000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">空</text></g><g data-mml-node="mi" transform="translate(13000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">间</text></g><g data-mml-node="mi" transform="translate(14000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">段</text></g><g data-mml-node="mi" transform="translate(15000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(16000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">启</text></g><g data-mml-node="mi" transform="translate(17000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">动</text></g><g data-mml-node="mi" transform="translate(18000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(19000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">分</text></g><g data-mml-node="mi" transform="translate(20000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">配</text></g><g data-mml-node="mi" transform="translate(21000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(22000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">结</text></g><g data-mml-node="mi" transform="translate(23000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">束</text></g><g data-mml-node="mi" transform="translate(24000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(25000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">回</text></g><g data-mml-node="mi" transform="translate(26000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">收</text></g></g></g><g data-mml-node="mtr" transform="translate(0,0)"><g data-mml-node="mtd"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">局</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">部</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">对</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">象</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">：</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">分</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">配</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">在</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">栈</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">上</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(11000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">进</text></g><g data-mml-node="mi" transform="translate(12000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">入</text></g><g data-mml-node="mi" transform="translate(13000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">函</text></g><g data-mml-node="mi" transform="translate(14000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(15000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(16000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">分</text></g><g data-mml-node="mi" transform="translate(17000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">配</text></g><g data-mml-node="mi" transform="translate(18000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(19000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">退</text></g><g data-mml-node="mi" transform="translate(20000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">出</text></g><g data-mml-node="mi" transform="translate(21000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">函</text></g><g data-mml-node="mi" transform="translate(22000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(23000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(24000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">回</text></g><g data-mml-node="mi" transform="translate(25000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">收</text></g></g></g><g data-mml-node="mtr" transform="translate(0,-1200)"><g data-mml-node="mtd"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">动</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">态</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">对</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">象</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">：</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">分</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">配</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">在</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">堆</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">上</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(11000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">需</text></g><g data-mml-node="mi" transform="translate(12000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">要</text></g><g data-mml-node="mi" transform="translate(13000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(14000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">分</text></g><g data-mml-node="mi" transform="translate(15000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">配</text></g><g data-mml-node="mi" transform="translate(16000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(17000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">不</text></g><g data-mml-node="mi" transform="translate(18000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">需</text></g><g data-mml-node="mi" transform="translate(19000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">要</text></g><g data-mml-node="mi" transform="translate(20000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(21000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">回</text></g><g data-mml-node="mi" transform="translate(22000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">收</text></g></g></g></g><g data-mml-node="mo" transform="translate(27889,0) translate(0 250)"></g></g></g></g></svg></mjx-container></span></p></li>
<li><p>对于小型程序，<code>new</code> 之后不 <code>delete</code>
无所谓，程序结束之后会自动删除；但是对于大型 24h
网络服务端程序，容易出现问题，总有分配内存失败的时候</p></li>
<li><p>内存管理方式，<strong>用户指定和垃圾回收</strong>，前者要求编写者的严谨，后者分为小回收和大回收，</p>
<p>安卓手机卡的原因：处于大回收状态，逻辑不明确，性能差</p></li>
<li><p>C艹 将构造和分配集成在一起：</p>
<ul>
<li><p>拷贝构造：在语义上实现一个对象变两个对象（二进制串的拷贝）。</p></li>
<li><p>移动构造：在语义上实现将一个对象的资源转移给另一个对象。</p></li>
</ul></li>
<li><p>空指针、悬垂指针（指针所指对象被释放，但指针没有做修改）、双重释放（两个对象的指针指向同一块内存空间，两个对象均释放）等问题导致运行时错误。</p></li>
</ul>
<p>计算机技术本质上是实现一个 <code>Trade-off</code></p>
<ul>
<li><p>Rust 中的每个值都有所有者 (owner)。</p></li>
<li><p>同一时刻<strong>只有一个</strong>所有者。</p></li>
<li><p>当所有者失效，值也将被丢弃。</p></li>
</ul>
<p>这是</p>
<p>一份数据只有一个所有者，如果超出作用域，其绑定数据自动释放</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() {<br>  <span class="hljs-comment">// Creates a Vec object.</span><br>  <span class="hljs-comment">// Gives ownership of the Vec object to v1.</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  v1.<span class="hljs-title function_ invoke__">pop</span>();<br>  v1.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">4</span>);<br>  <span class="hljs-comment">// At the end of the scope, v1 goes out of scope.</span><br>  <span class="hljs-comment">// v1 still owns the Vec object, so it can be cleaned up.</span><br>}<br></code></pre></td></tr></table></figure>
<p>以下代码在编译过程中出错，所有权的转移</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust">  <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-comment">// Ownership of the Vec object moves to v2.</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = v1;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, v1[<span class="hljs-number">2</span>]); <span class="hljs-comment">// error: use of moved value `v1`</span><br>----------------------Compile Error-----------------------<br>error[E0382]: borrow of moved value: `v1`<br>  |<br><span class="hljs-number">2</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  |         -- <span class="hljs-keyword">move</span> occurs because `v1` has <span class="hljs-keyword">type</span> `<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;`, which does not implement the `<span class="hljs-built_in">Copy</span>` <span class="hljs-keyword">trait</span><br><span class="hljs-number">3</span> |     <span class="hljs-comment">// Ownership of the Vec object moves to v2.</span><br><span class="hljs-number">4</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = v1;<br>  |              -- value moved here<br><span class="hljs-number">5</span> |     <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, v1[<span class="hljs-number">2</span>]); <span class="hljs-comment">// error: use of moved value `v1`</span><br>  |                    ^^ value borrowed here after <span class="hljs-keyword">move</span><br></code></pre></td></tr></table></figure>
<p>在函数调用的时候，如果传入参数过多，还要将所有权还回去，比较麻烦</p>
<p>使用<strong>借用</strong>，所有权本身没有变化，相当于是借用一下数据</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// v_ref is a reference to v.</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v_ref</span> = &amp;v;<br><span class="hljs-comment">// Moving ownership to v_new would invalidate v_ref.</span><br><span class="hljs-comment">// error: cannot move out of `v` because it is borrowed</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v_new</span> = v;<br><span class="hljs-comment">// Cancel the effect of NLL (non-lexical lifetime)</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, v_ref);<br></code></pre></td></tr></table></figure>
<p>rust
语言是一门<strong>面向编译器语言</strong>，可以认为写不出运行有问题的代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 借用与函数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">length</span>(vec_ref: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> {<br>  <span class="hljs-comment">// vec_ref is auto-dereferenced when you call methods on it.</span><br>  vec_ref.<span class="hljs-title function_ invoke__">len</span>()<br>}<br><span class="hljs-comment">// 可变借用</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(vec_ref: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, x: <span class="hljs-type">i32</span>) {<br>	vec_ref.<span class="hljs-title function_ invoke__">push</span>(x);<br>}<br><span class="hljs-comment">// Copy (特型)</span><br><span class="hljs-comment">// i32、f64、char、bool 可以拷贝</span><br><span class="hljs-comment">// 生命周期检查</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: &amp;<span class="hljs-type">i32</span>;<br>{<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>  y = &amp;x; <span class="hljs-comment">// error: `x` does not live long enough</span><br>}<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, *y);<br></code></pre></td></tr></table></figure>
<p>向量的三种迭代方式，不可变借用 <code>&amp;V</code>、可变借用
<code>&amp;mut V</code>、所有权 <code>V</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vs</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-comment">// Borrow immutably</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> &amp;vs { <span class="hljs-comment">// Can also write `for v in vs.iter()`</span><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I'm borrowing {}."</span>, v);<br>}<br><span class="hljs-comment">// Borrow mutably</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> vs { <span class="hljs-comment">// Can also write `for v in vs.iter_mut()`</span><br>  *v = *v + <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I'm mutably borrowing {}."</span>, v);<br>}<br><span class="hljs-comment">// Take ownership of the whole vector</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> vs { <span class="hljs-comment">// Can also write `for v in vs.into_iter()`</span><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I now own {}! AHAHAHAHA!"</span>, v);<br>}<br></code></pre></td></tr></table></figure>
<p>切片是一种特殊的引用，代表序列中的一个指定片段</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>
<h2 id="结构化数据">结构化数据</h2>
<p>有两种 struct 和 enum，mod 相当于 C艹 中的 namespace</p>
<p>结构体用 CamelCase 命名方式，里面的域用 snake_case 命名方式。</p>
<p>语法糖，对别的方法进行一种实现，写起来简便</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> { a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>, c: <span class="hljs-type">i32</span>, d: <span class="hljs-type">i32</span>, e: <span class="hljs-type">i32</span> }<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = Foo { a: <span class="hljs-number">1</span>, b: <span class="hljs-number">1</span>, c: <span class="hljs-number">2</span>, d: <span class="hljs-number">2</span>, e: <span class="hljs-number">3</span> };<br><span class="hljs-keyword">let</span> <span class="hljs-variable">x2</span> = Foo { e: <span class="hljs-number">4</span>, .. x };<br><span class="hljs-comment">// Useful to update multiple fields of the same struct:</span><br>x = Foo { a: <span class="hljs-number">2</span>, b: <span class="hljs-number">2</span>, e: <span class="hljs-number">2</span>, .. x };<br></code></pre></td></tr></table></figure>
<p>Rust
的枚举要强很多，是<strong>和类型</strong>，用来表示多选一的数据（<strong>代数数据类型</strong>，如笛卡尔坐标系）</p>
<p>变体 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="62.344ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 27556 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">无</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">据</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3000,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">有</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">命</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">名</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">据</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">域</text></g><g data-mml-node="mo" transform="translate(11000,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(11389,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">结</text></g><g data-mml-node="mi" transform="translate(12389,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">构</text></g><g data-mml-node="mi" transform="translate(13389,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">体</text></g><g data-mml-node="mo" transform="translate(14389,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(14778,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">、</text></g></g><g data-mml-node="mi" transform="translate(15778,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">无</text></g><g data-mml-node="mi" transform="translate(16778,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">命</text></g><g data-mml-node="mi" transform="translate(17778,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">名</text></g><g data-mml-node="mi" transform="translate(18778,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(19778,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(20778,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">据</text></g><g data-mml-node="mi" transform="translate(21778,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">域</text></g><g data-mml-node="mo" transform="translate(22778,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(23167,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">元</text></g><g data-mml-node="mi" transform="translate(24167,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">组</text></g><g data-mml-node="mi" transform="translate(25167,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">变</text></g><g data-mml-node="mi" transform="translate(26167,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">体</text></g><g data-mml-node="mo" transform="translate(27167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>，如</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Resultish</span> {<br>  <span class="hljs-literal">Ok</span>,<br>  Warning { code: <span class="hljs-type">i32</span>, message: <span class="hljs-type">String</span> },<br>  <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-type">String</span>)<br>}<br><span class="hljs-comment">// 使用 Resultish::each 来访问并匹配数据</span><br><span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">make_request</span>() {<br>  Resultish::<span class="hljs-literal">Ok</span> =&gt;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Success!"</span>),<br>  Resultish::Warning { code, message } =&gt;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Warning: {}!"</span>, message),<br>  Resultish::<span class="hljs-title function_ invoke__">Err</span>(s) =&gt;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Failed with error: {}"</span>, s),<br>}<br></code></pre></td></tr></table></figure>
<p>枚举类型还可以递归</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> {<br>	Nil,<br>	<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, List),<br>}<br><span class="hljs-comment">// 但上述枚举类型会报错，会趋于无穷大，使用 Box 加以限制</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_five</span> = Box::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> {<br>  Nil,<br>  <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">Box</span>&lt;List&gt;), <span class="hljs-comment">// OK!</span><br>}<br></code></pre></td></tr></table></figure>
<p>方法与所有权</p>
<p>方法的第一个参数（名字为
self）决定这个方法需要的所有权种类，分类更加细致：</p>
<ul>
<li>&amp;self：方法借用对象的值。 一般情况下尽量使用这种方式，类似于 C++
中的常成员函数。</li>
<li>&amp;mut self：方法可变地借用对象的值。
在方法需要修改对象时使用，类似于 C++ 中的普通成员函数。</li>
<li>self：方法获得对象的所有权。
方法会消耗掉对象，同时可以返回其他的值。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Point</span> {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">distance</span>(&amp;<span class="hljs-keyword">self</span>, other: Point) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f32</span> {<br>    <span class="hljs-keyword">let</span> (dx, dy) = (<span class="hljs-keyword">self</span>.x - other.x, <span class="hljs-keyword">self</span>.y - other.y);<br>    ((dx.<span class="hljs-title function_ invoke__">pow</span>(<span class="hljs-number">2</span>) + dy.<span class="hljs-title function_ invoke__">pow</span>(<span class="hljs-number">2</span>)) <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>).<span class="hljs-title function_ invoke__">sqrt</span>()<br>  }<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">translate</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) {<br>    <span class="hljs-keyword">self</span>.x += x;<br>    <span class="hljs-keyword">self</span>.y += y;<br>  }<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">mirror_y</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Point {<br>    Point { x: -<span class="hljs-keyword">self</span>.x, y: <span class="hljs-keyword">self</span>.y }<br>  }<br>}<br></code></pre></td></tr></table></figure>
<ul>
<li><p>一般会创建一个名为 new 的关联函数起到构造函数的作用。</p>
<p>Rust 没有内置的构造函数语法，也不会自动构造。</p></li>
<li><p>方法、关联函数不能重载、方法不能继承</p></li>
</ul>
<h2 id="模式匹配">模式匹配</h2>
<p>对结构体进行解构</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {<br>  x: <span class="hljs-type">i32</span>,<br>  y: <span class="hljs-type">i32</span>,<br>}<br><span class="hljs-keyword">match</span> p {<br>  Point { x, y } =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"({}, {})"</span>, x, y)<br>}<br></code></pre></td></tr></table></figure>
<p>使用引用的方式匹配</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">17</span>;<br><span class="hljs-comment">// 打印数值或者修改值</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-number">17</span>;<br><span class="hljs-keyword">match</span> x {<br>  <span class="hljs-keyword">ref</span> r <span class="hljs-keyword">if</span> x == <span class="hljs-number">5</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, r),<br>  <span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> r =&gt; *r = <span class="hljs-number">5</span><br>}<br></code></pre></td></tr></table></figure>
<p>内部绑定（使用 <code>@</code> ）</p>
<p>模式匹配的穷尽性，否则会报错（使用 <code>_</code> 表示其他情况）</p>
<p><code>for</code> 循环的模式匹配</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-title function_ invoke__">for</span> (i, x) <span class="hljs-keyword">in</span> v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() {<br>  <span class="hljs-built_in">print!</span>(<span class="hljs-string">"v[{i}] = {x} "</span>);<br>}<br><span class="hljs-comment">// v[0] = 1 v[1] = 2 v[2] = 3 </span><br></code></pre></td></tr></table></figure>
<h1 id="lecture-3标准库">lecture 3（标准库）</h1>
<h2 id="编码">编码</h2>
<p>C艹 语言 11 比 98 增加 unordered_map</p>
<p>C 里面的 string 为 <code>\0</code> 操作，即使是访问字符串长度也需要
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span> 的空间</p>
<p>而 C艹 使用 <code>std::string</code>
更加方法，对负数进行补码操作，便于加法</p>
<ul>
<li>Rust 的字符串处理机制比较复杂。
<ul>
<li>主要是用 UTF-8 编码的 Unicode 字符序列。</li>
<li>不是空字符 '\0' 结尾的 C 风格字符串，可以包含空字符。</li>
</ul></li>
<li>主要有两大类： &amp;str 和 String。</li>
</ul>
<p>字符的标识，与信息论有关：</p>
<p>模拟电路（信号是连续变化的，模拟类型更多，但不抗干扰，教室里的钟表）</p>
<p>数字电路（低电位和高电位，0V 和 5V，能抗干扰，数字手表）</p>
<p>ASCII 码 0 是 48，A 是 65，a 是 97</p>
<ul>
<li><p>编码：字符在计算机内部的表示方式</p></li>
<li><p>早期： ASCII 码，以英文字符为主， 7 位二进制</p></li>
<li><p>中文： GB 2312-1980《信息交换用汉字编码字符集》， 6,763
个汉字，两个字节</p>
<ul>
<li>GB 18030-2005《信息技术中文编码字符集》， 70,244
个汉字，两个字节或四个字节</li>
</ul></li>
<li><p>Unicode：试图把全世界的文字都纳入进来，收集了 144,697
个字符，四个字节</p>
<ul>
<li>常用 UTF-8 的形式来表示，<strong>变长</strong>一到四个字节，rust
便使用这种编码</li>
</ul></li>
<li><p>会出现乱码问题</p></li>
</ul>
<h3 align="center">
Unicode 中文乱码速查表
</h3>
<table>
<colgroup>
<col style="width: 3%">
<col style="width: 26%">
<col style="width: 32%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>xxxxxx</th>
<th>示例</th>
<th>特点</th>
<th>产生原因</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>古文码</td>
<td>鐢辨湀瑕佸ソ濂藉涔犲ぉ澶╁悜涓?</td>
<td>大都为不认识的古文，并加杂日韩文</td>
<td>以 GBK 方式读取 UTF-8 编码的中文</td>
</tr>
<tr class="even">
<td>口字码</td>
<td>����Ҫ�¨2�ѧϰ������</td>
<td>大部分字符为小方块</td>
<td>以 UTF-8 的方式读取 GBK 编码的中文</td>
</tr>
<tr class="odd">
<td>符号码</td>
<td>ç”±æœˆè|å￥½å￥½å-|ä1 å¤©å¤©å‘ä¸Š</td>
<td>大部分字符为各种符号</td>
<td>以 ISO8859-1 方式读取 UTF-8 编码的中文</td>
</tr>
<tr class="even">
<td>拼音码</td>
<td>óéÔÂòaoÃoÃÑ§Ï°ììììÏòéÏ</td>
<td>大部分字符为头顶带有各种类似声调符号的字母</td>
<td>以 ISO8859-1 方式读取 GBK 编码的中文</td>
</tr>
<tr class="odd">
<td>问句码</td>
<td>由月要好好学习天天向??</td>
<td>字符串长度为偶数时正确，长度为奇数时最后的字符变为问号</td>
<td>以 GBK 方式读取 UTF-8 编码的中文，然后又用 UTF-8 的格式再次读取</td>
</tr>
<tr class="even">
<td>锟拷码</td>
<td>锟斤拷锟斤拷要锟矫猴拷学习锟斤拷锟斤拷锟斤拷</td>
<td>全中文字符，且大部分字符为“锟斤拷”这几个字符</td>
<td>以 UTF-8 方式读取 GBK 编码的中文，然后又用 GBK 的格式再次读取</td>
</tr>
<tr class="odd">
<td>烫烫烫</td>
<td>烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫</td>
<td>字符显示为“烫烫烫”这几个字符</td>
<td>VC Debug 模式下，栈内存未初始化</td>
</tr>
<tr class="even">
<td>屯屯屯</td>
<td>屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯</td>
<td>字符显示为“屯屯屯”这几个字符</td>
<td>VC Debug 模式下，堆内存未初始化</td>
</tr>
</tbody>
</table>
<h2 id="str-和-string">&amp;str 和 String</h2>
<p>&amp;str</p>
<ul>
<li>&amp;str 是字符串切片，是切片的一种。</li>
<li>形如 "string literals" 的字符串字面值是 &amp;str 类型的1。</li>
<li>&amp;str 是静态分配空间的，且固定大小。</li>
<li>不能用方括号来做形如 some_str[i] 的索引，因为每个 Unicode
字符可能有多个字节。</li>
<li>正确的做法是在 chars() 中迭代：
<ul>
<li><code>for c in "1234".chars() { ... }</code></li>
</ul></li>
</ul>
<p>String</p>
<ul>
<li>String 是分配在堆上的，可以动态增长。
<ul>
<li>和 Vec 类似，实际上就是在 Vec&lt;u8&gt; 外面包了一层。</li>
</ul></li>
<li>也不能用下标来索引。
<ul>
<li>可以通过 s.nth(i) 来访问某个字符。</li>
</ul></li>
<li>通过取引用的方式可以获得 &amp;str。</li>
</ul>
<h2 id="option-枚举类型">Option 枚举类型</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; {<br>  <span class="hljs-literal">None</span>,<br>  <span class="hljs-title function_ invoke__">Some</span>(T),<br>}<br></code></pre></td></tr></table></figure>
<ul>
<li>Option<t> 是一个枚举类型，同时也是泛型类型。</t></li>
<li>为某种已有类型提供了<strong>表示没有或者空值的概念</strong>。</li>
<li>在 Rust 中，在需要返回空值时，推荐使用 Option<t>。
<ul>
<li>而不是返回诸如 NaN、 -1、 null 等特殊的值。</li>
</ul></t></li>
<li>类型 T 可以是任何类型，没有限制。</li>
</ul>
<p>一个处理除数为 0 的情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">divide</span>(numerator: <span class="hljs-type">f64</span>, denominator: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">f64</span>&gt; {<br><span class="hljs-keyword">if</span> denominator == <span class="hljs-number">0.0</span> {<br>    <span class="hljs-literal">None</span><br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-title function_ invoke__">Some</span>(numerator / denominator)<br>  }<br>}<br><span class="hljs-comment">// The return value of the function is an option</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">divide</span>(<span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>);<br><span class="hljs-comment">// Pattern match to retrieve the value</span><br><span class="hljs-keyword">match</span> result {<br>  <span class="hljs-comment">// The division was valid</span><br>  <span class="hljs-title function_ invoke__">Some</span>(x) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Result: {x}"</span>),<br>  <span class="hljs-comment">// The division was invalid</span><br>  <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Cannot divide by 0"</span>),<br>}<br></code></pre></td></tr></table></figure>
<p>典型用途：</p>
<p>初始值（求列表最大值）、函数定义域不是全集、表示简单的错误情况（未定义）、结构体的可选域或者可拿走的域、可选的函数参数、空指针</p>
<h2 id="错误处理">错误处理</h2>
<ul>
<li>对于不可恢复的错误，使用恐慌 panic!。
<ul>
<li>数组越界、栈越界、算术运算溢出……</li>
</ul></li>
<li>对于可恢复的错误，使用 Result。
<ul>
<li>文件操作、网络操作、字符串解析……</li>
</ul></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; {<br>  <span class="hljs-title function_ invoke__">Ok</span>(T),<br>  <span class="hljs-title function_ invoke__">Err</span>(E)<br>}<br></code></pre></td></tr></table></figure>
<ul>
<li>Result 与 Option 类似，除了正常结果外，还可以表示错误状态。</li>
<li>也定义了 unwrap 和 expect 等方法。</li>
<li>可以通过 ok 或 err 等方法转换成 Option。
<ul>
<li>把 Ok 或者 Err 的值作为 Some，另一种变成 None。</li>
</ul></li>
<li>也可以进行类似 Option 的操作。
<ul>
<li>and、 or……</li>
</ul></li>
</ul>
<p>其处理原则，对返回值为 Result 的函数，一定要显式地处理（否则编译器报
<code>warning</code> ）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::Error;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T&gt; = <span class="hljs-type">Result</span>&lt;T, Error&gt;;<br></code></pre></td></tr></table></figure>
<h3 id="操作符">?操作符</h3>
<p>配合 Result 类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; {<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">username</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>  File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">"hello.txt"</span>)?.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> username)?;<br>  <span class="hljs-title function_ invoke__">Ok</span>(username)<br>}<br></code></pre></td></tr></table></figure>
<p>配合 Opition 类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">last_char_of_first_line</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">char</span>&gt; {<br>  text.<span class="hljs-title function_ invoke__">lines</span>().<span class="hljs-title function_ invoke__">next</span>()?.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">last</span>()<br>}<br></code></pre></td></tr></table></figure>
<p>相当于可以提前传播错误，对上述两种类型对于 <code>Err</code> 和
<code>None</code> 就可以提前返回</p>
<p><strong>究竟是恐慌还是不恐慌？</strong>就看能否给调用代码恢复的机会。</p>
<p><strong>unwrap/expect
的场合：</strong>作为原型代码中的错误处理占位符</p>
<h2 id="容器">容器</h2>
<p><strong>Vec&lt;T&gt;</strong>：连续空间、可增长的序列，末尾可以高效增删、会发生增长和收缩</p>
<p><strong>VecDeque&lt;T&gt;</strong>：双端向量，两端可以高效增删，用环状缓冲区</p>
<p><strong>LinkedList&lt;T&gt;</strong>：双向链表，不能随机索引</p>
<p><strong>HashMap&lt;K, V&gt; / BTreeMap&lt;K,
V&gt;</strong>：字典（映射）类型，一般使用 <strong>HashMap&lt;K,
V&gt;</strong>，需要满足 K: Hash + Eq，需要有序的时候用
<strong>BTreeMap&lt;K, V&gt;</strong> ，需要满足 K: Ord</p>
<p>两者访问复杂度分别为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span> 和
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.112ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3585.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(2430,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(2596.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3196.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span> ，哈希表的使用举例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-comment">// 添加元素</span><br>scores.<span class="hljs-title function_ invoke__">insert</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"Blue"</span>), <span class="hljs-number">10</span>);<br>scores.<span class="hljs-title function_ invoke__">insert</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"Yellow"</span>), <span class="hljs-number">50</span>);<br><span class="hljs-comment">// 访问字典</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">team_name</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"Blue"</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">score</span> = scores.<span class="hljs-title function_ invoke__">get</span>(&amp;team_name);<br><span class="hljs-comment">// 遍历元素</span><br><span class="hljs-title function_ invoke__">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;scores {<br>	<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}: {}"</span>, key, value);<br>}<br><span class="hljs-comment">// 用于统计字母出现次数</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span>: BTreeMap&lt;<span class="hljs-type">char</span>, <span class="hljs-type">usize</span>&gt; = BTreeMap::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-keyword">for</span> <span class="hljs-variable">ch</span> <span class="hljs-keyword">in</span> <span class="hljs-string">"abcbcddef"</span>.<span class="hljs-title function_ invoke__">chars</span>() {<br>  <span class="hljs-comment">// {'a': 1, 'b': 2, 'c': 2, 'd': 2, 'e': 1, 'f': 1}</span><br>  count.<span class="hljs-title function_ invoke__">entry</span>(ch).<span class="hljs-title function_ invoke__">and_modify</span>(|e| *e += <span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">1</span>);<br>}<br></code></pre></td></tr></table></figure>
<p>collect() 的使用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 将数据从列表转化为 BTreeSet</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">data</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">set</span>: BTreeSet = data.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-comment">// 将数据中每个数乘以原来的两倍</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = input.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x * <span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-comment">// 使用 zip() 将两个数据叠加</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = a.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>(b.<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">map</span>(|(x, y)| x + y).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure>
<p>early，向量 lazy</p>
<p>B树外存，二叉树内存</p>
<h2 id="迭代器">迭代器</h2>
<p>对<strong>序列</strong>的一种抽象</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> {<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>  <span class="hljs-comment">// More fields omitted</span><br>}<br></code></pre></td></tr></table></figure>
<p>大数据方法 map revuse</p>
<h2 id="自动测试">自动测试</h2>
<p>软件工程：<strong>回归测试</strong>（列出对所有的情况，每次开发判断能否通过）</p>
<p><strong>评测系统</strong>是独立于程序的系统，用于测试；<strong>单元测试</strong>嵌入程序当中，在内部进行测试</p>
<p>cargo 提供了相应测试 test，在函数前面加上 <code>#[test]</code>
以标注这是一个测试函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() {<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">4</span>);<br>}<br></code></pre></td></tr></table></figure>
<p>习惯每写一个函数，就在文件后面实现对它的单元测试，也可以调换过来，测试驱动编程</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">vector_length</span>(data: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> {<br>  vector_length.<span class="hljs-title function_ invoke__">len</span>()<br>}<br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_vector_length</span>() {<br>  <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">vector_length</span>(&amp;<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]), <span class="hljs-number">3</span>);<br>}<br></code></pre></td></tr></table></figure>
<p>持续集成，CICD，每次 push 一次就会自动跑脚本，判断测试是否失败</p>
<h1 id="tutorial">Tutorial</h1>
<h2 id="习题评讲">习题评讲</h2>
<ul>
<li><p>使用元组实现相当于解包压包</p></li>
<li><p>使用 <code>a.inter().map(|x| x * 2).collect()</code> 等价于</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">ret</span> - <span class="hljs-built_in">vec!</span>[];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> &amp;a{<br>  rec.<span class="hljs-title function_ invoke__">push</span>(x * <span class="hljs-number">2</span>);<br>}<br></code></pre></td></tr></table></figure></li>
<li><p>随机数的选取，如果不希望抽重，使用随机种子打乱然后顺序取</p></li>
<li><p><code>json</code>
是传输数据格式中非常重要的格式：字符串、字典、数字，标准中没有注释，最后没有逗号。</p></li>
<li><p>general 的工作一定有人写，合并命令行参数第三方库
<code>merge</code></p></li>
<li><p>f64 没有实现偏序关系 Ord ，这是因为 NaN 不满足全序关系，从而 NaN
与所有数比较都是 false</p></li>
</ul>
<h2 id="oj-相关知识">OJ 相关知识</h2>
<p>请求和响应，前端属于客户端，不涉及跨主机访问</p>
<h3 id="http-请求">HTTP 请求</h3>
<p>例子：https://www/baidu.com/</p>
<p>GET:</p>
<p>HOST: www.baidu.com</p>
<p>Content-Type: html</p>
<h3 id="http-响应">HTTP 响应</h3>
<p>一个例子：</p>
<p>HTTP 200 OK</p>
<p>Content-Type: application</p>
<h3 id="json-序列化与反序列化">json 序列化与反序列化</h3>
<p>#[derive: deserialize]</p>
<p>result 转成 json 文件</p>
<h3 id="互斥锁">互斥锁</h3>
<p>yse std::sync::{Arc, Mutex};</p>
<p>保证数据只能被一个线程加以修改，但要防止死锁（情况如下）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">lock_a</span> = A.<span class="hljs-title function_ invoke__">luck</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">lock_b</span> = B.<span class="hljs-title function_ invoke__">luck</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure>
<p>在上锁的时候，所有错误不要出现恐慌</p>
<h3 id="不同提交隔离">不同提交隔离</h3>
<p>一个小段子：C艹中的 <deque>
中分配内存出错时，没有出现内存错误的异常</deque></p>
<h1 id="lecture-4">Lecture 4</h1>
<h2 id="泛型">泛型</h2>
<p>C 语言中没有泛型，如 <code>quicksort() bisearch()</code>
没有对数据类型进行泛化，而是交给程序员进行处理（手动传入
<code>compare()</code> 函数）</p>
<p>Rust 中第一个泛型，将类型作为参数，变成泛型枚举类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; {<br>  <span class="hljs-title function_ invoke__">Ok</span>(T),<br>  <span class="hljs-title function_ invoke__">Err</span>(E),<br>}<br></code></pre></td></tr></table></figure>
<p>python 不需要泛型，其有底层 <code>Object</code>
类型，并且是动态语言</p>
<p>对上述泛型枚举类型，在实现相应方法的时候其函数返回值也是
<code>&lt;T, E&gt;</code>，其也可以使用参数作为传入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>&lt;T, U&gt;(x: T, y: U){<br>  <span class="hljs-comment">// ...</span><br>}<br></code></pre></td></tr></table></figure>
<h2 id="特型trait">特型(trait)</h2>
<p>一定程度上对应<strong>面向对象编程的多态性</strong>，对于下一段美观打印、同时比较多个参数结构体实现代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> { <br>  x: <span class="hljs-type">i32</span>, <br>  y: <span class="hljs-type">i32</span>, <br>}<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Point</span> {<br>	<span class="hljs-keyword">fn</span> <span class="hljs-title function_">format</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {<br>		<span class="hljs-built_in">format!</span>(<span class="hljs-string">"({}, {})"</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y)<br>	}<br>	<span class="hljs-keyword">fn</span> <span class="hljs-title function_">equals</span>(&amp;<span class="hljs-keyword">self</span>, other: Point) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {<br>	<span class="hljs-keyword">self</span>.x == other.x &amp;&amp; <span class="hljs-keyword">self</span>.y == other.y<br>  }<br>}<br></code></pre></td></tr></table></figure>
<p>可以抽象出共同特点(trait)，相当于 C艹 中的虚函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// write trait</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">PrettyPrint</span> {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">format</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>}<br><span class="hljs-comment">// write actual function</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PrettyPoint</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">format</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {<br>    <span class="hljs-built_in">format!</span>(<span class="hljs-string">"({}, {})"</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y)<br>  }<br>}<br></code></pre></td></tr></table></figure>
<p>C++ 中标准库由快速排序和插入排序混合版实现</p>
<p>python java 使用 Tim-Sort 归并排序</p>
<p>C++ 背上了很大的历史包袱，每次遇到问题都需要加入新的概念</p>
<p>特型约束的泛型类型示例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; {<br>	<span class="hljs-title function_ invoke__">Ok</span>(T),<br>	<span class="hljs-title function_ invoke__">Err</span>(E), <br>}<br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">PrettyPrint</span> {<br>	<span class="hljs-keyword">fn</span> <span class="hljs-title function_">format</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>; <br>}<br><span class="hljs-keyword">impl</span>&lt;T: PrettyPrint, E: PrettyPrint&gt; PrettyPrint <span class="hljs-keyword">for</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; {<br>	<span class="hljs-keyword">fn</span> <span class="hljs-title function_">format</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> {<br>    <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {<br>      <span class="hljs-title function_ invoke__">Ok</span>(t) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Ok({})"</span>, t.<span class="hljs-title function_ invoke__">format</span>()),<br>      <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Err({})"</span>, e.<span class="hljs-title function_ invoke__">format</span>()), <br>    }<br>  }<br>}<br></code></pre></td></tr></table></figure>
<p>特型可以拿到其“子特型”的方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Parent</span> {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(&amp;<span class="hljs-keyword">self</span>) {<br>    <span class="hljs-comment">// ...</span><br>  }<br>}<br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Child</span>: Parent {<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>(&amp;<span class="hljs-keyword">self</span>) {<br>    <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">foo</span>();<br>  }<br>}<br></code></pre></td></tr></table></figure>
<p><code>#[derive(Debug)]</code>
能够让对应的数据结构获得相应实现，不用重新编写，共有以下自动<strong>核心特性</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">Clone</span>, <span class="hljs-built_in">Copy</span>, <span class="hljs-built_in">Debug</span>, <span class="hljs-built_in">Default</span>, <span class="hljs-built_in">Eq</span><br>Hash, <span class="hljs-built_in">Ord</span>, PatialEq, <span class="hljs-built_in">PartialOrd</span><br></code></pre></td></tr></table></figure>
<p>特型的自动获得需要满足其所有成员都能自动获得指定的特型，如 Eq
不能在包含 f32 的结构体类型上自动获得，因为 f32 不是 Eq 的（浮点数中的
NAN
与任意数比较都是错误的，<strong>不满足全序关系中的自反性</strong>）</p>
<p><strong>Debug</strong> 特型用于输出调试信息，如</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> { x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>, }<br><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = Point { x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> };<br><span class="hljs-comment">// println!("The origin is: {:?}", origin);</span><br></code></pre></td></tr></table></figure>
<p><strong>Default</strong> 特型用于定义一个默认值，如 0 或者 ""</p>
<p><strong>Eq 和 PartialEq</strong>
等价关系和部分等价关系，都有对称性和传递性，前者还有自反性</p>
<p><strong>Hash</strong> 表示可哈希的类型，H
类型是抽象的哈希状态，可以计算哈希值，而如果同时出现了 Eq
特型，需要满足以下重要性质</p>
<p>x == y -&gt; hash(x) == hash(y)</p>
<p><strong>PartialOrd 和 Ord</strong>
表示偏序和全序，都有反对称性和传递性，前者还要满足完全性（对所有的 a 和
b，有 a &lt;= b 或者 b &lt;= a 成立），后者可以按照字典序排序</p>
<p><strong>关联类型的需求</strong>：例如，图的表示：邻接矩阵/链表</p>
<p><strong>Sized 和 ?Sized</strong>
前者表示在编译时固定大小，后者大小是动态的（如 [T],
str），一般跟指针相关的泛型才会出现后者（如 Box<t>）</t></p>
<p>特型甚至可以为所有类型写，如 i32，但不推荐。为了写一个特型实现的 impl
代码段，要么拥有该特性，要么拥有该类型。</p>
<p><strong>Drop</strong> 表示可以销毁的特型，但一般情况下不需要手动实现
Drop</p>
<h2 id="特型对象">特型对象</h2>
<p>考虑以下特型和实现</p>
<p><strong>静态</strong>分发：在编译的时候给定了相应特性的函数</p>
<p><strong>动态</strong>分发：在运行的时候决定相应特性的函数，但只有运行之后才能使用，其他情况只能当成一个特型来使用，编译器不知道对应的类型信息（已经被抹去）</p>
<p><strong>对象安全性</strong>，需要满足一定条件，关联函数要求除接收方之外，其他地方都不能出现
Self 类型（否则获取到对应的类型），不能以 Sized
为超特型，接收方是引用或者指针形式的类型（Self, Box&lt;Self&gt;）</p>
<blockquote>
<p>课件上问题：不可变的引用是可以 Clone 的。</p>
</blockquote>
<h2 id="生命周期">生命周期</h2>
<p>考虑以下情况：</p>
<ol type="1">
<li>获取了一项资源。</li>
<li>乙方通过引用借用了甲方的这项资源。</li>
<li>甲方对这项资源使用完毕，对它进行释放。</li>
<li>乙方还保留着对这项资源的引用，并开始使用它。</li>
<li>乙方挂了……</li>
</ol>
<p>如何保证第 3 步和第 4
步的顺序关系？一般情况下，引用具有隐式的生命周期，不需要额外关注，但也可以<strong>显式</strong>地指定生命周期</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>&lt;<span class="hljs-symbol">'a</span>&gt;(x: &amp;<span class="hljs-symbol">'a</span> <span class="hljs-type">i32</span>) {<br>	<span class="hljs-comment">// ...</span><br>}<br></code></pre></td></tr></table></figure>
<p><code>fn borrow_x_or_y&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str;</code>
保证引用 x 和 y
的生命周期至少会和返回的引用生命周期一样长，若只需要前者和返回值的生命周期一样长，则可以分开为
'a 与 'b
<code>fn borrow_p&lt;'a, 'b&gt;(p: &amp;'a str, q: &amp;'b str) -&gt; &amp;'a str;</code>，如以下编译期间会报错</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pizza</span>(<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PizzaSlice</span>&lt;<span class="hljs-symbol">'a</span>&gt; {<br>  pizza: &amp;<span class="hljs-symbol">'a</span> Pizza, <span class="hljs-comment">// &lt;- references in structs must</span><br>  index: <span class="hljs-type">u32</span>, <span class="hljs-comment">// ALWAYS have explicit lifetimes</span><br>}<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>; {<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = <span class="hljs-title function_ invoke__">Pizza</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br>  s2 = PizzaSlice { pizza: &amp;p2, index: <span class="hljs-number">2</span> };<br>  <span class="hljs-comment">// no good - why?</span><br>}<br><span class="hljs-title function_ invoke__">drop</span>(s2); <span class="hljs-comment">// to undo NLL</span><br></code></pre></td></tr></table></figure>
<p>如果结构体或者枚举类型的成员是引用，那么就需要显式地指定生命周期</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'b</span>&gt; {<br>  v: &amp;<span class="hljs-symbol">'a</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;,<br>	s: &amp;<span class="hljs-symbol">'b</span> <span class="hljs-type">str</span>, <br>}<br></code></pre></td></tr></table></figure>
<h1 id="lecture-5">Lecture 5</h1>
<blockquote>
<p><strong>所有权</strong>是 rust
语言<strong>资源管理</strong>的灵魂，<strong>特型</strong>是 rust
语言<strong>灵活运用</strong>的灵魂。</p>
</blockquote>
<blockquote>
<p><strong>共享不修改，修改不共享——rust 设计哲学</strong></p>
</blockquote>
<h2 id="项目管理">项目管理</h2>
<h3 id="模块系统">模块系统</h3>
<ul>
<li>包 (packages)：Cargo 的一项功能，可以让用户构建、测试、分享箱。</li>
<li>箱
(crates)：也叫单元包，是由<strong>模块构成的一棵树</strong>，能够产生一个库或者可执行文件。</li>
<li>模块 (modules)：与 use
配合，<strong>控制路径</strong>的组织结构、作用域和访问权限。</li>
<li>路径
(paths)：命名项目的方式，这里的项目可以指结构体、函数、模块等。</li>
</ul>
<p>在模块中加上 <code>pub</code> 关键字便可以让其他用户访问，模块相当于
C艹 中的 namespace，模块之间可以嵌套，如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> english {<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> greetings { <span class="hljs-comment">/* ... */</span> }<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> farewells { <span class="hljs-comment">/* ... */</span> }<br>}<br><span class="hljs-keyword">mod</span> chinese {<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> greetings { <span class="hljs-comment">/* ... */</span> }<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> farewells { <span class="hljs-comment">/* ... */</span> }<br>}<br></code></pre></td></tr></table></figure>
<p>可以把模块写成单独的文件 <code>lib.rs</code>，用于整合所有的模块</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// lib.rs</span><br><span class="hljs-keyword">mod</span> english;<br><span class="hljs-comment">// english.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> greetings { <span class="hljs-comment">/*...*/</span> }<br></code></pre></td></tr></table></figure>
<p>也可以用目录来组织模块，把模块当做目录名使用</p>
<p>还可以在 Cargo 中使用自己编写的箱</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">[dependencies]<br>myfoo = { git = <span class="hljs-string">"https://github.com/me/foo-rs"</span> }<br>mybar = { path = <span class="hljs-string">"../rust-bar"</span> }<br></code></pre></td></tr></table></figure>
<h3 id="cargo-相关">Cargo 相关</h3>
<p><strong>单元测试</strong>直接附着在源代码中，<code>#[test]</code>，<strong>集成测试</strong>放在
<code>tests/*.rs</code> 中，<strong>基准测试程序</strong>放在
<code>benches/*.rs</code>（类似作坊中的基准模块）</p>
<p><code>feature</code> 是在构建时做选择性的开关（与 <code>bug</code>
不同）</p>
<p>使用 rust 语言，Cargo 编写脚本</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">[package]<br>build = <span class="hljs-string">"build.rs"</span><br></code></pre></td></tr></table></figure>
<p>可以将自己写的软件包发布到 crate.io ，原子性的库。</p>
<h2 id="语法补充">语法补充</h2>
<h3 id="属性">属性</h3>
<p>#! [no_std] 禁用标准库，#[derive(Debug)] 自动获得特型</p>
<p>#[inline(always)] 提示编译器内联优化，#[cfg(target_os = "linux")]
定义条件编译。</p>
<p>inter procedure o</p>
<h3 id="操作符-1">操作符</h3>
<p>运算类 &gt; 操作类 &gt; 位运算类 &gt; 逻辑类，其背后的原因是 a + b ==
c 应该被理解为 (a + b) ==
c，后者是源于逻辑二元运算存在<strong>短路情况</strong></p>
<p>使用特型来重载操作符，定义在 std::ops 下，有如下重载操作符：Neg, Not,
Deref, DerefMut | Mul, Div, Mod | Add, Sub...</p>
<h3 id="类型转换">类型转换</h3>
<p>使用 <strong>From 和 Into
实现自定义类型转换</strong>，前者实现之后后者会自动实现，例如实现<strong>对数转换</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Into</span>&lt;<span class="hljs-type">f64</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Log2</span> {<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">into</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> {<br>        <span class="hljs-comment">// return log_2 of the value</span><br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">ln</span>() / std::f64::consts::LN_2<br>    }<br>}<br><span class="hljs-comment">// 调用取得对数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">log2_4</span>: <span class="hljs-type">f64</span> = <span class="hljs-title function_ invoke__">Log2</span>(<span class="hljs-number">4.0</span>).<span class="hljs-title function_ invoke__">into</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">log2_8</span>: <span class="hljs-type">f64</span> = <span class="hljs-title function_ invoke__">Log2</span>(<span class="hljs-number">8.0</span>).<span class="hljs-title function_ invoke__">into</span>();<br></code></pre></td></tr></table></figure>
<h3 id="命名规范">命名规范</h3>
<h4 id="标识符">标识符</h4>
<ul>
<li><p>CamelCase：类型、特型</p></li>
<li><p>snake_case：箱、模块、函数、方法、变量</p></li>
<li><p>SCREAMING_SNAKE_CASE：常量和静态变量</p></li>
<li><p>T（单个大写字母）：类型参数</p></li>
<li><p>'a（撇 + 短的小写名字）：生命周期参数</p></li>
</ul>
<h4 id="构造函数和转换函数">构造函数和转换函数</h4>
<ul>
<li><p>new, new_with_stuff：构造函数</p></li>
<li><p>from_foo：转换构造函数</p></li>
<li><p>as_foo：低开销非消耗性转换</p></li>
<li><p>to_foo：高开销非消耗性转换</p></li>
<li><p>into_foo：消耗性转换</p></li>
</ul>
<h2 id="智能指针">智能指针</h2>
<h3 id="boxt">Box&lt;T&gt;</h3>
<p>用于在堆上分配空间存放数据，其拥有 T 类型的对象，其指针是唯一的，类似
C艹 中的 <code>std::unique_ptr</code>，是动态分配</p>
<h3 id="stdrcrct">std::rc::Rc&lt;T&gt;</h3>
<p>是 <strong>Referenced counted</strong> 的缩写，代表指针的别名个数</p>
<p>共享所有权的指针类型，相当于 C艹 中的
<code>std::shared_ptr</code>，并且其一直符合 rust
的借用规则，当且仅当引用计数为 1 时才能修改</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">shared</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">6</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, Rc::<span class="hljs-title function_ invoke__">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> shared)); <span class="hljs-comment">// ==&gt; Some(6)</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cloned</span> = shared.<span class="hljs-title function_ invoke__">clone</span>(); <span class="hljs-comment">// ==&gt; Another reference</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, Rc::<span class="hljs-title function_ invoke__">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> shared)); <span class="hljs-comment">// ==&gt; None</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, Rc::<span class="hljs-title function_ invoke__">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> cloned)); <span class="hljs-comment">// ==&gt; None</span><br></code></pre></td></tr></table></figure>
<p>gc
垃圾回收机制，如果有各种变量相互引用形成<strong>一种环</strong>，就不能释放，导致空间的浪费：</p>
<ul>
<li><p>A 有一个 B 的 Rc，B 也有一个 A 的 Rc，两者的引用计数都是
1。</p></li>
<li><p>由于构成了环，两个对象都不会被释放，从而引起内存泄露。</p></li>
</ul>
<p>可以使用<strong>弱引用</strong>来避免（与 C艹 中的
<code>weak_ptr</code> 类似） ，Rc::downgrade() 降级成 Weak。</p>
<blockquote>
<p>对于图 (V,
E)，对顶点拥有<strong>所有权</strong>，但是对于边来说，不能拥有对顶点的所有权，可以使用<strong>弱引用</strong>来实现</p>
</blockquote>
<p>但这样会引入双重计数，增加开销。</p>
<h3 id="stdcellcellt">std::cell::Cell&lt;T&gt;</h3>
<p>为 Copy 类型提供内部可变性的格子类型，用 get() 从 Cell 中取值，用
set() 更新 Cell 的值。</p>
<h3 id="stdcellrefcellt">std::cell::RefCell&lt;T&gt;</h3>
<p>可为任意类型提供内部可变性，当 borrow() 一个 RefCell&lt;T&gt;
时，得到的是 Ref&lt;T&gt;，而不是 &amp;T。</p>
<h3 id="const-t-和-mut-t">const T 和 *mut T</h3>
<p>相当于 C 语言的裸指针。</p>
<h2 id="常用库">常用库</h2>
<ul>
<li>正则表达式: reges</li>
<li>日志: log （源于航海，各种级别分开，error, warning）</li>
<li>日期: chrono</li>
<li>HTTP 客户端: reqwest</li>
<li>增强错误处理: thiserror , anyhow</li>
<li>数据库: rusqlite, r2d2</li>
</ul>
<h2 id="数据库">数据库</h2>
<h3 id="分类">分类</h3>
<p><strong>数据库</strong>是以一定方式存储在一起、能够给多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。</p>
<ul>
<li>关系数据库：<strong>创建在关系模型基础上的数据库</strong>，给予集合代数
<ul>
<li>Oracle 国外数据库，早些年中国各大银行使用，现在国产化</li>
<li>ProsgreSQL
<ul>
<li>MySQL</li>
<li>SQLite</li>
</ul></li>
</ul></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6310b37c16f2c2beb17decd6.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;"></p>
<ul>
<li>非关系型数据库
<ul>
<li>文档数据库（json 转换为二进制文件），如 MongoDB</li>
<li>键值数据库（类似 HashMap），如 LevelDB</li>
</ul></li>
</ul>
<h3 id="操作">操作</h3>
<p>数据查询：<strong>选择、投影、连接、并、交、差</strong></p>
<p>Excel 表中 vlookup 函数用于合并数据，指定键值</p>
<p>数据操作：<strong>新增、删除、修改、查询</strong></p>
<h3 id="sql-简介">SQL 简介</h3>
<p>常用命令：</p>
<ul>
<li>创建表格 CREATE TABLE</li>
<li>查询数据 SELECT</li>
<li>插入数据 INSERT</li>
<li>更新数据 UPDATE</li>
<li>删除数据 DELETE</li>
<li>删除表格 DROP TABLE</li>
</ul>
<p>DBA IT 认证，Oracle 数据管理库职业</p>
<h3 id="在-rust-中使用-sql">在 rust 中使用 SQL</h3>
<p>软件包 rusqlite</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; {<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">conn</span> = Connection::<span class="hljs-title function_ invoke__">open_in_memory</span>()?;<br>  conn.<span class="hljs-title function_ invoke__">execute</span>(<br>    <span class="hljs-string">"CREATE TABLE person (</span><br><span class="hljs-string">    id INTEGER PRIMARY KEY,</span><br><span class="hljs-string">    name TEXT NOT NULL,</span><br><span class="hljs-string">    data BLOB</span><br><span class="hljs-string">    )"</span>,<br>    (), <span class="hljs-comment">// empty list of parameters.</span><br>  )?;<br>}<br></code></pre></td></tr></table></figure>
<p>还可以与 Web 框架联合使用</p>
<p>创建数据库连接池，将连接池作为 Data&lt;T&gt; 传给请求处理代码</p>
<h1 id="lecture-6">Lecture 6</h1>
<blockquote>
<p>当今许多设备都是多核的，并发是现代语言必须具备的特性，</p>
</blockquote>
<h2 id="闭包">闭包</h2>
<h3 id="概念与类型推导">概念与类型推导</h3>
<p>闭包的概念和匿名函数、lambda 函数相似，其可以绑定在变量上：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">square</span> = |x: <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> { x * x };<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, <span class="hljs-title function_ invoke__">square</span>(<span class="hljs-number">3</span>));<br><span class="hljs-comment">// =&gt; 9</span><br></code></pre></td></tr></table></figure>
<p>类型可以推导，参数类型和返回值类型都可以不显示地给出</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">square_v4</span> = |x: <span class="hljs-type">u32</span>| { (x * x) <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> };<br><span class="hljs-keyword">let</span> <span class="hljs-variable">square</span> = |x| { x * x };<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, <span class="hljs-title function_ invoke__">square</span>(-<span class="hljs-number">2.4</span>));<br><span class="hljs-comment">// =&gt; 5.76</span><br></code></pre></td></tr></table></figure>
<h3 id="捕捉">捕捉</h3>
<p>闭包还可以包含其所在的环境（可以调用外面的参数，称为<strong>捕捉</strong>）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">magic_num</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">magic_johnson</span> = <span class="hljs-number">32</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">plus_magic</span> = |x: <span class="hljs-type">i32</span>| x + magic_num;<br></code></pre></td></tr></table></figure>
<p>闭包绑定后如果尝试借用，如果在上述代码后面加入以下代码，借用编译器则会报错</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">more_magic</span> = &amp;<span class="hljs-keyword">mut</span> magic_num; <span class="hljs-comment">// Err!</span><br></code></pre></td></tr></table></figure>
<h3 id="移动闭包">移动闭包</h3>
<p>可以使用 <code>{...}</code>
让闭包超过作用域来恢复，调用函数和被调用函数 Caller, Callee，也可以使用
<code>move</code>
关键字强制闭包获得环境变量的所有权，为<strong>移动闭包</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">make_closure</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&gt; {<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">move</span> |y| x + y;<br>  Box::<span class="hljs-title function_ invoke__">new</span>(f)<br>}<br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-title function_ invoke__">make_closure</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, <span class="hljs-title function_ invoke__">f</span>(<span class="hljs-number">3</span>));<br><span class="hljs-comment">// =&gt; 5</span><br></code></pre></td></tr></table></figure>
<h3 id="特型闭包">特型闭包</h3>
<p>闭包与所有权，只能调用一次，满足 rust
借用规则。与所有权相似，闭包也具有闭包特型，<code>Fn, FnMut, FnOnce</code>
分别代表借用、可变借用、所有权</p>
<p>如何正确地返回闭包？如下，使用动态的生命周期以及移动语义解决</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">box_up_your_closure_and_move_out</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&gt; {<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">local</span> = <span class="hljs-number">2</span>;<br>  Box::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">move</span> |x| x * local)<br>}<br></code></pre></td></tr></table></figure>
<p>Lambda 函数本质上是 C++/Rust
在调用处创建一个未知名字的类/结构体，然后传入环境的相关值，最后调用一个未知名字的函数。</p>
<h2 id="并发">并发</h2>
<h3 id="线程进程并发并行概念">线程进程、并发并行概念</h3>
<p>二进制可执行文件在执行之后，成为进程，在 CPU
中存放：<strong>寄存器，堆，栈，操作系统指令</strong>。</p>
<p><strong>Program Point</strong> 指向进程下一个指令（在X86 中称为
PC）</p>
<p>线程是<strong>轻量级</strong>，有 CPU
存放的寄存器、堆、栈、操作系统指令单元，但内存是相互共享的，但不引入通信的开销（网络、进程通信）</p>
<p>并发是程序同时有多个正在运行的线程，而并行是指多个处理单元，要求更高，真正意义的同时处理。</p>
<h3 id="并发执行">并发执行</h3>
<p>考虑下面代码，假设两个线程，一个执行 <code>foo()</code>，一个执行
<code>bar()</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() {<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span> = &amp;<span class="hljs-keyword">mut</span> x; *y = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, *y); <span class="hljs-comment">// foo expects 1</span><br>}<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>() {<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = &amp;<span class="hljs-keyword">mut</span> x; *z = <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, *z); <span class="hljs-comment">// bar expects 2</span><br>}<br></code></pre></td></tr></table></figure>
<p>这两个线程的执行顺序不是每次都能保证的，如果将两个函数当做两台 ATM
机，则会发生严重的后果。</p>
<p>并发编程的难点：<strong>数据共享</strong>、<strong>数据竞争</strong>、<strong>同步</strong>（保证所有线程都有正确的世界观，共享缓冲区）、<strong>死锁</strong></p>
<p>死锁发生有四个条件：<strong>互斥、持有资源、非抢占、等待成环</strong></p>
<p>一个形象的例子：</p>
<p><em>N</em>
个哲学家坐在一张圆桌周围，交替地进行吃饭和思考。每个哲学家需要一双筷子用来吃饭，但是一共只有
<em>N</em> 根筷子，每两个哲学家之间有一根。</p>
<p>哲学家的行为用算法描述如下：</p>
<ul>
<li>拿起他左侧的那根筷子（获取一个资源的锁）。</li>
<li>拿起他右侧的那根筷子（获取一个资源的锁）。</li>
<li>吃饭（使用资源）。</li>
<li>将两根筷子放回原处（释放资源的锁）。</li>
</ul>
<p>对所有哲学家来说，依据算法，所有人都拿到左侧的筷子，而此时桌上没有筷子，从而所有人卡在第二步</p>
<h2 id="线程">线程</h2>
<p>Rust 标准库提供了线程
<code>std::thread</code>，每个线程有自己的栈和状态，使用闭包来指定线程的行为</p>
<h3 id="线程句柄">线程句柄</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| {<br>  <span class="hljs-string">"Hello, world!"</span><br>});<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, handle.<span class="hljs-title function_ invoke__">join</span>());<br></code></pre></td></tr></table></figure>
<p><img src="https://lr-tsinghua11.github.io/img/video_editor/blackboard.png" srcset="/img/loading.gif" lazyload></p>
<p><code>join()</code>
会阻塞当前线程的执行，直到句柄对应的线程终止，其返回 <code>Ok</code>
或者 <code>Err</code></p>
<p><code>thread::park()</code> 可以暂停自己的执行，之后可以通过现成的
<code>unpark()</code> 来继续执行</p>
<h3 id="线程与所有权">线程与所有权</h3>
<p>线程的创建也要满足所有权的规则（包括闭包和所有权的规则），例如使用
<code>move</code> 来创建移动闭包，获得所有权</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> {<br>  thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {<br>  	<span class="hljs-built_in">println!</span>(<span class="hljs-string">"I'm #{}!"</span>, i);<br>}<br></code></pre></td></tr></table></figure>
<h2 id="共享线程状态">共享线程状态</h2>
<p>Rust 类型系统包含要求满足并发承诺的特型</p>
<ul>
<li><p>Send 表示可以在线程间安全转移</p></li>
<li><p>Sync 表示可以在线程间（通过引用）安全共享</p></li>
</ul>
<p>Send 类型可以将它的所有权在线程间转移，如果一种类型没有实现
Send，那么它只能留在原来的线程里。</p>
<p>Sync 类型在多个线程使用时不会引发内存安全问题，基本所有类型都是 Sync
的。以下为一个共享线程状态示例</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">data</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">3</span> {<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || {<br>      data[i] += <span class="hljs-number">1</span>;<br>    });<br>  }<br>  thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">50</span>));<br>}<br></code></pre></td></tr></table></figure>
<p>此时 data 有多个所有者，使用 <code>Arc&lt;T&gt;</code>
，代表原子性的引用计数指针（Atomic
Reference-Counted），但如果只是在初始化加入 Arc，编译也不通过。</p>
<p>Arc 也不具有内部可变性，需要添加<strong>互斥锁</strong>（Mutual
Exclusion），保证它包含的值只有一个线程能够访问；如果一个线程锁定了互斥锁，但是发生了恐慌，此时该互斥锁进入中毒状态，该锁不会被释放</p>
<p>高并发任务、超算比赛主要资源共享，Open Np，消息传递 npi</p>
<h2 id="通道">通道</h2>
<p>通道（channels）可以用来<strong>同步线程之间的状态</strong>，用于在线程之间传递消息，也可以用来提醒其他现成关于数据就绪、事件已经发行的情况</p>
<p><code>std::sync::mpsc</code> 实现多生产者、单消费者的通信功能</p>
<p><strong>同步：</strong>不同进程之间是需要等待的，<strong>异步：</strong>发送的东西放入（相当于无限大的）缓冲区，相互之间不需要等待</p>
<p>使用 <code>channel&lt;T&gt;()</code> 函数创建一对连接的
<code>(Sender&lt;T&gt;, Receiver&lt;T&gt;)</code></p>
<p><code>go</code> 语言有 <code>GC</code> 机制，导致编程开销大</p>
<p>对哲学家筷子问题，可以使用最后一个哲学家用相反方向拿筷子或者传递令牌规定拿筷子的哲学家。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/rust/" class="category-chain-item">rust</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/rust/">#rust</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Rust Notes</div>
      <div>https://lr-tsinghua11.github.io/2022/09/11/CS/rust/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Tony</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月11日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/29/Physics/Fundamental_Physics_2/" title="Fundamental_Physics_2">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Fundamental_Physics_2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/14/research/intersection%20Math%20knowledge/" title="intersection Math knowledge">
                        <span class="hidden-mobile">intersection Math knowledge</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js', function() {
    mermaid.initialize({"theme":"forest"});
  });
</script>





    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  
    <script  src="/js/img-lazyload.js" ></script>
  



  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var title = subtitle.title;
      
        typing(title);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?2d5b78dfbf046ab610d306e42da0ed37";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  

  
    
  





  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
