

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Learning_rate">
  <meta name="keywords" content="">
  
    <meta name="description" content="面向对象大作业报告">
<meta property="og:type" content="article">
<meta property="og:title" content="Functional plotter">
<meta property="og:url" content="https://lr-tsinghua11.github.io/2022/05/25/%E7%BC%96%E7%A8%8B/%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE%E5%99%A8%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A/index.html">
<meta property="og:site_name" content="Learning_rate">
<meta property="og:description" content="面向对象大作业报告">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lr-tsinghua11.github.io/img/%E6%B8%85%E6%96%B0%E4%BA%BA%E8%A1%8C%E9%81%93.jpg">
<meta property="article:published_time" content="2022-05-25T08:53:37.000Z">
<meta property="article:modified_time" content="2023-08-01T11:43:26.551Z">
<meta property="article:author" content="Learning_rate">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lr-tsinghua11.github.io/img/%E6%B8%85%E6%96%B0%E4%BA%BA%E8%A1%8C%E9%81%93.jpg">
  
  
  <title>Functional plotter - Learning_rate</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lr-tsinghua11.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":80,"cursorChar":".","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":true,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"2d5b78dfbf046ab610d306e42da0ed37","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong> Learning_rate&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/%E6%B8%85%E6%96%B0%E4%BA%BA%E8%A1%8C%E9%81%93.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          <span id="subtitle" title="">
            
          </span>
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-25 16:53" pubdate>
          2022年5月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          50 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Functional plotter</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：17 天前
                  
                
              </p>
            
            <div class="markdown-body">
              
              <center>面向对象</center>
<center>空教室，录音放。先继承，再封装。</center>
<center>写模板，搞工厂。郑成伟，凌精望。</center>
<center>谢谢你，非常棒！精品书，快推广！</center>

<h1 id="函数绘图器"><a href="#函数绘图器" class="headerlink" title="函数绘图器"></a>函数绘图器</h1><h2 id="效果呈现"><a href="#效果呈现" class="headerlink" title="效果呈现"></a>效果呈现</h2><h3 id="用户入界面"><a href="#用户入界面" class="headerlink" title="用户入界面"></a>用户入界面</h3><p>函数绘图器的用户输入 $\mbox{ui}$ 界面如下，其中点击 <code>θ</code> 按钮之后，函数表达式文本字符串会增加 $\theta$ 字符串，用户在该界面中输入表达式、精度、自变量 $x$ 取值范围等信息，输入结束之后，绘图器会自动识别函数表达式类型，结合步长以及定义域生成对应的图像。</p>
<p><img src="https://pic.imgdb.cn/item/628c5b40094754312947880c.jpg" srcset="/img/loading.gif" lazyload style="zoom:70%;" /></p>
<h3 id="有理函数"><a href="#有理函数" class="headerlink" title="有理函数"></a>有理函数</h3><p>本函数绘图器首先实现只与加减乘除相关的基本函数，如<strong>多项式函数、带括号的多项式函数、有理分式函数</strong>。三者统一表达式为 $f(x)=\dfrac{P(x)}{Q(x)}$ ，其中 $P(x)$ 和 $Q(x)$ 均为多项式且 $Q(x)\neq0$，绘制一些函数图像如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/628bac030947543129840abd.jpg" srcset="/img/loading.gif" lazyload style="zoom:45%;" /></p>
<script type="math/tex; mode=display">
\large 多项式函数:\ y=2x^3-x^2-3x+2,x\in[-1.5,1.5]</script><p><img src="https://pic.imgdb.cn/item/628bac670947543129853239.jpg" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<script type="math/tex; mode=display">
\large 含括号多项式函数:\ y=(x+1)\cdot (x-1)\cdot (x-2),x\in[-1.5,2.5]</script><p><img src="https://pic.imgdb.cn/item/628bb7ce0947543129a22f14.jpg" srcset="/img/loading.gif" lazyload style="zoom:30%;" /></p>
<script type="math/tex; mode=display">
\large 有理分式函数:\ y=\dfrac{x^2+1}{x^4+1},x\in[-2,2]</script><h3 id="其余初等函数"><a href="#其余初等函数" class="headerlink" title="其余初等函数"></a>其余初等函数</h3><p>同时，该函数绘图器实现了<strong>三角函数、指数函数、对数函数</strong>的绘制</p>
<p><img src="https://pic.imgdb.cn/item/628c5c40094754312948df9a.jpg" srcset="/img/loading.gif" lazyload style="zoom:30%;" /></p>
<script type="math/tex; mode=display">
\large 三角混合函数:\ y=\sin x +\cos x,x\in[-5,5]</script><p><img src="https://pic.imgdb.cn/item/628bb30c094754312995dbfc.jpg" srcset="/img/loading.gif" lazyload style="zoom:40%;" /></p>
<script type="math/tex; mode=display">
\large 指数函数:\ y=e^x,x\in[-2,1.5]</script><p><img src="https://pic.imgdb.cn/item/628bb5ff09475431299db82e.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<script type="math/tex; mode=display">
\large 对数函数:\ y=\ln x,x\in[0.05,2]</script><h3 id="极坐标函数"><a href="#极坐标函数" class="headerlink" title="极坐标函数"></a>极坐标函数</h3><p>当点击 $\theta$ 按钮时，绘图器会自动在表达式后面增加 $\theta$ 字符串，同时定义域会自动修改为 $[0,2\pi]$（可修改），以绘制极坐标函数：</p>
<p><img src="https://pic.imgdb.cn/item/628c3d4f094754312922da9b.jpg" srcset="/img/loading.gif" lazyload style="zoom:40%;" /></p>
<script type="math/tex; mode=display">
\large 阿基米德螺旋线:\ \rho=\theta,\theta\in[0,\dfrac{3}{2}\pi]</script><p><img src="https://pic.imgdb.cn/item/628bb8790947543129a33300.jpg" srcset="/img/loading.gif" lazyload style="zoom:40%;" /></p>
<script type="math/tex; mode=display">
\large 星形线:\ \rho=1-\sin \theta,\theta\in[0,2\pi]</script><p><img src="https://pic.imgdb.cn/item/628c3c4d094754312921f7f2.jpg" srcset="/img/loading.gif" lazyload style="zoom:40%;" /></p>
<script type="math/tex; mode=display">
\large 极坐标函数(有理分式):\ \rho=\dfrac{\theta-1}{\theta+1},\theta\in[0,2\pi]</script><h3 id="混合函数"><a href="#混合函数" class="headerlink" title="混合函数"></a>混合函数</h3><p>上述函数可以组合成更一般的初等函数，一些<strong>比较优雅</strong>的函数如下图所示</p>
<p><img src="https://pic.imgdb.cn/item/628c3b2f094754312920a828.jpg" srcset="/img/loading.gif" lazyload style="zoom:40%;" /></p>
<script type="math/tex; mode=display">
\large 三角函数与多项式混合:\ y=(x+1)\cdot (\sin x+1),x\in[-2,2]</script><p><img src="https://pic.imgdb.cn/item/628c6a8909475431295d6cc6.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<script type="math/tex; mode=display">
\large 三角函数与指数混合:\ y=\cos x\cdot e^x,\theta\in[0,2\pi]</script><p><img src="https://pic.imgdb.cn/item/628c98b20947543129a67d4b.jpg" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<script type="math/tex; mode=display">
\large 指数函数和多项式混合:\ y=(x^2-1)e^x,x\in[-1,1]</script><h3 id="极限修复函数"><a href="#极限修复函数" class="headerlink" title="极限修复函数"></a>极限修复函数</h3><p>除了一些定义域上连续可微的函数，本函数绘图器实现极限修复功能，可以绘制<strong>存在第一类间断点以及第二类间断点的函数</strong>，例如：</p>
<p><img src="https://pic.imgdb.cn/item/628c519609475431293bb1c0.jpg" srcset="/img/loading.gif" lazyload style="zoom:40%;" /></p>
<script type="math/tex; mode=display">
\large 与e相关的函数:\ y=x\ln(1+\dfrac{1}{x}),x\in[0,2]</script><p><img src="https://pic.imgdb.cn/item/628c5829094754312943dcc9.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<script type="math/tex; mode=display">
\large 一次函数:\ y=\dfrac{2x^2}{x},x\in[-2,2]</script><p><img src="https://pic.imgdb.cn/item/628c4d0e094754312935d3af.jpg" srcset="/img/loading.gif" lazyload style="zoom:40%;" /></p>
<script type="math/tex; mode=display">
\large 正弦极限函数:\ y=\dfrac{\sin x}{x},x\in[-5,5]</script><h2 id="框架构建"><a href="#框架构建" class="headerlink" title="框架构建"></a>框架构建</h2><p>该函数绘图器大作业使用 $\mbox{QT}$ 编写，共编写 $18$ 个文件（ $8$ 个头文件，$8$ 个 $\mbox{C++}$ 文件，$2$ 个 $\mbox{ui}$ 文件）</p>
<p>其中 $\mbox{Utils.h}$ 头文件中定义一些数学常数（如 $\pi,e$ ），以及一些<strong>内联函数</strong>，形成一种<strong>函数工具包</strong>便于调用，其余除生成实例对象的 $\mbox{main.cpp}$ 之外均分为头文件和源文件 $(\mbox{.h/cpp})$ ，且每对文件只针对一个类，各种类之间尽量<strong>解耦</strong>以及<strong>模块化</strong>，各文件之间的层级关系以及功能如下图所示：</p>

<pre>
<code class="mermaid" >
flowchart TD
    A([main.cpp]) --实例对象--> B([mainwindow.h/cpp])
    C((mainwindow.ui)) --用户输入--> B
    B -->|后端图像| D([latexImg.h/cpp])
    B --->|前端展示| E([dialog.h/cpp])
    B --后端数据--> F([Expression.h/cpp])
    F --直角坐标系--> G([recExp.h/cpp])
    F --极坐标系--> H([polarExp.h/cpp])
    G --表达式以及异常处理--> I[(vector< double > x,y)]
    H --表达式以及异常处理--> I
    D --转换latex格式--> J[downloader.h/cpp]
	J --URL网络请求--> K[(QPixmap img)]
	K --图像背景更换--> L{graph}
	I --线性重排以及调整--> L
	E --> M((dialog.ui))
	M --高精度计时器-->L
	N[Utils.h] --内联函数-->B
</code>
</pre>
<p>对于绘制函数图像这一需求，设计上先分为<strong>前端和后端</strong>，后端处理分为数据双列表的计算以及 $\LaTeX$ 图像的获取，前端将后端得到的内容进行重排以及处理，最终展示得到相应的含 $\LaTeX$ 表达式的图像</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="mbox-Utils-h-工具函数"><a href="#mbox-Utils-h-工具函数" class="headerlink" title="$\mbox{Utils.h}$ 工具函数"></a>$\mbox{Utils.h}$ 工具函数</h3><p>该头文件实现一些工具函数，有字符串处理、背景颜色更换、获取 $\mbox{vector}$ 对象中的最大值最小值、使用 $\mbox{C++}$ 文件流的操作转换 $\mbox{double}$ 类型数据和 $\mbox{string}$ 类型数据几种函数。例如其中更改背景颜色的工具函数中使用 $\mbox{QColor}$ 类创建白色和灰色实例对象，将从网络上获取到的 $\LaTeX$ 图像中的白色背景转换为灰色，以适应函数图像的背景：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//更改背景颜色</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> QPixmap <span class="hljs-title">changeBackGroundColor</span><span class="hljs-params">(QPixmap img)</span></span>&#123;<br>    <span class="hljs-function">QColor <span class="hljs-title">white</span><span class="hljs-params">(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)</span></span>;<br>    <span class="hljs-function">QColor <span class="hljs-title">grey</span><span class="hljs-params">(<span class="hljs-number">240</span>, <span class="hljs-number">240</span>, <span class="hljs-number">240</span>)</span></span>;<br>    QImage image = img.<span class="hljs-built_in">toImage</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;w &lt; image.<span class="hljs-built_in">width</span>();w++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> h = <span class="hljs-number">0</span>; h &lt; image.<span class="hljs-built_in">height</span>();h++)&#123;<br>            QRgb rgb = image.<span class="hljs-built_in">pixel</span>(w, h);<br>            <span class="hljs-keyword">if</span> (rgb == white.<span class="hljs-built_in">rgb</span>())<br>                image.<span class="hljs-built_in">setPixel</span>(w, h, grey.<span class="hljs-built_in">rgba</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> QPixmap::<span class="hljs-built_in">fromImage</span>(image);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该函数可以将以白色为背景的图片转换为以灰色为背景的图片：</p>
<p><img src="https://pic.imgdb.cn/item/628b8d0509475431292d1d3a.jpg" srcset="/img/loading.gif" lazyload style="zoom:20%;" /></p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>$\mbox{Utils.g}$ 文件中均使用内联函数，$\mbox{wiki}$ 上对 <code>inline function</code> 的定义如下：</p>
<blockquote>
<p>It serves as a compiler directive that suggests (but does not require) that the <strong>compiler</strong> substitute the body of the function inline by performing <strong>inline expansion</strong>, i.e. by inserting the function code at the address of each function call, thereby saving the overhead of a function call. </p>
</blockquote>
<p>可见，内联函数通过直接在调用点展开的方式节约函数调用的开销，这对于一些工具函数是合理的，毕竟这些工具函数不需要专门的类加以封装，对于所有类中的方法，均可以直接进行调用展开即可。</p>
<p>在 $\mbox{C++}$ 中也可以使用 $\mbox{lambda}$ 匿名函数实现函数的插入。 $\mbox{lambda}$ 表达式是 $\mbox{C++}$ 发展史上的一个重大事件，也是 $\mbox{C++}$ 支持函数式编程的重要一环。</p>
<p><strong>$\mbox{C++}$ 既融合了面向对象编程的约束，也融合了函数式编程的自由，一张一弛，乃编程之道</strong>。$\mbox{lambda}$ 表达式在数学上可以证明为图灵完备的，其开创了  $\mbox{C++}$ 的一个崭新编程范式。</p>
<p>具体来说，$\mbox{lambda}$ 表达式可以看做是一个临时使用的、嵌入在几乎任何地方的函数，简单示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> maxVec = [](vector&lt;<span class="hljs-type">double</span>&gt; x)&#123; <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(x.<span class="hljs-built_in">begin</span>(), x.<span class="hljs-built_in">end</span>()); &#125;;<br>    									<span class="hljs-comment">// maxVec 为 lambda 表达式，代表一个函数</span><br>    vector&lt;<span class="hljs-type">double</span>&gt; a&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">maxVec</span>(a) &lt;&lt; endl;			<span class="hljs-comment">// 使用起来相当于一个函数，可重复调用多个 Vector </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>在编写代码过程中，对于一些不需要专门声明的函数，可以使用上述 $\mbox{lambda}$ 表达式，$\mbox{lambda}$ 表达式还可以使将函数内部的局部变量进行捕获，防止函数作用完成之后原始数据丢失的情况，由于该特性没有在代码编写中使用，这里不再展开。</p>
<h3 id="后端数据处理"><a href="#后端数据处理" class="headerlink" title="后端数据处理"></a>后端数据处理</h3><p>采用正则表达式的方法对表达式中的对各种运算进行逐一搜索递归计算，下面给出所有正则表达式运算优先级代码，在初等函数的分类下，共 $17$ 个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::regex Expression::priority[<span class="hljs-number">17</span>]&#123;<br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(.*)\\+(.*)&quot;</span>),              <span class="hljs-comment">//0，加</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(.*)\\-(.*)&quot;</span>),              <span class="hljs-comment">//1，减</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(.*)\\*(.*)&quot;</span>),              <span class="hljs-comment">//2，乘</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(.*)/(.*)&quot;</span>),                <span class="hljs-comment">//3，除</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(.*)\\^(.*)&quot;</span>),              <span class="hljs-comment">//4，次方</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;sin(.*)&quot;</span>),                  <span class="hljs-comment">//5，正弦</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;cos(.*)&quot;</span>),                  <span class="hljs-comment">//6，余弦</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;tan(.*)&quot;</span>),                  <span class="hljs-comment">//7，正切</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;arcsin(.*)&quot;</span>),               <span class="hljs-comment">//8，反正弦</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;arccos(.*)&quot;</span>),               <span class="hljs-comment">//9，反余弦</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;arctan(.*)&quot;</span>),               <span class="hljs-comment">//10，反正切</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;log\\((.*),(.*)\\)&quot;</span>),       <span class="hljs-comment">//11，以 10 为底对数</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;ln(.*)&quot;</span>),                   <span class="hljs-comment">//12，以 e 为底对数</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(^(-?\\d+)(\\.\\d+)?$)&quot;</span>),   <span class="hljs-comment">//13，单个常数（包括任何小数）</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;x&quot;</span>),                        <span class="hljs-comment">//14，自变量符号 x</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;e&quot;</span>),                        <span class="hljs-comment">//15，自然底数 e</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;π&quot;</span>)                         <span class="hljs-comment">//16，圆周率 π</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>运算级较低的符号应该放在最后计算，由于递归的特点，其应该在前面进行检测，在运算时，只需要依次遍历每个正则表达式，若符合要求，则将表达式拆成几个部分进行递归计算，其流程图（仅有 $2$ 次递归）如下：</p>

<pre>
<code class="mermaid" >
flowchart TD
	A[A operator B] --> B[A]
	A[A operator B] --- C(operator)
	A[A operator B] --> D[B]
	B <--> O[a1]
	B <--> P[operator]
	B <--> Q[a2]
	B --data--> C
	D --data--> C
	D <--> R[b1]
	D <--> S[operator]
	D <--> T[b2]
	C -->Z[result]
</code>
</pre>
<p>对于输入表达式有误进行异常处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//合法、括号不匹配、分子不为0且分母为0、分子分母均为0（可能存在极限）、非括号运算符错误、常数错误（小数点出错）、函数无定义</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">judge</span>&#123;isLegal, mismatch, divisorZero, perhapsLim, operatorInlegal, constantInlegal, undefined&#125;;<br>    std::map&lt;<span class="hljs-type">double</span>, judge&gt; judges;<br></code></pre></td></tr></table></figure>
<p>采用枚举各种错误的方式，对于括号不匹配，分母为 $0$ 等一些异常处理进行相应的判断。使用标准库中的 $\mathbf{map}$ 数据结构，将对应自变量 $x$ 与相关判断构成映射关系，方便之后统一处理，例如对于 <code>/</code> 的处理如下，其中由于计算机浮点数误差，采用比较 $\mbox{tolerance}$ 误差的方法进行判定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-comment">//正则表达式以 / 为界切分为两部分，调用 str() 函数构造两个新的 Expression 实例对象</span><br><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_search</span>(<span class="hljs-keyword">this</span>-&gt;exp, m, priority[<span class="hljs-number">3</span>]))&#123;<br>       Expression e1&#123; m[<span class="hljs-number">1</span>].<span class="hljs-built_in">str</span>(), x &#125;;<br>       Expression e2&#123; m[<span class="hljs-number">2</span>].<span class="hljs-built_in">str</span>(), x &#125;;<br>       <span class="hljs-comment">//分子&quot;不为0&quot;，分母&quot;为0&quot;</span><br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(e2) &lt; tol &amp;&amp; <span class="hljs-built_in">fabs</span>(e1) &gt; tol)<br>           judges[x] = judge::divisorZero;<br>       <span class="hljs-comment">//分子&quot;为0&quot;，分母也&quot;为0&quot;，有可能存在极限</span><br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(e2) &lt; tol &amp;&amp; <span class="hljs-built_in">fabs</span>(e1) &lt; tol)<br>           judges[x] = judge::perhapsLim;<br>       cout &lt;&lt; errorStrings[judges[x]] &lt;&lt; endl;<br>       <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>(judges[x]) == <span class="hljs-number">0</span>)? e1 / e2 : <span class="hljs-number">0</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>最后在处理 <code>vector&lt;double&gt; x,y</code> 时若出现极限可能存在的情况，考虑其两侧的函数值，如果两者差异过大，则该处极限不存在，如果两者差异不大，则该处极限可以用两侧的点取平均得到近似解，写成数学表达式有</p>
<script type="math/tex; mode=display">
\begin{gathered}
|\lim_{x\to x_0^+}f(x)-\lim_{x\to x_0^-}f(x)|<\mbox{tolerance} , \lim_{x\to x_0}f(x)\ \  \mbox{exists}\\
|\lim_{x\to x_0^+}f(x)-\lim_{x\to x_0^-}f(x)|\geq \mbox{tolerance} , \lim_{x\to x_0}f(x)\ \  \mbox{doesn't exist}
\end{gathered}</script><p>相关处理函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">int</span>(x.<span class="hljs-built_in">size</span>()); i++)&#123;<br>    judges[x[i]] = judge::isLegal;<br>    y.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getValue</span>(x[i]));<br>    <span class="hljs-comment">//如果这个点存在极限，判定两侧的差值是否较大，如果不大则使用平均值</span><br>    <span class="hljs-keyword">if</span> (judges[x[i]] == judge::perhapsLim &amp;&amp; <span class="hljs-number">0</span> &lt; i &amp;&amp; i + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">int</span>(y.<span class="hljs-built_in">size</span>()) )&#123;<br>        judges[x[i + <span class="hljs-number">1</span>]] = judge::isLegal;<br>        y.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getValue</span>(y[i + <span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(y[i + <span class="hljs-number">1</span>] - y[i - <span class="hljs-number">1</span>]) &lt;= <span class="hljs-number">100</span> * tol)&#123;<br>            y[i] = (y[i + <span class="hljs-number">1</span>] + y[i - <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;<br>            judges[x[i]] = judge::isLegal;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            judges[x[i]] = judge::divisorZero;<br>            cout &lt;&lt; x[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y[i + <span class="hljs-number">1</span>] &lt;&lt; endl;<br>        &#125;<br>        i += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>处理之后得到的 $\mbox{x,y}$ 两列表还需要单独针对极坐标系进行计算，相应计算公式如下：</p>
<script type="math/tex; mode=display">
\begin{cases}
x=\rho \cos \theta\\
y=\rho \sin \theta
\end{cases}</script><p>针对两个继承的类，使用<strong>函数重载</strong>对两种情况进行处理，在 $\mbox{mainwindow.h/cpp}$ 中通过查找是否存在 <code>&quot;θ&quot;</code> 字符串判定需要定义的类，该类中的运算方法都继承自 <code>class Expression</code> ，<strong>复用</strong>相同的使用正则表达式计算对应的函数值。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>在处理一些冗余点时，使用 <code>iterator</code> 迭代器以及 $\mbox{C++}$ 新特性对 $\mbox{vector}$ 中的元素进行迭代， $\mbox{wiki}$ 中对 $\mbox{iterator}$ 的解释如下：</p>
<blockquote>
<p>In computer programming, an iterator is an object that enables a programmer to traverse a container, particularly lists.</p>
</blockquote>
<p>$\mbox{C++}$ 语言在其标准库中广泛使用了迭代器，并描述了几类选代器，它们所允许的操作不同。这些包括前向选代器、双向选代器和随机访问选代器，在 $\mbox{C++}$ 语言中还支持自定义迭代器，更加方便构建适用的类，例如机器学习中对数据预处理就可以使用迭代器的方式进行处理（ 依照 $\mbox{epoch,batch}$ 的大小分批次处理数据），这样可以在调用接口处使用 $\mbox{auto}$ 语句更加简洁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataLoader</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//乱序编码位置</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; _rand_order;<br>    <span class="hljs-comment">//每个 batch 的最大长度，总组数</span><br>    <span class="hljs-type">int</span> batch_size = <span class="hljs-number">0</span>, endIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//所有句子编码（顺序排列）</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; _data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//三维数组</span><br>    vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; ans;<br>    <span class="hljs-comment">// 迭代器，取出 ans 对应下标结果</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Iterator</span><br>    &#123;<br>        <span class="hljs-comment">//标签</span><br>        <span class="hljs-keyword">using</span> iterator_category = std::forward_iterator_tag;<br>        <span class="hljs-keyword">using</span> difference_type   = std::<span class="hljs-type">ptrdiff_t</span>;<br>        <span class="hljs-keyword">using</span> value_type        = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;;<br>        <span class="hljs-keyword">using</span> reference         = value_type&amp;;			<span class="hljs-comment">// 迭代器所指向的变量的引用类型</span><br>        <span class="hljs-keyword">using</span> pointer           = value_type*;			<span class="hljs-comment">// 迭代器所指向的变量的指针类型</span><br>    <span class="hljs-keyword">private</span>:<br>        pointer m_ptr;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Iterator</span>(pointer ptr) : <span class="hljs-built_in">m_ptr</span>(ptr) &#123;&#125;<br>        reference <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *m_ptr; &#125;<br>        pointer <span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> m_ptr; &#125;<br>        <span class="hljs-comment">//前缀 ++</span><br>        Iterator&amp; <span class="hljs-keyword">operator</span>++() &#123; m_ptr++; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;   <span class="hljs-comment">// ++i</span><br>        <span class="hljs-comment">//后缀 ++</span><br>        Iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123; Iterator tmp = *<span class="hljs-keyword">this</span>; ++(*<span class="hljs-keyword">this</span>); <span class="hljs-keyword">return</span> tmp; &#125;<br>    &#125;;<br>    <span class="hljs-comment">//迭代器开始</span><br>    <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(&amp;ans[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// 返回迭代器</span><br>    &#125;<br>    <span class="hljs-comment">//迭代器结束</span><br>    <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(&amp;ans[endIndex]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>auto batch : D</code> 等同于 <code>iteractor it = D.begin(); it &lt; D.end();it++, batch = *it</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> batch : D)&#123;<br>    string str = <span class="hljs-built_in">matrix_unicode</span>(batch);<br>    cout&lt;&lt; str &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由此可见，将迭代器和 $\mbox{auto}$ 关键字可以简化代码的编写，对于本次函数绘图器而言，若出现一些需要去除的点（已经极限修复的点不算），则将 $\mbox{vetcor<double> x,y}$ 中对应的 $(x,y)$ 均删除，实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = x.<span class="hljs-built_in">begin</span>(), j = y.<span class="hljs-built_in">begin</span>(); i != x.<span class="hljs-built_in">end</span>() &amp;&amp; j != y.<span class="hljs-built_in">end</span>(); i++, j++)&#123;<br>    <span class="hljs-comment">//如果这个点为特殊点，将其删除</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>(judges[*i]) != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// temp.erase返回迭代器，将不合法的元素全部删除</span><br>        i = x.<span class="hljs-built_in">erase</span>(i);<br>        j = y.<span class="hljs-built_in">erase</span>(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用两个迭代器同向遍历，遇到出现问题的点就自动对应删除，达到删除不合理点的目的，例如 $f(x)=\dfrac{1}{x}$ 中 $x=0$ 的点，在处理时便自动删除该间断点。</p>
<h3 id="后端图像处理"><a href="#后端图像处理" class="headerlink" title="后端图像处理"></a>后端图像处理</h3><p>在编写函数绘图器的过程中，曾经使用过与 $\mbox{Qt 4.0}$ 版本兼容的排版库 $\mbox{miktex}$，但由于当前 $\mbox{Qt}$ 版本为 $6.2.4$ 无法和该排版库兼容，另一方面，$\mbox{miktex}$ 在数学公式渲染方面有一定缺陷，需要更换思路。</p>
<p>进而想到 $\mbox{Qt}$ 有相应的网络包，可以通过给定的 $\mbox{URL}$ 网址获取对应的图片，而 $\mbox{latex.codecogs.com}$ 官网提供可以直接获取 $\LaTeX$ 排版之后的图片，经过清晰化调整之后在以下网址 </p>
<script type="math/tex; mode=display">
\mbox{https://latex.codecogs.com/png.latex?\%5Cdpi\%7B300\%7D\%20\%5Cbg\_white\%20\%5Chuge\%20}</script><p>后面添加正确的 $\LaTeX$ 公式（如 $\mbox{y=\\dfrac\{\\sin x\}\{x}\small\wedge\normalsize \mbox{2+1\}}$），便可以获取对应图片，相应的 $y=\dfrac{\sin x}{x^2+1}$ 在该<a target="_blank" rel="noopener" href="https://latex.codecogs.com/png.latex?%5Cdpi%7B300%7D%20%5Cbg_white%20%5Chuge%20y=\dfrac{\sin%20x}{x^2+1}">网址</a>中便可得到以下高清图片：</p>
<p><img src="https://pic.imgdb.cn/item/628ce54c09475431292c425d.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<p>将一般表达式转换到 $\LaTeX$ 表达式单独列封装成一个类 $\mbox{latexImg.h/cpp}$，针对各种表达式进行替换，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;pair&lt;string, string&gt;&gt; replaceLatex = &#123;&#123;<span class="hljs-string">&quot;θ&quot;</span>,<span class="hljs-string">&quot;\\theta&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;π&quot;</span>, <span class="hljs-string">&quot;\\pi&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;（&quot;</span>, <span class="hljs-string">&quot;(&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;）&quot;</span>, <span class="hljs-string">&quot;)&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;)*(&quot;</span>, <span class="hljs-string">&quot;) \\cdot (&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;)(&quot;</span>, <span class="hljs-string">&quot;) \\cdot (&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;PI&quot;</span>, <span class="hljs-string">&quot; \\pi &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;Pi&quot;</span>, <span class="hljs-string">&quot; \\pi &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;pi&quot;</span>, <span class="hljs-string">&quot; \\pi &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;x*(&quot;</span>,<span class="hljs-string">&quot;x \\cdot (&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;x(&quot;</span>,<span class="hljs-string">&quot;x \\cdot (&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;)*x&quot;</span>, <span class="hljs-string">&quot;) \\cdot x&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;)x&quot;</span>,<span class="hljs-string">&quot;) \\cdot x&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;sin&quot;</span>, <span class="hljs-string">&quot; \\Sin &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;cos&quot;</span>, <span class="hljs-string">&quot; \\Cos &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot; \\Tan &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;ln&quot;</span>, <span class="hljs-string">&quot; \\Ln &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot; \\cdot &quot;</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pr : solveRepeations)<br>    latexStr = <span class="hljs-built_in">replace_all</span>(latexStr, pr.first, pr.second);<br></code></pre></td></tr></table></figure>
<p>使用 $\mbox{pair}$ 数据结构以及 $\mbox{auto}$ 的使用，对成对的字符串进行替换，再编写 <code>removeRedundant()</code> 函数专门处理和分式相关的字符串，例如将 $\mbox{1/x}$ 转换为 $\mbox{\\dfrac\{1\}\{x\}}$ 依此类推</p>
<p>有关网络请求获取图片的代码如下，编写在 $\mbox{mainwindow.cpp}$ 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::getImg</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//在函数里面定义一个类的实例对象，需要在前面加上关键词 class</span><br>    <span class="hljs-comment">//使用 latexImg 对象获取对应表达式的 latex 图片</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">latexImg</span> latex&#123;<span class="hljs-keyword">this</span>-&gt;exp.<span class="hljs-built_in">toStdString</span>(), isRec&#125;;<br>    string latexURL = latex.<span class="hljs-built_in">getURL</span>();<br>    <span class="hljs-comment">//构造 QNetworkAccessManage 实例模拟获取网页的过程</span><br>    <span class="hljs-function">QUrl <span class="hljs-title">url</span><span class="hljs-params">(QString::fromStdString(latexURL))</span></span>;<br>    QNetworkAccessManager manager;<br>    QEventLoop loop;<br>    QNetworkReply *reply = manager.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">QNetworkRequest</span>(url));<br>    <span class="hljs-comment">//请求结束并下载完成后，退出子事件循环</span><br>    QObject::<span class="hljs-built_in">connect</span>(reply, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">finished</span>()), &amp;loop, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">quit</span>()));<br>    <span class="hljs-comment">//开启子事件循环</span><br>    loop.<span class="hljs-built_in">exec</span>();<br>    QByteArray jpegData = reply-&gt;<span class="hljs-built_in">readAll</span>();<br>    <span class="hljs-comment">//将获取图片存储在 mainwindow 中</span><br>    latexImg.<span class="hljs-built_in">loadFromData</span>(jpegData);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在调试过程中发现，对于类中的方法，如果函数里面定义一个类的实例对象，需要在前面加上关键词 <code>class</code>，否则编译不通过</p>
<h2 id="前端展示"><a href="#前端展示" class="headerlink" title="前端展示"></a>前端展示</h2><p>对于主窗口，使用 $\mbox{Qt}$ 中的设计师界面添加相应的按钮以及修改相应的初始值，设计相应的前端框架界面</p>
<p><img src="https://pic.imgdb.cn/item/628cf1f4094754312940eff6.jpg" srcset="/img/loading.gif" lazyload alt=""></p>
<p>对于从后端拿到的<strong>数据</strong>，分别进行等比例缩放以及在合适的位置处增加坐标轴和标度，从数学的角度来说，该步骤是将数据所在的线性空间<strong>线性且合适地映射</strong>到画布所在的线性空间。注意绘图原点在左上角，$x$ 方向向右，$y$ 方向向下，绘制的坐标轴处的箭头需要一定的偏置，本绘图器采用 $45\degree$ ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-comment">// x 放大倍数</span><br>   <span class="hljs-type">int</span> zoomOutX = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() * <span class="hljs-number">0.9</span> / width;<br>   <span class="hljs-comment">// y 放大倍数</span><br>   <span class="hljs-type">int</span> zoomOutY = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.9</span> / height;<br>   <span class="hljs-comment">//放大倍数，取较小者</span><br>   <span class="hljs-type">int</span> zoomOut = zoomOutX &lt; zoomOutY ? zoomOutX : zoomOutY;<br><span class="hljs-comment">//原点 x</span><br>   <span class="hljs-type">double</span> originX = offsetX * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() * <span class="hljs-number">0.05</span>;<br>   <span class="hljs-comment">//原点 y</span><br>   <span class="hljs-type">double</span> originY = offsetY * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.05</span>;<br>   minX = (minX + offsetX) * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() * <span class="hljs-number">0.05</span>;<br>   maxX = (maxX + offsetX) * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() * <span class="hljs-number">0.05</span>;<br>   minY = (minY + offsetY) * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.05</span>;<br>   maxY = (maxY + offsetY) * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.05</span>;<br>   <span class="hljs-comment">// x 轴</span><br>   <span class="hljs-function">QLine <span class="hljs-title">xLine</span><span class="hljs-params">(minX, originY, maxX, originY)</span></span>;<br>   qPainter.<span class="hljs-built_in">drawLine</span>(xLine);<br>   <span class="hljs-comment">// y 轴</span><br>   <span class="hljs-function">QLine <span class="hljs-title">yLine</span><span class="hljs-params">(originX, minY, originX, maxY)</span></span>;<br>qPainter.<span class="hljs-built_in">drawLine</span>(yLine);<br>   <span class="hljs-comment">//绘制原点、x轴、y轴处的字符</span><br>   qPainter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">QPointF</span>(originX + <span class="hljs-number">2</span>, originY - <span class="hljs-number">2</span>), <span class="hljs-string">&quot;O&quot;</span>);<br>   qPainter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">QPointF</span>(maxX, originY - <span class="hljs-number">7</span>), <span class="hljs-string">&quot;x&quot;</span>);<br>   qPainter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">QPointF</span>(originX + <span class="hljs-number">7</span>, minY), <span class="hljs-string">&quot;y&quot;</span>);<br>   <span class="hljs-comment">//绘制箭头，45°方向绘制箭头</span><br>   QLineF *arrows = <span class="hljs-keyword">new</span> QLineF[<span class="hljs-number">4</span>]&#123;&#123;maxX, originY, maxX - <span class="hljs-number">5</span>, originY - <span class="hljs-number">5</span>&#125;,<br>                                  &#123;maxX, originY, maxX - <span class="hljs-number">5</span>, originY + <span class="hljs-number">5</span>&#125;,<br>                                  &#123;originX, minY, originX - <span class="hljs-number">5</span>, minY + <span class="hljs-number">5</span>&#125;,<br>                                  &#123;originX, minY, originX + <span class="hljs-number">5</span>, minY + <span class="hljs-number">5</span>&#125;&#125;;<br><br></code></pre></td></tr></table></figure>
<p>而绘制刻度时，原点需要作为一个刻度，$y$ 轴需要正负号分别计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;originY + i * hSpacer &lt;= maxScreenY;i++)&#123;<br>       <span class="hljs-type">int</span> screenY = originY + i * hSpacer;<br>       qPainter.<span class="hljs-built_in">drawLine</span>(originX, screenY, originX + <span class="hljs-number">3</span>, screenY);<br>       <span class="hljs-type">double</span> realY = (screenY - <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.05</span>) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(zoomOut) - offsetY;<br>       qPainter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">QPoint</span>(originX + <span class="hljs-number">13</span>, screenY + <span class="hljs-number">5</span>), QString::<span class="hljs-built_in">number</span>(-realY, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">2</span>));<br>   &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;originY - i * hSpacer &gt;= minScreenY;i++)&#123;<br>       <span class="hljs-type">int</span> screenY = originY - i * hSpacer;<br>       qPainter.<span class="hljs-built_in">drawLine</span>(originX, screenY, originX + <span class="hljs-number">3</span>, screenY);<br>       <span class="hljs-type">double</span> realY = (screenY - <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.05</span>) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(zoomOut) - offsetY;<br>       qPainter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">QPoint</span>(originX + <span class="hljs-number">13</span>, screenY + <span class="hljs-number">5</span>), QString::<span class="hljs-built_in">number</span>(-realY, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">2</span>));<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>同理，对于从后端拿到的<strong>图像</strong>，进行背景颜色的替换再通过计算当前画大小得到相应的右上角位置，并最后设置画笔为蓝色，调用 $\mbox{Qt}$ 中的 <code>qPainter.drawPolyline(points, size)</code> 函数平滑连接各点，得到相应的图像</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-comment">//获取当前画布宽度和高度</span><br><span class="hljs-type">double</span> imgWidth = originImg.<span class="hljs-built_in">width</span>();<br>   <span class="hljs-type">double</span> imgHeight = originImg.<span class="hljs-built_in">height</span>();<br><span class="hljs-comment">//比较得到图片的高度</span><br>   <span class="hljs-type">int</span> sizeImg = <span class="hljs-built_in">MIN</span>(<span class="hljs-number">60</span>, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() / <span class="hljs-number">1.2</span> / imgWidth * imgHeight);<br><span class="hljs-comment">//将图片放置在合适的位置</span><br>   qPainter.<span class="hljs-built_in">drawPixmap</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() - sizeImg * <span class="hljs-number">1.2</span> * imgWidth / imgHeight, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.1</span>, sizeImg * imgWidth / imgHeight, sizeImg, <span class="hljs-built_in">changeBackGroundColor</span>(originImg));<br>   qPainter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>));<br>   qPainter.<span class="hljs-built_in">drawPolyline</span>(points, size);<br></code></pre></td></tr></table></figure>
<h3 id="高精度计时"><a href="#高精度计时" class="headerlink" title="高精度计时"></a>高精度计时</h3><p>关于这部分，可以访问本人博客有关 $\mbox{OOP}$ 第二次小作业报告中的探讨，网址如下<a href="https://lr-tsinghua11.github.io/2022/03/06/Program/OOP%20Homework%202/">面向对象编程第二次作业</a></p>
<p>大致为调用相关 $\mbox{API}$ ，通过所在电脑的频率和计数器高精度计算相关时间，并将时间显示在图像标题处</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="表达式函数"><a href="#表达式函数" class="headerlink" title="表达式函数"></a>表达式函数</h3><p>由于 $\mbox{Qt}$ 相关的 $\mbox{ui}$ 界面在编写过程中已经写好，对于该表达式函数，使用 $\mbox{Visual studio}$ 单独定义该类并进行测试，通过的测试样例如下（其中大致可以分为几个部分）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>单元测试分类</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>乘法含负号</td>
<td><code>Expression e(&quot;2*(-2)&quot;);</code></td>
</tr>
<tr>
<td>除法含负号</td>
<td><code>Expression e(&quot;-1/1&quot;);</code></td>
</tr>
<tr>
<td>加减（含括号）</td>
<td><code>Expression e(&quot;(-1+1)*(-1-1)&quot;);</code></td>
</tr>
<tr>
<td>加乘（含括号）</td>
<td><code>Expression e(&quot;(1+2)*(2+3)&quot;);</code></td>
</tr>
<tr>
<td>加减乘（含括号）</td>
<td><code>Expression e(&quot;(1+1)*(1-1)&quot;);</code></td>
</tr>
<tr>
<td>加乘（含括号和负号）</td>
<td><code>Expression e&#123; &quot;-(-(2*4-1*3))&quot;,1&#125;;</code></td>
</tr>
<tr>
<td>加减和幂次</td>
<td><code>Expression e(&quot;-1^3+3*1&quot;);</code></td>
</tr>
<tr>
<td>加减除幂次</td>
<td><code>Expression e(&quot;(x^2-1)/(x+1)&quot;);</code></td>
</tr>
<tr>
<td>三角函数（含负号）</td>
<td><code>Expression e(&quot;sin(-1)&quot;);</code>    <code>Expression e(&quot;tan(-1000)&quot;);</code></td>
</tr>
</tbody>
</table>
</div>
<p>调取之后输出相应的结果并口算进行验证，结果符合预测，验证代码如下，在表达式分段处加入 <code>cout &lt;&lt; Exp</code> 等语句调试上述正则表达式相关过程，进行 $\mbox{Debug}$：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;The result is &quot;</span> &lt;&lt; e.<span class="hljs-built_in">getValue</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Judge is &quot;</span> &lt;&lt; e.judges[<span class="hljs-built_in">double</span>(<span class="hljs-number">0</span>)] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>$\mbox{Visual Studio}$ 中单元测试代码截屏如下：</p>
<p><img src="https://pic.imgdb.cn/item/628cf6b7094754312948beb1.jpg" srcset="/img/loading.gif" lazyload style="zoom:40%;" /></p>
<h3 id="处理-LaTeX-公式"><a href="#处理-LaTeX-公式" class="headerlink" title="处理 $\LaTeX$ 公式"></a>处理 $\LaTeX$ 公式</h3><p>在中后期编写处理 $\LaTeX$ 公式进行单元测试，采用 $\mbox{wsl/Linux}$ 子系统控制台终端进行测试，摆脱大型 $\mbox{IDE}$ 的束缚，让代码输入输出全部都在 $\mbox{powershell}$ 中进行，能够达到快速 $\mbox{Debug}$ 的效果，截图如下：</p>
<p><img src="https://pic.imgdb.cn/item/628cf9e809475431294dfcd6.jpg" srcset="/img/loading.gif" lazyload style="zoom:60%;" /></p>
<p>其中可以在控制台中使用重定向 <code>&gt;</code> 运算符将输入输出结果保存到相应的 $\mbox{txt}$ 文件中，测试通过的样例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-number">1</span>/x \dfrac&#123;<span class="hljs-number">1</span>&#125;&#123;x&#125;<br><span class="hljs-number">1</span>/x+<span class="hljs-number">2</span>/x \dfrac&#123;<span class="hljs-number">1</span>&#125;&#123;x&#125;+\dfrac&#123;<span class="hljs-number">2</span>&#125;&#123;x&#125;<br>(<span class="hljs-number">1</span>+x)/x \dfrac&#123;<span class="hljs-number">1</span>+x&#125;&#123;x&#125;<br><span class="hljs-number">1</span>/(x+<span class="hljs-number">1</span>) \dfrac&#123;<span class="hljs-number">1</span>&#125;&#123;x+<span class="hljs-number">1</span>&#125;<br>(x+<span class="hljs-number">2</span>)/(x+<span class="hljs-number">1</span>) \dfrac&#123;x+<span class="hljs-number">2</span>&#125;&#123;x+<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure>
<p>对于多重分式需要括号匹配，该公式转换会出现一些问题。但是，在函数绘制中很少出现这种情形，如 $\dfrac{1+\dfrac{1}{x}}{x}=\dfrac{x+1}{x^2}$ 总可以通过手工化简的方式简化为只需要一个分号的形式，不需要考虑多重分式的情况。</p>
<p>从而该单元测试函数的测试至此为止，<strong>否则会极大影响开发进度</strong>。</p>
<h2 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h2><ul>
<li><p>该函数绘图器中正则表达式遍历查找的算法时间消耗比较大，对一般的函数基本消耗时间 $\in[1s,2s]$ ，由于数据结构相关课程没有学习，猜测一些树的结构能够加快运算速度</p>
</li>
<li><p>本次函数绘图器开发周期至少整整 $7$ 天，从最开始的手足无措，到后面一点点列出需求文档不断进行实现和填充，在需求和实现之间追求高效率地开发，之前编写的函数绘图器需求文档截图如下：</p>
<p><img src="https://pic.imgdb.cn/item/628cffa70947543129579805.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
</li>
<li><p>从上图中可以发现有些功能仍然没有实现，由于时间原因只能先搁置一段时间。但这种 $\mbox{to-do-list}$ 的方式可以很大幅度提高大作业代码编写的效率</p>
</li>
<li><p>单元测试在一个功能模块完成后便可以进行，针对不同的情况逐一进行测验，遇到相应的问题马上进行调整和修复，否则各种网状结构连接一起运行时，不容易定位 $\mbox{bug}$</p>
</li>
<li><p>一些难以解决的问题可以考虑另辟蹊径（如使用发送网络请求的方式获取 $\LaTeX$ 图片）</p>
</li>
<li><p>$\mbox{C++}$ 新特性的使用可以省去了很多繁琐的语法表达式，加快代码的编写效率，虽然和 $\mbox{pythonic}$ 的 $\mbox{python}$ 语言有一定差距，但毕竟前者更接触底层，效率较高（当然对一些特定问题也未必），两者各有千秋</p>
</li>
<li><p>$\mbox{Qt}$ 的熟悉以及使用虽然让我踩过不少坑，不过，对报错信息的理解以及在各种网络资源的帮助之下，逐渐排开各种“雷”</p>
</li>
</ul>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B/" class="category-chain-item">编程</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BC%96%E7%A8%8B/C/" class="category-chain-item">C++</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/">#C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Functional plotter</div>
      <div>https://lr-tsinghua11.github.io/2022/05/25/%E7%BC%96%E7%A8%8B/%E5%87%BD%E6%95%B0%E7%BB%98%E5%9B%BE%E5%99%A8%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Learning_rate</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月25日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/03/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E7%A7%AF%E5%88%86A(2)%E6%9C%9F%E6%9C%AB%E6%A8%A1%E6%8B%9F%E8%80%83%E8%AF%95%E8%AF%95%E9%A2%98/" title="A practice for Calculus final exam">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">A practice for Calculus final exam</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/" title="Foundation for machine learning">
                        <span class="hidden-mobile">Foundation for machine learning</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.13.10/mermaid.min.js', function() {
    mermaid.initialize({"theme":"forest"});
  });
</script>





    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":true,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  
    <script  src="/js/img-lazyload.js" ></script>
  



  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var title = subtitle.title;
      
        typing(title);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?2d5b78dfbf046ab610d306e42da0ed37";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  

  
    
  





  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
