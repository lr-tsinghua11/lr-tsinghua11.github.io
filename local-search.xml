<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust Notes</title>
    <link href="/2022/09/11/rust/"/>
    <url>/2022/09/11/rust/</url>
    
    <content type="html"><![CDATA[<h1 id="rust-class-1">Rust class 1</h1><h2 id="语言特性">语言特性</h2><p><strong>高效：</strong>Python 解释器，java 虚拟机，而 rust <strong>没有运行时</strong>，在 bare metal（裸机）上运行。</p><p>安卓基于 java，苹果 swift，有相应的垃圾回收机制，易卡顿，而 rust 没有垃圾收集机制。</p><p><strong>可靠：</strong>用<strong>类型系统和所有权模型</strong>来确保内存安全性和线程安全性，在编译时消除各种潜在的问题。</p><p><strong>好用：</strong>文档丰富，编译器（提供更改方法）。</p><h2 id="rust-语言应用">Rust 语言应用</h2><ul><li><p>Servo 浏览器引擎，Redox 操作系统，Linux 操作系统驱动和模块的支持</p></li><li><p>清华大学：操作系统教学 rCore，性能所 MadFS 文件系统，IO 500 遥遥领先</p></li><li><p>Cargo 能够大规模添加依赖（第三方库），不需要像 C++ 花时间去寻找并下载源码</p></li></ul><h2 id="rust-基础语法">rust 基础语法</h2><p>C++ cin cout 读取失败时，将流转换为非法，而 rust 则会显式地处理异常</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">io::<span class="hljs-title function_ invoke__">stdin</span>()<br>  .<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess)<br>  .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You guessed: &#123;guess&#125;&quot;</span>);<br></code></pre></td></tr></table></figure><p>猜数获取数字以及猜测语句</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// (1..=100) 代表 1-100 左闭右闭</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">secret_number</span> = rand::<span class="hljs-title function_ invoke__">thread_rng</span>().<span class="hljs-title function_ invoke__">gen_range</span>(<span class="hljs-number">1</span>..=<span class="hljs-number">100</span>);<br><span class="hljs-comment">// trim()前后处理空格，parse() 解析（转换类型）</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>: <span class="hljs-type">u32</span> = guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Please type a number!&quot;</span>);<br></code></pre></td></tr></table></figure><p>变量绑定</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">17</span>; <span class="hljs-comment">// 变量绑定，且隐式推断类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i16</span> = <span class="hljs-number">17</span>; <span class="hljs-comment">// 显式绑定类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>x += <span class="hljs-number">1</span>; <span class="hljs-comment">// error: re-assignment of immutable variable x</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span> = <span class="hljs-number">5</span>;<br>y += <span class="hljs-number">1</span>; <span class="hljs-comment">// OK!</span><br></code></pre></td></tr></table></figure><p>变量类型</p><ul><li>布尔 bool：两个值 true/false。</li><li>字符 char：用单引号，例如 'R'、' 计', 是 Unicode 的。</li><li>数值：分为整数和浮点数，有不同的大小和符号属性。<ul><li>i8、i16、i32、i64、isize</li><li>u8、u16、u32、u64、usize</li><li>f32、f64</li></ul></li><li>其中 isize 和 usize 是指针大小的整数，因此它们的大小与机器架构相关。</li><li>字面值 (literals) 写为 10i8、10u16、10.0f32、10usize 等。</li><li>字面值如果不指定类型，则默认整数为 i32，浮点数为 f64。</li><li>数组 (arrays)、切片 (slices)、str 字符串 (strings)、元组 (tuples)。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr1</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// (array of 3 elements)</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr2</span> = [<span class="hljs-number">2</span>; <span class="hljs-number">32</span>]; <span class="hljs-comment">// (array of 32 `2`s)</span><br><span class="hljs-comment">// 切片</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">total_slice</span> = &amp;arr; <span class="hljs-comment">// Slice all of `arr`</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">total_slice</span> = &amp;arr[..]; <span class="hljs-comment">// Same, but more explicit</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">partial_slice</span> = &amp;arr[<span class="hljs-number">2</span>..<span class="hljs-number">5</span>]; <span class="hljs-comment">// [2, 3, 4]</span><br><span class="hljs-comment">// 字符 String 和 &amp;str，可以分别当做 C++ 中的 string 和 const char*</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;galaxy&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;galaxy&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span>: <span class="hljs-type">String</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;galaxy&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s4</span>: &amp;<span class="hljs-type">str</span> = &amp;s3;<br><span class="hljs-comment">// 向量</span><br><span class="hljs-comment">// Explicit typing</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v0</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = Vec::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-comment">// v1 and v2 are equal</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1</span> = Vec::<span class="hljs-title function_ invoke__">new</span>();<br>v1.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br>v1.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2</span>);<br>v1.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// v3 and v4 are equal</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v3</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v4</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-comment">// 输出向量中的所有元素</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Task 10: The array is &#123;:?&#125;&quot;</span>, v2);<br></code></pre></td></tr></table></figure><p>类型转换</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 as 进行类型转换 (cast)</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">u32</span> = x <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br><span class="hljs-comment">// 一般来说只能在可以安全转换的类型之间进行转换操作</span><br></code></pre></td></tr></table></figure><p>引用</p><ul><li>在类型前面写 &amp; 表示引用类型： &amp;i32。</li><li>用 &amp; 来取引用（和 C++ 类似）。</li><li>用 * 来解引用（和 C++ 类似）。</li><li>rust 中引用和一般意义的指针是不一样的。</li></ul><p>条件语句</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-number">10</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span> &#123;<br><span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Not greater than zero!&quot;</span>);<br>-<span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>循环语句，三种循环 <span class="math inline">\(\begin{cases}\text{while}\\\text{loop = while true} \\\text{for}\end{cases}\)</span></p><p>迭代器</p><ul><li>n..m 创建一个从 n 到 m 半闭半开区间的迭代器。</li><li>n..=m 创建一个从 n 到 m 闭区间的迭代器。</li><li>很多数据结构可以当做迭代器来使用，比如数组、切片，还有向量 Vec 等等。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">xs</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-comment">// Loop through elements in a slice of `xs`.</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> &amp;xs &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>匹配语句，其中 <code>_</code> 匹配所有情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 单变量版本</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">match</span> x &#123;<br>  <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;one fish&quot;</span>), <span class="hljs-comment">// &lt;- comma required</span><br>  <span class="hljs-number">2</span> =&gt; &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;two fish&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;two fish&quot;</span>);<br>  &#125;, <span class="hljs-comment">// &lt;- comma optional when using braces</span><br>  _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;no fish for you&quot;</span>), <span class="hljs-comment">// &quot;otherwise&quot; case</span><br>&#125;<br><span class="hljs-comment">// 元组版本</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = -<span class="hljs-number">3</span>;<br><span class="hljs-title function_ invoke__">match</span> (x, y) &#123;<br>  (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;one&quot;</span>),<br>  (<span class="hljs-number">2</span>, j) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;two, &#123;&#125;&quot;</span>, j),<br>  (_, <span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>  (i, j) <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">5</span> &amp;&amp; j &lt; <span class="hljs-number">0</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;On guard!&quot;</span>),<br>  (_, _) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;:&lt;&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>模式绑定</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (a, b) = (<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><p>函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 函数头</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(x: T, y: U, z: V) <span class="hljs-punctuation">-&gt;</span> T &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// T 类型参数 x ，U 类型参数 y ，V 类型参数 z，返回 T 类型</span><br><span class="hljs-comment">// Rust 必须显式定义函数的参数和返回值的类型。</span><br><span class="hljs-comment">// 实际上编译器是可以推断函数的参数和返回值的类型的，但是 Rust 的设计者认为显式指定更好</span><br><br><span class="hljs-comment">// 函数返回</span><br><span class="hljs-comment">// 函数最后一个表达式是其返回值，可以使用 return 提前返回</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">square</span>(n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>n * n<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">squareish</span>(n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">5</span> &#123; <span class="hljs-keyword">return</span> n; &#125;<br>n * n<br>&#125;<br></code></pre></td></tr></table></figure><p>print! 和 println!</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, x, <span class="hljs-number">3</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// =&gt; foo, 3, true</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;, &#123;:?&#125;&quot;</span>, x, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-comment">// =&gt; &quot;foo&quot;, [1, 2, 3]</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;0&#125;, &#123;y&#125;, &#123;0&#125;&quot;</span>, x);<br><span class="hljs-comment">// =&gt; foo, 1, foo</span><br><br></code></pre></td></tr></table></figure><p>format!</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">fmted</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;:x&#125;, &#123;:?&#125;&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-number">155</span>, <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br><span class="hljs-comment">// fmted == &quot;12, 9b, Some(&quot;Hello&quot;)&quot;</span><br></code></pre></td></tr></table></figure><p>panic! 处理错误的方式，并不优雅</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Kaboom!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>assert! 和 assert_eq!</p><ul><li>如果条件 condition 不成立， assert!(condition) 会导致<strong>恐慌</strong>。</li><li>如果 left != right， assert_eq!(left, right) 会导致<strong>恐慌</strong>。</li></ul><p>unreachable! 用于表达不会达到的分支，如果达到就会导致<strong>恐慌</strong></p><p>unimplemented! 标注没有实现的功能，panic!("not yet implemented") 的简写</p><h1 id="lecture-2">lecture 2</h1><p>Rust 语言最 core 的语法，语言 = 核心语法 + 标准库</p><h2 id="所有权">所有权</h2><ul><li><p>资源管理的需求：内存使用的安全和性能</p><p>内存资源：<span class="math inline">\(\begin{cases}全局对象：事先分配的内存空间段，启动时分配，结束时回收\\局部对象：分配在栈上，进入函数时分配，退出函数时回收\\动态对象：分配在堆上，需要时分配，不需要时回收\end{cases}\)</span></p></li><li><p>对于小型程序，<code>new</code> 之后不 <code>delete</code> 无所谓，程序结束之后会自动删除；但是对于大型 24h 网络服务端程序，容易出现问题，总有分配内存失败的时候</p></li><li><p>内存管理方式，<strong>用户指定和垃圾回收</strong>，前者要求编写者的严谨，后者分为小回收和大回收，</p><p>安卓手机卡的原因：处于大回收状态，逻辑不明确，性能差</p></li><li><p>C艹 将构造和分配集成在一起：</p><ul><li><p>拷贝构造：在语义上实现一个对象变两个对象（二进制串的拷贝）。</p></li><li><p>移动构造：在语义上实现将一个对象的资源转移给另一个对象。</p></li></ul></li><li><p>空指针、悬垂指针（指针所指对象被释放，但指针没有做修改）、双重释放（两个对象的指针指向同一块内存空间，两个对象均释放）等问题导致运行时错误。</p></li></ul><p>计算机技术本质上是实现一个 <code>Trade-off</code></p><ul><li><p>Rust 中的每个值都有所有者 (owner)。</p></li><li><p>同一时刻<strong>只有一个</strong>所有者。</p></li><li><p>当所有者失效，值也将被丢弃。</p></li></ul><p>这是</p><p>一份数据只有一个所有者，如果超出作用域，其绑定数据自动释放</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() &#123;<br>  <span class="hljs-comment">// Creates a Vec object.</span><br>  <span class="hljs-comment">// Gives ownership of the Vec object to v1.</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  v1.<span class="hljs-title function_ invoke__">pop</span>();<br>  v1.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">4</span>);<br>  <span class="hljs-comment">// At the end of the scope, v1 goes out of scope.</span><br>  <span class="hljs-comment">// v1 still owns the Vec object, so it can be cleaned up.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下代码在编译过程中出错，所有权的转移</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust">  <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-comment">// Ownership of the Vec object moves to v2.</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = v1;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, v1[<span class="hljs-number">2</span>]); <span class="hljs-comment">// error: use of moved value `v1`</span><br>----------------------Compile Error-----------------------<br>error[E0382]: borrow of moved value: `v1`<br>  |<br><span class="hljs-number">2</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  |         -- <span class="hljs-keyword">move</span> occurs because `v1` has <span class="hljs-keyword">type</span> `<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;`, which does not implement the `<span class="hljs-built_in">Copy</span>` <span class="hljs-keyword">trait</span><br><span class="hljs-number">3</span> |     <span class="hljs-comment">// Ownership of the Vec object moves to v2.</span><br><span class="hljs-number">4</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = v1;<br>  |              -- value moved here<br><span class="hljs-number">5</span> |     <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, v1[<span class="hljs-number">2</span>]); <span class="hljs-comment">// error: use of moved value `v1`</span><br>  |                    ^^ value borrowed here after <span class="hljs-keyword">move</span><br></code></pre></td></tr></table></figure><p>在函数调用的时候，如果传入参数过多，还要将所有权还回去，比较麻烦</p><p>使用<strong>借用</strong>，所有权本身没有变化，相当于是借用一下数据</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// v_ref is a reference to v.</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v_ref</span> = &amp;v;<br><span class="hljs-comment">// Moving ownership to v_new would invalidate v_ref.</span><br><span class="hljs-comment">// error: cannot move out of `v` because it is borrowed</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v_new</span> = v;<br><span class="hljs-comment">// Cancel the effect of NLL (non-lexical lifetime)</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, v_ref);<br></code></pre></td></tr></table></figure><p>rust 语言是一门<strong>面向编译器语言</strong>，可以认为写不出运行有问题的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 借用与函数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">length</span>(vec_ref: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>  <span class="hljs-comment">// vec_ref is auto-dereferenced when you call methods on it.</span><br>  vec_ref.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br><span class="hljs-comment">// 可变借用</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(vec_ref: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, x: <span class="hljs-type">i32</span>) &#123;<br>vec_ref.<span class="hljs-title function_ invoke__">push</span>(x);<br>&#125;<br><span class="hljs-comment">// Copy (特型)</span><br><span class="hljs-comment">// i32、f64、char、bool 可以拷贝</span><br><span class="hljs-comment">// 生命周期检查</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: &amp;<span class="hljs-type">i32</span>;<br>&#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>  y = &amp;x; <span class="hljs-comment">// error: `x` does not live long enough</span><br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *y);<br></code></pre></td></tr></table></figure><p>向量的三种迭代方式，不可变借用 <code>&amp;V</code>、可变借用 <code>&amp;mut V</code>、所有权 <code>V</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vs</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-comment">// Borrow immutably</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> &amp;vs &#123; <span class="hljs-comment">// Can also write `for v in vs.iter()`</span><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I&#x27;m borrowing &#123;&#125;.&quot;</span>, v);<br>&#125;<br><span class="hljs-comment">// Borrow mutably</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> vs &#123; <span class="hljs-comment">// Can also write `for v in vs.iter_mut()`</span><br>  *v = *v + <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I&#x27;m mutably borrowing &#123;&#125;.&quot;</span>, v);<br>&#125;<br><span class="hljs-comment">// Take ownership of the whole vector</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> vs &#123; <span class="hljs-comment">// Can also write `for v in vs.into_iter()`</span><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I now own &#123;&#125;! AHAHAHAHA!&quot;</span>, v);<br>&#125;<br></code></pre></td></tr></table></figure><p>切片是一种特殊的引用，代表序列中的一个指定片段</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h2 id="结构化数据">结构化数据</h2><p>有两种 struct 和 enum，mod 相当于 C艹 中的 namespace</p><p>结构体用 CamelCase 命名方式，里面的域用 snake_case 命名方式。</p><p>语法糖，对别的方法进行一种实现，写起来简便</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123; a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>, c: <span class="hljs-type">i32</span>, d: <span class="hljs-type">i32</span>, e: <span class="hljs-type">i32</span> &#125;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = Foo &#123; a: <span class="hljs-number">1</span>, b: <span class="hljs-number">1</span>, c: <span class="hljs-number">2</span>, d: <span class="hljs-number">2</span>, e: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">x2</span> = Foo &#123; e: <span class="hljs-number">4</span>, .. x &#125;;<br><span class="hljs-comment">// Useful to update multiple fields of the same struct:</span><br>x = Foo &#123; a: <span class="hljs-number">2</span>, b: <span class="hljs-number">2</span>, e: <span class="hljs-number">2</span>, .. x &#125;;<br></code></pre></td></tr></table></figure><p>Rust 的枚举要强很多，是<strong>和类型</strong>，用来表示多选一的数据（<strong>代数数据类型</strong>，如笛卡尔坐标系）</p><p>变体 <span class="math inline">\(无数据、有命名的数据域(结构体)、无命名的数据域(元组变体)\)</span>，如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Resultish</span> &#123;<br>  <span class="hljs-literal">Ok</span>,<br>  Warning &#123; code: <span class="hljs-type">i32</span>, message: <span class="hljs-type">String</span> &#125;,<br>  <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-type">String</span>)<br>&#125;<br><span class="hljs-comment">// 使用 Resultish::each 来访问并匹配数据</span><br><span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">make_request</span>() &#123;<br>  Resultish::<span class="hljs-literal">Ok</span> =&gt;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Success!&quot;</span>),<br>  Resultish::Warning &#123; code, message &#125; =&gt;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Warning: &#123;&#125;!&quot;</span>, message),<br>  Resultish::<span class="hljs-title function_ invoke__">Err</span>(s) =&gt;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Failed with error: &#123;&#125;&quot;</span>, s),<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类型还可以递归</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>Nil,<br><span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, List),<br>&#125;<br><span class="hljs-comment">// 但上述枚举类型会报错，会趋于无穷大，使用 Box 加以限制</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">boxed_five</span> = Box::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>  Nil,<br>  <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">Box</span>&lt;List&gt;), <span class="hljs-comment">// OK!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法与所有权</p><p>方法的第一个参数（名字为 self）决定这个方法需要的所有权种类，分类更加细致：</p><ul><li>&amp;self：方法借用对象的值。 一般情况下尽量使用这种方式，类似于 C++ 中的常成员函数。</li><li>&amp;mut self：方法可变地借用对象的值。 在方法需要修改对象时使用，类似于 C++ 中的普通成员函数。</li><li>self：方法获得对象的所有权。 方法会消耗掉对象，同时可以返回其他的值。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">distance</span>(&amp;<span class="hljs-keyword">self</span>, other: Point) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f32</span> &#123;<br>    <span class="hljs-keyword">let</span> (dx, dy) = (<span class="hljs-keyword">self</span>.x - other.x, <span class="hljs-keyword">self</span>.y - other.y);<br>    ((dx.<span class="hljs-title function_ invoke__">pow</span>(<span class="hljs-number">2</span>) + dy.<span class="hljs-title function_ invoke__">pow</span>(<span class="hljs-number">2</span>)) <span class="hljs-keyword">as</span> <span class="hljs-type">f32</span>).<span class="hljs-title function_ invoke__">sqrt</span>()<br>  &#125;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">translate</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-keyword">self</span>.x += x;<br>    <span class="hljs-keyword">self</span>.y += y;<br>  &#125;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">mirror_y</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Point &#123;<br>    Point &#123; x: -<span class="hljs-keyword">self</span>.x, y: <span class="hljs-keyword">self</span>.y &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>一般会创建一个名为 new 的关联函数起到构造函数的作用。</p><p>Rust 没有内置的构造函数语法，也不会自动构造。</p></li><li><p>方法、关联函数不能重载、方法不能继承</p></li></ul><h2 id="模式匹配">模式匹配</h2><p>对结构体进行解构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>  x: <span class="hljs-type">i32</span>,<br>  y: <span class="hljs-type">i32</span>,<br>&#125;<br><span class="hljs-keyword">match</span> p &#123;<br>  Point &#123; x, y &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, x, y)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用引用的方式匹配</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">17</span>;<br><span class="hljs-comment">// 打印数值或者修改值</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-number">17</span>;<br><span class="hljs-keyword">match</span> x &#123;<br>  <span class="hljs-keyword">ref</span> r <span class="hljs-keyword">if</span> x == <span class="hljs-number">5</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r),<br>  <span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> r =&gt; *r = <span class="hljs-number">5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>内部绑定（使用 <code>@</code> ）</p><p>模式匹配的穷尽性，否则会报错（使用 <code>_</code> 表示其他情况）</p><p><code>for</code> 循环的模式匹配</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-title function_ invoke__">for</span> (i, x) <span class="hljs-keyword">in</span> v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>  <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;v[&#123;i&#125;] = &#123;x&#125; &quot;</span>);<br>&#125;<br><span class="hljs-comment">// v[0] = 1 v[1] = 2 v[2] = 3 </span><br></code></pre></td></tr></table></figure><h1 id="lecture-3标准库">lecture 3（标准库）</h1><h2 id="编码">编码</h2><p>C艹 语言 11 比 98 增加 unordered_map</p><p>C 里面的 string 为 <code>\0</code> 操作，即使是访问字符串长度也需要 <span class="math inline">\(O(n)\)</span> 的空间</p><p>而 C艹 使用 <code>std::string</code> 更加方法，对负数进行补码操作，便于加法</p><ul><li>Rust 的字符串处理机制比较复杂。<ul><li>主要是用 UTF-8 编码的 Unicode 字符序列。</li><li>不是空字符 '\0' 结尾的 C 风格字符串，可以包含空字符。</li></ul></li><li>主要有两大类： &amp;str 和 String。</li></ul><p>字符的标识，与信息论有关：</p><p>模拟电路（信号是连续变化的，模拟类型更多，但不抗干扰，教室里的钟表）</p><p>数字电路（低电位和高电位，0V 和 5V，能抗干扰，数字手表）</p><p>ASCII 码 0 是 48，A 是 65，a 是 97</p><ul><li><p>编码：字符在计算机内部的表示方式</p></li><li><p>早期： ASCII 码，以英文字符为主， 7 位二进制</p></li><li><p>中文： GB 2312-1980《信息交换用汉字编码字符集》， 6,763 个汉字，两个字节</p><ul><li>GB 18030-2005《信息技术中文编码字符集》， 70,244 个汉字，两个字节或四个字节</li></ul></li><li><p>Unicode：试图把全世界的文字都纳入进来，收集了 144,697 个字符，四个字节</p><ul><li>常用 UTF-8 的形式来表示，<strong>变长</strong>一到四个字节，rust 便使用这种编码</li></ul></li><li><p>会出现乱码问题</p></li></ul><h3 align="center">Unicode 中文乱码速查表</h3><table><colgroup><col style="width: 3%" /><col style="width: 26%" /><col style="width: 32%" /><col style="width: 36%" /></colgroup><thead><tr class="header"><th>xxxxxx</th><th>示例</th><th>特点</th><th>产生原因</th></tr></thead><tbody><tr class="odd"><td>古文码</td><td>鐢辨湀瑕佸ソ濂藉涔犲ぉ澶╁悜涓?</td><td>大都为不认识的古文，并加杂日韩文</td><td>以 GBK 方式读取 UTF-8 编码的中文</td></tr><tr class="even"><td>口字码</td><td>����Ҫ�¨2�ѧϰ������</td><td>大部分字符为小方块</td><td>以 UTF-8 的方式读取 GBK 编码的中文</td></tr><tr class="odd"><td>符号码</td><td>ç”±æœˆè|å￥½å￥½å-|ä1 å¤©å¤©å‘ä¸Š</td><td>大部分字符为各种符号</td><td>以 ISO8859-1 方式读取 UTF-8 编码的中文</td></tr><tr class="even"><td>拼音码</td><td>óéÔÂòaoÃoÃÑ§Ï°ììììÏòéÏ</td><td>大部分字符为头顶带有各种类似声调符号的字母</td><td>以 ISO8859-1 方式读取 GBK 编码的中文</td></tr><tr class="odd"><td>问句码</td><td>由月要好好学习天天向??</td><td>字符串长度为偶数时正确，长度为奇数时最后的字符变为问号</td><td>以 GBK 方式读取 UTF-8 编码的中文，然后又用 UTF-8 的格式再次读取</td></tr><tr class="even"><td>锟拷码</td><td>锟斤拷锟斤拷要锟矫猴拷学习锟斤拷锟斤拷锟斤拷</td><td>全中文字符，且大部分字符为“锟斤拷”这几个字符</td><td>以 UTF-8 方式读取 GBK 编码的中文，然后又用 GBK 的格式再次读取</td></tr><tr class="odd"><td>烫烫烫</td><td>烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫</td><td>字符显示为“烫烫烫”这几个字符</td><td>VC Debug 模式下，栈内存未初始化</td></tr><tr class="even"><td>屯屯屯</td><td>屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯屯</td><td>字符显示为“屯屯屯”这几个字符</td><td>VC Debug 模式下，堆内存未初始化</td></tr></tbody></table><h2 id="str-和-string">&amp;str 和 String</h2><p>&amp;str</p><ul><li>&amp;str 是字符串切片，是切片的一种。</li><li>形如 "string literals" 的字符串字面值是 &amp;str 类型的1。</li><li>&amp;str 是静态分配空间的，且固定大小。</li><li>不能用方括号来做形如 some_str[i] 的索引，因为每个 Unicode 字符可能有多个字节。</li><li>正确的做法是在 chars() 中迭代：<ul><li><code>for c in "1234".chars() &#123; ... &#125;</code></li></ul></li></ul><p>String</p><ul><li>String 是分配在堆上的，可以动态增长。<ul><li>和 Vec 类似，实际上就是在 Vec&lt;u8&gt; 外面包了一层。</li></ul></li><li>也不能用下标来索引。<ul><li>可以通过 s.nth(i) 来访问某个字符。</li></ul></li><li>通过取引用的方式可以获得 &amp;str。</li></ul><h2 id="option-枚举类型">Option 枚举类型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>  <span class="hljs-literal">None</span>,<br>  <span class="hljs-title function_ invoke__">Some</span>(T),<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Option<T> 是一个枚举类型，同时也是泛型类型。</li><li>为某种已有类型提供了<strong>表示没有或者空值的概念</strong>。</li><li>在 Rust 中，在需要返回空值时，推荐使用 Option<T>。<ul><li>而不是返回诸如 NaN、 -1、 null 等特殊的值。</li></ul></li><li>类型 T 可以是任何类型，没有限制。</li></ul><p>一个处理除数为 0 的情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">divide</span>(numerator: <span class="hljs-type">f64</span>, denominator: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">f64</span>&gt; &#123;<br><span class="hljs-keyword">if</span> denominator == <span class="hljs-number">0.0</span> &#123;<br>    <span class="hljs-literal">None</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(numerator / denominator)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// The return value of the function is an option</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">divide</span>(<span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>);<br><span class="hljs-comment">// Pattern match to retrieve the value</span><br><span class="hljs-keyword">match</span> result &#123;<br>  <span class="hljs-comment">// The division was valid</span><br>  <span class="hljs-title function_ invoke__">Some</span>(x) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Result: &#123;x&#125;&quot;</span>),<br>  <span class="hljs-comment">// The division was invalid</span><br>  <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Cannot divide by 0&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>典型用途：</p><p>初始值（求列表最大值）、函数定义域不是全集、表示简单的错误情况（未定义）、结构体的可选域或者可拿走的域、可选的函数参数、空指针</p><h2 id="错误处理">错误处理</h2><ul><li>对于不可恢复的错误，使用恐慌 panic!。<ul><li>数组越界、栈越界、算术运算溢出……</li></ul></li><li>对于可恢复的错误，使用 Result。<ul><li>文件操作、网络操作、字符串解析……</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>  <span class="hljs-title function_ invoke__">Ok</span>(T),<br>  <span class="hljs-title function_ invoke__">Err</span>(E)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Result 与 Option 类似，除了正常结果外，还可以表示错误状态。</li><li>也定义了 unwrap 和 expect 等方法。</li><li>可以通过 ok 或 err 等方法转换成 Option。<ul><li>把 Ok 或者 Err 的值作为 Some，另一种变成 None。</li></ul></li><li>也可以进行类似 Option 的操作。<ul><li>and、 or……</li></ul></li></ul><p>其处理原则，对返回值为 Result 的函数，一定要显式地处理（否则编译器报 <code>warning</code> ）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::Error;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T&gt; = <span class="hljs-type">Result</span>&lt;T, Error&gt;;<br></code></pre></td></tr></table></figure><h3 id="操作符">?操作符</h3><p>配合 Result 类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">username</span> = String::<span class="hljs-title function_ invoke__">new</span>();<br>  File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> username)?;<br>  <span class="hljs-title function_ invoke__">Ok</span>(username)<br>&#125;<br></code></pre></td></tr></table></figure><p>配合 Opition 类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">last_char_of_first_line</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">char</span>&gt; &#123;<br>  text.<span class="hljs-title function_ invoke__">lines</span>().<span class="hljs-title function_ invoke__">next</span>()?.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">last</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于可以提前传播错误，对上述两种类型对于 <code>Err</code> 和 <code>None</code> 就可以提前返回</p><p><strong>究竟是恐慌还是不恐慌？</strong>就看能否给调用代码恢复的机会。</p><p><strong>unwrap/expect 的场合：</strong>作为原型代码中的错误处理占位符</p><h2 id="容器">容器</h2><p><strong>Vec&lt;T&gt;</strong>：连续空间、可增长的序列，末尾可以高效增删、会发生增长和收缩</p><p><strong>VecDeque&lt;T&gt;</strong>：双端向量，两端可以高效增删，用环状缓冲区</p><p><strong>LinkedList&lt;T&gt;</strong>：双向链表，不能随机索引</p><p><strong>HashMap&lt;K, V&gt; / BTreeMap&lt;K, V&gt;</strong>：字典（映射）类型，一般使用 <strong>HashMap&lt;K, V&gt;</strong>，需要满足 K: Hash + Eq，需要有序的时候用 <strong>BTreeMap&lt;K, V&gt;</strong> ，需要满足 K: Ord</p><p>两者访问复杂度分别为 <span class="math inline">\(O(1)\)</span> 和 <span class="math inline">\(O(\log n)\)</span> ，哈希表的使用举例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-comment">// 添加元素</span><br>scores.<span class="hljs-title function_ invoke__">insert</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">10</span>);<br>scores.<span class="hljs-title function_ invoke__">insert</span>(String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>), <span class="hljs-number">50</span>);<br><span class="hljs-comment">// 访问字典</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">team_name</span> = String::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">score</span> = scores.<span class="hljs-title function_ invoke__">get</span>(&amp;team_name);<br><span class="hljs-comment">// 遍历元素</span><br><span class="hljs-title function_ invoke__">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;scores &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>&#125;<br><span class="hljs-comment">// 用于统计字母出现次数</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span>: BTreeMap&lt;<span class="hljs-type">char</span>, <span class="hljs-type">usize</span>&gt; = BTreeMap::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-keyword">for</span> <span class="hljs-variable">ch</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;abcbcddef&quot;</span>.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>  <span class="hljs-comment">// &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 2, &#x27;d&#x27;: 2, &#x27;e&#x27;: 1, &#x27;f&#x27;: 1&#125;</span><br>  count.<span class="hljs-title function_ invoke__">entry</span>(ch).<span class="hljs-title function_ invoke__">and_modify</span>(|e| *e += <span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>collect() 的使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 将数据从列表转化为 BTreeSet</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">data</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">set</span>: BTreeSet = data.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-comment">// 将数据中每个数乘以原来的两倍</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = input.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x * <span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-comment">// 使用 zip() 将两个数据叠加</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = a.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>(b.<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">map</span>(|(x, y)| x + y).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure><p>early，向量 lazy</p><p>B树外存，二叉树内存</p><h2 id="迭代器">迭代器</h2><p>对<strong>序列</strong>的一种抽象</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>  <span class="hljs-comment">// More fields omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><p>大数据方法 map revuse</p><h2 id="自动测试">自动测试</h2><p>软件工程：<strong>回归测试</strong>（列出对所有的情况，每次开发判断能否通过）</p><p><strong>评测系统</strong>是独立于程序的系统，用于测试；<strong>单元测试</strong>嵌入程序当中，在内部进行测试</p><p>cargo 提供了相应测试 test，在函数前面加上 <code>#[test]</code> 以标注这是一个测试函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>习惯每写一个函数，就在文件后面实现对它的单元测试，也可以调换过来，测试驱动编程</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">vector_length</span>(data: &amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>  vector_length.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_vector_length</span>() &#123;<br>  <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">vector_length</span>(&amp;<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]), <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>持续集成，CICD，每次 push 一次就会自动跑脚本，判断测试是否失败</p><h1 id="tutorial">Tutorial</h1><h2 id="习题评讲">习题评讲</h2><ul><li><p>使用元组实现相当于解包压包</p></li><li><p>使用 <code>a.inter().map(|x| x * 2).collect()</code> 等价于</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">ret</span> - <span class="hljs-built_in">vec!</span>[];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> &amp;a&#123;<br>  rec.<span class="hljs-title function_ invoke__">push</span>(x * <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>随机数的选取，如果不希望抽重，使用随机种子打乱然后顺序取</p></li><li><p><code>json</code> 是传输数据格式中非常重要的格式：字符串、字典、数字，标准中没有注释，最后没有逗号。</p></li><li><p>general 的工作一定有人写，合并命令行参数第三方库 <code>merge</code></p></li><li><p>f64 没有实现偏序关系 Ord ，这是因为 NaN 不满足全序关系，从而 NaN 与所有数比较都是 false</p></li></ul><h2 id="oj-相关知识">OJ 相关知识</h2><p>请求和响应，前端属于客户端，不涉及跨主机访问</p><h3 id="http-请求">HTTP 请求</h3><p>例子：https://www/baidu.com/</p><p>GET:</p><p>HOST: www.baidu.com</p><p>Content-Type: html</p><h3 id="http-响应">HTTP 响应</h3><p>一个例子：</p><p>HTTP 200 OK</p><p>Content-Type: application</p><h3 id="json-序列化与反序列化">json 序列化与反序列化</h3><p>#[derive: deserialize]</p><p>result 转成 json 文件</p><h3 id="互斥锁">互斥锁</h3><p>yse std::sync::{Arc, Mutex};</p><p>保证数据只能被一个线程加以修改，但要防止死锁（情况如下）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">lock_a</span> = A.<span class="hljs-title function_ invoke__">luck</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">lock_b</span> = B.<span class="hljs-title function_ invoke__">luck</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><p>在上锁的时候，所有错误不要出现恐慌</p><h3 id="不同提交隔离">不同提交隔离</h3><p>一个小段子：C艹中的 <deque> 中分配内存出错时，没有出现内存错误的异常</p><h1 id="lecture-4">Lecture 4</h1><h2 id="泛型">泛型</h2><p>C 语言中没有泛型，如 <code>quicksort() bisearch()</code> 没有对数据类型进行泛化，而是交给程序员进行处理（手动传入 <code>compare()</code> 函数）</p><p>Rust 中第一个泛型，将类型作为参数，变成泛型枚举类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>  <span class="hljs-title function_ invoke__">Ok</span>(T),<br>  <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure><p>python 不需要泛型，其有底层 <code>Object</code> 类型，并且是动态语言</p><p>对上述泛型枚举类型，在实现相应方法的时候其函数返回值也是 <code>&lt;T, E&gt;</code>，其也可以使用参数作为传入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>&lt;T, U&gt;(x: T, y: U)&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="特型trait">特型(trait)</h2><p>一定程度上对应<strong>面向对象编程的多态性</strong>，对于下一段美观打印、同时比较多个参数结构体实现代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123; <br>  x: <span class="hljs-type">i32</span>, <br>  y: <span class="hljs-type">i32</span>, <br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">format</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br><span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y)<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">equals</span>(&amp;<span class="hljs-keyword">self</span>, other: Point) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">self</span>.x == other.x &amp;&amp; <span class="hljs-keyword">self</span>.y == other.y<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以抽象出共同特点(trait)，相当于 C艹 中的虚函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// write trait</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">PrettyPrint</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">format</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><span class="hljs-comment">// write actual function</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PrettyPoint</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">format</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 中标准库由快速排序和插入排序混合版实现</p><p>python java 使用 Tim-Sort 归并排序</p><p>C++ 背上了很大的历史包袱，每次遇到问题都需要加入新的概念</p><p>特型约束的泛型类型示例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br><span class="hljs-title function_ invoke__">Ok</span>(T),<br><span class="hljs-title function_ invoke__">Err</span>(E), <br>&#125;<br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">PrettyPrint</span> &#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">format</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>; <br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T: PrettyPrint, E: PrettyPrint&gt; PrettyPrint <span class="hljs-keyword">for</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">format</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> &#123;<br>      <span class="hljs-title function_ invoke__">Ok</span>(t) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Ok(&#123;&#125;)&quot;</span>, t.<span class="hljs-title function_ invoke__">format</span>()),<br>      <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Err(&#123;&#125;)&quot;</span>, e.<span class="hljs-title function_ invoke__">format</span>()), <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>特型可以拿到其“子特型”的方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Child</span>: Parent &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>    <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">foo</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Debug)]</code> 能够让对应的数据结构获得相应实现，不用重新编写，共有以下自动<strong>核心特性</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">Clone</span>, <span class="hljs-built_in">Copy</span>, <span class="hljs-built_in">Debug</span>, <span class="hljs-built_in">Default</span>, <span class="hljs-built_in">Eq</span><br>Hash, <span class="hljs-built_in">Ord</span>, PatialEq, <span class="hljs-built_in">PartialOrd</span><br></code></pre></td></tr></table></figure><p>特型的自动获得需要满足其所有成员都能自动获得指定的特型，如 Eq 不能在包含 f32 的结构体类型上自动获得，因为 f32 不是 Eq 的（浮点数中的 NAN 与任意数比较都是错误的，<strong>不满足全序关系中的自反性</strong>）</p><p><strong>Debug</strong> 特型用于输出调试信息，如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>, &#125;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = Point &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;;<br><span class="hljs-comment">// println!(&quot;The origin is: &#123;:?&#125;&quot;, origin);</span><br></code></pre></td></tr></table></figure><p><strong>Default</strong> 特型用于定义一个默认值，如 0 或者 ""</p><p><strong>Eq 和 PartialEq</strong> 等价关系和部分等价关系，都有对称性和传递性，前者还有自反性</p><p><strong>Hash</strong> 表示可哈希的类型，H 类型是抽象的哈希状态，可以计算哈希值，而如果同时出现了 Eq 特型，需要满足以下重要性质</p><p>x == y -&gt; hash(x) == hash(y)</p><p><strong>PartialOrd 和 Ord</strong> 表示偏序和全序，都有反对称性和传递性，前者还要满足完全性（对所有的 a 和 b，有 a &lt;= b 或者 b &lt;= a 成立），后者可以按照字典序排序</p><p><strong>关联类型的需求</strong>：例如，图的表示：邻接矩阵/链表</p><p><strong>Sized 和 ?Sized</strong> 前者表示在编译时固定大小，后者大小是动态的（如 [T], str），一般跟指针相关的泛型才会出现后者（如 Box<T>）</p><p>特型甚至可以为所有类型写，如 i32，但不推荐。为了写一个特型实现的 impl 代码段，要么拥有该特性，要么拥有该类型。</p><p><strong>Drop</strong> 表示可以销毁的特型，但一般情况下不需要手动实现 Drop</p><h2 id="特型对象">特型对象</h2><p>考虑以下特型和实现</p><p><strong>静态</strong>分发：在编译的时候给定了相应特性的函数</p><p><strong>动态</strong>分发：在运行的时候决定相应特性的函数，但只有运行之后才能使用，其他情况只能当成一个特型来使用，编译器不知道对应的类型信息（已经被抹去）</p><p><strong>对象安全性</strong>，需要满足一定条件，关联函数要求除接收方之外，其他地方都不能出现 Self 类型（否则获取到对应的类型），不能以 Sized 为超特型，接收方是引用或者指针形式的类型（Self, Box&lt;Self&gt;）</p><blockquote><p>课件上问题：不可变的引用是可以 Clone 的。</p></blockquote><h2 id="生命周期">生命周期</h2><p>考虑以下情况：</p><ol type="1"><li>获取了一项资源。</li><li>乙方通过引用借用了甲方的这项资源。</li><li>甲方对这项资源使用完毕，对它进行释放。</li><li>乙方还保留着对这项资源的引用，并开始使用它。</li><li>乙方挂了……</li></ol><p>如何保证第 3 步和第 4 步的顺序关系？一般情况下，引用具有隐式的生命周期，不需要额外关注，但也可以<strong>显式</strong>地指定生命周期</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>) &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>fn borrow_x_or_y&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str;</code> 保证引用 x 和 y 的生命周期至少会和返回的引用生命周期一样长，若只需要前者和返回值的生命周期一样长，则可以分开为 'a 与 'b <code>fn borrow_p&lt;'a, 'b&gt;(p: &amp;'a str, q: &amp;'b str) -&gt; &amp;'a str;</code>，如以下编译期间会报错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pizza</span>(<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PizzaSlice</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>  pizza: &amp;<span class="hljs-symbol">&#x27;a</span> Pizza, <span class="hljs-comment">// &lt;- references in structs must</span><br>  index: <span class="hljs-type">u32</span>, <span class="hljs-comment">// ALWAYS have explicit lifetimes</span><br>&#125;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>; &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = <span class="hljs-title function_ invoke__">Pizza</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br>  s2 = PizzaSlice &#123; pizza: &amp;p2, index: <span class="hljs-number">2</span> &#125;;<br>  <span class="hljs-comment">// no good - why?</span><br>&#125;<br><span class="hljs-title function_ invoke__">drop</span>(s2); <span class="hljs-comment">// to undo NLL</span><br></code></pre></td></tr></table></figure><p>如果结构体或者枚举类型的成员是引用，那么就需要显式地指定生命周期</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt; &#123;<br>  v: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;,<br>s: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>, <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="lecture-5">Lecture 5</h1><blockquote><p><strong>所有权</strong>是 rust 语言<strong>资源管理</strong>的灵魂，<strong>特型</strong>是 rust 语言<strong>灵活运用</strong>的灵魂。</p></blockquote><blockquote><p><strong>共享不修改，修改不共享——rust 设计哲学</strong></p></blockquote><h2 id="项目管理">项目管理</h2><h3 id="模块系统">模块系统</h3><ul><li>包 (packages)：Cargo 的一项功能，可以让用户构建、测试、分享箱。</li><li>箱 (crates)：也叫单元包，是由<strong>模块构成的一棵树</strong>，能够产生一个库或者可执行文件。</li><li>模块 (modules)：与 use 配合，<strong>控制路径</strong>的组织结构、作用域和访问权限。</li><li>路径 (paths)：命名项目的方式，这里的项目可以指结构体、函数、模块等。</li></ul><p>在模块中加上 <code>pub</code> 关键字便可以让其他用户访问，模块相当于 C艹 中的 namespace，模块之间可以嵌套，如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> english &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> greetings &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> farewells &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br><span class="hljs-keyword">mod</span> chinese &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> greetings &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> farewells &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以把模块写成单独的文件 <code>lib.rs</code>，用于整合所有的模块</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// lib.rs</span><br><span class="hljs-keyword">mod</span> english;<br><span class="hljs-comment">// english.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> greetings &#123; <span class="hljs-comment">/*...*/</span> &#125;<br></code></pre></td></tr></table></figure><p>也可以用目录来组织模块，把模块当做目录名使用</p><p>还可以在 Cargo 中使用自己编写的箱</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">[dependencies]<br>myfoo = &#123; git = <span class="hljs-string">&quot;https://github.com/me/foo-rs&quot;</span> &#125;<br>mybar = &#123; path = <span class="hljs-string">&quot;../rust-bar&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="cargo-相关">Cargo 相关</h3><p><strong>单元测试</strong>直接附着在源代码中，<code>#[test]</code>，<strong>集成测试</strong>放在 <code>tests/*.rs</code> 中，<strong>基准测试程序</strong>放在 <code>benches/*.rs</code>（类似作坊中的基准模块）</p><p><code>feature</code> 是在构建时做选择性的开关（与 <code>bug</code> 不同）</p><p>使用 rust 语言，Cargo 编写脚本</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">[package]<br>build = <span class="hljs-string">&quot;build.rs&quot;</span><br></code></pre></td></tr></table></figure><p>可以将自己写的软件包发布到 crate.io ，原子性的库。</p><h2 id="语法补充">语法补充</h2><h3 id="属性">属性</h3><p>#! [no_std] 禁用标准库，#[derive(Debug)] 自动获得特型</p><p>#[inline(always)] 提示编译器内联优化，#[cfg(target_os = "linux")] 定义条件编译。</p><p>inter procedure o</p><h3 id="操作符-1">操作符</h3><p>运算类 &gt; 操作类 &gt; 位运算类 &gt; 逻辑类，其背后的原因是 a + b == c 应该被理解为 (a + b) == c，后者是源于逻辑二元运算存在<strong>短路情况</strong></p><p>使用特型来重载操作符，定义在 std::ops 下，有如下重载操作符：Neg, Not, Deref, DerefMut | Mul, Div, Mod | Add, Sub...</p><h3 id="类型转换">类型转换</h3><p>使用 <strong>From 和 Into 实现自定义类型转换</strong>，前者实现之后后者会自动实现，例如实现<strong>对数转换</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Into</span>&lt;<span class="hljs-type">f64</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Log2</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">into</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        <span class="hljs-comment">// return log_2 of the value</span><br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">ln</span>() / std::f64::consts::LN_2<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 调用取得对数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">log2_4</span>: <span class="hljs-type">f64</span> = <span class="hljs-title function_ invoke__">Log2</span>(<span class="hljs-number">4.0</span>).<span class="hljs-title function_ invoke__">into</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">log2_8</span>: <span class="hljs-type">f64</span> = <span class="hljs-title function_ invoke__">Log2</span>(<span class="hljs-number">8.0</span>).<span class="hljs-title function_ invoke__">into</span>();<br></code></pre></td></tr></table></figure><h3 id="命名规范">命名规范</h3><h4 id="标识符">标识符</h4><ul><li><p>CamelCase：类型、特型</p></li><li><p>snake_case：箱、模块、函数、方法、变量</p></li><li><p>SCREAMING_SNAKE_CASE：常量和静态变量</p></li><li><p>T（单个大写字母）：类型参数</p></li><li><p>'a（撇 + 短的小写名字）：生命周期参数</p></li></ul><h4 id="构造函数和转换函数">构造函数和转换函数</h4><ul><li><p>new, new_with_stuff：构造函数</p></li><li><p>from_foo：转换构造函数</p></li><li><p>as_foo：低开销非消耗性转换</p></li><li><p>to_foo：高开销非消耗性转换</p></li><li><p>into_foo：消耗性转换</p></li></ul><h2 id="智能指针">智能指针</h2><h3 id="boxt">Box&lt;T&gt;</h3><p>用于在堆上分配空间存放数据，其拥有 T 类型的对象，其指针是唯一的，类似 C艹 中的 <code>std::unique_ptr</code>，是动态分配</p><h3 id="stdrcrct">std::rc::Rc&lt;T&gt;</h3><p>是 <strong>Referenced counted</strong> 的缩写，代表指针的别名个数</p><p>共享所有权的指针类型，相当于 C艹 中的 <code>std::shared_ptr</code>，并且其一直符合 rust 的借用规则，当且仅当引用计数为 1 时才能修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">shared</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">6</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> shared)); <span class="hljs-comment">// ==&gt; Some(6)</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cloned</span> = shared.<span class="hljs-title function_ invoke__">clone</span>(); <span class="hljs-comment">// ==&gt; Another reference</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> shared)); <span class="hljs-comment">// ==&gt; None</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> cloned)); <span class="hljs-comment">// ==&gt; None</span><br></code></pre></td></tr></table></figure><p>gc 垃圾回收机制，如果有各种变量相互引用形成<strong>一种环</strong>，就不能释放，导致空间的浪费：</p><ul><li><p>A 有一个 B 的 Rc，B 也有一个 A 的 Rc，两者的引用计数都是 1。</p></li><li><p>由于构成了环，两个对象都不会被释放，从而引起内存泄露。</p></li></ul><p>可以使用<strong>弱引用</strong>来避免（与 C艹 中的 <code>weak_ptr</code> 类似） ，Rc::downgrade() 降级成 Weak。</p><blockquote><p>对于图 (V, E)，对顶点拥有<strong>所有权</strong>，但是对于边来说，不能拥有对顶点的所有权，可以使用<strong>弱引用</strong>来实现</p></blockquote><p>但这样会引入双重计数，增加开销。</p><h3 id="stdcellcellt">std::cell::Cell&lt;T&gt;</h3><p>为 Copy 类型提供内部可变性的格子类型，用 get() 从 Cell 中取值，用 set() 更新 Cell 的值。</p><h3 id="stdcellrefcellt">std::cell::RefCell&lt;T&gt;</h3><p>可为任意类型提供内部可变性，当 borrow() 一个 RefCell&lt;T&gt; 时，得到的是 Ref&lt;T&gt;，而不是 &amp;T。</p><h3 id="const-t-和-mut-t">const T 和 *mut T</h3><p>相当于 C 语言的裸指针。</p><h2 id="常用库">常用库</h2><ul><li>正则表达式: reges</li><li>日志: log （源于航海，各种级别分开，error, warning）</li><li>日期: chrono</li><li>HTTP 客户端: reqwest</li><li>增强错误处理: thiserror , anyhow</li><li>数据库: rusqlite, r2d2</li></ul><h2 id="数据库">数据库</h2><h3 id="分类">分类</h3><p><strong>数据库</strong>是以一定方式存储在一起、能够给多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。</p><ul><li>关系数据库：<strong>创建在关系模型基础上的数据库</strong>，给予集合代数<ul><li>Oracle 国外数据库，早些年中国各大银行使用，现在国产化</li><li>ProsgreSQL<ul><li>MySQL</li><li>SQLite</li></ul></li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/6310b37c16f2c2beb17decd6.jpg" style="zoom:50%;" /></p><ul><li>非关系型数据库<ul><li>文档数据库（json 转换为二进制文件），如 MongoDB</li><li>键值数据库（类似 HashMap），如 LevelDB</li></ul></li></ul><h3 id="操作">操作</h3><p>数据查询：<strong>选择、投影、连接、并、交、差</strong></p><p>Excel 表中 vlookup 函数用于合并数据，指定键值</p><p>数据操作：<strong>新增、删除、修改、查询</strong></p><h3 id="sql-简介">SQL 简介</h3><p>常用命令：</p><ul><li>创建表格 CREATE TABLE</li><li>查询数据 SELECT</li><li>插入数据 INSERT</li><li>更新数据 UPDATE</li><li>删除数据 DELETE</li><li>删除表格 DROP TABLE</li></ul><p>DBA IT 认证，Oracle 数据管理库职业</p><h3 id="在-rust-中使用-sql">在 rust 中使用 SQL</h3><p>软件包 rusqlite</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">conn</span> = Connection::<span class="hljs-title function_ invoke__">open_in_memory</span>()?;<br>  conn.<span class="hljs-title function_ invoke__">execute</span>(<br>    <span class="hljs-string">&quot;CREATE TABLE person (</span><br><span class="hljs-string">    id INTEGER PRIMARY KEY,</span><br><span class="hljs-string">    name TEXT NOT NULL,</span><br><span class="hljs-string">    data BLOB</span><br><span class="hljs-string">    )&quot;</span>,<br>    (), <span class="hljs-comment">// empty list of parameters.</span><br>  )?;<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以与 Web 框架联合使用</p><p>创建数据库连接池，将连接池作为 Data&lt;T&gt; 传给请求处理代码</p><h1 id="lecture-6">Lecture 6</h1><blockquote><p>当今许多设备都是多核的，并发是现代语言必须具备的特性，</p></blockquote><h2 id="闭包">闭包</h2><h3 id="概念与类型推导">概念与类型推导</h3><p>闭包的概念和匿名函数、lambda 函数相似，其可以绑定在变量上：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">square</span> = |x: <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; x * x &#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">square</span>(<span class="hljs-number">3</span>));<br><span class="hljs-comment">// =&gt; 9</span><br></code></pre></td></tr></table></figure><p>类型可以推导，参数类型和返回值类型都可以不显示地给出</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">square_v4</span> = |x: <span class="hljs-type">u32</span>| &#123; (x * x) <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> &#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">square</span> = |x| &#123; x * x &#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">square</span>(-<span class="hljs-number">2.4</span>));<br><span class="hljs-comment">// =&gt; 5.76</span><br></code></pre></td></tr></table></figure><h3 id="捕捉">捕捉</h3><p>闭包还可以包含其所在的环境（可以调用外面的参数，称为<strong>捕捉</strong>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">magic_num</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">magic_johnson</span> = <span class="hljs-number">32</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">plus_magic</span> = |x: <span class="hljs-type">i32</span>| x + magic_num;<br></code></pre></td></tr></table></figure><p>闭包绑定后如果尝试借用，如果在上述代码后面加入以下代码，借用编译器则会报错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">more_magic</span> = &amp;<span class="hljs-keyword">mut</span> magic_num; <span class="hljs-comment">// Err!</span><br></code></pre></td></tr></table></figure><h3 id="移动闭包">移动闭包</h3><p>可以使用 <code>&#123;...&#125;</code> 让闭包超过作用域来恢复，调用函数和被调用函数 Caller, Callee，也可以使用 <code>move</code> 关键字强制闭包获得环境变量的所有权，为<strong>移动闭包</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">make_closure</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&gt; &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">move</span> |y| x + y;<br>  Box::<span class="hljs-title function_ invoke__">new</span>(f)<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-title function_ invoke__">make_closure</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">f</span>(<span class="hljs-number">3</span>));<br><span class="hljs-comment">// =&gt; 5</span><br></code></pre></td></tr></table></figure><h3 id="特型闭包">特型闭包</h3><p>闭包与所有权，只能调用一次，满足 rust 借用规则。与所有权相似，闭包也具有闭包特型，<code>Fn, FnMut, FnOnce</code> 分别代表借用、可变借用、所有权</p><p>如何正确地返回闭包？如下，使用动态的生命周期以及移动语义解决</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">box_up_your_closure_and_move_out</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&gt; &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">local</span> = <span class="hljs-number">2</span>;<br>  Box::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">move</span> |x| x * local)<br>&#125;<br></code></pre></td></tr></table></figure><p>Lambda 函数本质上是 C++/Rust 在调用处创建一个未知名字的类/结构体，然后传入环境的相关值，最后调用一个未知名字的函数。</p><h2 id="并发">并发</h2><h3 id="线程进程并发并行概念">线程进程、并发并行概念</h3><p>二进制可执行文件在执行之后，成为进程，在 CPU 中存放：<strong>寄存器，堆，栈，操作系统指令</strong>。</p><p><strong>Program Point</strong> 指向进程下一个指令（在X86 中称为 PC）</p><p>线程是<strong>轻量级</strong>，有 CPU 存放的寄存器、堆、栈、操作系统指令单元，但内存是相互共享的，但不引入通信的开销（网络、进程通信）</p><p>并发是程序同时有多个正在运行的线程，而并行是指多个处理单元，要求更高，真正意义的同时处理。</p><h3 id="并发执行">并发执行</h3><p>考虑下面代码，假设两个线程，一个执行 <code>foo()</code>，一个执行 <code>bar()</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span> = &amp;<span class="hljs-keyword">mut</span> x; *y = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *y); <span class="hljs-comment">// foo expects 1</span><br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = &amp;<span class="hljs-keyword">mut</span> x; *z = <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *z); <span class="hljs-comment">// bar expects 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这两个线程的执行顺序不是每次都能保证的，如果将两个函数当做两台 ATM 机，则会发生严重的后果。</p><p>并发编程的难点：<strong>数据共享</strong>、<strong>数据竞争</strong>、<strong>同步</strong>（保证所有线程都有正确的世界观，共享缓冲区）、<strong>死锁</strong></p><p>死锁发生有四个条件：<strong>互斥、持有资源、非抢占、等待成环</strong></p><p>一个形象的例子：</p><p><em>N</em> 个哲学家坐在一张圆桌周围，交替地进行吃饭和思考。每个哲学家需要一双筷子用来吃饭，但是一共只有 <em>N</em> 根筷子，每两个哲学家之间有一根。</p><p>哲学家的行为用算法描述如下：</p><ul><li>拿起他左侧的那根筷子（获取一个资源的锁）。</li><li>拿起他右侧的那根筷子（获取一个资源的锁）。</li><li>吃饭（使用资源）。</li><li>将两根筷子放回原处（释放资源的锁）。</li></ul><p>对所有哲学家来说，依据算法，所有人都拿到左侧的筷子，而此时桌上没有筷子，从而所有人卡在第二步</p><h2 id="线程">线程</h2><p>Rust 标准库提供了线程 <code>std::thread</code>，每个线程有自己的栈和状态，使用闭包来指定线程的行为</p><h3 id="线程句柄">线程句柄</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>  <span class="hljs-string">&quot;Hello, world!&quot;</span><br>&#125;);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, handle.<span class="hljs-title function_ invoke__">join</span>());<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sequence">main-&gt;&gt;new_thread: spawn<br>new_thread-&gt;&gt;main: join<br></code></pre></td></tr></table></figure><p><code>join()</code> 会阻塞当前线程的执行，直到句柄对应的线程终止，其返回 <code>Ok</code> 或者 <code>Err</code></p><p><code>thread::park()</code> 可以暂停自己的执行，之后可以通过现成的 <code>unpark()</code> 来继续执行</p><h3 id="线程与所有权">线程与所有权</h3><p>线程的创建也要满足所有权的规则（包括闭包和所有权的规则），例如使用 <code>move</code> 来创建移动闭包，获得所有权</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>  thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;I&#x27;m #&#123;&#125;!&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="共享线程状态">共享线程状态</h2><p>Rust 类型系统包含要求满足并发承诺的特型</p><ul><li><p>Send 表示可以在线程间安全转移</p></li><li><p>Sync 表示可以在线程间（通过引用）安全共享</p></li></ul><p>Send 类型可以将它的所有权在线程间转移，如果一种类型没有实现 Send，那么它只能留在原来的线程里。</p><p>Sync 类型在多个线程使用时不会引发内存安全问题，基本所有类型都是 Sync 的。以下为一个共享线程状态示例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">data</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">3</span> &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>      data[i] += <span class="hljs-number">1</span>;<br>    &#125;);<br>  &#125;<br>  thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">50</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>此时 data 有多个所有者，使用 <code>Arc&lt;T&gt;</code> ，代表原子性的引用计数指针（Atomic Reference-Counted），但如果只是在初始化加入 Arc，编译也不通过。</p><p>Arc 也不具有内部可变性，需要添加<strong>互斥锁</strong>（Mutual Exclusion），保证它包含的值只有一个线程能够访问；如果一个线程锁定了互斥锁，但是发生了恐慌，此时该互斥锁进入中毒状态，该锁不会被释放</p><p>高并发任务、超算比赛主要资源共享，Open Np，消息传递 npi</p><h2 id="通道">通道</h2><p>通道（channels）可以用来<strong>同步线程之间的状态</strong>，用于在线程之间传递消息，也可以用来提醒其他现成关于数据就绪、事件已经发行的情况</p><p><code>std::sync::mpsc</code> 实现多生产者、单消费者的通信功能</p><p><strong>同步：</strong>不同进程之间是需要等待的，<strong>异步：</strong>发送的东西放入（相当于无限大的）缓冲区，相互之间不需要等待</p><p>使用 <code>channel&lt;T&gt;()</code> 函数创建一对连接的 <code>(Sender&lt;T&gt;, Receiver&lt;T&gt;)</code></p><p><code>go</code> 语言有 <code>GC</code> 机制，导致编程开销大</p><p>对哲学家筷子问题，可以使用最后一个哲学家用相反方向拿筷子或者传递令牌规定拿筷子的哲学家。</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>intersection Math knowledge</title>
    <link href="/2022/07/14/intersection%20Math%20knowledge/"/>
    <url>/2022/07/14/intersection%20Math%20knowledge/</url>
    
    <content type="html"><![CDATA[<h1 id="特殊曲线曲面">特殊曲线曲面</h1><h2 id="bernstein-多项式">$Bernstein $ 多项式</h2><p>定义 <span class="math inline">\(B_n(t)=\dfrac{n!}{i!(n-i)!}(1-t)^{n-i}t^{i}\ \ \ \ \ i=0\cdots n\)</span></p><p>性质 ① 非负：<span class="math inline">\(B_{i,n}(t)\geq 0,\ \ 1\leq t\leq 1\)</span>；② 归一：<span class="math inline">\(\displaystyle\sum_{i=0}^n{B_{i,n}(t)}=(1-t+t)^{n}=1\)</span>（二项式定理）</p><p>③ 对称性：<span class="math inline">\(B_{i,n}(t)=B_{n-i,n}(1-t)\)</span>； ④ 递归：<span class="math inline">\(B_{i,n}(t)=(1-t)B_{i,n-1}(t)+tB_{i-1,n-1}(t)\)</span>；</p><p>⑤ 升阶：<span class="math inline">\(B_{i,n}(t)=(1-\dfrac{i}{n+1})B_{i,n+1}(t)+\dfrac{i+1}{n+1}B_{i+1,n+1}(t)\)</span>；</p><p>⑥ 线性精度：<span class="math inline">\(t=\displaystyle \sum_{i=0}^n\dfrac{i}{n}B_{i,n}(t)\)</span>，表明单项式 <span class="math inline">\(t\)</span> 可以表示为 <span class="math inline">\(n\)</span> 次 <span class="math inline">\(Bernstein\)</span> 多项式的加权组合</p><p>⑦ 求导：<span class="math inline">\(\dfrac{dB_{i,n}(t)}{dt}=n(B_{i-1,n-1}(t)-B_{i,n-1}(t))\)</span>；</p><p>对于一般多项式 <span class="math inline">\(f(t)=a_nt^n+a_{n-1}t^{n-1}+\cdots a_1t+a_0\)</span> 可以看作 <span class="math inline">\(\{t^n,t^{n-1},\cdots,1\}\)</span> 的线性组合</p><p>若换成基向量 <span class="math inline">\(\{B_{i,n}(t)\},0\leq i\leq n\)</span> 称为 <span class="math inline">\(Bernstein\)</span> 基，注意：用 <span class="math inline">\(Bernstein\)</span> 基做展开不唯一</p><p><span class="math inline">\(f(t)+g(t)=\begin{cases}m=n,f+g=\displaystyle \sum_{i=0}^m(f_i^m+g_i^m)B_{i,m}(t)\\m\neq n,f+g=\displaystyle\sum_{i=0}^m(\large f_i^m+\normalsize\sum_{j=\max\{0,i-m+n\}}^{\min\{n,i\}}\frac{\begin{pmatrix}n\\j\end{pmatrix}\begin{pmatrix}m-n\\i-j\end{pmatrix}}{\begin{pmatrix}m\\i\end{pmatrix}}g_j^{n})B_{i,m}(t)\end{cases}\)</span></p><p>意义：以 <span class="math inline">\(Berstein\)</span> 基作展开虽然更复杂，但是保证了数值稳定性</p><h2 id="bacuteezier-曲线"><span class="math inline">\(B\acute{e}zier\)</span> 曲线</h2><p>以 <span class="math inline">\(Berstein\)</span> 基函数为参数函数，给定"控制顶点" <span class="math inline">\(\{\vec{b_0},\vec{b_1}\cdots \vec{b_n}\}\)</span>，则空间曲线方程 <span class="math display">\[\vec{r}(t)=\displaystyle\sum_{i=0}^{n}\vec{b_i}B_{i,n}(t),t\in[0,1]\]</span> 性质：① 几何不变性：对 <span class="math inline">\(\vec{b_i}\)</span> 平移旋转，<span class="math inline">\(\vec{r}(t)\)</span> 的形状保持不变；</p><p>​ <span class="math inline">\(\Large\ \)</span>② 对称性：<span class="math inline">\(\displaystyle \sum_{i=0}^n\vec{b_i}B_{i,n}(t)=\sum_{i=0}^n\vec{b_{n-i}}B_{i,n}(1-t)\)</span>（反向拟合曲线）</p><p>​ ② <span class="math inline">\(\dot{\vec{r}(t)}=n\displaystyle\sum_{i=0}^{n-1}(\vec{b}_{i+1}-\vec{b}_{i})B_{i,n-1}(t)\)</span>，也为 <span class="math inline">\(B\acute{e}zier\)</span> 曲线（向量相应改变）</p><p>​ ③ <span class="math inline">\(\vec{r}(t)\)</span> 为包围 <span class="math inline">\(\{\vec{b_i}\}^n\)</span> 的最小凸区域（曲线凸包，<span class="math inline">\(\large convex\)</span>），进而对于直线和 <span class="math inline">\(B\acute{e}zier\)</span> 曲线求交问题有：</p><p><strong>变差缩减</strong>：直线与 <span class="math inline">\(B\acute{e}zier\)</span> 曲线的交点 <span class="math inline">\(\leq\)</span> 直线与凸包边界的交点（凸包应用：求交算法，光顺检测）</p><p>​ ④不是所有的向量组都有 <span class="math inline">\(B\acute{e}zier\)</span> 曲线，有 <span class="math inline">\(\dot{r(0)}=n(\vec{b_1}-\vec{b_0}),\dot{r(1)}=n(\vec{b_n}-\vec{b_{n-1}})\)</span> 如果初始绕原点转</p><p>动后不能在一圈之内得到末态方向，由于凸包的性质则不能构成 <span class="math inline">\(B\acute{e}zier\)</span> 曲线</p><h2 id="bacuteezier-曲面"><span class="math inline">\(B\acute{e}zier\)</span> 曲面</h2><p>定义 <span class="math inline">\(\vec{r}(u,v)=\displaystyle\sum_{i=0}^m\sum_{j=0}^n\vec{b_{ij}}B_{i,m}(u)B_{i,n}(v)\ \ u,v\in[0,1]\)</span>，与 <span class="math inline">\(B\acute{e}zier\)</span> 曲线性质相似：几何不变、端点边界、凸包</p><h2 id="b-样条曲线面"><span class="math inline">\(B-\)</span>样条曲线/面</h2><p>给定节点向量 <span class="math inline">\(T=(t_0,t_1,t_2\cdots t_n)\)</span> 其中 <span class="math inline">\(t_0\leq t_1\leq t_2\cdots t_n\)</span>，对区间划分，定义 <span class="math inline">\(DB-\)</span>样条基函数 <span class="math inline">\(N_{i,k}(t)\)</span></p><p><span class="math inline">\(N_{i,1}(t)=\begin{cases}1,t_i\leq t\leq t_{i+1}\\0,\mbox{otherwise}\end{cases}\)</span> ，显然在节点处不连续，当 <span class="math inline">\(k&gt;1,i=0,1\cdots n\)</span> 时，有递推式</p><p><span class="math inline">\(N_{i,k}(t)=\dfrac{t-t_i}{t_{i+k-1}-t_i}N_{i,k-1}(t)+\dfrac{t_{i+k}-t}{t_{i+k}-t_{i+1}}N_{i+1,k-1}(t)\)</span> ，代入计算有</p><p><span class="math inline">\(N_{0,2}=(\dfrac{t-t_0}{t_1-t_0})N_{0,1}(t)+(\dfrac{t_2-t}{t_2-t_1})N_{1,1}(t)\)</span>，为锯齿状，在节点处连续，导数不连续</p><p><span class="math inline">\(N_{0,3}(t)=\dfrac{(t-t_0)^2}{(t_2-t_0)(t_1-t_0)}N_{0,1}(t)+((\dfrac{t-t_0}{t_2-t_0})(\dfrac{t_2-t}{t_2-t_1})+(\dfrac{t-t_1}{t_2-t_1})(\dfrac{t_3-t}{t_3-t_1}))N_{1,1}\)</span>，拱形状</p><p>在节点处导数连续，但二阶导不连续，一般地有 <span class="math inline">\(N_{i,k}(t)\)</span> 在节点处 <span class="math inline">\((k-2)\)</span> 阶导连续，<span class="math inline">\((k-1)\)</span> 阶导不连续</p><p>性质：① 正值：<span class="math inline">\(N_{i,k}(t)&gt; 0,t\in(t_i,t_{i+k})\)</span>；</p><p><span class="math inline">\(\Large\ \)</span> ② 局部支撑（<span class="math inline">\(\mbox{support}\)</span>）：<span class="math inline">\(N_{i,k}(t)=0,t\leq t_i\ or \ t\geq t_{i+k}\)</span>；</p><p><span class="math inline">\(\Large\ \)</span> ③ 单位分割：<span class="math inline">\(\displaystyle \sum_{i=0}^{n}N_{i,k}(t)=1,t\in[t_0,t_n]\)</span>；</p><p><span class="math inline">\(\Large\ \)</span> ④ 连续性：<span class="math inline">\(N_{i,k}(t)\)</span> 在单节点处是 <span class="math inline">\(C^{k-2}\)</span> 阶连续的</p><p>有 <span class="math inline">\(\mbox{de\ Boor}\)</span> 算法（求值与剖分）得到 <span class="math inline">\(B-\)</span>样条曲线 <span class="math display">\[r(t)=\sum_{i=0}^{n+j}\boldsymbol{p}_i^jN_{i,k-j}(t),\ \boldsymbol p_i^j=(1-\alpha_i^j)\boldsymbol p_{i-1}^{j-1}+\alpha_i^j\boldsymbol p_{i}^{j-1},\alpha_i^j=\dfrac{\bar{t}-t_i}{t_{i+k-j}-t_i},\boldsymbol p_j^0=\boldsymbol p_j\]</span> <span class="math inline">\(B\)</span> 样条曲线是一种特殊的 <span class="math inline">\(B\acute{e}zier\)</span> 曲线，具体来说端点为 <span class="math inline">\(k\)</span> 重节点</p><p><span class="math inline">\(B-\)</span>样条曲面定义为 <span class="math inline">\(\vec{r}(u,v)=\displaystyle \sum_{i=0}^{m}\sum_{j=0}^{n}\vec{P_{i,j}}N_{i,k}(u)N_{j,k}(v)\)</span></p><h2 id="nurbs-曲线"><span class="math inline">\(NURBS\)</span> 曲线</h2><p><span class="math inline">\(NURBS\)</span> 曲线非均匀有理 <span class="math inline">\(B-\)</span>样条，定义： <span class="math display">\[\displaystyle \vec{r}(t)=\dfrac{\displaystyle\sum_{i=0}^n\omega_i\vec{p_i}N_{i,k}(t)}{\displaystyle\sum_{i=0}^n\omega_iN_{i,k}(t)},\mbox{where}\  \begin{cases}N_{i,1}(t)=\begin{cases}1,t_i\leq t\leq t_{i+1}\\0,\mbox{otherwise}\end{cases}\\N_{i,k}(t)=\dfrac{t-t_i}{t_{i+k-1}-t_i}N_{i,k-1}(t)+\dfrac{t_{i+k}-t}{t_{i+k}-t_{i+1}}N_{i+1,k-1}(t)\end{cases}\]</span> 圆锥曲线等二次曲线都可以写成 <span class="math inline">\(NURB\)</span> 曲线的形式</p><p>例：<span class="math inline">\(\dfrac{1}{4}\)</span> 椭圆：<span class="math inline">\(\begin{cases}x=a\cos \theta\\y=b\sin \theta\end{cases}\ ,\theta\in[0,\dfrac{\pi}{2}]\)</span>，若令 <span class="math inline">\(t=\tan \dfrac{\theta}{2}\)</span>，有 <span class="math inline">\(\begin{cases}x=a\cdot \cfrac{1-t^2}{1+t^2}\\y=b\cdot \dfrac{2t}{1+t^2}\end{cases},\ t\in[0,1]\)</span> <span class="math display">\[\vec{r}(t)=(a\cdot\dfrac{1-t^2}{1+t^2},b\cdot\dfrac{2t}{1+t^2})=\dfrac{\omega_0(1-t)^2\vec{b_0}+2\omega_1t(1-t)\vec{b_1}+\omega_2t^2\vec{b_2}}{\omega_0(1-t)^2+2\omega_1t(1-t)+\omega_2t^2}\]</span> 代入对应系数相等解得 <span class="math inline">\(\omega_2=2\omega_0=2\omega_1,\vec{b_0}=(a,0),\vec{b_1}=(a,b),\vec{b_2}=(0,b)\)</span></p><p>定义 <span class="math inline">\(NURBS\)</span> 曲面 <span class="math inline">\(\displaystyle \vec{r}(t)=\dfrac{\displaystyle\sum_{i=0}^m\sum_{j=0}^n\omega_{ij}\vec{p_i}N_{i,k}(u)N_{j,k}(v)}{\displaystyle\sum_{i=0}^m\sum_{j=0}^n\omega_{ij}N_{i,k}(u)N_{j,k}(v)}\)</span>，在当今建模主流应用曲面</p><p>其中当 <span class="math inline">\(u=u_0\)</span> 时为 <span class="math inline">\(NURBS\)</span> 二次曲面，例如圆环面（ <span class="math inline">\(\mbox{Torus}\)</span> ），旋转面</p><p>当今学术界提出实现 <span class="math inline">\(C^2\)</span> 连续的样条</p><h1 id="曲线和曲面的表示">曲线和曲面的表示</h1><h2 id="平面曲线奇异点性质">平面曲线奇异点性质</h2><p>对隐式曲线<span class="math inline">\(f(x,y)=0\)</span>，奇异点判据<span class="math inline">\(\dfrac{\partial f}{\partial x}\big |_{x=x_0}=0\ and\ \dfrac{\partial f}{\partial y}\big |_{y=y_0}=0\)</span>，奇异点为<span class="math inline">\((x_0,y_0)\)</span></p><p>①二次曲线<span class="math inline">\(a_{11}x^2+2a_{12}xy+a_{22}y^2+2a_{13}x+2a_{23}y+a_{33}=0\)</span> 存在奇异点；</p><p>②退化为两条相交直线，或者退化为单个点；</p><p>③<span class="math display">\[ \left| \matrix{  a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\\} \right|=0 \]</span></p><p>条件①②③等价</p><h2 id="空间曲面">空间曲面</h2><p>①<span class="math inline">\(f(x,y,z)=0\)</span> 的法向量为 <span class="math inline">\(n=(\dfrac{\partial f}{\partial x},\dfrac{\partial f}{\partial y},\dfrac{\partial f}{\partial z})\)</span>，其切平面点法式方程为 <span class="math display">\[\dfrac{\partial f}{\partial x}\big|_{x=x_0}(x-x_0)+\dfrac{\partial f}{\partial y}\big |_{y=y_0}(y-y_0)+\dfrac{\partial f}{\partial z}\big |_{z=z_0}(z-z_0)=0\]</span> 空间曲面奇异点存在的充要条件： <span class="math inline">\(\dfrac{\partial f}{\partial x}\big |_{x=x_0}=\dfrac{\partial f}{\partial y}\big |_{y=y_0}=\dfrac{\partial f}{\partial z}\big |_{z=z_0}=0\)</span></p><p>对一般二次曲面<span class="math inline">\(Ax^2+By^2+Cz^2+Dxy+Eyz+Fxz+Gx+Hy+Iz+J=0\)</span></p><p>一般情况下是：椭球面、双曲面、抛物面，有圆锥面，相交双平面等均有奇异点</p><p>例1: <span class="math inline">\(z^2=x^2+y^2\)</span>在<span class="math inline">\((0,0,0)\)</span>处法向量为 <span class="math inline">\(n=(0,0,0)\)</span>，不可导，无切平面方程</p><p>例2: <span class="math inline">\(z=xy\)</span> 换参数 <span class="math inline">\(x=u+v,y=u-v\)</span>，得到<span class="math inline">\(z=u^2-v^2\)</span>为双曲面方程</p><p>隐函数定理：<span class="math inline">\(f(x,y,z)=0\)</span>，只要<span class="math inline">\(\dfrac{\partial f}{\partial z}\ne 0\)</span></p><p>②空间曲面参数表示 <span class="math inline">\(x=x(t),y=y(t),z=z(t)\)</span>，切线矢量<span class="math inline">\(r=(\dfrac{dx}{dt},\dfrac{dy}{dt},\dfrac{dz}{dt})\)</span></p><p>对球坐标下 <span class="math inline">\(x=r\cdot cos\alpha \cdot sin\theta\ \ \ y=r\cdot sin\alpha \cdot sin\theta\ \ \ z=r\cdot cos\theta\)</span> <span class="math inline">\(ds^2=r^2sin\theta drd\theta d\alpha\)</span></p><h2 id="空间曲线">空间曲线</h2><p>①使用两个空间曲面相交 <span class="math inline">\(f(x,y,z)=0\ and \ g(x,y,z)=0\)</span>，其在某点处的切线向量与两个空间曲面的法向量均垂直</p><p><span class="math inline">\(n_1=(\dfrac{\partial f}{\partial x}\big |_{x=x_0},\dfrac{\partial f}{\partial y}\big |_{y=y_0},\dfrac{\partial f}{\partial z}\big |_{z=z_0})\ \ \ n_2=(\dfrac{\partial g}{\partial x}\big |_{x=x_0},\dfrac{\partial g}{\partial y}\big |_{y=y_0},\dfrac{\partial g}{\partial z}\big |_{z=z_0})\)</span>，从而 <span class="math inline">\(l=n_1\times n_2\)</span></p><p>②弧长微元$ds=|r(t+dt)-r(t)| <span class="math inline">\(，空间曲线有奇异点的条件\)</span>=0<span class="math inline">\(，例：\)</span>y<sup>2=x</sup>3<span class="math inline">\(有\)</span>x$轴上下两段</p><p>参数方程 <span class="math inline">\(x=t^3,y=t^2\)</span>，在<span class="math inline">\(t=0\)</span> 处 <span class="math inline">\(\dfrac{dr}{dt}=(0,0)\)</span>，则称<span class="math inline">\((0,0)\)</span>为奇异点（又称Cusp点），计算其弧长积分为 <span class="math display">\[s(t_1,t_2)=\int_{t_1}^{t_2}\sqrt{4t^2+9t^4}dt=\int_{t_1}^{t_2}\sqrt{1+\frac{9}{4}t^2}d(t^2)=\frac{2}{3}(1+\frac{9}{4}t^2)^{\frac{3}{2}}\big |_{t_1}^{t_2}\]</span> 在 <span class="math inline">\(t=0\)</span> 处积分处不连续，需要分段</p><h1 id="曲线的微分几何">曲线的微分几何</h1><h2 id="位矢弧长参数-_vecr-vecrs">位矢（弧长参数）<span class="math inline">\(\ \ _{\vec{r}\ =\ \vec{r}(s)}\)</span></h2><p>对 <span class="math inline">\(\vec{r}=\vec{r}(t)\)</span> ，中 <span class="math inline">\(t\)</span> 为任意参数，如果令 <span class="math inline">\(t=s\)</span> ，则代入弧长微元 <span class="math inline">\(ds=|\dot{r}(t)|dt\)</span> 有<span class="math inline">\(|\dot{\vec{r}(s)}|=1\)</span></p><p>写成点乘形式有 <span class="math inline">\(\dot{\vec{r}(s)}\cdot \dot{\vec{r}(s)}=0\)</span>，两边求导有 <span class="math inline">\(\ddot{\vec{r}(s)}\cdot \dot{\vec{r}(s)}=0\)</span></p><p>即若用弧长作为参数，则位矢对弧长的一阶导和位矢对弧长的二阶导相互正交</p><p><strong>例</strong>：对于圆周运动，使用弧长参数 <span class="math inline">\(s=R\cdot \omega t\)</span> <span class="math display">\[\begin{equation}\left\{        \begin{array}{}        x=R\cdot cos(\omega t)&amp; \\        y=R\cdot sin(\omega t)&amp; \\        \end{array}\right.\end{equation}\]</span> 得 <span class="math inline">\(\vec{r}(s)=(R\cdot cos(\dfrac{s}{R}),R\cdot sin(\dfrac{s}{R}))\)</span>，有<span class="math inline">\(\dot{\vec{r}(s)}=(-sin(\dfrac{s}{R}),cos(\dfrac{s}{R}))\)</span></p><p><span class="math inline">\(\ddot{\vec{r}(s)}=(-\dfrac{1}{R}\cdot cos(\dfrac{s}{R}),-\dfrac{1}{R}\cdot sin(\dfrac{s}{R}))\)</span>，后两者相互正交，且 <span class="math inline">\(|\ddot{\vec{r}(s)}|=\dfrac{1}{R}\)</span></p><p>另一种理解方式：位矢对弧长的导数相当于是一个正则化的速度矢量，该速度矢量的大小不</p><p>变，其变化一定沿其法向，两者相互正交</p><p>曲率的计算方式：有 <span class="math inline">\(\rho=\dfrac{ds}{d\theta}=\dfrac{\dot{\vec{r}}(s+ds)-\dot{\vec{r}}(s)}{\ddot{\vec{r}(s)}\cdot d\theta}\)</span>，由分子两矢量与其差构成等腰三角形</p><p><span class="math inline">\(ds\to 0\)</span> 时，<span class="math inline">\(\dot{\vec{r}}(s+ds)-\dot{\vec{r}}(s)=|\dot{\vec{r}(s)}|\cdot d\theta=1\cdot d\theta\)</span>，从而消去有 <span class="math inline">\(\rho=\dfrac{1}{|\ddot{\vec{r}(s)}|}\)</span>，即 <span class="math inline">\(|\ddot{\vec{r}(s)}|=\kappa\)</span></p><p>定义，单位主法向量 <span class="math inline">\(\vec{n}(s)=\dfrac{\ddot{\vec{r}(s)}}{|\ddot{\vec{r}(s)}|}\)</span>，单位切向量 <span class="math inline">\(\vec{t}=\dot{\vec{r}(s)}\)</span></p><p>对任意一点处， <span class="math inline">\(\vec{n}\)</span> 和 <span class="math inline">\(\vec{t}\)</span> 两者张成的平面就是密切平面，若为平面曲线，则密切平面不变</p><p>对于空间曲线，密切平面就随着点的运动变化而变化</p><p>定义副法向量 $=  $，有 <span class="math inline">\((\vec{t},\vec{n},\vec{b})\)</span> 为以 <span class="math inline">\(P\)</span> 点为原点的一组坐标架，有 <span class="math inline">\(\vec{b}=\dot{\vec{r}(s)}\times \dfrac{\ddot{\vec{r}(s)}}{\kappa}\)</span></p><p>考虑 $(s) $ 的变化有 <span class="math inline">\(\vec{n} \cdot \vec{n}=1\)</span>，求导有 <span class="math inline">\(\dot{\vec{n}(s)}\ \bot\  \ddot{\vec{n}(s)}\)</span>，从而令 <span class="math inline">\(\dot{\vec{n}(s)}=\mu\vec{t}+\tau\vec{b}\)</span>，则 <span class="math inline">\(\vec{b}\)</span> 变化</p><p><span class="math inline">\(\dot{\vec{b}(s)}=\dfrac{d}{ds}(\vec{t}\times \vec{n})=\ddot{\vec{r}(s)}\times \dfrac{\ddot{\vec{r}(s)}}{|\ddot{\vec{r}(s)}|}+\vec{t}\times \dfrac{d\vec{n}}{ds}=0+\vec{t}\times (\mu\vec{t}+\tau\vec{b})=-\tau\vec{n}\)</span>（右手螺旋）</p><p>定义 <span class="math inline">\(\tau\)</span> 为曲线的挠率，几何意义：<span class="math inline">\(\vec{b}\)</span> 为密切平面中单位切向量和单位法向量的叉乘，即为密切</p><p>平面的法向量，<span class="math inline">\(\dot{\vec{b}(s)}\)</span> 代表密切平面法向量方向的变化，即曲线局部摆脱密切平面的趋势，若挠</p><p>率处处为0，则该曲线为平面曲线</p><p>计算挠率的方法：对 <span class="math inline">\(\dot{\vec{b}(s)}=-\tau\cdot \vec{n}(s)\)</span>，两边点乘 <span class="math inline">\(\vec{n}(s)\)</span> 计算得<span class="math inline">\(\tau=-\vec{n}(s)\cdot \dot{\vec{b}(s)}=\)</span></p><p><span class="math inline">\(-\dfrac{\ddot{\vec{r}(s)}}{\kappa}\cdot (\dfrac{\dot{\vec{r}(s)}\times \ddot{\vec{r}(s)}}{\kappa})&#39;=\dfrac{(\dot{\vec{r}},\ddot{\vec{r}},\dddot{\vec{r}})}{\ddot{\vec{r}\cdot} \ddot{\vec{r}}}\)</span>，其中 <span class="math inline">\((a,b,c)\)</span> 表示混合积（平行六面体有向体积）</p><p><strong>例</strong>：等距螺线 <span class="math inline">\(\vec{r}(t)=(acos(t),asin(t),bt)\)</span>，弧长参数：<span class="math inline">\(\vec{r}(s)=(acos(\dfrac{s}{c}),asin(\dfrac{s}{c}),\dfrac{bs}{c})\)</span></p><p>代入公式有曲率半径 <span class="math inline">\(\rho=\dfrac{1}{|\ddot{\vec{r}}(s)|}=\dfrac{c^2}{a}\)</span>，计算挠率 <span class="math inline">\(\tau=\dfrac{b}{c^2}\)</span></p><h2 id="位矢一般参数-_vecr-vecrt">位矢（一般参数）<span class="math inline">\(\ \ _{\vec{r}\ =\ \vec{r}(t)}\)</span></h2><p>要求 <span class="math inline">\(s=s(t)\)</span> 是单调的，对一般参数求导有</p><p><span class="math inline">\(\dot{\vec{r}(t)}=\dfrac{d\vec{r}}{ds}\dfrac{ds}{dt}\)</span>，令速率 <span class="math inline">\(v=|\dfrac{ds}{dt}|\)</span>，有 <span class="math inline">\(\dot{\vec{r}(t)}=\dfrac{d\vec{r}}{ds}|v|\)</span>，为一阶导公式</p><p><span class="math inline">\(\ddot{\vec{r}(t)}=\dfrac{d}{dt}(\dot{\vec{r}(s)}\cdot |v|)=\ddot{\vec{r}(s)}|v|^2+\dot{\vec{r}(s)}\dfrac{d|v|}{dt}=\dfrac{|v|^2}{\rho }\vec{n}+\dfrac{d|v|}{dt}\vec{t}\)</span></p><p>称 <span class="math inline">\(\kappa\)</span> 变号的点为拐点，<span class="math inline">\(ds\)</span> 是不依赖参数的</p><h2 id="fernet-serret-公式">Fernet-Serret 公式</h2><p>将上述产生的坐标架 <span class="math inline">\((\vec{t},\vec{n},\vec{b})\)</span> 对弧长参数的导数写成矩阵形式： <span class="math display">\[\begin{pmatrix}\boldsymbol t&#39;\\\boldsymbol n&#39;\\\boldsymbol b&#39;\end{pmatrix}=\begin{pmatrix}0&amp;\kappa&amp;0\\-\kappa&amp;0&amp;\tau\\0&amp;-\tau&amp;0\end{pmatrix}\begin{pmatrix}\boldsymbol t\\\boldsymbol n\\\boldsymbol b\end{pmatrix}\]</span> 则 <span class="math inline">\(\kappa=\kappa(s)\)</span> 和 <span class="math inline">\(\tau=\tau(s)\)</span> 称为曲线的内在方程。</p><p>若两者以及初始条件 <span class="math inline">\(\vec{r}(0),\dot{\vec{r}(0)},\ddot{\vec{r}(0)},\ddot{\vec{r}(0)}\)</span> 均已知，则该空间曲线可以确定</p><h1 id="曲面的微分几何">曲面的微分几何</h1><h2 id="切平面和法向量">切平面和法向量</h2><p>对某些变换后的一组参数坐标满足其中一个参数为定值时形成的曲线簇和另一组曲线簇相互正交</p><p>如 <span class="math inline">\((x,y),(r,\theta),(s,t)_{(x=s+t,y=s-t)},(r,\theta,\phi)\)</span> 等等</p><p>定义曲面 <span class="math inline">\(S\)</span> 的方程满足其每一个点的位矢 <span class="math inline">\(\vec{r}=\vec{r}(u,v)\)</span>，考虑参数空间中的一条空间曲线</p><p><span class="math inline">\(u=u(t),v=v(t)\)</span> 在该参数空间条件下 <span class="math inline">\(\vec{r}=\vec{r}(u(t),v(t))\)</span> 也为空间曲线，其切向量全微分为</p><p><span class="math inline">\(\dot{\vec{r}(t)}=\dfrac{\partial \vec{r}}{\partial u}\dot{u}+\dfrac{\partial \vec{r}}{\partial v}\dot{v}\)</span>，其法向量为两者的叉乘 <span class="math inline">\(\vec{N}=\dfrac{\dfrac{\partial r}{\partial u}\times \dfrac{\partial r}{\partial v}}{|\dfrac{\partial r}{\partial u}\times \dfrac{\partial r}{\partial v}|}\)</span></p><p>当 <span class="math inline">\(\dfrac{\partial r}{\partial u}\times \dfrac{\partial r}{\partial v}=0\)</span> 时对应的点为奇异点，如圆锥面的顶点，椭圆圆锥的顶点</p><h2 id="曲面的第一基本齐式度量">曲面的第一基本齐式（度量）</h2><p><span class="math inline">\(ds=|\dfrac{d\vec{r}}{dt}|dt=|\dfrac{\partial \vec{r}}{\partial u}\cdot \dfrac{du}{dt}+\dfrac{\partial \vec{r}}{\partial v}\cdot \dfrac{dv}{dt}|=\sqrt{Edu^2+2Fdudv+Gdv^2}\)</span></p><p>其中定义 <span class="math inline">\(E=\dfrac{\partial \vec{r}}{\partial u}\cdot \dfrac{\partial \vec{r}}{\partial u}\)</span>，<span class="math inline">\(F=\dfrac{\partial \vec{r}}{\partial u}\cdot \dfrac{\partial \vec{r}}{\partial v}\)</span>，<span class="math inline">\(G=\dfrac{\partial \vec{r}}{\partial v}\cdot \dfrac{\partial \vec{r}}{\partial v}\)</span>，三者为第一基本齐式系数</p><p>有第一基本齐式 <span class="math inline">\(I=Edu^2+2Fdudv+Gdv^2=\dfrac{1}{E}(Edu+Fdv)^2+\dfrac{EG-F^2}{E}dv^2\)</span></p><p><strong>例</strong>：对球面 <span class="math inline">\(\vec{r}=(Rsin\theta cos\phi,Rsin\theta sin\phi,Rcos\theta)\)</span> 计算有 <span class="math inline">\(I=Rd\theta^2+R^2sin^2\theta d\phi^2\)</span></p><p>对 <span class="math inline">\(\vec{r}=\vec{r}(u(t),v(t))\)</span>，计算两个切矢之间的夹角有 <span class="math inline">\(cos\omega=\dfrac{\dfrac{\partial \vec{r}}{\partial u}\cdot \dfrac{\partial \vec{r}}{\partial v}}{|\dfrac{\partial \vec{r}}{\partial u}||\dfrac{\partial \vec{r}}{\partial v}|}=\dfrac{F}{\sqrt{EG}}\)</span></p><p>从而有面积微元 <span class="math inline">\(\delta A=sinw\cdot \sqrt{EG}\delta u\delta v=\sqrt{EG-F^2}\delta u \delta v\)</span></p><p>应用：①计算面积；②计算弧长</p><p><strong>例</strong>：对柱面 <span class="math inline">\(x^2+y^2=R^2\)</span> 使用柱坐标有 <span class="math inline">\((Rcos\theta,Rsin\theta,z)\)</span>，有 <span class="math inline">\((\theta,z)\)</span> 相当于 <span class="math inline">\((u,v)\)</span>，</p><p>求导有 <span class="math inline">\(\dfrac{\partial\vec{r}}{\partial \theta}=(-Rsin\theta,Rcos\theta,0),\dfrac{\partial \vec{r}}{\partial z}=(0,0,1)\)</span>，则 <span class="math inline">\(E=R^2,F=0,G=1\)</span>，代入有</p><p><span class="math inline">\(I=R^2d\theta^2+dz\)</span></p><p><strong>例</strong>：求双曲抛物面 <span class="math inline">\(\vec{r}=(u,v,uv)\)</span> 当 <span class="math inline">\(u,v\)</span> 取正半轴以及 <span class="math inline">\(u^2+v^2\leq1\)</span> 围成的区域面积</p><p><span class="math inline">\(\dfrac{\partial \vec{r}}{\partial u}=(1,0,v)\)</span>，<span class="math inline">\(\dfrac{\partial \vec{r}}{\partial v}=(0,1,u)\)</span>，则有 <span class="math inline">\(E=1+v^2,F=uv,G=1+u^2\)</span>，代入面积微元</p><p><span class="math inline">\(dA=\sqrt{(1+v^2)(1+u^2)-u^2v^2}dudv=\sqrt{1+v^2+u^2}dudv\)</span>，换成极坐标积分有</p><p><span class="math inline">\(S=\displaystyle\int_0^{\frac{\pi}{2}}d\theta\int_0^1\sqrt{1+r^2}rdr=\dfrac{\pi}{6}(2\sqrt{2}-1)\)</span></p><h2 id="曲面的第二基本齐式曲率">曲面的第二基本齐式（曲率）</h2><p>量化曲面的曲率考虑曲面 <span class="math inline">\(S\)</span> 上通过点 <span class="math inline">\(P\)</span> 的一条曲线 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(P\)</span> 处的单位法向量关系有： <span class="math display">\[\vec{k}=\dfrac{d\vec{t}}{ds}=\kappa\vec{n}=\vec{k}_n+\vec{k}_g\]</span> 其中，<span class="math inline">\(\vec{k}_n\)</span> 为法曲率向量为曲率向量在曲面法向的投影，称为法曲率向量；<span class="math inline">\(\vec{k}_g\)</span> 为曲率向量在曲面切平面的投影，称为测地曲率向量（当 <span class="math inline">\(\vec{k_n}=0\)</span> 时曲线在该点朝“前”走，若该曲线处处法向量都等于测地曲率向量，则该曲线为测地线，代表连接起点和终点最短的曲线 ），对于 <span class="math inline">\(\vec{\kappa_n}\)</span> 的计算有 <span class="math display">\[\because \boldsymbol N\cdot \boldsymbol t=0\ \therefore\dfrac{d\boldsymbol t}{ds}\cdot \boldsymbol N+\dfrac{d\boldsymbol N}{ds}\cdot \boldsymbol t=0,\ \vec{\boldsymbol \kappa_n}=\dfrac{d\boldsymbol t}{ds}\cdot \boldsymbol N=-\dfrac{d\boldsymbol N}{ds}\cdot t=-\dfrac{d\boldsymbol r}{ds}\cdot \dfrac{d\boldsymbol N}{ds}=-\dfrac{d\boldsymbol r\cdot d\boldsymbol N}{d\boldsymbol r\cdot d\boldsymbol r}\]</span> 令 <span class="math inline">\(L=-\dfrac{\partial \boldsymbol r}{\partial u}\cdot \dfrac{\partial \boldsymbol N}{\partial u},M=-\dfrac{1}{2}(\dfrac{\partial \boldsymbol r}{\partial u}\cdot \dfrac{\partial \boldsymbol N}{\partial v}+\dfrac{\partial \boldsymbol r}{\partial v}\cdot \dfrac{\partial \boldsymbol N}{\partial u})=-\dfrac{\partial \boldsymbol r}{\partial u}\cdot \dfrac{\partial \boldsymbol N}{\partial v}=\dfrac{\partial \boldsymbol r}{\partial v}\cdot \dfrac{\partial \boldsymbol N}{\partial u},N=-\dfrac{\partial \boldsymbol r}{\partial v}\cdot \dfrac{\partial \boldsymbol N}{\partial v}\)</span></p><p><span class="math inline">\(\dfrac{\partial \boldsymbol r}{\partial u}\cdot \boldsymbol N=0,\dfrac{\partial \boldsymbol r}{\partial v}\cdot \boldsymbol N=0\)</span> ，均对 <span class="math inline">\(u,v\)</span> 求导代入有 <span class="math inline">\(L=\dfrac{\partial^2 \boldsymbol r}{\partial u^2}\cdot \boldsymbol N,M=\dfrac{\partial ^2\boldsymbol r}{\partial u\partial v}\cdot \boldsymbol N,N=\dfrac{\partial^2 \boldsymbol r}{\partial v^2}\cdot \boldsymbol N\)</span> 有 <span class="math display">\[\kappa_n=-\dfrac{d\boldsymbol r\cdot d\boldsymbol N}{d\boldsymbol r\cdot d\boldsymbol r}=\dfrac{Ldu^2+2Mdudv+Ndv^2}{Edu^2+2Fdudv+Gdv^2}\]</span> 称分子 <span class="math inline">\(H=Ldu^2+2Mdudv+Ndv^2\)</span> 为第二基本齐式，若定义 <span class="math inline">\(\lambda=\dfrac{dv}{du}\)</span> 为曲线 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(P\)</span> 点处的切线方向</p><p>则对给定参数 <span class="math inline">\((u,v)\)</span> 下，<span class="math inline">\(\boldsymbol \kappa_n=\dfrac{H}{I}=\dfrac{L+2M\lambda+N\lambda^2}{E+2F\lambda+G\lambda^2}=f(\lambda)\)</span>，有 <span class="math inline">\(\kappa_{max},\kappa_{min}\)</span></p><p>即曲面上给定点 <span class="math inline">\(P\)</span> 处的法曲率只依赖于切向 <span class="math inline">\(\lambda\)</span> ，进而得到 <span class="math inline">\(Meusnier\)</span> 定理：曲面 <span class="math inline">\(S\)</span> 上过点 <span class="math inline">\(P\)</span> 且具有相同切向的所有曲线具有相同的法曲率</p><p>定义高斯曲率 <span class="math inline">\(K=\kappa_{min}\kappa_{max}\)</span>，平均曲率 <span class="math inline">\(H=\dfrac{\kappa_{min}+\kappa_{max}}{2}\)</span></p><p>主曲率为 <span class="math inline">\(f(\lambda)\)</span> 取得最大值最小值时对应的切线方向，<span class="math inline">\(Euler\)</span> 定理：选取 <span class="math inline">\(xy\)</span> 轴为 <span class="math inline">\(\kappa_{max},\kappa_{min}\)</span> 对应方向，设 <span class="math inline">\(\vec{t}\)</span> 与 <span class="math inline">\(x\)</span> 轴方向夹角为 <span class="math inline">\(\theta\)</span> ，有法曲率 <span class="math inline">\(\large\kappa_n\small{(\vec{t})}=\large\kappa_{max}\cos^2 \theta+\large\kappa_{min}\sin ^2\theta\)</span> ，当 <span class="math inline">\(\large\kappa_{max}=2\large\kappa_{min}\)</span> 时图像如下</p><p><img src="https://pic.imgdb.cn/item/62d0258ff54cd3f9371814f6.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
      <category>SRT项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>求交问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shor&#39;s Algorithm</title>
    <link href="/2022/07/06/Shor&#39;s%20Algorithm/"/>
    <url>/2022/07/06/Shor&#39;s%20Algorithm/</url>
    
    <content type="html"><![CDATA[<p>传统部分成功率的数学证明参考 B 站视频 <a href="https://www.bilibili.com/video/BV1Ua411L7a9?spm_id_from=333.337.search-card.all.click&amp;vd_source=d9afebd071d024f27b0f4860d8972d67">Shor算法 | 如何用量子计算机分解质因数？</a></p><h2 id="构造素因子的传统方法初等数论">构造素因子的传统方法（初等数论）</h2><p>1: 找一个整数 <span class="math inline">\(1&lt;a&lt;N\)</span> ，计算 <span class="math inline">\(\operatorname{gcd}(a, N)\)</span></p><p>2: 若 <span class="math inline">\(\operatorname{gcd}(a, N)&gt;1\)</span> ，则已经找到了 <span class="math inline">\(N\)</span> 的一个非平凡因子</p><p>3: 若 <span class="math inline">\(\operatorname{gcd}(a, N)=1\)</span> ，则用<strong>量子算法</strong>找到最小的满足 <span class="math inline">\(a^{r} \equiv 1(\bmod N)\)</span> 的正整数 <span class="math inline">\(r\)</span> （也称作 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(N\)</span> 的阶， <span class="math inline">\(\left.r=\operatorname{ord}_{N}(a)\right)\)</span></p><p>4: 若 <span class="math inline">\(2 \nmid r\)</span> ，或 <span class="math inline">\(a^{\frac{r}{2}} \equiv-1(\bmod N)\)</span> ，则返回第一步重新找一个 <span class="math inline">\(a\)</span></p><p>5: 若 <span class="math inline">\(2 \mid r\)</span> ，且 <span class="math inline">\(a^{\frac{r}{2}} \not \equiv-1(\bmod N)\)</span> ，则有 <span class="math inline">\(N \mid\left(a^{\frac{r}{2}}+1\right)\left(a^{\frac{r}{2}}-1\right)\)</span> ，可以证明，通过求出 <span class="math inline">\(\operatorname{gcd}\left(a^{\frac{r}{2}}+1, N\right)\)</span> 或 <span class="math inline">\(\operatorname{gcd}\left(a^{\frac{r}{2}}-1, N\right)\)</span> 一定可以找到 <span class="math inline">\(N\)</span> 的一个非平凡因子</p><h2 id="r为偶的成功率算法成功率">r为偶的成功率（算法成功率）</h2><p>这里 <span class="math inline">\(a\)</span> 为 <span class="math inline">\(a=1,2, \cdots ,N-1\)</span> 中的随机数，令 <span class="math inline">\(r=\operatorname{ord}_{N}(a)\)</span><span class="math inline">\(,P(\mbox{success})\)</span><span class="math inline">\(=P\left(2 \mid r \wedge a^{\frac{r}{2}} \not \equiv-1(\bmod N)\right)\)</span></p><p>分解 <span class="math inline">\(N\)</span> 有 <span class="math inline">\(N=p_{1}^{\alpha_{1}} p_{2}^{\alpha_{2}} \cdots p_{m}^{\alpha_{m}}\)</span> 由有限阿贝尔群的基本定理：</p><blockquote><p><strong>模 <span class="math inline">\(\mathrm{N}\)</span> 乘法群 <span class="math inline">\((\mathbb{Z} / N \mathbb{Z})^{\times}\)</span>可分解为若干循环群的直积。</strong>例如对下列表格，实际为中国剩余（孙子）定理的解</p><p><span class="math inline">\(5\)</span> 和 <span class="math inline">\(7\)</span> 分别在模 <span class="math inline">\(7\)</span> 和模 <span class="math inline">\(5\)</span> 意义下的数论倒数为 <span class="math inline">\(3\)</span> 和 <span class="math inline">\(3\)</span>，所以对元素 <span class="math inline">\(a\in( \mathbb{Z} / 5 \mathbb{Z})^{\times},b\in( \mathbb{Z} / 7 \mathbb{Z})^{\times}\)</span></p><p>其直积的计算为 <span class="math inline">\(a\cdot 3\cdot 7+b\cdot 3\cdot 5=3(7a+5b)\)</span>，如 <span class="math inline">\(a=4,b=6,3(28+30)=174=34\pmod{35}\)</span></p></blockquote><p><span class="math display">\[\begin{aligned}&amp;\begin{array}{r|cccccc}(\mathbb{Z} / 5 \mathbb{Z})^{\times}\large {\backslash}\normalsize (\mathbb{Z} / 7 \mathbb{Z})^{\times} &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 \\\hline1 &amp; 1 &amp; 16 &amp; 31 &amp; 11 &amp; 26 &amp; 6 \\2&amp; 22 &amp; 2 &amp; 17 &amp; 32 &amp; 12 &amp; 27 \\3&amp; 8 &amp; 23 &amp; 3 &amp; 18 &amp; 33 &amp; 13 \\4&amp; 29 &amp; 9 &amp; 24 &amp; 4 &amp; 19 &amp; 34\end{array}\end{aligned}\]</span></p><p><span class="math inline">\((\mathbb{Z} / N \mathbb{Z})^{\times} \cong\left(\mathbb{Z} / p_{1}^{\alpha_{1}} \mathbb{Z}\right)^{\times} \times\left(\mathbb{Z} / p_{2}^{\alpha_{2}} \mathbb{Z}\right)^{\times} \times \cdots \times\left(\mathbb{Z} / p_{m}^{\alpha_{m}} \mathbb{Z}\right)\)</span> ，<span class="math inline">\(\left(\mathbb{Z} / p_{i}^{\alpha_{i}} \mathbb{Z}\right)^{\times} \cong C_{\varphi(p^{\alpha})}\left(p_{i}&gt;2\right)\)</span> <span class="math display">\[\begin{aligned}&amp;a=1 \ldots N-1, r=\operatorname{ord}_{N}(a) \\&amp;P(\text { success })=P\left(2 \mid r \wedge a^{\frac{r}{2}} \not \equiv-1 \quad(\bmod N)\right) \\&amp;N=p_{1}^{\alpha_{1}} p_{2}^{\alpha_{2}} \cdots p_{m}^{\alpha_{m}}\end{aligned}\]</span> 定义 <span class="math inline">\(r=\operatorname{ord}_{N}(a), r_{i}=\operatorname{ord}_{p_{i}^{\alpha_{i}}}(a)\)</span> ，有 <span class="math inline">\(r=\operatorname{lcm}\left(r_{1}, r_{2}, \ldots, r_{m}\right) ， 2 \nmid r \Longleftrightarrow \forall i, 2 \nmid r_{i}\)</span> 定义 <span class="math inline">\(v_{2}(n)=\max _{k}\left\{2^{k} \mid n\right\}\)</span> 表示 <span class="math inline">\(n\)</span> 中因子 <span class="math inline">\(2\)</span> 的次数， <span class="math display">\[\begin{aligned}a^{\frac{r}{2}} \equiv-1 \quad(\bmod N) &amp; \Longleftrightarrow \forall i, a^{\frac{r}{2}} \equiv-1 \quad\left(\bmod p_{i}^{\alpha_{i}}\right) \\&amp; \Longleftrightarrow \forall i, 2 \nmid r / r_{i} \\&amp; \Longleftrightarrow \forall i, j, v_{2}\left(r_{i}\right)=v_{2}\left(r_{j}\right)\end{aligned}\]</span> 对于随机的 <span class="math inline">\(a\)</span> ，不能通过 <span class="math inline">\(a\)</span> 找到 <span class="math inline">\(N\)</span> 的非平凡因子当且仅当 <span class="math inline">\(\forall i, j, v_{2}\left(r_{i}\right)=v_{2}\left(r_{j}\right)\)</span></p><p><span class="math display">\[P\left(v_{2}\left(r_{i}\right)=t\right)= \begin{cases}\dfrac{1}{2^{v_{2}(\varphi(n))}} &amp; t=0 \\ \dfrac{1}{2^{v_{2}(\varphi(n))-t+1}} &amp; 1 \leq t \leq v_{2}(\varphi(n))\end{cases}\]</span> 对于与 <span class="math inline">\(N\)</span> 互质的所有 <span class="math inline">\(a\)</span> ，失败概率 <span class="math display">\[P(\text { fail })=P\left(2 \nmid r \vee a^{\frac{r}{2}} \equiv-1 \quad(\bmod N)\right)=\sum_{t} \prod_{i} P\left(v_{2}\left(r_{i}\right)=t\right)\]</span> 当 <span class="math inline">\(N=p^{k}, 2 p^{k},(k \geq 1)\)</span> 时， <span class="math inline">\(P(\)</span><span class="math inline">\(\mbox{fail}\)</span><span class="math inline">\()=1\)</span> ，否则 <span class="math inline">\(P(\)</span><span class="math inline">\(\mbox{fail}\)</span><span class="math inline">\() \leq \dfrac{1}{2}\)</span></p><p>这些情况也可以设计量子电路在更小的时间复杂度内得到判定，从而成功概率 <span class="math inline">\(&gt;\dfrac{1}{2}\)</span></p><h2 id="将求阶算法转换为相位估计法">将求阶算法转换为相位估计法</h2><p>对于酉变换 <span class="math inline">\(U:|y\rangle\mapsto|xy\pmod{N}\rangle\)</span>，已知 <span class="math inline">\(r\)</span> 为 <span class="math inline">\(x\)</span> 模 <span class="math inline">\(N\)</span> 的阶，即满足 <span class="math inline">\(x^{t}\equiv 1\pmod{N}\)</span> 的最小正整数 <span class="math inline">\(t\)</span></p><p>任取 <span class="math inline">\(0\leq s\leq r-1\)</span>，则可以构造性地给出 <span class="math inline">\(U\)</span> 变换的一个特征向量 <span class="math display">\[|u_s\rangle=\large \dfrac{1}{\sqrt{r}}\sum_{k=0}^{r-1}e^{-\frac{2\pi isk}{r}}|x^{k}\bmod{N}\rangle\]</span> 计算可知 <span class="math inline">\(U|u_s\rangle=\dfrac{1}{\sqrt{r}}\displaystyle \sum_{k=0}^{r-1}e^{-\frac{2\pi isk}{r}}|x^{k+1}\bmod{N}\rangle=\dfrac{1}{\sqrt{r}}e^{\frac{2\pi is}{r}}\sum_{k=0}^{r-1}e^{-\frac{2\pi is(k+1)}{r}}|x^{k+1}\bmod{N}\rangle\)</span> 由 <span class="math inline">\(x^{r}=1\)</span></p><p>则 <span class="math inline">\(\{x,x^2,\cdots,x^{r-1},x^{r}\}=\{1,x,x^2,\cdots,x^{r-1}\}\)</span> 则 <span class="math inline">\(\boxed{U|u_s\rangle=e^{\frac{2\pi is}{r}}|u_s\rangle}\)</span>，故 <span class="math inline">\(e^{\frac{2\pi is}{r}}\)</span> 为 <span class="math inline">\(U\)</span> 的特征值</p><p>从而制备酉变换 <span class="math inline">\(U\)</span>，只要确定 <span class="math inline">\(\epsilon\)</span> 精度内的相位 <span class="math inline">\(\small\Delta \normalsize \varphi =\dfrac{2\pi s}{r}\)</span>（误差分析给出比特数 <span class="math inline">\(t=n+\left \lceil \log \left(2+\dfrac{1}{2\epsilon}\right)\right\rceil\)</span>）</p><p>便在一定精度内得到 <span class="math inline">\(s=\dfrac{ \small\Delta \normalsize \varphi r}{2\pi}\)</span>，由连分式算法，任意有理数连分式经过有限步可以终止，从而 <span class="math inline">\(s\)</span> 可求</p><h2 id="相位估计法">相位估计法</h2><p>在给定精度得到相应需要 <span class="math inline">\(t\)</span> 比特后，搭建如下量子电路： <img src="https://pic.imgdb.cn/item/62c59c765be16ec74a874b1b.jpg" /></p><p>通俗来说，上面 <span class="math inline">\(t\)</span> 比特给出一系列“平铺”的量子纠缠态，具体写成数学表达式有 <span class="math display">\[\begin{aligned}\frac{1}{2^{t / 2}}\left(|0\rangle+e^{2 \pi i 2^{t-1} \varphi}|1\rangle\right)\left(|0\rangle+e^{2 \pi i 2^{t-2} \varphi}|1\rangle\right) &amp; \ldots\left(|0\rangle+e^{2 \pi i 2^{0} \varphi}|1\rangle\right) \\&amp;=\frac{1}{2^{t / 2}} \sum_{k=0}^{2^{t}-1} e^{2 \pi i \varphi k}|k\rangle .\end{aligned}\]</span> 这里求和式的结果可以观察为二进制展开得到，用逆快速傅里叶变换便可以 <span class="math inline">\(t\)</span> 位（概率为 $1-$）精度的 <span class="math inline">\(\varphi\)</span></p><p><strong>只要设计上符合各精度要求，便可以逼近得到实例酉变换的相位 <span class="math inline">\(\varphi\)</span>，进而用连分数算法逼近出一个随机数 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(N\)</span> 意义下的阶 <span class="math inline">\(s\)</span>，该 <span class="math inline">\(s\)</span> 为偶数的概率也是可观的（ <span class="math inline">\(&gt; \dfrac{1}{2}\)</span>），实在不行的话多尝试几个随机数 <span class="math inline">\(a\)</span>，只要找到一个阶数为偶数的 <span class="math inline">\(a\)</span>，便可以使用欧几里得算法得到 <span class="math inline">\(N\)</span> 的一个非平凡素因子。</strong></p><p>至此，从理论上大数分解在量子计算机中可以有效（多项式时间复杂度）求出，具体复杂度上界为 <span class="math display">\[O(N^2\log N\log \log N)\]</span> 远超经典计算机（目前为 <span class="math inline">\(O(2^{(\log N)^c}),c=\dfrac{1}{2}\ \mbox{or } c=\dfrac{1}{3}\)</span> 后者基于一个数论猜想），达到指数加速</p><h2 id="总结">总结</h2><p>根据当今密码学的应用，如果这个算法被真正实现于硬件（需要解决纯化、噪声等一系列问题）并证明有效，</p><p>当前的 <span class="math inline">\(\mbox{RSA}\)</span> 公钥体系，以及基于椭圆曲线的加密体系都可以在 <span class="math inline">\(\mbox{Shor}\)</span> 算法的框架进一步优化下得到有效破解</p><p>可以说，大部分互联网所谓的安全加密体系都会被崩塌，美国甚至成立了<strong>后量子密码协议</strong>，专门用于对抗量子算法对当前算法的威胁，不过至少当前经典密码学中的格密码学未被量子算法所破解，许多加密协议可以通过引入格密码学的方式更加安全。</p><p>我之所以费尽心思写这篇 <span class="math inline">\(\mbox{Shor}\)</span> 算法，是因为我好久没有过被这种数理构思所折服的感觉了，上次应该是高一推导分析力学最终得到最小作用量原理 <span class="math inline">\(\delta S=0\)</span> 的时候，希望探索世界总能带给我震撼……</p><p>不知道几十年后的发展怎么样，个人还是有所期待和充满信心吧，这些算法基本都是 <span class="math inline">\(25\)</span> 年前提出的，不知道这些算法最后会对人类有害，还是有利，个人还是希望生产力的解放带来全球的福祉吧。</p>]]></content>
    
    
    <categories>
      
      <category>量子</category>
      
      <category>量子计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 命令行技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux and Shell in Department of Electronics</title>
    <link href="/2022/07/04/Program/%E7%94%B5%E5%AD%90%E7%B3%BBlinux%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/04/Program/%E7%94%B5%E5%AD%90%E7%B3%BBlinux%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>终端是什么？</strong></p><p>CLI: command line interface GUI: graphic user interface</p><p>早期终端是一种硬件，当前把终端转换成软件，例如 <span class="math inline">\(Terminal\)</span> ，实际上叫终端模拟器</p><p><img src="https://pic.imgdb.cn/item/62c2d35d5be16ec74a6b3b7a.jpg" style="zoom:50%;" /></p><p>shell 为何叫壳：</p><p><img src="https://pic.imgdb.cn/item/62c2d4065be16ec74a6c19bf.jpg" style="zoom:75%;" /></p><p>linux 分配用户，例如以下代码新建用户： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">liudu@L0510410:/mnt/c/Users/18472$ sudo useradd -m -d /home/test test<br>Liudu@L0510410:/mnt/c/Users/18472$ cd /home<br>liudu@L0510410:/home$ ls<br></code></pre></td></tr></table></figure></p><p><img src="https://pic.imgdb.cn/item/62c2d5675be16ec74a6ddb4e.jpg" /></p><p>查看当前系统中的全部用户组： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/group<br></code></pre></td></tr></table></figure></p><p>查看目录下所有文件的权限，<span class="math inline">\(\mbox{ll}\)</span> 等价于 <span class="math inline">\(\mbox{ls -al}\)</span> ，第一个字符代表文件类型，三个紧随的 <span class="math inline">\(rwx\)</span> 代表读、写、执行，如 <code>-rw-r--r--</code>，三个三元字符组分别代表文件所有者的权限、文件的组的权限、所有其他用户的权限。</p><p>改变文件权限方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod [-R] [u/g/o/a] [+/-/=] [r/w/x] [file]<br></code></pre></td></tr></table></figure><p>数字方法可以更简洁地修改文件权限。表示方法是为每个权限赋予权重，读的权重为4，写的权重为2，执行的权重为1（与二进制编码相同)。在表示每类用户的权限时，把该类用户所拥有的全部权限的权重相加，得到一个0-7的数，再按属主、属组、其他用户的顺序排列起来，得到一个三位数，表示该文件的权限。数字方法只能直接设定文件权限，不能增添或者删除权限。</p><p>不管三七二十一，一个文件打不开，直接 <code>chmod 777 file</code>，获取最高权限，但这是很不负责任的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">安装可视化文件树的包</span><br>sudo apt install tree<br><span class="hljs-meta"># </span><span class="language-bash">查看根目录下两级的文件树</span><br>tree -L 2 /<br><span class="hljs-meta"># </span><span class="language-bash">查看当前目录下的文件树，加上 -a 会显示隐藏目录</span><br>tree <br><span class="hljs-meta"># </span><span class="language-bash">-h 指人易读的方式列出空间大小，列出文件系统的整体磁盘用量</span><br>df -h<br><span class="hljs-meta"># </span><span class="language-bash">列出当前目录下各文件的大小</span><br>du -h<br><span class="hljs-meta"># </span><span class="language-bash">指定文件大小</span><br>du -h file<br></code></pre></td></tr></table></figure><p>在目录下查找文件并在 <code>vscode</code> 中打开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find test.txt -exec code &#123;&#125; \;<br></code></pre></td></tr></table></figure><p>使用 <code>ln</code> 创建软连接（浅蓝色），和快捷方式一样，如果快捷方式所指代的文件被删，会变红</p><p>加上 <code>-s</code> 为软链接，不加为硬链接</p><p><img src="https://pic.imgdb.cn/item/62c2e6165be16ec74a83ff65.jpg" /></p><p>系统命令，<code>top</code> 命令查看“任务管理器”，<code>ps</code> 命令查看进程，<code>-x</code> 可以查看其他用户进程，<code>-u</code> 显示较为详细的信息，<code>-a</code> 查看所有进程</p><p>终止进程，在 <code>top</code> 种查找 <code>PID</code> 序号，然后执行终止命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill PID<br></code></pre></td></tr></table></figure><p>查找当前安装的 apt 软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt list --installed<br></code></pre></td></tr></table></figure><p><code>cat</code> 本身是用来连接文件，但基本用来输出文件内容，加入 <code>-n</code> 可以显示行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat 1.txt 2.txt &gt; 3.txt <br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/62c2ea7d5be16ec74a89e603.jpg" /></p><p><strong><code>grep</code> 指令</strong>用于过滤文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">在 3.txt 中查找并标红 a 字符</span><br>grep a 3.txt<br><span class="hljs-meta"># </span><span class="language-bash">匹配字符需要加上单引号‘’，匹配以 abc 开头的字符</span><br>grep &#x27;\&lt;abc&#x27; 3.txt<br><span class="hljs-meta"># </span><span class="language-bash">当前目录下查找以 abc 开头的字符，必须加上 -r</span><br>grep -r &#x27;abc.*&#x27; ./<br></code></pre></td></tr></table></figure><p><strong>Vim 编辑器</strong></p><p>切换到输入模式 <code>I</code>，切换到命令模式 <code>Esc</code>，输入 <code>:</code> 进入底线命令模式，再次输入 <code>wq</code> 便可以退出</p><p><img src="https://pic.imgdb.cn/item/62c2ebae5be16ec74a8b8c8e.jpg" /></p><p>管道，将两个或者多个命令连接在一起，将上一个命令的输出作为下一个命令的输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">查找当前目录下含 1 的文件</span><br>ls | grep 1<br><span class="hljs-meta"># </span><span class="language-bash">计算 1+ ··· + 100</span><br>echo &#123;1..100&#125; | tr &#x27; &#x27; &#x27;+&#x27; | bc <br></code></pre></td></tr></table></figure><p><strong>shell 脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">函数写法</span><br>function test()&#123;<br>echo &quot;参数1: $&#123;1&#125;！&quot;;  # 通过$&#123;n&#125;来获取传入函数的第n个参数<br>echo &quot;参数10：$&#123;10&#125;！&quot;; # 双引号括起来的字符串中可以引用变量<br>n=$(($&#123;1&#125;+$&#123;10&#125;));<br>return Sn;          # 如果不加return,则返回值为最后一条命令的结果<br>&#125;<br>test 1 2 3 4 5 6 7 8 9 10;  #调用函数时依序传递参数<br>echo $?;    #可以通过变量$？来获取函数的返回值或者上一条命令的结果<br></code></pre></td></tr></table></figure><p><code>bash</code> 命令进入子 shell，<code>export a</code> 将变量 <code>a</code> 外部导入到子 shell 中，输入 <code>exit</code> 退出</p><p><strong>SSH</strong>：Secure Shell, 安全外壳协议</p><p><strong>作业</strong>：</p><ol type="1"><li><p>在 Linux 上新建一个用户并赋予超级用户权限，设置家目录和默认 shell (为 bash )，并设置 Linux 在输入 sudo 密码时显示星号。请将全部命令及输出截图打包。</p></li><li><p>请编写 Shell 脚本，求 <span class="math inline">\(100\)</span> 以内的奇数和。结果打印到标准输出设备。</p></li><li><p>请编写 Shell 脚本，在家目录下新建 <span class="math inline">\(d a t a\)</span> 目录并向其中新建 100 个名为 test1. txt, <span class="math inline">\(\cdots\)</span>, test100. txt的文件。之后查找到 data 目录下所有文件名包含“5”的文件，并向 其中分别写入文件名中的数字这么多行的“abcd”。</p></li></ol><p>作业自愿选择是否完成和完成程度。提交时打包成一个文件，命名为 班级 姓名+学号，上传至 ***</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux 命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 命令行技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Summary of freshman year</title>
    <link href="/2022/06/28/Summary%20of%20freshman%20year/"/>
    <url>/2022/06/28/Summary%20of%20freshman%20year/</url>
    
    <content type="html"><![CDATA[<p>关于写一个大一学年总结的原因，主要是看到很多学 CS 的前辈们都喜欢在稍微放松的节点总结一下。之前高中的时候没有这个习惯，感觉时间过了就过了，忙完这件事情总有下一件事情要忙，趁着小学期还早，暑假貌似比较长，权当写一个像样的大一总结吧，也希望看到这些的你有所启发。</p><h1 id="暑假">暑假</h1><p><strong>高考</strong>也许上天还是看得起我的努力（如果之后有时间我可以详细叙述一下我高中的破防时光，不过现在觉得也是一笔财富），高考成绩误打误撞地考上了华子的（半个？）CS，有欣喜，也有忐忑，不知道在这条全新的道路上自己究竟会发展成什么样子。</p><p><strong>学车</strong>高考完后几天在一个露天坝花了一上午的时间学会骑自行车（手动捂脸），接着暑假先是和绝大多数毕业生一样报名学车，在闷热的夏天里每天重复着同样的动作，个人觉得还没有在华子脱靶骑自行车好玩，学车就和几个在县城读书的高三毕业生一起学，之间也很少有交流，教练也经常刷短视频，不得不再次评价短视频推荐算法的厉害，反正感觉好多时间就在这种无聊透顶的驾驶中消逝。科一科二顺利一把过，但暑假后期由于开学比较早，科三没预约成功，就只有等着寒假再说。</p><p><strong>游泳</strong>八月份联系上教育园区的游泳班，想的是毕竟在华子毕业游泳不过不行啊，就去学了个蛙泳，小学的时候我还有好几次去游泳馆被水呛到发烧的经历，心理上不是很能放松。跟一堆5、6岁的小孩一起学游泳，真的是搞不懂，明明我都知道阿基米德原理，结果自己的平均密度很容易变高，老是减少排水量，那些小朋友在水里面都开始到处耍了我还不得要领……反正前半期还学得比较难受，后面掌握到技巧后慢慢的就会了，后面几次就在 1.4m 的水池游来游去，反正至少淹不死了……</p><p>游泳的话前面由于刚学会骑自行车比较兴奋，每天骑一个小时到郊区学游泳，后面发现晒黑了，就改乘公交车。由于我游泳馆旁边就是我县城最好中学，走过去贴着一张巨大的同学 A 考上华子的海报，在想没有在 ly 的鼓舞下来到成外，我的人生轨迹究竟会是什么样子……</p><p><strong>编程</strong>在母亲大人认识到的一位从业者的建议下，开始啃《C++ primer plus》。虽然现在看来这种入门方式非常不友好，并且当时啥也不知道，拿着破 windows 电脑（其实在后面我的<del>调教</del>下还蛮不错的），安装 Vs 6.0，画风如下图。真的搞不懂，那个时候我自己的鲁棒性堪称极高，在这样的界面以及各种过时 C 语言规范折磨下，我还能把那本将近七百页的书看个八九不离十，做完大部分现在看起来几乎没什么意思的习题，虽然大部分忘了……然后我承认是看到 python 语言各种天花乱坠的宣传，也搞了一点点 python，主要也就是熟悉 python 语法。</p><p><strong>夏令营</strong>严格来说不算是一个夏令营，就是一个线上的讲座吧，主讲人是华子宣传片《追光少年》里面的角色原型，研究立方卫星的，主要是讲他们实验室的工作，反正也听不懂，A 发在朋友圈的，就跟着一起报了名。最终有两个作业，一个是弄一个单片机，一个是用 matplotlib 结合数据绘制卫星的轨迹图。当时觉得前面那个挺有趣的，就买了个单片机，配置了一堆硬件软件，最后把硬件语言烧在芯片上，大概跟 zcy 的数字电路实验比较相似，只不过我们这个是超级低配版的。好在有 C 语言基础，照着 PPT 上的代码结合网上的参考资料，还把进阶内容也做了出来（呼吸闪光灯），感觉效果还行。</p><p>暑假大概就这样，当然免不了毕业典礼、宴席、经验分享以及杂七杂八之类的，主要大部分时间生活在县城，同学之间来往很少，就这样，在教练车的兜兜转转中，在阳光下聒噪的蝉鸣中，在黑框框的跳来跳去中，暑假就过去了。</p><p>其实现在想来，那个暑假有点封闭，跟之后寒假生活亦或是今年的暑假相比，感觉自己懵懵懂懂，也没跟外界或者是其他人有交集。</p><h1 id="秋季">秋季</h1><p>大一上学期大家都还比较乖，前面是一些开学教育，因为疫情很多讲座只能在线上举行，当然也摸了很多鱼，甚至在军理课上直接睡着了……期间由于军理考试和 A 是错开的，就约定在六教和三教之间的公路见面交换资料，由于我是先考，准备比较充分，虽然我们一个 A 卷，一个 B 卷，都还行。</p><p>初高中那时幻想大学的生活会很丰富，但是上了华子之后，还是真的感觉事多。学业上写沟微积分线性代数程设每门课都比较硬，每周都要花很多时间，尤其是那个时候乖到所有课都到教室，所有习题课都去听，所有作业都独立认真完成。</p><h3 id="学业">学业</h3><p><strong>写作与沟通</strong>，主题是<strong>数字化生存</strong>，其实现在看起来这个主题还蛮适合的，至少我的博客是这样的。ZYY 人美心善，是个宝藏老师，让这门课的痛苦减轻了不少。短文写了一个贴吧现象，自认为比较烂，长文总体框架选择得比较好，从媒介发展视角探讨了微信“拍一拍”流行的原因。虽然这些传媒学方面的知识之后应该是用不到了，但至少学到的文献查找以及一些写作技巧还是很有帮助的。</p><p><strong>微积分</strong>，WXF 的课对我来说真的 nice，他从数的起源开始讲起，自然数、有理数、实数、良序关系、绝对值、指数对数、三角函数，一切被中学数学公式化（或者说功利化）的符号在几条公理的基础上就能建立起来。</p><p>最有印象的是 WXF 第一次开放线下答疑，同学们“蜂拥而至”，当时好像是用阿基米德公理证明选择公理什么的，我们思考了好久都解不出来，WXF 直接口述证明过程，赞叹不已。前几次作业，每次作业花上十个小时都不过分，有的 open question 想不出来，还让我不得不去看实分析教材……</p><p>但是不足的是，从功利的角度，WXF 上课对考试帮助不大，毕竟平常都深入数学的深刻本质去了，哪有时间讲怎么算对考试的那些题……好在当时维持了高中刷题的好习惯，提前做了一些往年题，保持考试手感，这门课至少没寄掉……按照 WXF 的说法，期末解答出附加题的同学且总评 <span class="math inline">\(\in [90,100]\)</span> 的同学总评是 <span class="math inline">\(A+\)</span>，当时发下试卷看了一下附加题，好像是用一个积分中值第二定理再处理一下就能证明，就先做了附加题，最后拿到人生第一个 <span class="math inline">\(A+\)</span> 。（手动狗头）</p><p><strong>线性代数</strong>，JY 姐姐的课，比较 nice，讲课 ppt 非常数学，满篇都是公式，不像 WXF 还放点 Geogebra 作的图，但思路确实比较清晰，至少对于我这种代数基础比较薄弱的很友好。还有 JY 每次作业都有些补充题需要多动一些脑筋，而且他们作业都是手批，比 WXF 的助教认真多了（ WXF 助教基本到期末才改平常的作业） ，可见如果是 JY 的助教工作量是有多大。</p><p>比较有印象的一节课，她讲到正定二次型的时候，举了一个薯片形状为马鞍面抗压能力大的例子，还挺有趣的，JY 姐姐难得在课堂上笑了一次。虽然有时候下雨的冬天坐在五教会犯困，甚至有次把笔记本落在教室了，还好一位日新的好心人帮忙送还，但是 JY 的课也很推荐，至少学到了很多东西。</p><p><strong>程序设计基础</strong>，软院 LYS 老师的大硬课，这门课来年春天的时候被评为优秀课堂。其实个人觉得这种课其实上课啥的都不重要，最重要的是动手实践。经常在 LYS 老师课上写 JY 的线代作业，然后 LYS 老师讲到他在美国读书什么什么的就认真听一下……</p><p>每周四都要上机，在东配楼，机房电脑上全是灰尘，随着课程的进行，后面和链表相关的题真的让人头疼，感觉用数组做呢，感觉过不去，用链表呢，链表要手写，太麻烦……然后当时助教让我当组长，结果就成了 PPT 制作者 + PPT 报告者……虽然增加了工作量，不过也能锻炼自己。</p><p>然后临近期末就是头疼的大作业了，助教给了一个大约 800 行用 WIN32 编写的框架，要求实现一个横版闯关游戏，那段时间是真的肝，而且当时一点模块化思想都没有，一个文件写到底，一旦调不出来直接塞到全局变量去，到后面加个按钮都非常炸裂。当时的启蒙书是毛星云的《逐梦旅程：Windows游戏编程之从零开始》，哎，没想到浅墨竟然就在我大作业交后两天辞别人世，我一直记得《逐梦旅程》中的一句话：</p><blockquote><p>谨以此书献给所有怀揣游戏开发梦想的人们，因为，你们不是一个人在战斗。</p></blockquote><p>愿浅墨在天堂实现他的梦想，逝者安息。</p><p>期末考试五个题，一堆<strong>码农题</strong>，写起来还挺难受的，当时不知道一些技巧，有个题要讨论八个方向，直接复制粘贴改数据八次……然后最后一个算法题，还以为自己没法做出来，但当时还有将近两个小时的时间（手动狗头），就拿出纸笔开始写思路，当时想测一下穷举法能过几个，然后写了一堆 for ，提交，结果就神奇般的过了，对，除了处理初始数据有个优化之外，其他啥都没优化，直接就给过了，然后三小时考试一个半小时提前交卷……LYS 老师是图形所的，之后还会提到他。</p><p><strong>体育</strong>，WJH 老师，是一个和蔼的老头，经常口出一些顺口溜，<strong>“祖国好，清华好，无体育，不清华，全面发展我最好”</strong>，清华的<strong>3000米</strong>是真的难受，对于我这种初高中跑 1km 都难受得要死的体育差生简直是五雷轰顶。不过跟着清华阳光长跑的氛围，经常在紫荆操场上跑步，逐渐在耐力方面有所提升，长跑项目还是可以练的嘛，贵在坚持。反正最后体育成绩也算可以接受。</p><p><strong>思想道德与法律</strong>，ZXM 老师，这门课任务量挺大的，分组小组展示。个人其实很讨厌这种小组活动，感觉跟生产队一样，分组也全看运气，如果分到摆烂组是真的难受。当时还选了一个组长，结果我实在看不下去，好多事情被我一个人包办了……</p><p>然后不得不说，有次上课一个同班好朋友拉我翘课去写微积分作业，结果那堂课就签到了……也没有怪罪好朋友的意思，当时我自己也没有定力，思修教室人很多很闷，特别难受，觉是睡过好几次了，课也没听进去几个字，思修群倒是特别热闹，好像老师也不怎么管，都让大家畅所欲言，唯一的收获是一堆表情包……就这样咯，本来对这种从小到大都不感冒的课程无所谓。</p><p><strong>英语听说讨论</strong>，Matthew 的课，一个新聘请的外教老师，本来对华子的英语课抱有希望拯救我这垃圾英语，没想到还是失望了……前面几节课认真听讲，后面结果摆烂，上英语课的时候当天程设小作业就放出来了，于是在英语课堂上写代码，然后个人 presentation 还行，结果又是 group presentation 随机分组难受，一堆人摆烂，好多事情都是我做的，结果最后展示的时候组员忘词是真的无语了好吧……反正跟 zcy 学长说的一样，华子英语课上是学不到东西的……</p><p><strong>未央工程导论</strong>，究极大屑课，跟贵系的<strong>信息技术科学概论</strong>有的一拼，未央十二个专业方向“百饼齐放”。而且这课还要签到，签到学号十分随机，时序数据预测很难。有次讲座是副校长，直接让半个未央的同学全来签到，还记得那次室友在群里一发，我们宿舍剩下三个人马上骑车飞奔到现场，真的是有惊无险。好在那堂课讲课还行，用一个动画展现了排队中的统筹策略，授课比较风趣。不过这门课是真的难受，还要写两篇报告，照着 PPT 修修补补，总算弄完了这个烂摊子。</p><h3 id="srt">SRT</h3><p>未央工程导论中间有几堂课是导师引领相关研究方向，然后 SEY 老师开始画大饼大法把我们一半的同学<del>骗</del>到 SRT 项目中（包括我），项目题目叫<strong>二次曲线曲面函数求交库</strong>，是关于数学方面很底层的求交算法实现，前期对 git 命令不是很熟悉，以及对整个 SRT 项目抱有太多期待，投入了过量的时间……总之，顺着 GEMS 项目迁移了许多函数到 GMT 中，得到相应的测试，但感觉浪费了不少时间……不过，大一需要尝试，也算是一个经历吧……</p><p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"https://lr-tsinghua11.github.io/video/亲爱的旅人啊.mp4","pic":"https://lr-tsinghua11.github.io/img/亲爱的旅人啊.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></p>]]></content>
    
    
    <categories>
      
      <category>随想</category>
      
      <category>里程碑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大一学年总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>General Physics finals(Jiang Shuo)</title>
    <link href="/2022/06/20/General%20Physics%20finals(Jiang%20Shuo)/"/>
    <url>/2022/06/20/General%20Physics%20finals(Jiang%20Shuo)/</url>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(\mathbf{PDF}\)</span> 文件下载请点击这里 <a href="https://lr-tsinghua11.github.io/pdf/蒋硕2021春期末试题解答.pdf">蒋硕2021春期末试题解答</a> <a href="https://lr-tsinghua11.github.io/pdf/蒋硕2020秋期末试题解答.pdf">蒋硕2020秋期末试题解答</a></p><h1 id="gpⅰ-final-exam-202114">GPⅠ Final Exam (2021/1/4)</h1><center><font size = 4.5><font face="楷体">author 鲁睿 未央软-11</center><p>(In questions asking for the expression of certain relation, you need to express them in terms of given and physical constants. Of course, you can combine them to write simple formula, but do explicitly list out your regrouping. For example: <span class="math inline">\(a=A / m, A=v c / b\)</span>,V,c,b,m are the constants or terms provided. 题目中所要你求的关系表达式，需要用给定量和物理常数表达。当然你可以组合定义以简便表达，但一定明确给出你的重组)</p><h2 id="mbox-points"><span class="math inline">\(1_{(16 \mbox{ points})}\)</span></h2><p>(16 points) The device below can be used to measure the density and viscosity of a liquid using a so-called hydrometer. The hydrometer is shown in the figure below:The hydrometer has total mass <span class="math inline">\(=m\)</span>; Its bottom is heavier so that it can stably float in liquid (it can move up-down, but will not rock side-ways). The long neck part has uniform cross area <span class="math inline">\(A\)</span>. The equilibrium position of the hydrometer in a liquid is taken as <span class="math inline">\(x=0\)</span>. Now if the hydrometer is displaced from its equilibrium by <span class="math inline">\(x\)</span> as shown in the figure (the <span class="math inline">\(x\)</span> is always within the neck region), it will start to oscillate. From measuring this oscillation frequency and amplitude decay, we can deduce the density and viscosity of the liquid.</p><p><img src="https://pic.imgdb.cn/item/62af07c3094754312995b5a8.jpg" style="zoom:20%;" /></p><p><span class="math inline">\((1)\)</span> (5 points) Neglect any friction caused by the viscosity of the liquid, A) write out the equation of motion for <span class="math inline">\(x\)</span> of the hydrometer. B) Express its natural frequency <span class="math inline">\(\omega_{0}\)</span> in terms of <span class="math inline">\(\rho\)</span> the density of liquid; hydrometer mass <span class="math inline">\(m ; g\)</span> gravitation constant etc.</p><p><span class="math inline">\((2)\)</span> (3 points) If the liquid is viscous, it will introduce a resistance force <span class="math inline">\(\dfrac{F_{\text {friction }}}{m}=-\gamma \dot{x} ; \gamma\)</span> is called damping or viscous coefficient; If we would like to have the hydrometer be back to the stable equilibrium as quick as possible, what is the <span class="math inline">\(\gamma\)</span> in term of the <span class="math inline">\(\omega_{0}\)</span> ?</p><p><span class="math inline">\((3)\)</span> (8 points) In application of measurement of the density <span class="math inline">\(\rho\)</span> and viscosity <span class="math inline">\(\gamma\)</span> of the liquid, the liquid should not be too viscous so that the hydrometer can oscillate. We can directly measure the displacement x (for example let the top of the hydrometer be the cathode of a capacitor, while another fixed plate (the dashed line of in the figure) be the anode, and we can measure the voltage difference between them which is proportional to <span class="math inline">\(x\)</span> ). The measured result is shown in the figure below:</p><p><img src="https://pic.imgdb.cn/item/62af0bb309475431299a9bcf.jpg" style="zoom:50%;" /></p><p>​ The time between the <span class="math inline">\(1^{\text {st }}\)</span> peak and <span class="math inline">\(9^{\text {th }}\)</span> peak is <span class="math inline">\(4\)</span> seconds; and the <span class="math inline">\(9^{\text {th }}\)</span> peak is about <span class="math inline">\(e^{-1}\)</span> of the first peak. From measurement, please calculate the following values:</p><p>​ a) Period <span class="math inline">\(T\)</span> of the damped oscillation; b) angular frequency <span class="math inline">\(\omega\)</span>; c) The value of natural frequency <span class="math inline">\(\omega_{0}\)</span> and the viscosity <span class="math inline">\(\gamma\)</span> ?; d) Quality factor Q for this oscillator.[(a), b) are 1 point each; (c) 4 points; (d) 2 points]</p><hr /><p><span class="math inline">\((1)\)</span> Initial state equilibrium <span class="math inline">\(mg=\rho Vg\)</span>, when it moves <span class="math inline">\(x\)</span>, according to Newton's second law <span class="math display">\[\rho (V-xA)g-mg=m\ddot{x}=-xAg\]</span> So <span class="math inline">\(\ddot{x}=-\dfrac{\rho Ag}{m}x=-\omega_0^2x\)</span>, then <span class="math inline">\(\omega_0=\sqrt{\dfrac{\rho Ag}{m}}\)</span></p><p><span class="math inline">\((2)\)</span> Compare to <span class="math inline">\(\small (1)\)</span>, add <span class="math inline">\(F_{\mbox{friction}}=-m\gamma\dot{x}\)</span>, according to Newton's seconde law <span class="math display">\[\rho (V-xA)g-mg-m\gamma \dot{x}=m\ddot{x}=-xAg-m\gamma\dot{x}\Longrightarrow \ddot{x}+\gamma \dot{x}+\dfrac{\rho Ag}{m}x=0\]</span> its eigenvalues are <span class="math inline">\(\lambda_{1,2}=\dfrac{-\gamma\pm\sqrt{\gamma^2-4\omega_0^2}}{2}\)</span>. If <span class="math inline">\(\gamma^2-4\omega_0^2= 0\)</span>, the hydrometer will be back as quick as possible. <span class="math display">\[\gamma= 2\omega_0\]</span> <span class="math inline">\((3)\)</span> a) <span class="math inline">\(4=(9-1)\cdot T\Longrightarrow T=0.5s\)</span> b) <span class="math inline">\(T=\dfrac{2\pi}{\omega}\Longrightarrow \omega=4\pi \mbox{ rad/s}\)</span></p><ol start="3" type="a"><li>Obviously <span class="math inline">\(\gamma&lt;2\omega_0\)</span>, so <span class="math inline">\(x(t)=x_0e^{-\frac{\gamma}{2}t}\cos(\sqrt{\omega^2_0-\dfrac{1}{4}\gamma^2}t+\varphi)\)</span> <span class="math inline">\(,e^{-\frac{\gamma}{2}\cdot 4}=e^{-1}\Longrightarrow \gamma=0.5\mbox{ s}^{-1}\)</span></li></ol><p>solve <span class="math inline">\(\sqrt{\omega_0^2-\dfrac{1}{4}\gamma^2}=\omega\)</span> then <span class="math inline">\(\omega_0=\sqrt{\omega_0^2+\dfrac{1}{4}\gamma^2}= 12.56886\mbox{ rad/s}\)</span></p><ol start="4" type="a"><li><span class="math inline">\(Q=2\pi\dfrac{E}{\Delta E}=2\pi \dfrac{A_0^2}{A_0^2(1-(e^{-\frac{\gamma}{2}T})^2)}\approx \dfrac{2\pi}{\gamma T}=\dfrac{\omega}{\gamma}=25.13771\)</span></li></ol><h2 id="mbox-points-1"><span class="math inline">\(2_{(12 \mbox{ points})}\)</span></h2><p>Central Field. Below you need to Calculate lowest orbit energy, angular momentum, radius and speed of an electron at the ground orbit in hydrogen (H) atom, using Bohr's orbit model and de Broglie matter wave hypothesis. Bohr proposed electron like a particle moves around nuclei in a circular orbit subject to Coulomb force. It has orbit radius <span class="math inline">\(R\)</span> (called Bohr radius), energy <span class="math inline">\(E\)</span>, angular momentum <span class="math inline">\(L\)</span> and speed <span class="math inline">\(v\)</span> to be determined. Using de Broglie matter wave, the longest wavelength can stably exist on the orbit must satisfy: <span class="math inline">\(\lambda=2 \pi R\)</span> (If you understand the standing wave picture behind this formula, that's great; If not, just treat it as a given condition), and you may know his famous relation between momentum and wavelength: <span class="math inline">\(p=\)</span> <span class="math inline">\(\dfrac{h}{\lambda}, h=6.63 \times 10^{-34}\)</span> (SI unit). The Coulomb potential energy in hydrogen atom between electron and proton is: <span class="math inline">\(U=-\dfrac{\mathrm{A}}{r}\  \mathrm{A}\)</span> is a natural constant <span class="math inline">\(A=2.3 \times 10^{-28}\)</span> (SI unit). Mass of electron is <span class="math inline">\(m_{e}=9.11 \times 10^{-31} \mathrm{~kg}\)</span> (the reduced mass can be treated equal to this since proton is 1800 time massive). Using the provided information, calculate the</p><ol type="A"><li>Angular momentum <span class="math inline">\(L\)</span> in terms of <span class="math inline">\(h\)</span>.</li><li>Bohr Radius <span class="math inline">\(R\)</span> in units of <span class="math inline">\(\AA\left(1 \AA=10^{-10} \mathrm{~m}\right)\)</span></li><li>Energy <span class="math inline">\(\mathrm{E}\)</span> in <span class="math inline">\(\mathrm{eV} 1 \mathrm{eV}=1.6 \times 10^{-19} \mathrm{~J}\)</span></li><li>Orbital speed <span class="math inline">\(V=\alpha C, C\)</span> is speed of light, express <span class="math inline">\(\alpha\)</span> in terms of physical constants (h, <span class="math inline">\(m_{e}, \mathrm{C}\)</span> and Bohr radius <span class="math inline">\(\mathrm{R}\)</span> ) and find its value (3 points each for A) to D))</li></ol><hr /><ol type="A"><li><p><span class="math inline">\(\lambda=2\pi R=\dfrac{h}{p}\Longrightarrow L=pR=\dfrac{h}{2\pi}=\hbar\)</span></p></li><li><p><span class="math inline">\(F=-\dfrac{dU}{dr}=-\dfrac{A}{r^2}\)</span>, <span class="math inline">\(\dfrac{A}{R^2}=m\dfrac{v^2}{R}\Longrightarrow \begin{cases}mv^2R=A\\mvR=\dfrac{h}{2\pi}\end{cases}\Longrightarrow R=\dfrac{h^2}{4\pi^2mA}=0.531\AA\)</span></p></li><li><p><span class="math inline">\(E=\dfrac{1}{2}mv^2-\dfrac{A}{R}=-\dfrac{A}{2R}=-\dfrac{2\pi ^2mA^2}{h^2}=-13.52\mbox{ eV}\)</span></p></li><li><p><span class="math inline">\(\alpha =\dfrac{V}{C}=\dfrac{2\pi A}{hC}=7.26\times10^{-3}\approx\dfrac{1}{137}\)</span></p></li></ol><h2 id="mbox-points-2"><span class="math inline">\(3_{(14 \mbox{ points})}\)</span></h2><p>Interference: LIGO (Laser Interferometer Gravitation-Wave Observatory) is using interference to observe the expansion-contraction if space due to gravitation wave.</p><p><img src="https://pic.imgdb.cn/item/62af13e00947543129a538cf.jpg" style="zoom:50%;" /></p><p>As shown in the figure: It is basically a big Michelson Interferometer, two arm length <span class="math inline">\(L_{0}\)</span> is 4000 meter <span class="math inline">\((4 \mathrm{~km}\)</span> ) each. Two extra mirrors inside will make light being reflected backwardforward <span class="math inline">\(N=300\)</span> times, effectively prolong the length of each arm. The light from each arm finally meets at the beam splitter and creates interference pattern. When gravitation wave (indicated by the curve on top) passes, one arm length will be lengthened and the other be compressed. This effect is expressed by a strain coefficient <span class="math inline">\(\delta\)</span>, it expresses the length difference in the two arms by: <span class="math inline">\(\Delta L=\delta L_{0}\)</span> When there is no gravitation wave, the two arms are with equal length, and due to halfwavelength difference effect, light from two paths cancels each other and the interference is dark; when the gravitation wave creates a difference in arm length, the interference intensity will change, and from such change <span class="math inline">\(\delta\)</span> can be measured.</p><p><img src="https://pic.imgdb.cn/item/62af14680947543129a5e57d.jpg" style="zoom:80%;" /></p><p>The measured results are shown above. Vertical is the calculated <span class="math inline">\(\delta\)</span> from intensity change, horizontal is time. Two groups of data on the left and right are from two observatories located at different places (Hanford at Washington State and Livingston at Louisiana). The top row is the measurement; the middle is theoretical simulation and the bottom is noise level.</p><ol type="1"><li>From data, what is the order of magnitude of <span class="math inline">\(\delta\)</span> ? How big is the length difference <span class="math inline">\(\Delta L\)</span> ? (2 points)</li><li>At such order of magnitude <span class="math inline">\(\delta\)</span>, what is the phase difference between the light that passes the two arms of the interferometer then reaches the detector? The center wavelength of laser in use is <span class="math inline">\(\lambda=1064 \mathrm{~nm}\)</span> (3 points)</li><li>At such phase difference, what is the change of light intensity from zero? Needed parameter: The total intensity of the laser is <span class="math inline">\(I_{0}=1000 \mathrm{~W}\)</span> (5 points)</li><li>For such small intensity change, and the signal is really not too much above the noise, why the result is not due to some seismic-environmental changes (such as seismic activity, local temperature fluctuation, or even just student drop a wrench on the floor <span class="math inline">\(\cdots)\)</span> ? ( 4 points)</li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(10^{-21}\sim 10^{-22}\)</span> , <span class="math inline">\(\Delta L_{\mbox{max}}=4\times 10^{-18}\mbox{ m}\)</span></p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\Delta\varphi =\dfrac{2\pi}{\lambda}\Delta L\cdot 2N=1.42\times10^{-8}\mbox{ rad}\)</span></p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\tilde{A_1}=A_0\cos (\omega t),\tilde{A_2}=A_0\cos (\omega t+\pi +\Delta \varphi )\)</span> and the total intensity is <span class="math inline">\(I_0=\overline{\tilde{A_1^2}}+\overline{\tilde{A_2^2}}=\dfrac{A_0^2}{2}+\dfrac{A_0^2}{2}=A_0^2\)</span></p><p>the final amplitude is <span class="math inline">\(\tilde{A}=\tilde{A_1}+\tilde{A_2}=A_0(\cos (\omega t)-\cos(\omega t+\Delta \varphi ) )=2A_0\sin (\dfrac{\Delta\varphi}{2})\sin (\omega t+\dfrac{\Delta \varphi }{2})\)</span></p><p>So the intensity is <span class="math inline">\(I=\overline{\tilde{A^2}}=4A_0^2\sin ^2(\dfrac{\Delta \varphi }{2})\cdot \dfrac{1}{2}\approx 2A_0^2(\dfrac{\Delta \varphi}{2})^2=\dfrac{1}{2}I_0(\Delta \varphi)^2 =1.00\times 10^{-13}\mbox{ W}\)</span></p><p><span class="math inline">\((4)\)</span> Two different experienments in different places show the same trend of the wave.</p><h2 id="mbox-points-3"><span class="math inline">\(4_{(10 \mbox{ points})}\)</span></h2><p>(10 points) For a give wedge-shaped thin film (the top and bottom surfaces are flat planes, intersect and has very small angle <span class="math inline">\(\alpha\)</span> ) shown in the figure:</p><p><img src="https://pic.imgdb.cn/item/62af19d70947543129acfbc8.jpg" style="zoom:50%;" /></p><p>At the beginning it is air <span class="math inline">\((n=1)\)</span> between the top-bottom surface, the incoming light with vacuum wavelength <span class="math inline">\(500 \mathrm{~nm}\)</span> illuminates the top at normal angle. 1) Give a simple description or sketch of the interference fringe at the top surface of the thin film (no calculation needed). (2 points) 2) Now we start to fill some gas <span class="math inline">\((n&gt;1)\)</span> into the space between the top-bottom surfaces, will the fringe moves towards or away from the intersection? (2 points) 3) If the spacing between the fringes (the distance between the adjacent maxima or minima) changes from original (air case) <span class="math inline">\(1 \mathrm{~mm}\)</span> to <span class="math inline">\(0.8 \mathrm{~mm}\)</span> (unknown gas), what is the index of refraction <span class="math inline">\(n\)</span> of the unknown gas? (6 points)</p><hr /><p><span class="math inline">\((1)\)</span> uniform interference fringe</p><p><span class="math inline">\((2)\)</span> towards</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\Delta x\cdot 2\alpha =\lambda\Longrightarrow \Delta x=\dfrac{\lambda }{2\alpha }\)</span> and after filling the gas <span class="math inline">\(\lambda^{\prime }=\dfrac{\lambda }{n}\)</span> <span class="math inline">\(\Delta x^{\prime }=\dfrac{\lambda }{2\alpha n}\)</span> So <span class="math inline">\(n=\dfrac{\Delta x}{\Delta x^{\prime}}=1.25\)</span></p><h2 id="mbox-points-4"><span class="math inline">\(5_{(12 \mbox{ points})}\)</span></h2><p>As shown in the figure:</p><p><img src="https://pic.imgdb.cn/item/62af1c4d0947543129b039fc.jpg" style="zoom:30%;" /></p><p>A rod with proper length <span class="math inline">\(L_{0}\)</span> is moving with constant high velocity <span class="math inline">\(v\)</span> along <span class="math inline">\(x\)</span> direction in lab frame (frame S). The head of it <span class="math inline">\(\mathrm{H}\)</span> will hit a stiff wall and be stopped, and at meantime the stop signal (the curly curve in figure) will transmit from <span class="math inline">\(\mathrm{H}\)</span> through the rod with speed of light <span class="math inline">\(c\)</span> (the position of wall is at <span class="math inline">\(x=0\)</span> ). When the stop signal reaches the tail of the rod <span class="math inline">\(T\)</span>, only then it stops moving. There are also marks on the ground in lab with spacing <span class="math inline">\(\Delta d=1\)</span> unit length. When the tail of the rod stops, it will reach certain marks <span class="math inline">\(n\)</span>. (fig.b) 1) (4 points) <span class="math inline">\(\ln \mathrm{S}\)</span> view, calculate the value of <span class="math inline">\(\mathrm{n}\)</span>, in terms of <span class="math inline">\(L_{0}, \beta\)</span> 2) (4 points) In the rod view (call it frame <span class="math inline">\(S^{\prime}\)</span> ) in which the tail of rod <span class="math inline">\(T\)</span> is stationary. please draw the figure in <span class="math inline">\(\mathrm{S}^{\prime}\)</span>, corresponding to the figure a) above. In the figure, please specify the length of the rod; the spacing of the mark <span class="math inline">\(\Delta d^{\prime}\)</span>, which parts are moving and their speed.</p><ol start="3" type="1"><li>(4 points) In frame S', calculate the stop marks <span class="math inline">\(n^{\prime}\)</span>, in terms of <span class="math inline">\(L_{0}, \beta\)</span>.</li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\Delta t=\dfrac{\Delta L&#39;}{v+c}=\dfrac{L_0\sqrt{1-\beta ^2}}{v+c}\)</span> and the value of <span class="math inline">\(n\)</span> equals to <span class="math inline">\(c\Delta t=L_0\sqrt{\dfrac{1-\beta }{1+\beta}}\)</span></p><p><span class="math inline">\((2)\)</span> <img src="https://pic.imgdb.cn/item/62af20ee0947543129b689e3.jpg" style="zoom:20%;" /> its length is <span class="math inline">\(L\)</span>, <span class="math inline">\(\Delta d^{\prime}=\sqrt{1-\beta ^2}\)</span></p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\Delta x=L_0-\dfrac{L_0}{c}\cdot v=(1-\beta )L_0\)</span> and the value is <span class="math inline">\(n^{\prime}=\dfrac{\Delta x}{\Delta d^{\prime}}=L_0\sqrt{\dfrac{1-\beta }NaN}\)</span></p><h2 id="mbox-points-5"><span class="math inline">\(6_{(18 \mbox{ points})}\)</span></h2><p>In the ground frame, <span class="math inline">\(A(x=y=0)\)</span> fires a bullet at <span class="math inline">\(t=0\)</span> towards a stationary target ball at <span class="math inline">\((x, y)=(4ls, 3ls)\)</span> (no friction or resistance). The bullet and target ball both have same rest mass <span class="math inline">\(m\)</span>; the bullet has speed <span class="math inline">\(u=0.5 c\)</span> (with respect to <span class="math inline">\(A\)</span> ), the bullet will sink into ball and travel with it. For another observer <span class="math inline">\(B\)</span> whose speed <span class="math inline">\(v=0.8 c\)</span> relative to <span class="math inline">\(A\)</span>, and <span class="math inline">\(x^{\prime}=0, y^{\prime}=0, t^{\prime}=0\)</span> overlap those of A's:</p><p><img src="https://pic.imgdb.cn/item/62af22900947543129b8a675.jpg" style="zoom:20%;" /></p><ol type="1"><li>(5 points) For observer <span class="math inline">\(B\)</span>, what are the space-time coordinates for the bullet hits the target ball?</li><li>(3 points) Suppose B does not know u (the bullet speed relative to A), but B can measure the velocity of the bullet in his frame using the results of 1 ), what is the velocity of bullet <span class="math inline">\(\left(u_{x}^{\prime}, u_{y}^{\prime}\right)\)</span> in B's frame from results in (a)?</li><li>(2 points) For <span class="math inline">\(A\)</span>, since he knows <span class="math inline">\(u=0.5 c\)</span>, and he can deduce bullet's velocity measured by <span class="math inline">\(B\)</span> to be <span class="math inline">\(\left(u_{x}^{\prime}, u_{y}^{\prime}\right)\)</span>, please do a calculation on <span class="math inline">\(\left(u_{x}^{\prime}, u_{y}^{\prime}\right)\)</span> from A's view.</li><li>(4 points) After bullet hits ball and moves together with it. What will be the final momentum (express the momentum in its <span class="math inline">\(x, y\)</span> components) and energy in A's frame</li><li>(4 points) Answer same questions in 4) but in B's frame.</li></ol><hr /><p><span class="math inline">\((1)\)</span> the hit event happens at <span class="math inline">\(\begin{cases}x=4ls\\y=3ls\\t=10s\end{cases}\stackrel{v=0.8c}{\Longrightarrow }t^{\prime}=\dfrac{t-\dfrac{v}{c^2}x}{\sqrt{1-\dfrac{v^2}{c^2}}}=\dfrac{34}{3}\mbox{ s}\)</span></p><p><span class="math inline">\((2)\)</span> Use the time that <span class="math inline">\(B\)</span> measures <span class="math inline">\(v_{By}^{\prime}=\dfrac{\Delta y}{t^{\prime}}=\dfrac{9}{34}c\)</span> and the <span class="math inline">\(v_x\)</span> difference between <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is <span class="math display">\[v_{Ax}-v_{Bx}=\dfrac{\Delta x^{\prime}}{t^{\prime}}=\dfrac{x\cdot \sqrt{1-\beta ^2}}{t^{\prime}}=\dfrac{18}{85}c=0.8c-v_{Bx}\]</span> So <span class="math inline">\(v_{Bx}=\dfrac{10}{17}c\)</span> <span class="math inline">\(,\vec{v}_{B}=(-\dfrac{10}{17}c,\dfrac{9}{34}c)\)</span></p><p><span class="math inline">\((3)\)</span> Use relativistic velocity transformation <span class="math inline">\(v_{x}^{\prime}=\dfrac{v_x-v}{1-\dfrac{v_xv}{c^2}}=-\dfrac{10}{17}c,v_{y}^{\prime}=\dfrac{v_y\cdot \sqrt{1-\beta ^2}}{1-\dfrac{v_xv}{c^2}}=\dfrac{9}{34}c\)</span></p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(|\vec{p}|=\dfrac{mv}{\sqrt{1-\dfrac{v^2}{c^2}}}=\dfrac{\sqrt{3}}{3}mc\)</span>. According to momentum conservation <span class="math inline">\(\vec{p^{\prime}}=\dfrac{mc}{\sqrt{3}}(\dfrac{4}{5},\dfrac{3}{5})\)</span></p><p>add the energy together <span class="math inline">\(E=mc^2+\dfrac{mc^2}{\sqrt{1-\dfrac{v^2}{c^2}}}=(1+\dfrac{2\sqrt{3}}{3})mc^2\)</span></p><p><span class="math inline">\((5)\)</span> Apply relativistic energy momentum transformation <span class="math display">\[\begin{pmatrix}\dfrac{E^{\prime}}{c}\\p_{x}^{\prime}\\p_{y}^{\prime}\\p_{z}^{\prime}\end{pmatrix}=\begin{pmatrix}\gamma &amp; -\beta \gamma&amp;0&amp;0\\-\beta \gamma &amp;\gamma&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{pmatrix}\begin{pmatrix}\dfrac{E}{c}\\p_{x}\\p_{y}\\p_{z}\end{pmatrix}\]</span> So <span class="math inline">\(E^{\prime}=\gamma(E-\beta c p_{x})=\dfrac{75+34\sqrt{3}}{45}mc^2,p_{x}^{\prime}=\gamma (p_x-\beta \dfrac{E}{c})=-(\dfrac{4}{3}+\dfrac{4\sqrt{3}}{9})mc\)</span></p><p><span class="math inline">\(p_{y}^{\prime}=p_y=\dfrac{\sqrt{3}}{5}mc,\vec{p^{\prime}}=(-\dfrac{12+4\sqrt{3}}{9}mc,\dfrac{\sqrt{3}}{5}mc),E^{\prime}=\dfrac{75+34\sqrt{3}}{45}mc^2\)</span></p><h2 id="mbox-points-6"><span class="math inline">\(7_{(18 \mbox{ points})}\)</span></h2><p>Compton Scattering of photon by stationary electron:</p><p><img src="https://pic.imgdb.cn/item/62af2c100947543129c5ffaf.jpg" style="zoom:33%;" /></p><p>The initial photon with energy <span class="math inline">\(E_{i}\)</span> (and wavelength <span class="math inline">\(\lambda_{i}, E=\dfrac{h c}{\lambda}\)</span> ) along <span class="math inline">\(\mathrm{x}\)</span>-direction interacts with a stational electron (rest mass <span class="math inline">\(m_{e}, m_{e}=9.1 \times 10^{-31} \mathrm{~kg} \sim 0.51 \mathrm{MeV}\)</span> ). The scattered photon will be along direction <span class="math inline">\(\theta\)</span>, with energy <span class="math inline">\(E_{f}\)</span> and corresponding wavelength <span class="math inline">\(\lambda_{f}\)</span>. Compton effect is how the wavelength change of the photon <span class="math inline">\(\Delta \lambda=\lambda_{f}-\lambda_{i}\)</span> relates to scattering angle <span class="math inline">\(\theta\)</span> 1. ( 6 points) Write out the conservation relation of the process: a) Using 4-vector symbol (state each 4 -vector corresponding to which)</p><ol start="2" type="a"><li>Write out energy conservation; momentum (components) conservation respectively.</li></ol><ol start="2" type="1"><li><p>( 6 points) Find the relation between the <span class="math inline">\(\Delta \lambda\)</span> and <span class="math inline">\(\theta\)</span></p></li><li><p>(4 points) The relation would be like: <span class="math inline">\(\Delta \lambda=\lambda_{C}(1-\cos \theta), \lambda_{C}\)</span> is a natural constant called Compton wavelength (for electron), please express it in terms of other constant, and calculate its value.</p></li><li><p>(2 points) If the photon interacts with a proton whose rest mass <span class="math inline">\(m_{p}=1800 m_{e}\)</span>, what is the value of Compton wavelength in this case?</p></li></ol><hr /><p><span class="math inline">\((1)\)</span> a) <span class="math inline">\(\mathcal{P}=\begin{pmatrix}\dfrac{E}{c}\\p_x\\p_y\\p_z\end{pmatrix}\)</span> so <span class="math inline">\(\mathcal{P}_{0}=\begin{pmatrix}\dfrac{h}{\lambda_i}+m_ec\\\dfrac{h}{\lambda_i}\\0\\0\end{pmatrix},\mathcal{P}_{1}=\begin{pmatrix}\dfrac{h}{\lambda_f}+\dfrac{E}{c}\\\dfrac{h}{\lambda_f}\cos \theta+p\cos \varphi \\\dfrac{h}{\lambda_f}\sin \theta-p\sin \varphi\\0\end{pmatrix}\)</span></p><ol start="2" type="a"><li>Energy conservation <span class="math display">\[\dfrac{h}{\lambda_i}+m_ec=\dfrac{h}{\lambda_f}+\dfrac{E}{c}\]</span> momentum (components) conservation <span class="math display">\[\begin{cases}\dfrac{h}{\lambda_i}=\dfrac{h}{\lambda_f}\cos \theta +p\cos \varphi\\0=\dfrac{h}{\lambda_f}\sin \theta-p\sin \varphi \end{cases}\]</span> <span class="math inline">\((2)\)</span> Eliminate $$, <span class="math inline">\((p\cos \varphi)^2+(p\sin \varphi)^2=(\dfrac{h}{\lambda_i}-\dfrac{h}{\lambda_f}\cos \theta)^2+(\dfrac{h}{\lambda_f}\sin \theta)^2=h^2(\dfrac{1}{\lambda_i^2}+\dfrac{1}{\lambda_f^2}-\dfrac{2\cos \theta}{\lambda_i\lambda_f})=p^2\)</span></li></ol><p>For the photon <span class="math inline">\(p^2c^2+E_0^2=E^2=h^2c^2(\dfrac{1}{\lambda_i^2}+\dfrac{1}{\lambda_f^2}-\dfrac{2\cos \theta}{\lambda_i\lambda_f})+E_0^2\)</span> And we have <span class="math inline">\(E=hc(\dfrac{1}{\lambda_i}-\dfrac{1}{\lambda_f})+E_0\)</span></p><p><span class="math inline">\(\therefore h^2c^2(\dfrac{1}{\lambda_i^2}+\dfrac{1}{\lambda_f^2}-\dfrac{2}{\lambda_i\lambda_f})+E_0^2+2hcE_0(\dfrac{1}{\lambda_i}-\dfrac{1}{\lambda_f})=h^2c^2(\dfrac{1}{\lambda_i^2}+\dfrac{1}{\lambda_f^2}-\dfrac{2\cos \theta}{\lambda_i\lambda_f})+E_0^2\)</span></p><p><span class="math inline">\(\therefore 2hcE_0\dfrac{\Delta \lambda}{\lambda_i\lambda_f}=2h^2c^2\dfrac{1-\cos \theta}{\lambda_i\lambda_f}\Longrightarrow \Delta \lambda =\dfrac{h}{m_ec}(1-\cos \theta)\)</span></p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\lambda _C=\dfrac{h}{m_ec}=2.43\times 10^{-12}\mbox{ m}\)</span></p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(\lambda^{\prime}=\dfrac{h}{m_{p}c}=\dfrac{h}{1800m_ec}=\dfrac{\lambda_C}{1800}=1.35\times 10^{-15}\mbox{ m}\)</span></p><h1 id="gpⅰ-final-exam-2021618">GPⅠ Final Exam (2021/6/18)</h1><center><font size = 4.5><font face="楷体">author 鲁睿 未央软-11</center><h2 id="mbox-points-7"><span class="math inline">\(1_{(14 \mbox{ points})}\)</span></h2><p>Central field problem:</p><p>In the classical model of tritium ( Isotope of <span class="math inline">\(\mathrm{H}\)</span>, with 1 proton, 2 neutron), the nucleus charge is <span class="math inline">\(+1 e\)</span>, and electron (charge <span class="math inline">\(-e)\)</span> moves around nuclei in a circular orbit with radius <span class="math inline">\(=r_{0}\)</span>. Suddenly a nuclei reaction happened and the one neutron becomes proton inside the nuclei to bring the charge of it to <span class="math inline">\(+2 e\)</span>, the tritium becomes a Helium ion. The electron in the old orbit is facing a new situation:</p><p>(The force between nuclei charge and e is Coulomb attraction: <span class="math inline">\(F=-\dfrac{c}{r^{2}} ; C=\)</span> <span class="math inline">\(\dfrac{Z e^{2}}{4 \pi \varepsilon_{0}}\)</span>; <span class="math inline">\(Z\)</span> : number of proton; <span class="math inline">\(\varepsilon_{0}\)</span> is a constant; use <span class="math inline">\(m_{e}\)</span> for reduced mass)</p><ol type="1"><li><p>(4 points) Express the total energy <span class="math inline">\(E_{0}\)</span>, Coulomb potential energy <span class="math inline">\(U\)</span>, kinetic energy <span class="math inline">\(K\)</span> and angular momentum <span class="math inline">\(L_{0}\)</span> of e in tritium in the original circular orbit, in terms of <span class="math inline">\(C, r_{0} ;\)</span> i.e. <span class="math inline">\(E_{0}, U, K, L_{0}=\)</span> ?</p></li><li><p>(4 points) In the new situation (helium ion), what is the energy <span class="math inline">\(E\)</span> and <span class="math inline">\(L\)</span> for electron, in terms of <span class="math inline">\(E_{0}, L_{0}\)</span></p></li><li><p>(4 points) Find the new orbit parameter <span class="math inline">\(r_{0}^{\prime}, \varepsilon\)</span>; closest and furthest <span class="math inline">\(r_{\text {max }}\)</span>; <span class="math inline">\(r_{\text {min }}\)</span> in terms of <span class="math inline">\(r_{0}\)</span> and other constant.</p></li><li><p>(2 points) Find the long (2a) and short axis (2b) of the new elliptical orbit in terms of <span class="math inline">\(r_{0}\)</span></p></li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(U=\displaystyle \int_{r_0}^{+\infty}F(r)dr=-\dfrac{C}{r_0},m\dfrac{v^2}{r_0}=\dfrac{C}{r_0^2},K=\dfrac{1}{2}mv^2=\dfrac{C}{2r_0}\)</span></p><p>total energy is <span class="math inline">\(E_0=K-\dfrac{C}{r_0}=-\dfrac{C}{2r_0}\)</span> and the angular momentum is <span class="math inline">\(L=mvr_0=mr_0\sqrt{\dfrac{C}{mr_0}}=\sqrt{Cmr_0}\)</span></p><p><span class="math inline">\((2)\)</span> At the moment the reaction happened, the kinetic energy and radius don't change <span class="math display">\[E=K-\dfrac{C^{\prime}}{r_0}=K-\dfrac{2C}{r_0}=-\dfrac{3}{2}\dfrac{C}{r_0}=3E_0,L=mvr_0=L_0\]</span> <span class="math inline">\((3)\)</span> According to elliptical orbit energy <span class="math inline">\(E=-\dfrac{C^{\prime}}{2a}=-\dfrac{2C}{2a}=-\dfrac{3C}{2r_0}\Longrightarrow a=\dfrac{2}{3}r_0\)</span></p><p><span class="math inline">\(r_{\max}=r_0,r_{\min}+r_{\max}=2a=\dfrac{4}{3}r_0\Longrightarrow r_{\min}=\dfrac{1}{3}r_0\)</span></p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(a+c=r_0,a-c=\dfrac{1}{3}r_0\Longrightarrow a=\dfrac{2}{3}r_0,c=\dfrac{1}{3}r_0,b=\sqrt{a^2-c^2}=\dfrac{r_0}{\sqrt{3}}\)</span> <span class="math inline">\(2a=\dfrac{4}{3}r_0.2b=\dfrac{2\sqrt{3}}{3}r_0\)</span></p><h2 id="mbox-points-8"><span class="math inline">\(2_{(16 \mbox{ points})}\)</span></h2><p>Two identical mass points, mass <span class="math inline">\(=m\)</span>, are connected through identical springs (spring constant=<span class="math inline">\(k\)</span>) to the fixed walls as shown in figure:</p><p><img src="https://pic.imgdb.cn/item/62b02b560947543129d2a884.jpg" style="zoom:10%;" /></p><p>There is also a damper (whose mass can be neglected) between the two <span class="math inline">\(\mathrm{m}\)</span>. It provides a resisting force trying to slow the faster moving particle, its magnitude is <span class="math inline">\(b v\)</span>, where <span class="math inline">\(b\)</span> is a constant and <span class="math inline">\(\mathrm{v}=\left|\dot{x_{1}}-\dot{x_{2}}\right| ; x_{1}, x_{2}\)</span> are displacement from equilibrium.</p><ol type="1"><li>(4 points) Please write out the equations of motion for the points, i.e. <span class="math inline">\(\ddot{x}_{1}, \ddot{x}_{2}\)</span> has to obey what equations, using parameters of <span class="math inline">\(\omega_{0}=\sqrt{k / m}\)</span> and <span class="math inline">\(\gamma=\dfrac{b}{m}\)</span></li><li>(4 points) Above equations may be coupled and hard to solve. We can simplify (decouple) them by replacing variables, such as <span class="math inline">\(y_{2}=x_{1}-x_{2}\)</span> etc. Let's call new variables <span class="math inline">\(y_{1}, y_{2}\)</span>, please list out relation between <span class="math inline">\(y_{1}, y_{2}\)</span> and <span class="math inline">\(x_{1}, x_{2}\)</span>; also list out equations on <span class="math inline">\(\ddot{y}_{1}, \ddot{y}_{2}\)</span>, in terms of <span class="math inline">\(\omega_{0} ; \gamma\)</span></li><li>(4 points) What are the general solutions for <span class="math inline">\(y_{1}, y_{2}\)</span> (under weak damping), which parameters will depend on initial conditions?</li><li>(4 points) If the initial conditions are, at <span class="math inline">\(t=0\)</span>, the two points are at equilibrium positions, and point1 ( <span class="math inline">\(\mathrm{m}\)</span> represented by <span class="math inline">\(x_{1}\)</span> ) receive a quick blow and gain velocity of <span class="math inline">\(v_{0}\)</span>. After a long enough time, the motion of the two points will become <span class="math inline">\(x_{1}=x_{2}=\dfrac{v_{0}}{2 \omega} f(t)\)</span> What is the function form of <span class="math inline">\(f(t)\)</span> ? and what is the <span class="math inline">\(\omega\)</span> (in terms of given parameters)</li></ol><hr /><p><span class="math inline">\((1)\)</span> Newton's second law <span class="math inline">\(\begin{cases}k(x_2-x_1)-kx_1-b(\dot{x_1}-\dot{x_2})=m\ddot{x_1}\\-k(x_2-x_1)-kx_2+b(\dot{x_1}-\dot{x_2})=m\ddot{x_2}\end{cases}\)</span> replace <span class="math inline">\(\sqrt{\dfrac{k}{m}}=\omega_0,\gamma=\dfrac{b}{m}\)</span> <span class="math display">\[\begin{cases}\ddot{x_1}=\omega_0^2(x_2-2x_1)+\gamma(\dot{x_2}-\dot{x_1})\\\ddot{x_2}=\omega_0^2(x_1-2x_2)+\gamma(\dot{x_1}-\dot{x_2})\end{cases}\]</span> <span class="math inline">\((2)\)</span> Add and subtract two equations and set <span class="math inline">\(\begin{cases}y_1=x_1+x_2\\y_2=x_1-x_2\end{cases}\)</span> therefore <span class="math display">\[\begin{cases}\ddot{y_1}=-\omega_0^2y_1\\\ddot{y_2}=-3\omega_0^2y_2-2\gamma \dot{y_2}\end{cases}\]</span> <span class="math inline">\((3)\)</span> Since the damping is weak, <span class="math inline">\(\lambda_{1,2}=-\gamma\pm i\sqrt{3\omega_0^2-\gamma^2}\)</span> so <span class="math display">\[\begin{cases}y_1(t)=A_1\cos (\omega_0t+\varphi _1)\\y_2(t)=A_2e^{-\gamma t}\cos (\sqrt{3\omega_0^2-\gamma^2}t+\varphi _2)\end{cases}\]</span> <span class="math inline">\((4)\)</span> After a long enough time, <span class="math inline">\(e^{-\gamma t}\to 0,y_2\to 0\)</span> And for <span class="math inline">\(y_1(t)\)</span></p><p><span class="math inline">\(y_{1}(0)=x_1(0)+x_2(0)=0,y_1^{\prime}(0)=x_1^{\prime}(0)+x_2^{\prime}(0)=v_0\)</span> So <span class="math inline">\(y_1(t)=\dfrac{v_0}{\omega_0}\sin (\omega_0 t)=x_1(t)+x_2(t)\)</span></p><p>when <span class="math inline">\(t\to +\infty\)</span> <span class="math inline">\(x_1(t)=x_2(t)=\dfrac{1}{2}y_1(t)=\dfrac{v_0}{2\omega_0}\sin (\omega_0 t)\)</span> So <span class="math inline">\(f(t)=\sin (\omega_0t),\omega=\omega_0\)</span></p><h2 id="mbox-points-9"><span class="math inline">\(3_{(12 \mbox{ points})}\)</span></h2><p>A plane wave of wavelength <span class="math inline">\(\lambda\)</span> travels along the z direction, excite the atoms at point <span class="math inline">\(S\)</span>. The emitting light from the atoms will be <strong>in phase</strong> with the plane wave and has same frequency, and its emission can be treated as spherical wave. At distance <span class="math inline">\(D\)</span> from the atoms we put the observing screen. The amplitudes for the plane wave and spherical wave on the screen are both <span class="math inline">\(A\)</span> (This is true under paraxial approximation, <span class="math inline">\(D&gt;&gt;\rho), \rho\)</span> is the distance to the center of screen. Compute the intensity distribution on the screen <span class="math inline">\(\mathrm{I}(\mathrm{x}, \mathrm{y})\)</span>, in terms of <span class="math inline">\(\boldsymbol{\rho}\)</span>, <span class="math inline">\(D, \lambda\)</span> and <span class="math inline">\(A\)</span></p><p><img src="https://pic.imgdb.cn/item/62b0313a0947543129deb842.jpg" style="zoom:16%;" /></p><hr /><p>For the plane wave, <span class="math inline">\(\tilde{A_1}=A\cos (\omega t)\)</span>, and under paraxial approximation, the phase difference is <span class="math display">\[\Delta \varphi=\dfrac{2\pi}{\lambda}(\sqrt{D^2+x^2+y^2}-D)\approx\dfrac{2\pi D}{\lambda}((1+\dfrac{1}{2}\dfrac{x^2+y^2}{D^2})-1)=\dfrac{\pi(x^2+y^2)}{\lambda D}=\dfrac{\pi \rho^2}{\lambda D}\]</span> so <span class="math inline">\(\tilde{A_2}=A\cos (\omega t+\Delta \varphi),\tilde{A}_{tot}=\tilde{A_1}+\tilde{A_2}=2A\cos (\dfrac{\Delta \varphi }{2})\cos (\omega t+\dfrac{\Delta \varphi}{2})\)</span> <span class="math display">\[I(\rho)=|\tilde{A_{tot}}^2|=4A^2\cos^2 (\dfrac{\Delta \varphi }{2})\cdot \dfrac{1}{2}=A^2(1+\cos (\Delta \varphi ))=A^2(1+\cos (\dfrac{\pi \rho^2}{\lambda D}))\]</span></p><h2 id="mbox-points-10"><span class="math inline">\(4_{(14 \mbox{ points})}\)</span></h2><p>Interference: LIGO (Laser Interferometer Gravitation-Wave Observatory) is using interference to observe the expansion-contraction if space due to gravitation wave.</p><p><img src="https://pic.imgdb.cn/item/62af13e00947543129a538cf.jpg" style="zoom:50%;" /></p><p>As shown in the figure: It is basically a big Michelson Interferometer, two arm length <span class="math inline">\(L_{0}\)</span> is 4000 meter <span class="math inline">\((4 \mathrm{~km}\)</span> ) each. Two extra mirrors inside will make light being reflected backwardforward <span class="math inline">\(N=300\)</span> times, effectively prolong the length of each arm. The light from each arm finally meets at the beam splitter and creates interference pattern. When gravitation wave (indicated by the curve on top) passes, one arm length will be lengthened and the other be compressed. This effect is expressed by a strain coefficient <span class="math inline">\(\delta\)</span>, it expresses the length difference in the two arms by: <span class="math inline">\(\Delta L=\delta L_{0}\)</span> When there is no gravitation wave, the two arms are with equal length, and due to halfwavelength difference effect, light from two paths cancels each other and the interference is dark; when the gravitation wave creates a difference in arm length, the interference intensity will change, and from such change <span class="math inline">\(\delta\)</span> can be measured.</p><p><img src="https://pic.imgdb.cn/item/62af14680947543129a5e57d.jpg" style="zoom:80%;" /></p><p>The measured results are shown above. Vertical is the calculated <span class="math inline">\(\delta\)</span> from intensity change, horizontal is time. Two groups of data on the left and right are from two observatories located at different places (Hanford at Washington State and Livingston at Louisiana). The top row is the measurement; the middle is theoretical simulation and the bottom is noise level.</p><ol type="1"><li>From data, what is the order of magnitude of <span class="math inline">\(\delta\)</span> ? How big is the length difference <span class="math inline">\(\Delta L\)</span> ? (2 points)</li><li>At such order of magnitude <span class="math inline">\(\delta\)</span>, what is the phase difference between the light that passes the two arms of the interferometer then reaches the detector? The center wavelength of laser in use is <span class="math inline">\(\lambda=1064 \mathrm{~nm}\)</span> (3 points)</li><li>At such phase difference, what is the change of light intensity from zero? Needed parameter: The total intensity of the laser is <span class="math inline">\(I_{0}=1000 \mathrm{~W}\)</span> (5 points)</li><li>For such small intensity change, and the signal is really not too much above the noise, why the result is not due to some seismic-environmental changes (such as seismic activity, local temperature fluctuation, or even just student drop a wrench on the floor <span class="math inline">\(\cdots)\)</span> ? ( 4 points)</li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(10^{-21}\sim 10^{-22}\)</span> , <span class="math inline">\(\Delta L_{\mbox{max}}=4\times 10^{-18}\mbox{ m}\)</span></p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\Delta\varphi =\dfrac{2\pi}{\lambda}\Delta L\cdot 2N=1.42\times10^{-8}\mbox{ rad}\)</span></p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\tilde{A_1}=A_0\cos (\omega t),\tilde{A_2}=A_0\cos (\omega t+\pi +\Delta \varphi )\)</span> and the total intensity is <span class="math inline">\(I_0=\overline{\tilde{A_1^2}}+\overline{\tilde{A_2^2}}=\dfrac{A_0^2}{2}+\dfrac{A_0^2}{2}=A_0^2\)</span></p><p>the final amplitude is <span class="math inline">\(\tilde{A}=\tilde{A_1}+\tilde{A_2}=A_0(\cos (\omega t)-\cos(\omega t+\Delta \varphi ) )=2A_0\sin (\dfrac{\Delta\varphi}{2})\sin (\omega t+\dfrac{\Delta \varphi }{2})\)</span></p><p>So the intensity is <span class="math inline">\(I=\overline{\tilde{A^2}}=4A_0^2\sin ^2(\dfrac{\Delta \varphi }{2})\cdot \dfrac{1}{2}\approx 2A_0^2(\dfrac{\Delta \varphi}{2})^2=\dfrac{1}{2}I_0(\Delta \varphi)^2 =1.00\times 10^{-13}\mbox{ W}\)</span></p><p><span class="math inline">\((4)\)</span> Two different experienments in different places show the same trend of the wave.</p><h2 id="mbox-points-11"><span class="math inline">\(5_{(12 \mbox{ points})}\)</span></h2><p>A spaceship flying at constant speed <span class="math inline">\(v\)</span> towards <span class="math inline">\(+x\)</span> away from earth. On board it has a light transmitter and detector. <strong>The following data before questions are all referring to ship's frame</strong> ( <span class="math inline">\(S\)</span> ' frame): The ship emit out a light signal with frequency <span class="math inline">\(\omega_{0}\)</span> towards the earth, part of it will be reflected by earth and comes back to the ship (as how radar works). <span class="math inline">\(20\)</span> s after the emission, the detector on the ship picks up the reflected signal from earth, and the frequency of the reflected light <span class="math inline">\(\omega\)</span> is found to be half of <span class="math inline">\(\omega_{0}\)</span>, i.e., <span class="math inline">\(\omega=\dfrac{1}{2} \omega_{0}\)</span>.</p><ol type="1"><li>(2 points) At the time when the emitted light just reaches the earth and been reflected, what is the position of the earth in S' (ship's) frame?</li><li>(4 points) What is the velocity <span class="math inline">\(v\)</span> of ship relative to the earth?</li><li>(6 points) At the time when the reflected light reaches the ship and been detected, how far away of the ship from the earth in earth's frame? (Write the answer in <span class="math inline">\(\gamma, \beta\)</span> first in case your <span class="math inline">\(v\)</span> value is wrong in 2) and you still be able getting most credit for this part;</li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\Delta x^{\prime}=\dfrac{c\Delta t}{2}=10\mbox{ ls}\)</span></p><p><span class="math inline">\((2)\)</span> According to the Doppler effect of light <span class="math inline">\((\sqrt{\dfrac{1-\beta }{1+\beta }})^2=\dfrac{1}{2}\Longrightarrow \beta =\dfrac{1}{3},v=\dfrac{1}{3}c\)</span></p><p><span class="math inline">\((3)\)</span> According to time dilation effect, in the <span class="math inline">\(S\)</span> frame, <span class="math inline">\(\Delta t=\gamma \Delta t^{\prime}\)</span>. Set their initial distance is <span class="math inline">\(l\)</span> <span class="math display">\[\Delta t=\dfrac{l}{c}+\dfrac{(l+\dfrac{l}{c}\cdot v)}{c-v}=\dfrac{l}{c}\dfrac{2}{1-\beta },l^{\prime}=l+\dfrac{l}{c}\cdot v+\dfrac{(l+\dfrac{l}{c}\cdot v)}{c-v}\cdot v=l\cdot \dfrac{1+\beta }{1-\beta}\]</span> So <span class="math inline">\(l^{\prime}=\dfrac{1+\beta }{1-\beta }l=\dfrac{1+\beta}{1-\beta }\dfrac{c\Delta t(1-\beta)}{2}=\dfrac{1+\beta }{2}\gamma c\Delta t=\dfrac{c\Delta t}{2} \sqrt{\dfrac{1+\beta }{1-\beta }}=10\sqrt{2}\mbox{ ls}\)</span></p><blockquote><p>Another solution: In <span class="math inline">\(S^{\prime}\)</span> frame, when the light reaches the ship, <span class="math inline">\(\Delta x^{\prime}=10\mbox{ ls}+\dfrac{1}{3}c\cdot 10\mbox{ s}=\dfrac{40}{3}\mbox{ ls}(=\dfrac{1+\beta }{2}c\Delta t)\)</span></p><p>And the length is measured when <span class="math inline">\(\Delta t^{\prime}=0\)</span>, So <span class="math inline">\(\Delta x=\dfrac{\Delta x^{\prime}+v\Delta t^{\prime}}{\sqrt{1-\dfrac{v^2}{c^2}}}=\dfrac{\Delta x^{\prime}}{\sqrt{1-\dfrac{v^2}{c^2}}}=\dfrac{c\Delta t}{2}\sqrt{\dfrac{1+\beta}{1-\beta}}=10\sqrt{2}\mbox{ ls}\)</span></p></blockquote><h2 id="mbox-points-12"><span class="math inline">\(6_{(16 \mbox{ points})}\)</span></h2><p>In the famous Bertozzi's Ultimate speed experiment, stationary electrons were passing an accelerating electric field with potential of negative millions of volts (MeV in energy). The accelerating electrons then travel in vacuum tube and their terminal speed can be measured with time-of-flight method. The general setup and results are shown in the figure: (top 2 are setup and signal on oscilloscope; bottom 2 are results)</p><p><img src="https://pic.imgdb.cn/item/62b03a850947543129efa78c.jpg" style="zoom:20%;" /></p><ol type="1"><li>(4 points) Please write out the formular for relation between <span class="math inline">\(v^{2}\)</span> and <span class="math inline">\(\mathrm{K}\)</span> (kinetics energy), of which the curve in the figure above should follow.</li><li>(4 points) Compute the <span class="math inline">\(v^{2}\)</span> at <span class="math inline">\(\mathrm{K}=1.0 \mathrm{MeV}\)</span> and <span class="math inline">\(\mathrm{K}=4.5 \mathrm{MeV}\)</span> from the formula, taking the rest mass of electron to be <span class="math inline">\(m_{e}=0.5 \mathrm{MeV} c^{2}=9 \times 10^{16}(\mathrm{~m} / \mathrm{s})^{2}\)</span>.</li><li>(2 points) There may be a difference between the calculation in 2) with measured results in table 1.1. Suppose the measured results are accurate, what do you think is the major reason that cause the difference.</li><li>(5 points) Now we use electrons with <span class="math inline">\(\mathrm{K}=4.5 \mathrm{MeV} ; m_{e}=0.5 \mathrm{MeV}\)</span> to bombard a stationary proton (rest mass <span class="math inline">\(m_{p}=940 \mathrm{MeV}\)</span> ). If they form a " <span class="math inline">\(\mathrm{H}\)</span> " atom, what will be the rest mass (in <span class="math inline">\(\mathrm{MeV})\)</span> of "H" atom?</li><li>(1 point) How many energy needs to be released in order to form a stable <span class="math inline">\(\mathrm{H}\)</span> atom?</li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(K=\dfrac{mc^2}{\sqrt{1-\dfrac{v^2}{c^2}}}-mc^2\Longrightarrow v^2=c^2(1-(\dfrac{mc^2}{K+mc^2})^2)\)</span></p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(v^{2}(K=1\mbox{ MeV})=8\times 10^{16}\mbox{ (m/s)}^2,v^{2}(K=4.5\mbox{ MeV})=8.91\times 10^{16}\mbox{ (m/s)}^2\)</span></p><p><span class="math inline">\((3)\)</span> The velocity of radiation decreases as electrons move.</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(E=K+m_ec^2+m_pc^2=945\mbox{ MeV},p=\dfrac{1}{c}\sqrt{(K+m_ec^2)^2-(m_ec^2)^2}=4.975\mbox{ MeV/c}\)</span></p><p>For the new atom <span class="math inline">\(E^2=(pc)^2+E_0^2\Longrightarrow E_0=\sqrt{E^2-(pc)^2}=944.987\mbox{ MeV}\)</span></p><p><span class="math inline">\((5)\)</span> <span class="math inline">\(\Delta E=4.4987\mbox{ MeV}\)</span></p><h2 id="mbox-points-13"><span class="math inline">\(7_{(16 \mbox{ points})}\)</span></h2><p>In this problem we use transformation relation to work out reflection of light by a moving mirror.</p><p>We know that energy-momentum is a 4-vector, i.e. <span class="math inline">\((E / c, \vec{p})\)</span> transform obeying Lorentz between inertial frames. Using the relation <span class="math inline">\(E=\hbar \omega, \vec{p}=\hbar \vec{k}, \omega\)</span> is the angular frequency and <span class="math inline">\(\vec{k}\)</span> wave vector of light wave, <span class="math inline">\(\hbar\)</span> is a universal constant; then the <span class="math inline">\(\underset{\rightarrow}{K} \equiv(\omega / c, \vec{k})\)</span> is also a 4-vector.</p><ol type="1"><li>(3 points, 1 for each)<ol type="a"><li>For light, what is the length of this <span class="math inline">\(\underset{\rightarrow}{K}\)</span>, i.e. <span class="math inline">\(|\underset{\rightarrow}{K}|^{2}\)</span> equals what?</li></ol></li></ol><ol start="2" type="a"><li>This means <span class="math inline">\(\dfrac{\omega}{|k|}\)</span> equals what? <span class="math inline">\(|k|=\sqrt{k_{x}^{2}+k_{y}^{2}+k_{z}^{2}}\)</span> is the length of wave vector. c) Is this <span class="math inline">\(\dfrac{\omega}{|k|}\)</span> value invariant between frames?</li></ol><p>Now take a look for light reflection by a moving mirror, the mirror ( <span class="math inline">\(S^{\prime}\)</span> ) is moving with <span class="math inline">\(v\)</span> relative to the ground S (the source of light is stationary on the ground), the ground view and mirror view are shown in the figure below:</p><p><img src="https://pic.imgdb.cn/item/62b04ca309475431290ab1f5.jpg" style="zoom:20%;" /></p><p>In the mirror frame ( <span class="math inline">\(S^{\prime}\)</span> view), it just sees a light with frequency <span class="math inline">\(\omega^{\prime}\)</span> coming in with angle <span class="math inline">\(\theta_{i}^{\prime}\)</span>, and it will reflect the incoming light. The reflection law in the mirror frame is just the familiar one: <span class="math inline">\(\omega_{r}^{\prime}=\omega_{i}^{\prime}, \theta_{r}^{\prime}=\theta_{i}^{\prime}\)</span>. But for the ground observer, the reflected light may have different frequency and out-going angle compared with incoming one:</p><ol start="2" type="1"><li>(7 points) For a given incoming light in <span class="math inline">\(S\)</span> frame, i.e. <span class="math inline">\(\omega_{i}, k_{i}\)</span> ( <span class="math inline">\(k_{i}\)</span> is the magnitud of incoming wave vector) and angle <span class="math inline">\(\theta_{i}\)</span> is known, please find out the <span class="math inline">\(\omega_{i}^{\prime}\)</span> and <span class="math inline">\(\cos \theta_{i}^{\prime}\)</span>, the frequency and incoming angle in the mirror (S') frame, express them in terms of <span class="math inline">\(c, \beta, \gamma, \omega_{i}, \theta_{i}\)</span></li><li>(6 points) Using the reflection law in mirror frame, find out the frequency and angle of reflected light in ground frame: <span class="math inline">\(\omega_{r}\)</span> and <span class="math inline">\(\cos \theta_{r}\)</span>, express them in terms of <span class="math inline">\(c, \beta, \gamma, \omega_{i}, \theta_{i}\)</span></li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(|\underset{\rightarrow}{K}|=0,\dfrac{\omega}{|k|}=c\)</span> <span class="math inline">\(,\dfrac{\omega }{|k|} \mbox{is invariant}\)</span></p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\underset{\rightarrow}{K}=(\dfrac{\omega}{c},k_x,k_y,k_z)\)</span> satisfies Lorentz transformation. <span class="math display">\[\begin{pmatrix}\dfrac{\omega^{\prime}}{c}\\k_{x}^{\prime}\\k_{y}^{\prime}\\k_{z}^{\prime}\end{pmatrix}=\begin{pmatrix}\gamma &amp; -\beta \gamma&amp;0&amp;0\\-\beta \gamma &amp;\gamma&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{pmatrix}\begin{pmatrix}\dfrac{\omega}{c}\\k_{x}\\k_{y}\\k_{z}\end{pmatrix}\]</span> <span class="math inline">\(\omega^{\prime}=\gamma(\omega-\beta c k_x)=\gamma(\omega-\beta c (-\dfrac{\omega }{c}\cdot \cos \theta_i))=\gamma\omega(1+\beta \cos \theta_i)\)</span></p><p><span class="math inline">\(k^{\prime}_x=\gamma(k_x-\beta \cdot \dfrac{\omega}{c})=\gamma(-\dfrac{\omega }{c}\cdot \cos \theta_i-\beta \cdot \dfrac{\omega }{c})=-\dfrac{\omega }{c}\gamma(\cos \theta_i+\beta )\)</span></p><p><span class="math inline">\(\cos \theta_{i}^{\prime}=\dfrac{k_x^{\prime}}{|k^{\prime}|}=\dfrac{k_x^{\prime}}{|\dfrac{\omega^{\prime}}{c}|}=\dfrac{\cos \theta_i+\beta}{1+\beta \cos \theta_i}\Longrightarrow \theta_i^{\prime}=\arccos(\dfrac{\cos \theta_i+\beta}{1+\beta \cos \theta_i})\)</span></p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\omega_{r}^{\prime}=\omega^{\prime}_{i}\)</span>, then transform to <span class="math inline">\(S\)</span> frame <span class="math display">\[\begin{pmatrix}\dfrac{\omega}{c}\\k_{x}\\k_{y}\\k_{z}\end{pmatrix}=\begin{pmatrix}\gamma &amp; \beta \gamma&amp;0&amp;0\\\beta \gamma &amp;\gamma&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{pmatrix}\begin{pmatrix}\dfrac{\omega^{\prime}}{c}\\k_{x}^{\prime}\\k_{y}^{\prime}\\k_{z}^{\prime}\end{pmatrix}\]</span> <span class="math inline">\(\omega_{r}=\gamma(\omega^{\prime}+\beta ck_x^{\prime})=\gamma(\gamma\omega(1+\beta \cos \theta _i)+\beta c(\dfrac{\omega}{c}\gamma(\beta +\cos \theta_i)))=\dfrac{1+\beta ^2+2\beta \cos \theta_i}{1-\beta ^2}\omega\)</span></p><p><span class="math inline">\(k_{rx}=\gamma(k_x^{\prime}+\beta \dfrac{\omega^{\prime}}{c})=\gamma(\gamma\dfrac{\omega}{c}(\cos \theta_i+\beta)+\beta \dfrac{\gamma\omega(1+\beta \cos \theta_i)}{c})=\dfrac{\beta ^2\cos \theta_i+2\beta +\cos \theta_i}{1-\beta ^2}\dfrac{\omega}{c}\)</span></p><p><span class="math inline">\(\theta_{r}=\arccos(\dfrac{k_{rx}}{\dfrac{\omega_r}{c}})=\arccos(\dfrac{\beta ^2\cos \theta_i+2\beta +\cos \theta_i}{1+2\beta \cos \theta_i+\beta ^2})\)</span></p>]]></content>
    
    
    <categories>
      
      <category>试卷</category>
      
      <category>基物</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基物Ⅰ试卷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calculus-A2-homework all</title>
    <link href="/2022/06/18/Math/%E5%BE%AE%E7%A7%AF%E5%88%86A2%E4%BD%9C%E4%B8%9A%E5%90%88%E9%9B%86%EF%BC%881-10%EF%BC%89/"/>
    <url>/2022/06/18/Math/%E5%BE%AE%E7%A7%AF%E5%88%86A2%E4%BD%9C%E4%B8%9A%E5%90%88%E9%9B%86%EF%BC%881-10%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(\mathbf{PDF}\)</span> 文件下载请点击这里 <a href="https://lr-tsinghua11.github.io/pdf/微积分A2作业合集（1-9）.pdf">微积分A(2)作业</a></p><h1 id="largetextcolorblue微积分第一次作业-smallwtimes-f-_textcolorblue2022.2.25"><span class="math inline">\(\large\textcolor{blue}{微积分第一次作业\ \small(W\times f)}\ \ \ \ \ \ _\textcolor{blue}{2022.2.25}\)</span></h1><h2 id="section">1</h2><p>设 <span class="math inline">\(\|\cdot\|\)</span> 是范数，证明 <span class="math inline">\(\mathbb{C}=\{\vec{x}\in\mathbb{R}^m\mid\|\vec{x}\|\leq 1\}\)</span> 是闭凸集。</p><p>（ <span class="math inline">\(\mathbb{C}\in\mathbb{R}^{m}\)</span> 是凸集<span class="math inline">\(\ \Longleftrightarrow \ \forall\  \vec{x},\vec{y}\in\mathbb{C},\ \forall \ t\in(0,1),\ (1-t)\vec{x}+t\vec{y}\in\mathbb{C}\)</span>）</p><hr /><p><strong>证明</strong>：先证明其为凸集，由范数的性质，满足三角不等式和正齐次性有 <span class="math display">\[\|\vec{x}\|,\|\vec{y}\|\leq 1\in\mathbb{C},\ \forall \ t\in(0,1),\ \|(1-t)\vec{x}+t\vec{y}\|\leq(1-t)\|\vec{x}\|+t\|\vec{y}\|\leq 1\]</span> 考虑 <span class="math inline">\(\mathbb{C}\)</span> 的补集 <span class="math inline">\(\mathbb{A}=\{\vec{x}\in\mathbb{R}^m\mid\|\vec{x}\|&gt; 1\}\)</span>，对于该集合中任意一点 <span class="math inline">\(\vec{a}\in\mathbb{A}\)</span>，令 <span class="math inline">\(\|\vec{a}\|=\lambda&gt;1\)</span> <span class="math display">\[\forall \ \vec{a}\in\mathbb{A},\ \exists \ \delta=\dfrac{\lambda-1}{2},\ s.t.\forall \ \|\vec{x}-\vec{a}\|&lt;\delta,\|\vec{x}\|\geq\|\vec{a}\|-\|\vec{a}-\vec{x}\|=\|\vec{a}\|-\|\vec{x}-\vec{a}\|&gt;1\]</span> 从而 <span class="math inline">\(\mathbb{A}\)</span> 满足任意一点总存在该点领域全在 <span class="math inline">\(\mathbb{A}\)</span> 中，<span class="math inline">\(\mathbb{A}\)</span> 为开集，<span class="math inline">\(\mathbb{C}\)</span> 为 <span class="math inline">\(\mathbb{A}\)</span> 的补集，则 <span class="math inline">\(\mathbb{C}\)</span> 为闭集</p><p>再结合其为凸集，得 <span class="math inline">\(\mathbb{C}\)</span> 为闭凸集 <span class="math inline">\(□\)</span></p><h2 id="section-1">2</h2><p>设 <span class="math inline">\(\|\cdot\|\)</span> 满足正定、正齐次性，证明：<span class="math inline">\(\|\cdot\|\)</span> 是范数 <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(\mathbb{C}=\{\vec{x}\in\mathbb{R}^m\mid\|\vec{x}\|\leq 1\}\)</span> 是凸集。</p><hr /><p><strong>证明</strong>：由第一题结论可得，<span class="math inline">\(\|\cdot\|\)</span> 是范数 <span class="math inline">\(\Longrightarrow\)</span> <span class="math inline">\(\mathbb{C}=\{\vec{x}\in\mathbb{R}^m\mid\|\vec{x}\|\leq 1\}\)</span> 是凸集。</p><p>又若 <span class="math inline">\(\mathbb{C}=\{\vec{x}\in\mathbb{R}^m\mid\|\vec{x}\|\leq 1\}\)</span> 是凸集，即 <span class="math inline">\(\forall\  \vec{x},\vec{y}\in\mathbb{C},\ \forall \ t\in(0,1),\ (1-t)\vec{x}+t\vec{y}\in\mathbb{C}\)</span>。若</p><p><span class="math inline">\(\|\vec{x}\|\)</span> 或 <span class="math inline">\(\|\vec{y}\|\)</span> 中有一者为 <span class="math inline">\(0\)</span>，由 <span class="math inline">\(\|\cdot\|\)</span> 的正定性，可得 <span class="math inline">\(\vec{x}\)</span> 或 <span class="math inline">\(\vec{y}\)</span> 中一者为 <span class="math inline">\(\boldsymbol 0\in \mathbb{R}^m\)</span>，此时三角不等式</p><p><span class="math inline">\(\|\vec{x}\|+\|\vec{y}\|\geq\|\vec{x}+\vec{y}\|\)</span> 成立。则对两者范数均大于 <span class="math inline">\(0\)</span> 的情况， <span class="math inline">\(\forall\ \vec{x},\vec{y}\)</span>，令<span class="math inline">\(\|\vec{x}\|=l_1&gt;0\)</span></p><p><span class="math inline">\(\|\vec{y}\|=l_2&gt;0\)</span>，单位化有 <span class="math inline">\(\vec{n}_1=\dfrac{\vec{x}}{l_1},\vec{n}_2=\dfrac{\vec{y}}{l_2}\)</span>，满足 <span class="math inline">\(\vec{n}_1,\vec{n}_2\in\mathbb{C}\)</span>， 由凸集性质 <span class="math display">\[\begin{gathered}\because \forall \ t\in(0,1),\|(1-t)\vec{n}_1+t\vec{n}_2\|\in\mathbb{C},\vec{n}_1=\dfrac{\vec{x}}{l_1},\vec{n}_2=\dfrac{\vec{y}}{l_2}\\\therefore \forall\ t\in (0,1),\|\dfrac{1-t}{l_1}\cdot \vec{x}+\dfrac{t}{l_2}\cdot \vec{y}\|\leq 1\ \therefore \mbox{set}\ \ \ t=\dfrac{l_2}{l_1+l_2},\|\dfrac{\vec{x}+\vec{y}}{l_1+l_2}\|\leq1\end{gathered}\]</span> 由正齐次性，<span class="math inline">\(\|\dfrac{\vec{x}+\vec{y}}{l_1+l_2}\|=\dfrac{1}{l_1+l_2}\|\vec{x}+\vec{y}\|\leq 1\)</span>，则有 <span class="math inline">\(\|\vec{x}+\vec{y}\|\leq l_1+l_2=\|\vec{x}\|+\|\vec{y}\|\)</span></p><p>则 <span class="math inline">\(\mathbb{C}=\{\vec{x}\in\mathbb{R}^m\mid\|\vec{x}\|\leq 1\}\)</span> 是凸集 <span class="math inline">\(\Longrightarrow \|\cdot\|\)</span> 为范数，两者等价 <span class="math inline">\(□\)</span></p><h2 id="section-2">3</h2><p>证明 <span class="math inline">\(\|\vec{x}\|_{\infty}=\underset{1\leq i\leq m}{\max}|x^{i}|\)</span> 是范数。</p><hr /><p><strong>证明</strong>：显然正定性满足；且 <span class="math inline">\(\|\lambda\vec{x}\|_{\infty}=\underset{1\leq i\leq m}{\max}|\lambda x^{i}|=|\lambda|\underset{1\leq i\leq m}{\max}|x^{i}|=|\lambda|\|\vec{x}\|_{\infty}\)</span> 满足正齐次性，</p><p>有 <span class="math inline">\(\vec{x}=(x^1,\cdots,x^m)^{T},\vec{y}=(y^1,\cdots,y^m)^{T}\)</span>，设两者最大值为 <span class="math inline">\(|x^{max}|,|y^{max}|\)</span> <span class="math display">\[\begin{gathered}\|\vec{x}+\vec{y}\|_{\infty}=(x^1+y^1,x^2+y^2,\cdots,x^m+y^m)\leq(|x^{1}|+|y^1|,\cdots,|x^{m}|+|y^m|)\\\leq(|x^{max}|+|y_1|,\cdots,|x^{max}|+|y^m|)=|x^{max}|+(|y^1|,\cdots,|y^m|)\leq|x^{max}|+|y^{max}|\\\end{gathered}\]</span> 即有 <span class="math inline">\(\forall \ \vec{x},\vec{y},\ \|\vec{x}+\vec{y}\|_{\infty}\leq\|\vec{x}\|_{\infty}+\|\vec{y}\|_{\infty}\)</span>，满足三角不等式，从而 <span class="math inline">\(\|\vec{x}\|_{\infty}\)</span> 是（无穷）范数 <span class="math inline">\(□\)</span></p><h2 id="section-3">4</h2><p>设 <span class="math inline">\(p&gt;1\)</span>，证明 <span class="math inline">\(\|\vec{x}\|_{p}=(\displaystyle \sum_{i=1}^m|x^i|^p)^{\frac{1}{p}}\)</span> 是范数。</p><hr /><p><strong>证明</strong>：显然 <span class="math inline">\((\displaystyle \sum_{i=1}^m|x^i|^p)^{\frac{1}{p}}\geq 0\)</span> 满足正定性，若乘以 <span class="math inline">\(\lambda\)</span> 倍，有 <span class="math display">\[\|\lambda\vec{x}\|_{p}=\|\vec{x}\|_{\infty}=(\displaystyle \sum_{i=1}^m|\lambda x^i|^p)^{\frac{1}{p}}=\|\vec{x}\|_{\infty}=(\lambda^p \displaystyle \sum_{i=1}^m|x^i|^p)^{\frac{1}{p}}=\lambda \cdot(\displaystyle \sum_{i=1}^m|x^i|^p)^{\frac{1}{p}}=\lambda\|\vec{x}\|_{\infty}\]</span> 从而 <span class="math inline">\(\|\vec{x}\|_p\)</span> 满足正齐次性，对三角不等式，先证明两个不等式</p><blockquote><p>引理一：<strong><span class="math inline">\(\mbox{Young}\)</span> 不等式</strong>：设 <span class="math inline">\(a,b&gt;0,q,p&gt;1,\dfrac{1}{p}+\dfrac{1}{q}=1\)</span>，有以下不等式成立 <span class="math display">\[ab\leq \dfrac{a^p}{p}+\dfrac{b^q}{q}\]</span> 构造函数 <span class="math inline">\(f(x)=\dfrac{1}{p}x^{p}+\dfrac{1}{q}-x\ (x&gt;0)\)</span>，求导有 <span class="math inline">\(f&#39;(x)=x^{p-1}-1\)</span>，当 <span class="math inline">\(x\in(0,1)\)</span> 时，</p><p><span class="math inline">\(f&#39;(x)&lt;0\)</span>，<span class="math inline">\(f(x)\)</span> 单调递减；当 <span class="math inline">\(x\in (1,+\infty)\)</span> 时，<span class="math inline">\(f&#39;(x)&gt;0\)</span>，<span class="math inline">\(f(x)\)</span> 单调递增。从而</p><p><span class="math inline">\(f(x)\geq f(1)=\dfrac{1}{p}+\dfrac{1}{q}-1=0\)</span>。令 <span class="math inline">\(x=\dfrac{a}{b^{\frac{q}{p}}}\)</span> 有 <span class="math inline">\(\dfrac{1}{p}\dfrac{a^p}{b^{q}}+\dfrac{1}{q}\geq\dfrac{a}{b^{\frac{q}{p}}}\)</span>，两边乘以 <span class="math inline">\(b^q\)</span>，代入</p><p><span class="math inline">\(\dfrac{1}{p}=1-\dfrac{1}{q}\)</span>，则有 <span class="math inline">\(\dfrac{a^p}{p}+\dfrac{b^q}{q}\geq a\cdot b^{q-\frac{q}{p}}=ab\)</span></p><p>引理二：<strong><span class="math inline">\(\mbox{Hölder}\)</span> 不等式</strong>：设 <span class="math inline">\(a_k,b_k&gt;0,p,q\geq1,k=1,2,\cdots,n,\dfrac{1}{p}+\dfrac{1}{q}=1\)</span>，有以下不等式成立 <span class="math display">\[\displaystyle \sum_{k=1}^na_kb_k\leq(\sum_{k=1}^na_k^p)^{\frac{1}{p}}\cdot(\sum_{k=1}^nb_k^q)^{\frac{1}{q}}\]</span> 考虑两者相除运用 <span class="math inline">\(\mbox{Young}\)</span> 不等式即可得证 <span class="math display">\[\begin{gathered}\dfrac{\displaystyle \sum_{i=1}^na_kb_k}{\displaystyle (\sum_{k=1}^na_k^p)^{\frac{1}{p}}\cdot(\sum_{k=1}^nb_k^q)^{\frac{1}{q}}}=\displaystyle\large \sum_{k=1}^n((\normalsize\dfrac{a_k^p}{\normalsize \displaystyle \sum_{k=1}^na_k^p})^{\frac{1}{p}}\cdot(\normalsize \dfrac{b_k^q}{\normalsize \displaystyle \sum_{k=1}^nb_k^q})^{\frac{1}{q}})\normalsize \\\leq\dfrac{1}{p}\sum_{i=1}^n\dfrac{a_k^p}{\normalsize \displaystyle \sum_{k=1}^na_k^p}+\dfrac{1}{q}\sum_{i=1}^n\dfrac{b_k^q}{\normalsize \displaystyle \sum_{k=1}^nb_k^q}=\dfrac{1}{p}+\dfrac{1}{q}=1\end{gathered}\]</span></p></blockquote><p>拆开和的 <span class="math inline">\(p-\)</span>范数有 <span class="math inline">\(\displaystyle \sum_{i=1}^{n}\left(x^{i}+y^{i}\right)^{p}=\sum_{i=1}^{n} x^{i}\left(x^{i}+y^{i}\right)^{p-1}+\sum_{i=1}^{n} y^{i}\left(x^{i}+y^{i}\right)^{p-1}\)</span></p><p>令 <span class="math inline">\(\dfrac{1}{p}+\dfrac{1}{q}=1\)</span>，利用 <span class="math inline">\(\mbox{Hölder}\)</span> 不等式放缩两者有 <span class="math display">\[\begin{gathered}\sum_{i=1}^{n} x^{i}(x^{i}+y^{i})^{p-1} \leq(\sum_{i=1}^{n} (x^{i})^{p})^{\frac{1}{p}}(\sum_{i=1}^{n}(x^{i}+y^{i})^{(p-1) q})^{\frac{1}{q}}=(\sum_{i=1}^{n} (x^{i})^{p})^{\frac{1}{p}}\cdot (\sum_{i=1}^{n}(x^{i}+y^{i})^{p})^{\frac{1}{q}}\\\sum_{i=1}^{n} y^{i}(x^{i}+y^{i})^{p-1} \leq(\sum_{i=1}^{n} (y^{i})^{p})^{\frac{1}{p}}(\sum_{i=1}^{n}(x^{i}+y^{i})^{(p-1) q})^{\frac{1}{q}}=(\sum_{i=1}^{n} (y^{i})^{p})^{\frac{1}{p}}\cdot (\sum_{i=1}^{n}(x^{i}+y^{i})^{p})^{\frac{1}{q}}\end{gathered}\]</span> 从而求和得到 <span class="math inline">\(\displaystyle \sum_{i=1}^n(x^i+y^i)^p\leq \Large(\normalsize (\displaystyle \sum_{i=1}^n(x^i)^p)^{\frac{1}{p}}+(\sum_{i=1}^n(y^i)^p)^{\frac{1}{p}}\Large)\normalsize \cdot (\sum_{i=1}^{n}(x^{i}+y^{i})^{p})^{\frac{1}{q}}\)</span>，移项即得 <span class="math display">\[(\displaystyle \sum_{i=1}^n(x^i)^p)^{\frac{1}{p}}+(\sum_{i=1}^n(y^i)^p)^{\frac{1}{p}}\geq (\sum_{i=1}^n(x^i+y^i)^p)^{1-\frac{1}{q}}=(\sum_{i=1}^n(x^i+y^i)^p)^{\frac{1}{p}}\]</span> <span class="math inline">\(\|\vec{x}\|_{p}=(\displaystyle \sum_{i=1}^m|x^i|^p)^{\frac{1}{p}}\)</span> 满足正定、正齐次、三角不等式，从而为范数 <span class="math inline">\(□\)</span></p><h2 id="section-4">5</h2><p>设 <span class="math inline">\(m&gt;1\)</span>，证明 <span class="math inline">\(\mathbb{A}=\{\vec{x}\in\mathbb{R}^m\mid \|x\|=1\}\)</span> 是道路连通集。</p><hr /><p><strong>证明</strong>：<span class="math inline">\(\forall \ \vec{x},\vec{y}\in E\)</span>，令 <span class="math inline">\(f(t)=\dfrac{(1-t)\vec{x}+t\vec{y}}{\|(1-t)\vec{x}+t\vec{y}\|}\)</span>，对 <span class="math inline">\(\vec{x}=\vec{y}\)</span> 时，显然 若 <span class="math inline">\(。\vec{x}\neq\vec{y}\)</span>，<span class="math inline">\(f(0)=\vec{x}\)</span>，</p><p><span class="math inline">\(f(1)=\vec{y}\)</span>，先证明该函数映射连续性。有线性函数 <span class="math inline">\(g_1:[0,1]\longrightarrow \mathbb{R}^m,t \longmapsto (1-t)\vec{x}+t\vec{y}\)</span> 连</p><p>续，考虑函数 <span class="math inline">\(g_2:[0,1]\longrightarrow [0,1]t\longmapsto\|(1-t)\vec{x}+t\vec{y}\|\)</span>，由范数的正齐次性和三角不等式得 <span class="math display">\[\forall \ t_1,t_2\in[0,1],|g_2(t_1)-g_2(t_2)|=|\|\vec{x}+t_1(\vec{y}-\vec{x})\|-\|\vec{x}+t_2(\vec{y}-\vec{x})\||\leq|t_1-t_2|\|\vec{y}-\vec{x}\|\]</span> 而 <span class="math inline">\(\|\vec{y}-\vec{x}\|\leq \|\vec{y}\|+\|-\vec{x}\|=2\)</span> 为有限量，则有 <span class="math display">\[\forall \ \epsilon&gt;0,\exists\ \delta&lt;\dfrac{\epsilon}{2},s.t.\forall \ t_1,t_2\in[0,1],|t_1-t_2|&lt;\delta,|g(t_1)-g(t_2)|\leq|t_1-t_2|\|\vec{y}-\vec{x}\|&lt;\epsilon\]</span> 从而 <span class="math inline">\(g_2\)</span> 为连续函数，同时由范数的正定性，<span class="math inline">\(\|(1-t)\vec{x}+t\vec{y}\|\geq0\)</span>，若 <span class="math inline">\(\|(1-t)\vec{x}+t\vec{y}\|=0\)</span></p><p>由正定性 <span class="math inline">\((1-t)\vec{x}+t\vec{y}=0\)</span> 得 <span class="math inline">\(\vec{x}=-\vec{y}\)</span> ，只要 <span class="math inline">\(\vec{x}\neq -\vec{y}\Longrightarrow \|(1-t)\vec{x}+t\vec{y}\|\neq 0\)</span></p><p>令 <span class="math inline">\(g_3:x\in(0,1]\longmapsto \dfrac{1}{x}\in[1,+\infty)\)</span> 为连续函数，复合函数 <span class="math inline">\(f(t)=(g_3\circ g_2)\cdot g_1\)</span> 也连续</p><p>而 <span class="math inline">\(\|f(t)\|=\dfrac{\|(1-t)\vec{x}+t\vec{y}\|}{\|(1-t)\vec{x}+t\vec{y}\|}=1\)</span>，则对 <span class="math inline">\(t\in[0,1]\)</span>，都有 <span class="math inline">\(f(t)\in \mathbb{A}\)</span>，满足道路连通集条件</p><p>而针对特殊情况（两向量恰好反向）， <span class="math inline">\(\vec{x}=-\vec{y}\)</span>，可选取 <span class="math inline">\(\vec{z}\neq \vec{x},\vec{z}\neq\vec{y}\)</span>，令 <span class="math inline">\(\vec{x}\)</span> 到 <span class="math inline">\(\vec{z}\)</span> 的连续映射为</p><p><span class="math inline">\(f_1(t)\)</span>，<span class="math inline">\(\vec{z}\)</span> 到 <span class="math inline">\(\vec{y}\)</span> 的连续映射为 <span class="math inline">\(f_2(t)\)</span>，可以构造连续映射 <span class="math display">\[f(t)=\begin{cases}f_1(2t),t\in[0,\dfrac{1}{2})\\f_2(2t-1),t\in[\dfrac{1}{2},1]\end{cases}\]</span> 也满足道路连续性的条件，从而 <span class="math display">\[\forall \ \vec{x},\vec{y}\in \mathbb{A},\ \exists\ 连续\ f(t),f(0)=\vec{x},f(1)=\vec{y},s.t.\forall\ t\in[0,1],f(t)\in\mathbb{A}\]</span> 即 <span class="math inline">\(\mathbb{A}\)</span> 为道路连通集 <span class="math inline">\(□\)</span></p><h2 id="section-5">6</h2><p>设 <span class="math inline">\(m&gt;1\)</span>，证明 <span class="math inline">\(\mathbb{D}=\{A\mid A\ 是\ m\ 阶方阵,\det A&gt;0\}\)</span> 是道路连通集。</p><hr /><p><strong>证明</strong>：首先证明单位阵 <span class="math inline">\(I\)</span> 到 <span class="math inline">\(\mathbb{D}\)</span> 中任意元素 <span class="math inline">\(A\in\mathbb{D},\det A&gt;0\)</span> 是连通的，对单位阵 <span class="math inline">\(I\)</span>，总存在一系列初等变换有 <span class="math display">\[E_1E_2\cdots E_nIE_1&#39;E_2&#39;\cdots E_n&#39;=A\]</span> 若 <span class="math inline">\(E_i\)</span> 是倍乘变换，倍乘系数为 <span class="math inline">\(k\neq0\)</span>，则对 <span class="math inline">\(\forall\ B\in \mathbb{D}\)</span>，作连续映射 <span class="math display">\[f_i(t):\mathcal{GL}^{+}(m) \longrightarrow  \mathcal{GL}^{+}(m)\quad B\longmapsto(1+(k-1)t)E_iB\]</span> 若 <span class="math inline">\(E_i\)</span> 是倍加变换，倍加系数为 <span class="math inline">\(m&gt;0\)</span>，则对 <span class="math inline">\(\forall \ C\in\mathbb{D}\)</span>，作连续映射 <span class="math display">\[g_i(t):\mathcal{GL}^{+}(m) \longrightarrow  \mathcal{GL}^{+}(m)\quad C\longmapsto(1+(k-1)t)E_iC\]</span> 若 <span class="math inline">\(E_i\)</span> 是换行 <span class="math inline">\(/\)</span> 换列变换并对其中一行 $/ $ 列乘以 <span class="math inline">\(-1\)</span> （保证行列式 <span class="math inline">\(&gt;0\)</span>），对改变的两行 <span class="math inline">\(/\)</span> 两列有连续复合映射 <span class="math display">\[(A,B)\stackrel{E_1}{\longrightarrow} (A+B,B)\stackrel{E_2}{\longrightarrow}(A+B,-A)\stackrel{E_3}{\longrightarrow}(B,-A)\stackrel{E_4(-1)}{\longrightarrow}(B,A)\]</span> 综上，对所有初等矩阵 <span class="math inline">\(E_i\)</span>，均存在连续映射 <span class="math inline">\(f_{E_{i}}(t)\)</span> 从 <span class="math inline">\(I\)</span> 到 <span class="math inline">\(E_i\)</span>，使得 <span class="math inline">\(I\)</span> 到 <span class="math inline">\(A\in\mathbb{D}\)</span> 是连通的</p><p>对 <span class="math inline">\(\forall \ A_1,A_2\in \mathbb{D}\)</span>，对 <span class="math inline">\(A_2\)</span> 实行上述步骤得到连续映射 <span class="math inline">\(I\longmapsto A_2,F(t):\displaystyle \prod_{i=1}^n f_{E_i}\)</span>，则 <span class="math inline">\(A_1^{-1}\circ F\)</span> 满足<span class="math inline">\(A_1\longmapsto A_2\)</span> 连续映射，且由于 <span class="math inline">\(f_{i}(t)\)</span> 和 <span class="math inline">\(g_{i}(t)\)</span> 都映射到 <span class="math inline">\(\mathbb{D}\)</span> 中，<span class="math inline">\(\forall \ t\in[0,1],A_1^{-1}\circ F(t)\in\mathbb{D}\)</span></p><p>，即 <span class="math inline">\(\mathbb{D}\)</span> 道路连通 <span class="math inline">\(□\)</span></p><h2 id="section-6">7</h2><p>设 <span class="math inline">\(f:\mathbb{R}^m\diagdown\{0\}\longmapsto \mathbb{R}\)</span>，且 <span class="math inline">\(f\)</span> 连续，满足 <span class="math inline">\(\forall \ t&gt;0,\vec{x}\neq0 ,f(t\vec{x})=f(\vec{x})\)</span>，证明 <span class="math inline">\(f\)</span> 有最大值和最小值。</p><hr /><p><strong>证明</strong>：令单位“实心球”集合 <span class="math inline">\(\mathbb{S}=\{\vec{y}\mid \|\vec{y}\|\leq 1\}\)</span> 为有界闭集，对 <span class="math inline">\(\forall\ \vec{y}\in\mathbb{R}^m\diagdown\{0\}\)</span>，若 <span class="math inline">\(\|\vec{y}\|\leq1\)</span>，</p><p>则 <span class="math inline">\(\vec{y}\in\mathbb{S}\)</span>，否则 <span class="math inline">\(\|\vec{y}\|&gt;1\)</span>，令 <span class="math inline">\(\vec{z}=\dfrac{\vec{y}}{\|\vec{y}\|}\)</span>，其范数 <span class="math inline">\(\|\vec{z}\|=1 ,\vec{z}\in\mathbb{S}\)</span>，<span class="math inline">\(f(\vec{y})=f(\|\vec{y}\|\cdot\vec{z})=f(\vec{z})\)</span></p><p>定义映射 <span class="math inline">\(g:\mathbb{S}\longmapsto\mathbb{R},g(\vec{x})=f(\vec{x})\)</span>，由知 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 的值域相同，且 <span class="math inline">\(g\)</span> 为有界闭集上的连续映射</p><p>从而 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 都有最大值和最小值 <span class="math inline">\(□\)</span></p><h2 id="section-7">8</h2><p>设 <span class="math inline">\(f(x,y,z)=\dfrac{x+2y+3z}{x^2+y^2+z^2+1}\)</span>，证明 <span class="math inline">\(f\)</span> 有正的最大值和负的最小值。</p><hr /><p>证明：令三维欧式空间向量 <span class="math inline">\(\vec{r}=(x,y,z)\)</span>，有 <span class="math display">\[f(x,y,z)=f(\vec{r})=\dfrac{\vec{r}\cdot(1,2,3)}{\|\vec{r}\|^2+1}=\dfrac{\|\vec{r}\|\cdot\sqrt{14}\cos \theta}{\|\vec{r}\|^2+1}\]</span> 由均值不等式 <span class="math inline">\(\dfrac{\|\vec{r}\|}{\|\vec{r}\|^2+1}\leq\dfrac{1}{2}\)</span>，以及 <span class="math inline">\(\cos \theta\in[-1,1]\)</span>，得 <span class="math inline">\(f(\vec{r})\in[-\dfrac{\sqrt{14}}{2},\dfrac{\sqrt{14}}{2}]\)</span> 有界</p><p>而 <span class="math inline">\(f(x,y,z)\)</span> 为连续函数，从而有最值，且当 <span class="math inline">\(x,y,z&gt;0\)</span> 时 <span class="math inline">\(f(x,y,z)&gt;0\)</span>；当 <span class="math inline">\(x,y,z&lt;0\)</span> 时</p><p><span class="math inline">\(f(x,y,z)&lt;0\)</span>，则 <span class="math inline">\(f\)</span> 有正的最大值和负的最小值 <span class="math inline">\(□\)</span></p><h1 id="largetextcolorblue微积分第二次作业-smallwtimes-f-_textcolorblue2022.3.4"><span class="math inline">\(\large\textcolor{blue}{微积分第二次作业\ \small(W\times f)}\ \ \ \ \ \ _\textcolor{blue}{2022.3.4}\)</span></h1><h2 id="section-8">1</h2><p>1、（连续性与偏连续性）设 <span class="math inline">\(f:[a,b]\times [c,d]\rightarrow \mathbb{R}\)</span>。</p><ol type="a"><li>如果 <span class="math inline">\(f\)</span> 是连续函数, 那么是否成立: 对任意 <span class="math inline">\(y \in[c, d], f(\cdot, y)\)</span> : <span class="math inline">\([a, b] \rightarrow \mathbb{R}\)</span> 连续; 对任意 <span class="math inline">\(x \in[a, b]\)</span></li></ol><p><span class="math inline">\(f(x, \cdot):[c, d] \rightarrow \mathbb{R}\)</span> 连续?</p><ol start="2" type="a"><li>如果对任意 <span class="math inline">\(y \in[c, d], \quad f(\cdot, y):[a, b] \rightarrow \mathbb{R}\)</span> 连续; 对任意 <span class="math inline">\(x \in[a, b]\)</span>, <span class="math inline">\(f(x, \cdot):[c, d] \rightarrow \mathbb{R}\)</span> 连续, 那么 <span class="math inline">\(f\)</span> 是否为连续函数? 考虑 <span class="math display">\[f(x, y)= \begin{cases}\dfrac{x y}{x^{2}+y^{2}}, &amp; x y \neq 0 \\ 0, &amp; x y=0\end{cases}\]</span></li><li>设 <span class="math inline">\(x_{0} \in[a, b], y_{0} \in[c, d], f\)</span> 满足: <span class="math inline">\(f\left(\cdot, y_{0}\right):[a, b] \rightarrow \mathbb{R}\)</span> 连续; 并且对 任意 <span class="math inline">\(\varepsilon&gt;0\)</span>, 存在</li></ol><p><span class="math inline">\(\delta(\varepsilon)&gt;0\)</span> 使得对任意 <span class="math inline">\(x \in[a, b]\)</span> 以及任意 <span class="math inline">\(y \in[c, d]\)</span>, 只要 <span class="math inline">\(\left|y-y_{0}\right|&lt;\delta(\varepsilon)\)</span>, 就有</p><p><span class="math inline">\(\left|f(x, y)-f\left(x, y_{0}\right)\right|&lt;\varepsilon\)</span> 。证明 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\left(x_{0}, y_{0}\right)\)</span> 连续。</p><ol start="4" type="a"><li>设 <span class="math inline">\(f(x, y)\)</span> 分别对每个变量 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 是连续的，且对 <span class="math inline">\(y\)</span> 是单调不减的, 证明 <span class="math inline">\(f\)</span> 关于 <span class="math inline">\((x, y)\)</span> 是连续</li></ol><p>的。</p><hr /><p>解：<span class="math inline">\((a)\)</span> <strong>是</strong>。由连续函数定义，对 <span class="math inline">\(\mathbf{x}^*=(x^1,x^2)\)</span> <span class="math display">\[\forall \ \mathbf{x}^*\in [a,b]\times [c,d],\forall \ \epsilon&gt;0,\exists\ \delta&gt;0,s.t.\forall\ \|x-x^*\|\leq\delta,\|f(\mathbf{x})-f(\mathbf{x^*})\|&lt;\epsilon\]</span> 则固定 <span class="math inline">\(x^1\)</span> 时，仅取 <span class="math inline">\(\|x-x^*\|\leq \delta\)</span> 中 <span class="math inline">\(x\)</span> 第一分量为 <span class="math inline">\(x^1\)</span> 的点集，由上述定义知 <span class="math display">\[\begin{gathered}\forall \ 固定\ x^1\in [a,b],\forall \ x^2\in [c,d],\mathbf{x}^*=(x^1,x^2),s.t.\forall \ \epsilon&gt;0,\exists\ \delta&gt;0,\\\forall\ \|x-x^*\|\leq\delta,\|f(\mathbf{x})-f(\mathbf{x^*})\|&lt;\epsilon\end{gathered}\]</span> 从而固定 <span class="math inline">\(x^1\)</span> 时，<span class="math inline">\(f(x^1,x^2)\)</span> 随 <span class="math inline">\(x^2\)</span> 连续；由对称性可得，固定 <span class="math inline">\(x^2\)</span> 时，<span class="math inline">\(f(x^1,x^2)\)</span> 随 <span class="math inline">\(x^1\)</span> 连续</p><p><span class="math inline">\((b)\)</span> <strong>否</strong>。考虑函数 <span class="math inline">\(f(x,y)=\begin{cases}\dfrac{xy}{x^2+y^2},&amp; xy\neq 0\\0&amp; xy=0\end{cases}\quad x,y\in[-1,1]\)</span>，由对称性，固定 <span class="math inline">\(x\)</span> 有</p><p>若 <span class="math inline">\(x=0\)</span>，则 <span class="math inline">\(f(x,y)=0\)</span> 在 <span class="math inline">\(y\in[-1,1]\)</span> 区间上均满足 <span class="math inline">\(f(0,y)\)</span> 随 <span class="math inline">\(y\)</span> 连续；</p><p>若 <span class="math inline">\(x\neq 0\)</span>，则函数 <span class="math inline">\(g_1(y)=x^2+y^2\neq 0\)</span>，<span class="math inline">\(g_2(z)=\dfrac{1}{z}(z\neq 0)\)</span>， <span class="math inline">\(g_3(y)=xy\)</span> 三者均连续</p><p>则 <span class="math inline">\(f(x,y)=(g_2\circ g_1)\cdot g_3\)</span> 复合函数连续，即 <span class="math inline">\(\forall\ x\in [-1,1],f(x,\cdot):[c,d]\rightarrow \mathbb{R}\)</span> 连续</p><p>同理 <span class="math inline">\(\forall\ y\in [-1,1],f(\cdot,y):[c,d]\rightarrow \mathbb{R}\)</span> 连续，而考虑 <span class="math inline">\(f(x,y)\)</span> 在原点处的连续性 <span class="math display">\[\lim\limits_{(x,y)\to (0,0)}\dfrac{xy}{x^2+y^2}\Large |\normalsize _{(x,y)\to (x,kx)}=\dfrac{k}{1+k^2}\in[-\dfrac{1}{2},\dfrac{1}{2}]\]</span> <span class="math inline">\(k\)</span> 值变化时，<span class="math inline">\(f(x,y)=\dfrac{xy}{x^2+y^2}\)</span> 在 <span class="math inline">\((0,0)\)</span> 处的极限不存在，从而 <span class="math inline">\(f\)</span> 不一定为连续函数</p><p><span class="math inline">\((c)\)</span> <strong>证明</strong>：由 <span class="math inline">\(f\)</span> 满足 <span class="math inline">\(f(\cdot ,y_0):[a,b]\to \mathbb{R}\)</span> 连续，翻译成 $-$ 语言有 <span class="math display">\[\forall \ y_0\in[c,d],\forall \ \epsilon &gt;0 ,\exists\ \delta_1 &gt;0,|x-x_0|&lt;\delta_1(\epsilon ),|f(x_0,y_0)-f(x,y_0)|&lt;\epsilon\]</span> 由 $$ 的任意性，则 <span class="math inline">\(\forall \ \epsilon &#39;&gt;0\)</span>，上述取 <span class="math inline">\(\epsilon=\dfrac{1}{2}\epsilon&#39;\)</span>，另一条件为 <span class="math display">\[\forall\ \epsilon &gt;0,\exists \ \delta_2&gt;0,\forall \ x\in[a,b],y\in[c,d],|y-y_0|&lt;\delta_2(\epsilon),|f(x,y)-f(x,y_0)|&lt;\epsilon\]</span> 由后者条件中 <span class="math inline">\(x\)</span> 的任意性，取 $=' $，则考虑欧几里得空间中的 <span class="math inline">\(2-\)</span>范数有 <span class="math display">\[\forall \ \epsilon&#39; &gt;0,\exists \ \delta =\min(\delta_1,\delta_2)&gt;0,\forall \ x\in[a,b],y\in[c,d]\\\|x-x^*\|=\sqrt{(x-x_0)^2+(y-y_0)^2}&lt;\delta\Longrightarrow |x-x_0|&lt;\delta_1 ,|y-y_0|&lt;\delta_2  \\|f(x,y)-f(x_0,y_0)|\leq |f(x,y)-f(x,y_0)|+|f(x_0,y_0)-f(x,y_0)|&lt;\dfrac{1}{2}\epsilon&#39;+\dfrac{1}{2}\epsilon &#39;=\epsilon&#39;\]</span> 则 <span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 处连续</p><p><span class="math inline">\((d)\)</span> <strong>证明</strong>：由于 <span class="math inline">\(f(x,y)\)</span> 对 <span class="math inline">\(y\)</span> 单调不减，则有对 <span class="math inline">\(\forall \ x\in[a,b]\)</span>， 不妨只考虑 <span class="math inline">\(y&gt;y_0\)</span> 的部分</p><p><span class="math inline">\(\delta(y_0)&gt;0,0&lt;f(x,y_0+\delta(y_0))-f(x,y_0)&lt;\epsilon\)</span>，取 <span class="math inline">\(y=y_0+\delta(y_0)\)</span>，考虑 <span class="math display">\[|f(x,y)-f(x_0,y_0)|=|f(x,y_0+\delta(y_0))-f(x_0,y_0)|\\\leq |f(x,y_0+\delta(y_0))-f(x,y_0)|+|f(x,y_0)-f(x_0,y_0)|&lt;\epsilon+\epsilon=2\epsilon\]</span> 其中后者由于 <span class="math inline">\(f(x,y)\)</span> 对 <span class="math inline">\(x\)</span> 连续可以保证，从而 <span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 处连续</p><h2 id="section-9">2</h2><p>设 <span class="math inline">\(U \subseteq \mathbb{R}^{2}\)</span> 是开集, <span class="math inline">\((a, b) \in U, f\)</span> 在 <span class="math inline">\(U \backslash\{(a, b)\}\)</span> 上有定义, 且满足极限 <span class="math display">\[A=\lim _{(x, y) \rightarrow(a, b)} f(x, y), \quad B=\lim _{y \rightarrow b} \lim _{x \rightarrow a} f(x, y)\]</span> 都存在。证明 <span class="math inline">\(A=B\)</span> 。由此知道, 如果 <span class="math display">\[\lim _{y \rightarrow b} \lim _{x \rightarrow a} f(x, y) \neq \lim _{x \rightarrow a} \lim _{y \rightarrow b} f(x, y)\]</span> 则极限 <span class="math inline">\(\lim\limits _{(x, y) \rightarrow(a, b)} f(x, y)\)</span> 不存在。</p><hr /><p><strong>证明</strong>：由于对 <span class="math inline">\(\forall \ 0&lt;|y-b|&lt;\delta_0\)</span>，<span class="math inline">\(\varphi(y)=\lim\limits_{x\to a}f(x,y)\)</span> 存在，即 <span class="math display">\[\forall \ \epsilon&gt;0,y\in U,\exists\ \delta_{1}(y),s.t. |x-a|&lt;\delta_{1}(y),|f(x,y)-\varphi(y)|&lt;\epsilon\]</span> 而又有 <span class="math inline">\(\lim\limits_{y\to b}\varphi(y)=B\)</span> 存在，即 <span class="math inline">\(\forall \ \epsilon&gt;0,\exists\ \delta_2 &gt;0,|y-b|&lt;\delta_2,|\varphi(y)-B|&lt;\epsilon\)</span></p><p>而 <span class="math inline">\(\lim\limits_{(x,y)\to (a,b)}f(x,y)=A\)</span>，即有 <span class="math display">\[\forall\ \epsilon &gt;0,\exists \ \delta_0&gt;0,\forall \ x,y\in U,\|\boldsymbol v^*-\boldsymbol v\|&lt;\delta_0(\epsilon),|f(x,y)-A|&lt;\epsilon\]</span> 则取 <span class="math inline">\(|y-b|&lt;\min(\delta_0,\delta_2),|x-b|&lt;\min(\delta_1(y),\delta_0)\)</span>，总有 <span class="math inline">\(|f(x,y)-B|&lt;\epsilon+\epsilon=2\epsilon\)</span></p><p>从而 <span class="math inline">\(|A-B|&lt;\epsilon+2\epsilon=3\epsilon\)</span>，则 <span class="math inline">\(A=B\)</span>，且若 <span class="math inline">\(\displaystyle \lim _{y \rightarrow b} \lim _{x \rightarrow a} f(x, y) \neq \lim _{x \rightarrow a} \lim _{y \rightarrow b} f(x, y)\)</span> 两者极限存在</p><p>反证法，若极限 <span class="math inline">\(\lim\limits _{(x, y) \rightarrow(a, b)} f(x, y)\)</span> 存在，则由上述证明以及对称性知，三者相等，与假设矛盾，从而</p><p>极限 <span class="math inline">\(\lim\limits _{(x, y) \rightarrow(a, b)} f(x, y)\)</span> 不存在</p><h2 id="section-10">3</h2><p>设</p><ol type="a"><li><p>极限 <span class="math inline">\(\displaystyle H(y)=\lim _{x \rightarrow a} f(x, y)\)</span> 对任意 <span class="math inline">\(y \neq b\)</span> 存在;</p></li><li><p>极限 <span class="math inline">\(\displaystyle G(x)=\lim _{y \rightarrow b} f(x, y)\)</span> 对任意 <span class="math inline">\(x\)</span> 存在，且存在 <span class="math inline">\(\delta_{0}&gt;0\)</span> 使得：对任意 <span class="math inline">\(\varepsilon&gt;0\)</span>，存在</p></li></ol><p><span class="math inline">\(\delta_{2}(\varepsilon)&gt;0\)</span> 对任意 <span class="math inline">\(0&lt;|y-b|&lt;\delta_{2}(\varepsilon)\)</span> 任意 <span class="math inline">\(0&lt;|x-a|&lt;\delta_{0}\)</span> 有 <span class="math inline">\(|f(x, y)-G(x)|&lt;\varepsilon\)</span>，则</p><p>极限 <span class="math inline">\(\displaystyle \lim _{x \rightarrow a} \lim _{y \rightarrow b} f(x, y), \lim _{y \rightarrow b} \lim _{x \rightarrow a} f(x, y)\)</span> 和 <span class="math inline">\(\displaystyle \lim _{x \rightarrow a, y \rightarrow b} f(x, y)\)</span> 都存在, 且</p><p><span class="math display">\[\lim _{x \rightarrow a, y \rightarrow b} f(x, y)=\lim _{y \rightarrow b} \lim _{x \rightarrow a} f(x, y)=\lim _{x \rightarrow a} \lim _{y \rightarrow b} f(x, y)\]</span></p><hr /><p>证明：（<strong>Cauchy准则</strong> ）<span class="math inline">\(\forall \ 0&lt;|y_1-b|&lt;\delta_2(\epsilon),0&lt;|y_2-b|&lt;\delta_2(\epsilon)\)</span>，对 <span class="math inline">\(|x-a|&lt;\delta_{0}\)</span>，都有 <span class="math display">\[|f(x,y_1)-G(x)|&lt;\dfrac{\epsilon}{2},|f(x,y_2)-G(x)|&lt;\dfrac{\epsilon}{2}\ \therefore |f(x,y_1)-f(x,y_2)|&lt;\dfrac{\epsilon}{2}\cdot 2=\epsilon\]</span> 则令 <span class="math inline">\(x\to a\)</span>，由于 <span class="math inline">\(H(y)=\lim\limits_{x\to a}f(x,y)\)</span> 存在，则有 <span class="math inline">\(|H(y_1)-H(y_2)|&lt;\epsilon\)</span>，即 <span class="math display">\[\forall \ \epsilon &gt;0,\exists \ \delta&gt;0,\forall \ y_i(i=1,2),0&lt;|y_i-b|&lt;\delta ,|H(y_1)-H(y_2)|&lt;\epsilon\]</span> 由柯西收敛准则得到 <span class="math inline">\(\lim\limits_{y\to b}\lim\limits_{x\to a}f(x,y)\)</span> 极限存在，由 <span class="math inline">\(0&lt;|y_0-b|&lt;\delta_2(\epsilon)\)</span> <span class="math display">\[|G(x_1)-G(x_2)|\leq|G(x_1)-f(x_1,y_0)|+|G(x_2)-f(x_2,y_0)|+|f(x_1,y_0)-f(x_2,y_0)|\]</span> 只需要 <span class="math inline">\(0&lt;|x-a|&lt;\delta_0(\dfrac{1}{3}\epsilon)\)</span>，就有 <span class="math inline">\(|G(x_1)-f(x_1,y_0)|&lt;\dfrac{1}{3}\epsilon,|G(x_2)-f(x_2,y_0)|&lt;\dfrac{1}{3}\epsilon\)</span></p><p>而由于 <span class="math inline">\(\displaystyle H(y)=\lim _{x \rightarrow a} f(x, y)\)</span> 对 <span class="math inline">\(y\neq b\)</span> 时均存在，则添加条件 <span class="math inline">\(0&lt;|x-a|&lt;\delta_1(\dfrac{1}{3}\epsilon)\)</span></p><p>就有 <span class="math inline">\(|f(x_1,y_0)-f(x_2,y_0)|&lt;\dfrac{1}{3}\epsilon\)</span>，则满足下列条件 <span class="math display">\[0&lt;|x-a|&lt;\min(\delta_{0}(\dfrac{1}{3}\epsilon),\delta_{1}(\dfrac{1}{3}\epsilon)),0&lt;|y-b|&lt;\delta_{1}(\epsilon),|G(x_1)-G(x_2)|&lt;\dfrac{1}{3}\epsilon\cdot 3=\epsilon\]</span> 由柯西收敛准则得 <span class="math inline">\(\lim\limits_{x\to a}\lim\limits_{y\to b}f(x,y)\)</span> 存在，由作业第<strong>2</strong>题知，三种极限存在且相等</p><h2 id="section-11">4</h2><p>设</p><p><span class="math display">\[f(x,y)=\begin{cases}x\sin (\dfrac{1}{y}),&amp; y\neq 0\\0,&amp;y=0\end{cases}\]</span></p><p>讨论极限 <span class="math inline">\(\lim\limits_{(x,y)\to (0,0)}f(x,y),\lim\limits_{y\to 0}\lim\limits_{x\to 0}f(x,y),\lim\limits_{x\to 0}\lim\limits_{y\to 0}f(x,y)\)</span></p><p>解：显然 <span class="math inline">\(\lim\limits_{x\to 0}f(x,y)=0\)</span>，则有 <span class="math inline">\(\lim\limits_{y\to 0}\lim\limits_{x\to 0}f(x,y)=0\)</span>，而对 <span class="math inline">\(y\to 0\)</span> 的性质有 <span class="math display">\[\forall \ |x|&gt;0,f(x,y)=\begin{cases}x\sin(\dfrac{1}{y}),&amp;y\neq 0\\0,&amp;y=0\end{cases}\]</span> 对 <span class="math inline">\(y_{n}=\dfrac{1}{2n\pi +\dfrac{\pi}{2}},y_{m}=\dfrac{1}{2m\pi -\dfrac{\pi}{2}}\)</span>，总有 <span class="math inline">\(f(x,y_n)-f(x,y_m)=x-(-x)=2x\)</span></p><p>由柯西收敛准则，<span class="math inline">\(\forall \ x\neq 0,\lim\limits_{y\to 0}x\sin(\dfrac{1}{y})\)</span> 不存在，从而 <span class="math inline">\(\lim\limits_{x\to 0}\lim\limits_{y\to 0}f(x,y)\)</span> 极限不存在</p><p>而对 <span class="math inline">\(\forall \ \epsilon &gt;0,\exists\ \delta=\epsilon,\sqrt{x^2+y^2}&lt;\delta,|f(x,y)-0|\leq |x||\sin(\dfrac{1}{y})|\leq |x|&lt;\delta=\epsilon\)</span></p><p>从而 <span class="math inline">\(\lim\limits_{(x,y)\to (0,0)}f(x,y)\)</span> 极限存在，且极限为 <span class="math inline">\(0\)</span></p><h2 id="section-12">5</h2><p>判断以下极限的存在性; 若存在, 求出极限值。</p><p><span class="math display">\[(1) \lim _{(x, y) \rightarrow(0,0)} \frac{\arcsin \left(x^{2}+y^{2}\right)}{x^{2}+y^{2}} &amp;(3) \lim _{(x, y) \rightarrow(0,0)}\left(x^{2}+y^{2}\right) \mathrm{e}^{x-y}&amp;(5) \lim _{(x, y) \rightarrow(0,0)} \frac{x+y}{|x|+|y|}\\(7) \lim _{(x, y) \rightarrow \infty} \frac{x+y}{x^{2}+x y+y^{2}}&amp;(9) \lim _{(x, y) \rightarrow \infty}\left(\frac{|x y|}{x^{2}+x y+y^{2}}\right)^{x^{2}}\]</span></p><hr /><p>解：<span class="math inline">\((1)\)</span> 令 <span class="math inline">\(z=x^2+y^2\)</span> ， <span class="math inline">\(\lim\limits_{z\to 0}\dfrac{\arcsin(z)}{z}=1\)</span>，而当 <span class="math inline">\(x,y\to 0\)</span> 时， <span class="math inline">\(z=x^2+y^2\neq 0\)</span> 则 <span class="math display">\[\displaystyle \lim _{(x, y) \rightarrow(0,0)} \frac{\arcsin \left(x^{2}+y^{2}\right)}{x^{2}+y^{2}}=0\]</span> <span class="math inline">\((3)\)</span> 由极限的连续性，且 <span class="math inline">\(\lim\limits_{(x,y)\to (0,0)}x^2+y^2=0,\lim\limits_{(x,y)\to (0,0)}e^{x-y}=0\)</span> 则极限存在，且极限为 <span class="math inline">\(0\)</span></p><p><span class="math inline">\((5)\)</span> 只需取 <span class="math inline">\(k&gt;0\)</span>，<span class="math inline">\(\lim\limits_{(x,kx)\to (0,0)}\dfrac{x+y}{|x|+|y|}=\dfrac{(1+k)x}{(1+k)|x|}\)</span> 从而极限不存在</p><p><span class="math inline">\((7)\)</span> 放缩有 <span class="math inline">\(|\dfrac{x+y}{x^2+xy+y^2}|\leq \dfrac{|x+y|}{|x^{2}+y^2|-|xy|}\leq \dfrac{|x+y|}{|2xy|-|xy|}\leq\dfrac{|x|+|y|}{|xy|}\leq \dfrac{1}{|x|}+\dfrac{1}{|y|}\)</span></p><p>从而 <span class="math inline">\(\displaystyle \lim _{(x, y) \rightarrow \infty} \frac{x+y}{x^{2}+x y+y^{2}}=0\)</span></p><p><span class="math inline">\((9)\)</span> 若取 <span class="math inline">\(y=x\)</span>，有 <span class="math inline">\(\lim\limits_{(x,x)\to \infty}\dfrac{|xy|}{x^2+xy+y^2}=\pm\dfrac{1}{3}\)</span>，此时 <span class="math inline">\(\lim\limits_{x\to \infty}(\pm\dfrac{1}{3})^{x^2}=0\)</span></p><p>又若取 <span class="math inline">\(y=-x\)</span>，有 <span class="math inline">\(\lim\limits_{(x,x)\to \infty}\dfrac{|xy|}{x^2+xy+y^2}=\pm1\)</span>，此时 <span class="math inline">\(\lim\limits_{x\to \infty}(\pm\dfrac{1}{3})^{x^2}\neq 0\)</span></p><p>从而 <span class="math inline">\(\displaystyle \lim _{(x, y) \rightarrow \infty}\left(\frac{|x y|}{x^{2}+x y+y^{2}}\right)^{x^{2}}\)</span> 极限不存在</p><h2 id="section-13">6</h2><p>设 <span class="math inline">\(\Omega \subseteq \mathbb{R}^{m}\)</span> 是一个非空集合。</p><ol type="a"><li><p>证明函数 <span class="math inline">\(\displaystyle f: \mathbb{R}^{m} \rightarrow \mathbb{R}, f(\mathbf{x})=\inf _{\mathbf{y} \in \Omega}\|\mathbf{y}-\mathbf{x}\|\)</span>, 是一个连续函数。</p></li><li><p>若 <span class="math inline">\(\Omega\)</span> 是闭集, 证明对任意 <span class="math inline">\(\mathbf{x}\)</span> 不在 <span class="math inline">\(\Omega\)</span> 中, 存在 <span class="math inline">\(\mathbf{y}^{*} \in \Omega\)</span> 使得 <span class="math inline">\(f(\mathbf{x})=\left\|\mathbf{y}^{*}-\mathbf{x}\right\|\)</span>, 并 且 <span class="math inline">\(\mathbf{y}^{*} \in \partial \Omega\)</span> (即 <span class="math inline">\(\mathbf{y}^{*}\)</span> 的任意邻域中都有不属于 <span class="math inline">\(\Omega\)</span> 的点)。</p></li><li><p>若 <span class="math inline">\(\Omega_{1}, \Omega_{2}\)</span> 是闭集且其中至少一个有界, 证明存在 <span class="math inline">\(\mathbf{x}_{k}^{*} \in \Omega_{k}\)</span> 使得</p></li></ol><p><span class="math display">\[\left\|\mathbf{x}_{1}^{*}-\mathbf{x}_{2}^{*}\right\|=\inf _{\mathbf{x}_{1} \in \Omega_{1}, \mathbf{x}_{2} \in \Omega_{2}}\left\|\mathbf{x}_{1}-\mathbf{x}_{2}\right\| .\]</span> (d) 举例说明上述 “闭”、“有界”的条件是不能或缺的。</p><hr /><p>证明：<span class="math inline">\((a)\)</span> <span class="math inline">\(\forall \ \epsilon&gt;0,\exists\ \delta&gt;0,||\mathbf{x}-\mathbf{x}_0||&lt;\delta\)</span>，范数三角不等式 <span class="math inline">\(\|\mathbf{y}-\mathbf{x}\|\leq \|\mathbf{y}-\mathbf{x_0}\|+\|\mathbf{x}_0-\mathbf{x}\|\)</span></p><p>左侧放缩 <span class="math inline">\(\displaystyle \inf _{\mathbf{y} \in \Omega}\|\mathbf{y}-\mathbf{x}\|\leq\|\mathbf{y}-\mathbf{x}\|\leq \|\mathbf{y}-\mathbf{x}_0\|+\|\mathbf{x}_0-\mathbf{x}\|\)</span> 对所有的 <span class="math inline">\(\mathbf{y}\)</span> 成立，则取特定 <span class="math inline">\(\mathbf{y}\)</span> 得 <span class="math display">\[\displaystyle \inf _{\mathbf{y} \in \Omega}\|\mathbf{y}-\mathbf{x}\|\leq \inf _{\mathbf{y} \in \Omega}\|\mathbf{y}-\mathbf{x}_0\|+\|\mathbf{x}_0-\mathbf{x}\|\]</span> 同理交换 <span class="math inline">\(\mathbf{x}\)</span> 和 <span class="math inline">\(\mathbf{x}_0\)</span> 得到 <span class="math inline">\(|\displaystyle \inf _{\mathbf{y} \in \Omega}\|\mathbf{y}-\mathbf{x}\|-\displaystyle \inf _{\mathbf{y} \in \Omega}\|\mathbf{y}-\mathbf{x}_0\||\leq \|\mathbf{x}-\mathbf{x_0}\|\)</span>，则取 $=$，就有 <span class="math display">\[\forall \ \epsilon&gt;0,\exists\ \delta=\epsilon,||\mathbf{x}-\mathbf{x}_0||&lt;\epsilon,|f(\mathbf{x})-f(\mathbf{x}_0)|\leq \delta=\epsilon\]</span> 则 <span class="math inline">\(\displaystyle f(\mathbf{x})=\inf _{\mathbf{y} \in \Omega}\|\mathbf{y}-\mathbf{x}\|\)</span> 连续</p><p><span class="math inline">\((b)\)</span> 由三角不等式 <span class="math inline">\(\|\mathbf{y^*}-\mathbf{y_n}\|+\|\mathbf{y_n}-\mathbf{x}\|\geq \|\mathbf{y^*-\mathbf{x}}\|\)</span> 若 <span class="math inline">\(f(\mathbf{x})\)</span> 中 <span class="math inline">\(\mathbf{y}\)</span> 的取值为 <span class="math inline">\(\Omega\)</span> 的内点，则</p><p><span class="math inline">\(\forall \ \epsilon_0&gt;\epsilon&gt;0,\exists \ \|\mathbf{y^*}-\mathbf{y}_n\|&lt;\epsilon\)</span>，从而可以找到其领域中的 <span class="math inline">\(\mathbf{y}_n\)</span> 并尽量使三者共线，从而矛盾</p><p>从而 <span class="math inline">\(\mathbf{y}^*\in \partial \Omega\)</span></p><p><span class="math inline">\((c)\)</span> 假设 <span class="math inline">\(\Omega_2\)</span> 为有界集合，固定在 <span class="math inline">\(\Omega_1\)</span> 中一点，由在有界闭集上的连续函数有界有 <span class="math display">\[\forall \ \mathbf{x}_1\in\Omega_{1},\exists \ \mathbf{x}_2^*\in \Omega_{2},\|\mathbf{x}_1-\mathbf{x}_2^*\|=\inf_{\mathbf{x_2}\in \Omega_2}\|\mathbf{x_2}-\mathbf{x_1}\|\]</span> 则取所有 <span class="math inline">\(\mathbf{x}_1\)</span> 中范数最小的，则存在 <span class="math inline">\(\displaystyle \left\|\mathbf{x}_{1}^{*}-\mathbf{x}_{2}^{*}\right\|=\inf _{\mathbf{x}_{1} \in \Omega_{1}, \mathbf{x}_{2} \in \Omega_{2}}\left\|\mathbf{x}_{1}-\mathbf{x}_{2}\right\| .\)</span></p><p><span class="math inline">\((d)\)</span> 取 <span class="math inline">\(\Omega:x^2+y^2&lt;1\)</span>，范数定义为二维平面中的欧式距离，则 <span class="math inline">\(\Omega\)</span> 与 <span class="math inline">\((2,0)\)</span> 就没有最小值</p><p>而两个无界区域之间有可能没有范数最小值，如 <span class="math inline">\(\{(x,y)\big |y=\tan (x),0\leq x&lt;\dfrac{\pi}{2}\}\)</span></p><p>和 <span class="math inline">\(\{(x,y)\big |x=\dfrac{\pi}{2}\}\)</span>，两者的欧式距离没有最小值（无限趋于 <span class="math inline">\(0\)</span> ）</p><h1 id="largetextcolorblue微积分第三次作业-smallwtimes-f-_textcolorblue2022.largepi"><span class="math inline">\(\large\textcolor{blue}{微积分第三次作业\ \small(W\times f)}\ \ \ \ \ \ _\textcolor{blue}{2022.\Large\pi}\)</span></h1><h2 id="教材习题1.4.4">教材习题1.4.4</h2><p>求下列函数的全微分 <span class="math display">\[(1)u=\sin \dfrac{1}{\sqrt{x^2+y^2+z^2}}\ \ \mbox{at}\ \ (\dfrac{\sqrt{2}}{2}.\dfrac{1}{2},-\dfrac{1}{2}) \quad  (2)\arccos e^{xy}\]</span></p><hr /><p>解：<span class="math inline">\((1)\)</span> <span class="math inline">\(du=\dfrac{\partial u}{\partial x}dx+\dfrac{\partial u}{\partial y}dy+\dfrac{\partial u}{\partial z}dz\)</span>，代入有 <span class="math display">\[\begin{gathered}du=\cos\dfrac{1}{\sqrt{x^2+y^2+z^2}}\cdot (-\dfrac{1}{2}(x^2+y^2+z^2)^{-\frac{3}{2}})(2xdx+2ydy+2zdz)\\=-\cos 1\cdot (xdx+ydy+zdz)=-\cos 1\cdot (\dfrac{\sqrt{2}}{2}dx+\dfrac{1}{2}dy-\dfrac{1}{2}dz)\end{gathered}\]</span> <span class="math inline">\((2)\)</span> 由 <span class="math inline">\((\arccos x)&#39;=-\dfrac{1}{\sqrt{1-x^2}}\)</span> <span class="math display">\[du=\dfrac{\partial u}{\partial x}dx+\dfrac{\partial u}{\partial y}dy=-\dfrac{1}{\sqrt{1-e^{2xy}}}(ye^{xy}dx+xe^{xy}dy)=-\dfrac{1}{\sqrt{e^{-2xy}-1}}(ydx+xdy)\]</span></p><h2 id="教材习题1.4.6">教材习题1.4.6</h2><p>已知扇形中心角 <span class="math inline">\(\alpha=60^\circ\)</span>，半径 <span class="math inline">\(R=20\ \mbox{cm}\)</span>，当 <span class="math inline">\(\alpha\)</span> 增加 <span class="math inline">\(1^\circ\)</span> 时，为使扇形面积保持不变，其半径的增加量 <span class="math inline">\(\Delta R\)</span> 近似等于多少？</p><hr /><p>解：由面积公式 <span class="math inline">\(S=\dfrac{1}{2}R^{2}\alpha\)</span>，要求 <span class="math inline">\(dS=\dfrac{1}{2}R^{2}d\alpha+R\alpha dR=0\)</span> 取 <span class="math inline">\(dR=\Delta R,d\alpha =\Delta \alpha\)</span></p><p>解得 <span class="math inline">\(\Delta R=-\dfrac{R}{2}\dfrac{\Delta \alpha}{\alpha}=-\dfrac{1}{6}\ \mbox{cm}\)</span></p><blockquote><p><span class="math inline">\(\dfrac{1}{6}\approx0.16666667\)</span>，与直接计算 <span class="math inline">\(|\Delta R|=0.16461185\ \mbox{cm}\)</span> 相对误差为 <span class="math inline">\(1.2\%\)</span></p></blockquote><h2 id="教材习题1.4.114">教材习题1.4.11(4)</h2><p>求下列函数在点 <span class="math inline">\(P_{0}\)</span> 处沿方向 <span class="math inline">\(l\)</span> 的方向导数。</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(z=\ln(x_1+x_2+\cdots+x_n),P_n=(1,0,\cdots,0),l=(1,1,\cdots,1)\)</span></p><hr /><p>解：由于方向导数针对单位向量，先单位化 <span class="math inline">\(l_{\small \mbox{unit}}=\dfrac{1}{\sqrt{n}}(1,1,\cdots,1)\)</span> 则由方向导数定义 <span class="math display">\[\partial _{\vec{l}}\large z\normalsize=\dfrac{d}{dt}\ln(1+n\cdot \dfrac{t}{\sqrt{n}})\big |_{t=0}=\sqrt{n}\]</span></p><h2 id="教材习题1.4.122">教材习题1.4.12(2)</h2><p>求下列数量场的梯度。<span class="math inline">\((2)\)</span> <span class="math inline">\(u(x,y,z)=\dfrac{xyz}{x+y+z}\)</span></p><hr /><p>解：代入标准正交基 <span class="math inline">\(x,y,z\)</span> 下的梯度 <span class="math display">\[\nabla u=\dfrac{\partial u}{\partial x}\hat{x}+\dfrac{\partial u}{\partial y}\hat{y}+\dfrac{\partial u}{\partial z}\hat{z}=\dfrac{yz(y+z)}{(x+y+z)^2}\hat{x}+\dfrac{xz(x+z)}{(x+y+z)^2}\hat{y}+\dfrac{xy(x+y)}{(x+y+z)^2}\hat{z}\]</span></p><h2 id="教材习题1.4.15">教材习题1.4.15</h2><p>证明下列函数满足相应的等式。</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\begin{cases}u=e^{x}\cos y\\v=e^{x}\sin y\end{cases}\)</span> 满足 <span class="math inline">\(\mbox{Cauchy-Riemann}\)</span> 条件 <span class="math inline">\(\begin{cases}\dfrac{\partial u}{\partial x}=\dfrac{\partial v}{\partial y}\\\dfrac{\partial u}{\partial y}=-\dfrac{\partial v}{\partial x}\end{cases}\)</span>，且分别满足 <span class="math inline">\(\Delta u=0\)</span></p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(n&gt;2\)</span>，<span class="math inline">\(u=(\sqrt{x_1^{2}+x_2^2+\cdots+x_n^2})^{2-n}\)</span> 满足 <span class="math inline">\(\dfrac{\partial ^2u}{\partial x_{1}^{2}}+\dfrac{\partial ^2u}{\partial x_{2}^{2}}+\cdots+\dfrac{\partial ^2u}{\partial x_{n}^{2}}=0\)</span></p><hr /><p>证明：<span class="math inline">\((3)\)</span> 代入有 <span class="math inline">\(\dfrac{\partial u}{\partial x}=e^{x}\cos y=\dfrac{\partial v}{\partial y}=e^{x}cos y,\dfrac{\partial u}{\partial y}=-e^{x}\sin y=-\dfrac{\partial v}{\partial x}\)</span></p><p>则若 <span class="math inline">\(\dfrac{\partial^2 f}{\partial x^{2}}+\dfrac{\partial^2 f}{\partial y^{2}}=0\)</span>，<span class="math inline">\(f(u,v)=f(e^{x}\cos y,e^{x}\sin y)\)</span>代入计算两次偏导数有 <span class="math display">\[\begin{gathered}\dfrac{\partial f}{\partial x}=\dfrac{\partial f}{\partial u}e^{x}\cos y+\dfrac{\partial f}{\partial v}e^{x}\sin y=u\dfrac{\partial f}{\partial u}+v\dfrac{\partial f}{\partial v}\\\dfrac{\partial f}{\partial y}=-\dfrac{\partial f}{\partial u}e^{x}\sin y+\dfrac{\partial f}{\partial v}e^{x}\cos y=-v\dfrac{\partial f}{\partial u}+u\dfrac{\partial f}{\partial v}\end{gathered}\]</span></p><p><span class="math display">\[\begin{gathered}\dfrac{\partial ^2f}{\partial x^2}=u\dfrac{\partial f}{\partial u}+u^2\dfrac{\partial^2 f}{\partial u^2}+v\dfrac{\partial f}{\partial v}+v^2\dfrac{\partial^2 f}{\partial v^2}\\\dfrac{\partial ^2f}{\partial y^2}=-u\dfrac{\partial f}{\partial u}+v^2\dfrac{\partial^2 f}{\partial u^2}-v\dfrac{\partial f}{\partial v}+u^2\dfrac{\partial^2 f}{\partial v^2}\end{gathered}\]</span></p><p>从而 <span class="math inline">\(\dfrac{\partial^2 f}{\partial x^{2}}+\dfrac{\partial^2 f}{\partial y^{2}}=0\Longrightarrow (u^2+v^2)(\dfrac{\partial^2 f}{\partial u^{2}}+\dfrac{\partial^2 f}{\partial v^{2}})=0\Longrightarrow \dfrac{\partial^2 f}{\partial u^{2}}+\dfrac{\partial^2 f}{\partial v^{2}}=0\)</span></p><p><span class="math inline">\((4)\)</span> 对 <span class="math inline">\(\forall \ i\in[1,n]\)</span>，有 <span class="math inline">\(\dfrac{\partial u}{\partial x_i}=\dfrac{(1-\dfrac{n}{2})\cdot 2x_{i}}{(x_1^2+\cdots+x_n^2)^{\frac{n}{2}}}=\dfrac{(2-n)\cdot x_{i}}{(x_1^2+\cdots+x_n^2)^{\frac{n}{2}}}\)</span></p><p>则二阶导 <span class="math inline">\(\dfrac{\partial^2 u}{\partial x_i^2}=\dfrac{2-n}{(x_1^2+\cdots+x_n^2)^{\frac{n}{2}}}+\dfrac{(n-2)\cdot \dfrac{n}{2}x_i\cdot 2x_i}{(x_1^2+\cdots+x_n^2)^{\frac{n}{2}+1}}\)</span>，则对所有二阶导求和 <span class="math display">\[\sum_{i=1}^{n}\dfrac{\partial^2 u}{\partial x_i^2}=(x_1^2+\cdots+x_n^2)^{-\frac{n}{2}}((2-n)\cdot n+(n-2)\cdot n)=0\]</span></p><h2 id="教材习题1.5.33">教材习题1.5.3(3)</h2><p>求下列复合函数的偏导数 <span class="math inline">\(\dfrac{\partial z}{\partial x},\dfrac{\partial z}{\partial y}\)</span>（已知 <span class="math inline">\(f\)</span> 为可微函数）</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(z=f(x^2-y^2,e^{xy})\)</span></p><hr /><p>解：令 <span class="math inline">\(u=x^2-y^2,v=e^{xy}\)</span> 则代入计算偏导数 <span class="math display">\[\dfrac{\partial z}{\partial x}=\dfrac{\partial z}{\partial u}\cdot 2x+\dfrac{\partial z}{\partial v}\cdot ye^{xy},\dfrac{\partial z}{\partial y}=\dfrac{\partial z}{\partial u}\cdot (-2y)+\dfrac{\partial z}{\partial v}\cdot xe^{xy}\]</span></p><h2 id="教材习题1.5.5">教材习题1.5.5</h2><p>已知函数 <span class="math inline">\(u=f(x,y)\)</span>，其中 <span class="math inline">\(x=r\cos \theta,y=r\sin \theta\)</span>， <span class="math inline">\(f\)</span> 可微，证明 <span class="math display">\[(\dfrac{\partial u}{\partial r})^2+(\dfrac{1}{r}\dfrac{\partial u}{\partial \theta})^2=(\dfrac{\partial u}{\partial x})^2+(\dfrac{\partial u}{\partial y})^2\]</span></p><hr /><p>证明：对 <span class="math inline">\(u=f(x,y)=f(r\cos \theta,r\sin \theta)\)</span> 对 <span class="math inline">\(r,\theta\)</span> 分别求偏导有 <span class="math display">\[\dfrac{\partial u}{\partial r}=\dfrac{\partial u}{\partial x}\cdot \cos \theta+\dfrac{\partial u}{\partial y}\cdot \sin \theta,\dfrac{\partial u}{\partial \theta}=\dfrac{\partial u}{\partial x}\cdot (-r\sin \theta)+\dfrac{\partial u}{\partial y}\cdot(r\cos \theta)\]</span> 则计算 <span class="math inline">\((\dfrac{\partial u}{\partial r})^2+(\dfrac{1}{r}\dfrac{\partial u}{\partial \theta})^2=(\dfrac{\partial u}{\partial x}\cdot \cos \theta+\dfrac{\partial u}{\partial y}\cdot \sin \theta)^{2}+(\dfrac{\partial u}{\partial x}\cdot (-\sin \theta)+\dfrac{\partial u}{\partial y}\cdot(\cos \theta))^2\)</span></p><p><span class="math inline">\(=(\dfrac{\partial u}{\partial x})^2+(\dfrac{\partial u}{\partial y})^2\)</span> 从而 <span class="math inline">\((\dfrac{\partial u}{\partial r})^2+(\dfrac{1}{r}\dfrac{\partial u}{\partial \theta})^2=(\dfrac{\partial u}{\partial x})^2+(\dfrac{\partial u}{\partial y})^2\)</span></p><h2 id="教材习题1.5.7">教材习题1.5.7</h2><p>设 <span class="math inline">\(f\in C^{2}(\mathbb{R}^2)\)</span> 满足 <span class="math inline">\(\mbox{Laplace}\)</span> 方程 <span class="math inline">\((\dfrac{\partial f}{\partial x})^2+(\dfrac{\partial f}{\partial y})^2=0\)</span>，证明： <span class="math display">\[u(x,y)=f(\dfrac{x}{x^2+y^2},\dfrac{y}{x^2+y^2})\]</span> 也满足 <span class="math inline">\(\mbox{Laplace}\)</span> 方程。</p><hr /><p>证明：（<strong>使用平面极坐标下拉普拉斯算子简化计算</strong>）<span class="math inline">\(\Delta f_{\mbox{polar}}=\dfrac{\partial ^2f}{\partial r^2}+\dfrac{1}{r}\dfrac{\partial f}{\partial r}+\dfrac{1}{r^2}\dfrac{\partial ^2f}{\partial \theta^2}\)</span></p><p>则对于满足直角坐标系下 <span class="math inline">\(\mbox{Laplace}\)</span> 方程 <span class="math inline">\(\Delta f_{\mbox{rectan}}=0=\Delta f_{\mbox{polar}}\)</span>，转换 <span class="math inline">\(u(x,y)=f(\dfrac{1}{r},\theta)\)</span></p><p>而 <span class="math inline">\(\dfrac{\partial u}{\partial (\frac{1}{r})}=-r^2\dfrac{\partial u}{\partial r}\)</span>，<span class="math inline">\(\dfrac{\partial^2 u}{\partial (\frac{1}{r})^2}=(-r^2)(-2r\dfrac{\partial u}{\partial r}-r^2\dfrac{\partial^2 u}{\partial r^2})=r^{3}(2\dfrac{\partial u}{\partial r}+r\dfrac{\partial^2 u}{\partial r^2})\)</span></p><p>则代入以 <span class="math inline">\((\dfrac{1}{r},\theta)\)</span> 为度量的极坐标拉普拉斯算子判定有 <span class="math display">\[\begin{gathered}\Delta f_{\mbox{polar&#39;}}=\dfrac{\partial ^2f}{\partial (\frac{1}{r})^2}+\dfrac{1}{\frac{1}{r}}\dfrac{\partial f}{\partial (\frac{1}{r})}+\dfrac{1}{(\frac{1}{r})^2}\dfrac{\partial ^2f}{\partial \theta^2}\\=r^{3}(2\dfrac{\partial  f}{\partial r}+r\dfrac{\partial^2  f}{\partial r^2})+r(-r^2\dfrac{\partial  f}{\partial r})+r^{2}\dfrac{\partial ^2f}{\partial \theta^2}=r^{3}(\dfrac{\partial  f}{\partial r}+r\dfrac{\partial^2  f}{\partial r^2})+r^2\dfrac{\partial ^2f}{\partial \theta^2}=r^{4}\Delta f_{\mbox{polar}}\end{gathered}\]</span> 从而 <span class="math inline">\(\Delta f_{\mbox{polar&#39;}}=0\)</span> 即 <span class="math inline">\(f(\dfrac{1}{r},\theta)=f(\dfrac{x}{x^2+y^2},\dfrac{y}{x^2+y^2})\)</span> 满足 <span class="math inline">\(\mbox{Laplace}\)</span> 方程</p><h2 id="讲义习题2.2.8">讲义习题2.2.8</h2><p>记 <span class="math inline">\(\mathbb{R}^{m} \times \mathbb{R}=\left\{\left(X^{1}, \ldots, X^{m}, X^{m+1}\right) \mid X^{k} \in \mathbb{R}\right\}, \mathbb{R}^{m}=\left\{\left(x^{1}, \ldots, x^{m}\right) \mid x^{k} \in \mathbb{R}\right\}\)</span></p><p><img src="https://pic.imgdb.cn/item/622ec3995baa1a80aba5514c.jpg" style="zoom: 33%;" /></p><p><span class="math inline">\(N=(0, \ldots, 0,2) \in \mathbb{R}^{m} \times \mathbb{R}, S^{m}=\left\{\left(X^{1}, \ldots, X^{m}, X^{m+1}\right) \mid\left(X^{1}\right)^{2}+\cdots+\right.\)</span> <span class="math inline">\(\left.\left(X^{m}\right)^{2}+\left(X^{m+1}-1\right)^{2}=1\right\}\)</span> 。定义球极投影，对 <span class="math inline">\(\left(x^{1}, \ldots, x^{m}\right) \in \mathbb{R}^{m}\)</span>, 连接 <span class="math inline">\(\left(x^{1}, \ldots, x^{m}, 0\right)\)</span> 与 <span class="math inline">\(N\)</span> 的直线交 <span class="math inline">\(S^{m}\)</span> 于 <span class="math inline">\(\left(X^{1}, \ldots, X^{m}, X^{m+1}\right)\)</span> 。证明映射 <span class="math display">\[\left(X^{1}\left(x^{1}, \ldots, x^{m}\right), \ldots, X^{m}\left(x^{1}, \ldots, x^{m}\right), X^{m+1}\left(x^{1}, \ldots, x^{m}\right)\right)\]</span> 是可微映射, 并求它的 <span class="math inline">\(\mbox{Jacobi}\)</span> 矩阵。</p><hr /><p>解：连接 <span class="math inline">\(N=(0,\cdots,0,2)\)</span> 与 <span class="math inline">\(\mathbf{x}=(x^1,\cdots,x^m,0)\)</span> 的直线参数方程为 <span class="math display">\[\vec{l}=(0,\cdots ,0,2)+t(x^1,\cdots,x^m,-2)=(tx^1,tx^2,\cdots,tx^m,2-2t)\]</span> 代入“高维球”方程得 <span class="math inline">\(t^{2} \displaystyle\sum_{i=1}^{n}\left(x^{i}\right)^{2}+(1-2 t)^{2}=1 \Longrightarrow t=\dfrac{4}{4+\displaystyle \sum_{i=0}^{n}\left(x^{i}\right)^{2}}\)</span></p><p>则球极投影 <span class="math inline">\(f(\mathbf{x})=(\dfrac{4 x^{1}}{4+\displaystyle \sum_{i=0}^{n}\left(x^{i}\right)^{2}}, \dfrac{4 x^{2}}{4+\displaystyle \sum_{i=0}^{n}\left(x^{i}\right)^{2}}, \cdots, \dfrac{4 x^{m}}{4+\displaystyle \sum_{i=0}^{n}\left(x^{i}\right)^{2}}, \dfrac{2 \displaystyle \sum_{4}\left(x^{i}\right)^{2}}{4+\displaystyle \sum_{i=0}^{n}\left(x^{i}\right)^{2}})\)</span></p><p>这是由于每个分量对 <span class="math inline">\(x^i\)</span> 均是初等函数，从而该球极投影映射为可微映射</p><p>雅可比矩阵定义 <span class="math inline">\(\displaystyle \left[\begin{array}{ccc} \dfrac{\partial X_{1}}{\partial x_{1}} &amp; \cdots &amp; \dfrac{\partial X_{1}}{\partial x_{m}} \\ \vdots &amp; \ddots &amp; \vdots \\ \dfrac{\partial X_{m+1}}{\partial x_{1}} &amp; \cdots &amp; \dfrac{\partial X_{m+1}}{\partial x_{m}} \end{array}\right]\)</span>，记该矩阵第 <span class="math inline">\(k\)</span> 行第 <span class="math inline">\(l\)</span> 列元素为 <span class="math inline">\(A_{k,l}\)</span></p><p>计算有 <span class="math inline">\(A_{k, l}= \begin{cases}4 \cdot \dfrac{4+\displaystyle \sum_{i=0}^{n}\left(x^{i}\right)^{2}-2\left(x^{k}\right)^{2}}{\left(4+\displaystyle \sum_{i=0}^{n}\left(x^{i}\right)^{2}\right)^{2}} &amp; l=k \leq m \\ \dfrac{-8 x^{k} x^{j}}{\left(4+\displaystyle \sum_{i=0}^{n}\left(x^{i}\right)^{2}\right)^{2}} &amp; l \neq k \leq m \\ \dfrac{16 x^{l}}{\left(4+\displaystyle \sum_{i=0}^{n}\left(x^{i}\right)^{2}\right)^{2}} &amp; k=m+1\end{cases}\)</span> 为雅可比矩阵的每一项</p><h2 id="讲义习题2.3.10">讲义习题2.3.10</h2><p><span class="math inline">\(\mathbb{R}^{3}\)</span> 中的球坐标系。其中极径 <span class="math inline">\(r\)</span>, 纬度 <span class="math inline">\(\theta\)</span> 和经度 <span class="math inline">\(\varphi\)</span> 如图所示。</p><p><img src="https://pic.imgdb.cn/item/622edbc95baa1a80abaff723.jpg" style="zoom:33%;" /></p><p><span class="math inline">\((a)\)</span> 试写出用球坐标 <span class="math inline">\((r, \theta, \varphi)\)</span> 表达的直角坐标 <span class="math inline">\((x(r, \theta, \varphi), y(r, \theta, \varphi), z(r, \theta, \varphi))\)</span> 的表达式, 并证明它是可微映射, 求出该映射的 <span class="math inline">\(\mbox{Jacobi}\)</span> 矩阵。该矩阵是否可逆? 为什么?</p><p><span class="math inline">\((b)\)</span> 记 <span class="math display">\[\mathbf{e}_{r}=\left(\begin{array}{l}\dfrac{\partial x}{\partial r} \\\dfrac{\partial y}{\partial r} \\\dfrac{\partial z}{\partial r}\end{array}\right), \quad \mathbf{e}_{\theta}=\left(\begin{array}{l}\dfrac{\partial x}{\partial \theta} \\\dfrac{\partial y}{\partial \theta} \\\dfrac{\partial z}{\partial \theta}\end{array}\right), \quad \mathbf{e}_{\varphi}=\left(\begin{array}{l}\dfrac{\partial x}{\partial \varphi} \\\dfrac{\partial y}{\partial \varphi} \\\dfrac{\partial z}{\partial \varphi}\end{array}\right)\]</span> 求它们给出的度量矩阵。</p><p><span class="math inline">\((c)\)</span> 计算 <span class="math inline">\((x(r, \theta, \varphi), y(r, \theta, \varphi), z(r, \theta, \varphi))\)</span> 的 <span class="math inline">\(\mbox{Jacobi}\)</span> 矩阵的行列式, 并对结果给出几何解释。</p><p><span class="math inline">\((d)\)</span> 对可微函数 <span class="math inline">\(f: \mathbb{R}^{3} \rightarrow \mathbb{R}\)</span>, 求在球坐标系下 <span class="math inline">\(f\)</span> 的梯度 <span class="math inline">\(\nabla f\)</span> （用偏导数 <span class="math inline">\(\dfrac{\partial f}{\partial r}, \dfrac{\partial f}{\partial \theta}, \dfrac{\partial f}{\partial \varphi}\)</span> 表示)。</p><p><span class="math inline">\((e)\)</span> 记 <span class="math inline">\(S^{2}=\left\{(x, y, z) \in \mathbb{R}^{3} \mid x^{2}+y^{2}+z^{2}=1\right\}\)</span> 。如果 <span class="math inline">\(f(\theta, \varphi)\)</span> 是 <span class="math inline">\(S^{2}\)</span> 上的可微函数, 求 <span class="math inline">\(\nabla f\)</span> (用偏导数 <span class="math inline">\(\dfrac{\partial f}{\partial \theta}, \dfrac{\partial f}{\partial \varphi}\)</span> 表示)。</p><hr /><p>解：<span class="math inline">\((a)\)</span> 由几何关系得 <span class="math inline">\(\left(\begin{array}{l} x \\ y\\z \end{array}\right)=\left(\begin{gathered} r \sin\theta\cos\varphi \\ r \sin \theta\sin\varphi\\ r\cos\theta \end{gathered}\right)\)</span>，显然该映射可微，对其求导得到雅克比矩阵 <span class="math display">\[\left(\begin{gathered}\mathrm{d}x\\\mathrm{d}y\\\mathrm{d}z\end{gathered}\right)=\begin{pmatrix}\sin\theta\cos\varphi&amp;r\cos\theta\cos\varphi&amp;-r\sin\theta\sin\varphi\\\sin\theta\sin\varphi&amp;r\cos\theta\sin\varphi&amp;r\sin\theta\cos\varphi\\\cos\theta&amp;-r\sin\theta&amp;0\end{pmatrix}\left(\begin{gathered}\mathrm{d}r\\\mathrm{d}\theta\\\mathrm{d}\varphi\end{gathered}\right)=J\left(\begin{gathered}\mathrm{d}r\\\mathrm{d}\theta\\\mathrm{d}\varphi\end{gathered}\right)\]</span> <span class="math inline">\((b)\)</span> 代入计算有 <span class="math inline">\(\mathbf{e}_r=\left(\begin{gathered}\sin\theta\cos\varphi\\ \sin \theta\sin\varphi\\ \cos\theta\end{gathered}\right), \mathbf{e}_\theta=\left(\begin{gathered}r\cos\theta\cos\varphi\\ r\cos \theta\sin\varphi\\ -r\sin\theta\end{gathered}\right), \mathbf{e}_\varphi=\left(\begin{gathered}-r\sin\theta\sin\varphi\\ r\sin \theta\cos\varphi\\ 0\end{gathered}\right)\)</span> <span class="math display">\[\begin{gathered}\langle\mathbf{e}_r,\mathbf{e}_r\rangle=1,\langle\mathbf{e}_r,\mathbf{e}_\theta\rangle=0,\langle\mathbf{e}_r,\mathbf{e}_\varphi\rangle=0,\langle\mathbf{e}_\theta,\mathbf{e}_\theta\rangle=r^2,\langle\mathbf{e}_\theta,\mathbf{e}_\varphi\rangle=0,\langle\mathbf{e}_\varphi,\mathbf{e}_\varphi\rangle=r^2\sin^2\theta\end{gathered}\]</span> 则度量矩阵为 <span class="math inline">\(\left(\begin{array}{} 1 &amp; 0 &amp;0\\ 0 &amp; r^{2}&amp;0\\ 0&amp;0&amp;r^2\sin^2\theta \end{array}\right)\)</span></p><p><span class="math inline">\((c)\)</span> 由 <span class="math inline">\(\small(a)\)</span> 中雅可比矩阵计算行列式 <span class="math display">\[\begin{gathered}\det J=r^2\sin ^3\theta\sin ^2\varphi+r^2\sin \theta\cos^2 \theta\sin ^2\varphi+r^2\sin \theta\cos^2 \theta\cos ^2\varphi+r^2\sin ^3\theta\cos ^2\varphi\\=r^2\sin \theta\sin ^2\varphi+r^2\sin \theta\cos ^2\varphi=r^2\sin \theta\end{gathered}\]</span> 该行列式代表三维坐标下微体积元与三维直角坐标系中微体积元之比</p><p><span class="math inline">\((d)\)</span> 由梯度表达式计算得 <span class="math display">\[\begin{gathered}\nabla f(r, \theta,\varphi)=\left(\mathbf{e}_{r}, \mathbf{e}_{\theta},\mathbf{e}_\varphi\right)\left(\begin{array}{}1 &amp; 0 &amp;0\\0 &amp; r^{2}&amp;0\\0&amp;0&amp;r^2\sin^2\theta\end{array}\right)^{-1}\left(\begin{array}{c}\partial_{r} f \\\partial_{\theta} f\\\partial_{\varphi} f\end{array}\right)\\=\partial_{r} f \mathbf{e}_{r}+\frac{1}{r^{2}} \partial_{\theta} f \mathbf{e}_{\theta}+\frac{1}{r^2\sin^2\theta}\partial_\varphi f\mathbf{e}_\varphi=\dfrac{\partial f}{\partial r}\mathbf{e}_{r}+\dfrac{1}{r^2}\dfrac{\partial f}{\partial \theta}\mathbf{e}_{\theta}+\dfrac{1}{r^2\sin^2 \theta}\dfrac{\partial f}{\partial \varphi}\mathbf{e}_{\varphi}\end{gathered}\]</span> <span class="math inline">\((e)\)</span> 相当于是固定 <span class="math inline">\(r\equiv1\)</span>，则 <span class="math inline">\(\nabla f=\dfrac{\partial f}{\partial \theta}\mathbf{e}_{\theta}+\dfrac{1}{\sin^2 \theta}\dfrac{\partial f}{\partial \varphi}\mathbf{e}_{\varphi}\)</span></p><h2 id="讲义习题2.3.11">讲义习题2.3.11</h2><p>环面上, 纬度 <span class="math inline">\(\theta\)</span> 和经度 <span class="math inline">\(\varphi\)</span> 如图所示。设环面轴径为 <span class="math inline">\(a\)</span>, 经线半径为 <span class="math inline">\(b\)</span>, <span class="math inline">\(0&lt;b&lt;a\)</span> ，如图所示。</p><p><img src="https://pic.imgdb.cn/item/622ee3385baa1a80abb3411d.jpg" style="zoom:33%;" /></p><p><span class="math inline">\((a)\)</span> 试写出用环面坐标 <span class="math inline">\((\theta, \varphi)\)</span> 表达的直角坐标 <span class="math inline">\((x(\theta, \varphi), y(\theta, \varphi), z(\theta, \varphi))\)</span> 的表达式, 并证明它是可微映射, 求出该映射的 <span class="math inline">\(\mbox{Jacobi}\)</span> 矩阵。该矩阵是否可逆? 为什么?</p><p><span class="math inline">\((b)\)</span> 记 <span class="math display">\[\mathbf{e}_{\theta}=\left(\begin{array}{l}\dfrac{\partial x}{\partial \theta} \\\dfrac{\partial y}{\partial \theta} \\\dfrac{\partial z}{\partial \theta}\end{array}\right), \quad \mathbf{e}_{\varphi}=\left(\begin{array}{l}\dfrac{\partial x}{\partial \varphi} \\\dfrac{\partial y}{\partial \varphi} \\\dfrac{\partial z}{\partial \varphi}\end{array}\right)\]</span> 求它们给出的度量矩阵。</p><p><span class="math inline">\((c)\)</span> 如果 <span class="math inline">\(f(\theta, \varphi)\)</span> 是环面上的可微函数, 求 <span class="math inline">\(\nabla f\)</span> (用偏导数 <span class="math inline">\(\dfrac{\partial f}{\partial \theta}, \dfrac{\partial f}{\partial \varphi}\)</span> 表示)。</p><hr /><p>解：<span class="math inline">\((a)\)</span> 由几何关系得 <span class="math inline">\(\left(\begin{array}{l} x \\ y\\z \end{array}\right)=\left(\begin{gathered} (a+b\cos \theta)\cos \varphi \\ (a+b\cos \theta)\sin \varphi\\ b\sin\theta \end{gathered}\right)\)</span>，显然其可微，对其求导有 <span class="math display">\[\left(\begin{array}{l}\mathrm{d} x \\\mathrm{~d} y \\\mathrm{~d} z\end{array}\right)=\left(\begin{array}{cc}-b \sin \theta \cos \varphi &amp; -(a+b \cos \theta) \sin \varphi \\-b \sin \theta \sin \varphi &amp; (a+b \cos \theta) \cos \varphi \\b \cos \theta &amp; 0\end{array}\right)\left(\begin{array}{c}\mathrm{d} \theta \\\mathrm{d} \varphi\end{array}\right)=J\left(\begin{array}{c}\mathrm{d} r \\\mathrm{~d} \theta \\\mathrm{d} \varphi\end{array}\right)\]</span> <span class="math inline">\((b)\)</span> 有 <span class="math inline">\(\mathbf{e}_\theta=\left(\begin{gathered}-b\sin \theta\cos \varphi\\ -b\sin \theta\sin \varphi\\ -b\cos\theta\end{gathered}\right), \mathbf{e}_\varphi=\left(\begin{gathered}-(a+b\cos \theta)\sin \varphi\\(a+b\cos \theta)\cos \varphi\\ 0\end{gathered}\right)\)</span>，计算度量矩阵 <span class="math display">\[\begin{gathered}\langle\mathbf{e}_{\theta},\mathbf{e}_{\theta}\rangle=b^2,\langle\mathbf{e}_{\varphi},\mathbf{e}_\theta\rangle=0,\langle\mathbf{e}_{\varphi},\mathbf{e}_\varphi\rangle=(a+b\cos \theta)^{2}\end{gathered}\]</span> <span class="math inline">\((c)\)</span> 由梯度表达式 <span class="math inline">\(\nabla f(\theta,\varphi)=\left( \mathbf{e}_{\theta},\mathbf{e}_\varphi\right)\left(\begin{array}{} b^2 &amp; 0 \\ 0 &amp; (a+b\cos \theta)^2 \end{array}\right)^{-1}\left(\begin{array}{c} \partial_{\theta} f\\ \partial_{\varphi} f \end{array}\right)\\\)</span></p><p>得到 <span class="math inline">\(\nabla f(\theta,\varphi)=\dfrac{1}{b^2}\dfrac{\partial f}{\partial \theta}\mathbf{e}_{\theta}+\dfrac{1}{(a+b\cos \theta)^{2}}\dfrac{\partial f}{\partial \varphi}\mathbf{e}_{\varphi}\)</span></p><h2 id="讲义习题2.4.5">讲义习题2.4.5</h2><p>平面极坐标系下 <span class="math inline">\(\mbox{Laplace}\)</span> 方程为 <span class="math inline">\(\dfrac{\partial^{2} u}{\partial r^{2}}+\dfrac{1}{r} \dfrac{\partial u}{\partial r}+\dfrac{1}{r^{2}} \dfrac{\partial^{2} u}{\partial \theta^{2}}=0\)</span> 。</p><p>求分离变量形式的解 <span class="math inline">\(u(r, \theta)=X(r) Y(\theta)\)</span> 。</p><hr /><p>解：代入分离变量形式有 <span class="math inline">\(\Delta u=Y(\theta)\left(\partial_{r, r}^{2} X(r)+\dfrac{1}{r} \partial_{r} X(r)\right)+\dfrac{X(r)}{r^{2}} \partial_{\theta, \theta} Y(\theta)=0\)</span> 变形为 <span class="math display">\[\frac{1}{X(r)}\left(r^{2} \partial_{r, r}^{2} X(r)+r \partial_{r} X(r)\right)+\frac{1}{Y(\theta)} \partial_{\theta, \theta} Y(\theta)=0\]</span> 由于前两项与后一项无关联，令 <span class="math inline">\(r^{2} \partial_{r, r}^{2} X(r)+r \partial_{r} X(r)=C X(r),\partial_{\theta, \theta} Y(\theta)=-CY(\theta)\)</span></p><p>前者为欧拉方程，取 <span class="math inline">\(t=\ln r\)</span>，化简得 <span class="math inline">\(\dfrac{\partial^2 X(t)}{\partial t^2}=CX(t)\)</span>，则分类讨论有 <span class="math display">\[\begin{aligned}&amp;X(r)=k_{1} \cosh (\sqrt{C} \ln r)+k_{2} \sinh (\sqrt{C} \ln r), &amp; C&gt;0 \\&amp;Y(\theta)=k_{3} \cos (\sqrt{C} \theta)+k_{4} \sin (\sqrt{C} \theta) ; \\&amp;X(r)=k_{1} \cos (\sqrt{-C} \ln r)+k_{2} \sin (\sqrt{-C} \ln r), &amp;C&lt;0 \\&amp;Y(\theta)=k_{3} \cosh (\sqrt{-C} \theta)+k_{4} \sinh (\sqrt{-C} \theta) ; \\&amp;X(r)=k_{1} \ln r+k_{2}, Y(\theta)=k_{3} \theta ; &amp;C=0\end{aligned}\]</span> 从而合并所有解令 <span class="math inline">\(C&gt;0\)</span> 有 <span class="math display">\[u(r, \theta)=\left\{\begin{array}{l}\left(C_{1} r^{C}+C_{2} r^{-C}\right) \cos \left(C \theta+C_{3}\right) \\\cos \left(C \ln r+C_{1}\right)\left(C_{2} \mathrm{e}^{C \theta}+C_{3} \mathrm{e}^{-C \theta}\right) \\C_{1}\left(\ln r+C_{2}\right) \theta\end{array}\right.\]</span></p><h2 id="讲义习题2.4.6">讲义习题2.4.6</h2><p>求直角坐标系下的 <span class="math inline">\(\mbox{Laplace}\)</span> 方程 <span class="math inline">\(\Delta f=\dfrac{\partial^{2} f}{\partial x^{2}}+\dfrac{\partial^{2} f}{\partial y^{2}}+\dfrac{\partial^{2} f}{\partial z^{2}}=0\)</span> 在空间球坐标系下表达式。</p><hr /><p>解：利用 <span class="math inline">\(\Delta=\nabla\cdot \nabla\)</span>，且由讲义 <span class="math inline">\(2.3.10\)</span> 习题知 <span class="math display">\[\begin{gathered}\nabla f(r, \theta,\varphi)=\dfrac{\partial f}{\partial r}\mathbf{e}_{r}+\dfrac{1}{r^2}\dfrac{\partial f}{\partial \theta}\mathbf{e}_{\theta}+\dfrac{1}{r^2\sin^2 \theta}\dfrac{\partial f}{\partial \varphi}\mathbf{e}_{\varphi}\\\mathbf{e}_r=\left(\begin{gathered}\sin\theta\cos\varphi\\ \sin \theta\sin\varphi\\\cos\theta\end{gathered}\right),\mathbf{e}_\theta=\left(\begin{gathered}r\cos\theta\cos\varphi\\ r\cos \theta\sin\varphi\\-r\sin\theta\end{gathered}\right),\mathbf{e}_\varphi=\left(\begin{gathered}-r\sin\theta\sin\varphi\\ r\sin \theta\cos\varphi\\0\end{gathered}\right)\end{gathered}\]</span> 且不同坐标的偏导有，计算拉普拉斯算子得到 <span class="math display">\[\begin{gathered}\partial_{r} \mathbf{e}_{r}=0, \partial_{r} \mathbf{e}_{\theta}=\frac{\mathbf{e}_{\theta}}{r}, \partial_{r} \mathbf{e}_{\varphi}=\frac{\mathbf{e}_{\varphi}}{r} \\\partial_{\theta} \mathbf{e}_{r}=\frac{\mathbf{e}_{\theta}}{r}, \partial_{\theta} \mathbf{e}_{\theta}=-r \mathbf{e}_{r}, \partial_{\theta} \mathbf{e}_{\varphi}=\cot \theta \mathbf{e}_{\varphi} \\\partial_{\varphi} \mathbf{e}_{r}=\frac{\mathbf{e}_{\varphi}}{r}, \partial_{\varphi} \mathbf{e}_{\theta}=\cot \theta \mathbf{e}_{\varphi}, \partial_{\varphi} \mathbf{e}_{\varphi}=\left[\begin{array}{c}-r \sin \theta \cos \varphi \\-r \sin \theta \sin \varphi \\0\end{array}\right]\\\Delta=\left(\mathbf{e}_{r} \partial_{r}+\frac{\mathbf{e}_{\theta}}{r^{2}} \partial_{\theta}+\frac{\mathbf{e}_{\varphi}}{r^{2} \sin ^{2} \theta} \partial_{\varphi}\right) \cdot\left(\mathbf{e}_{r} \partial_{r}+\frac{\mathbf{e}_{\theta}}{r^{2}} \partial_{\theta}+\frac{\mathbf{e}_{\varphi}}{r^{2} \sin ^{2} \theta} \partial_{\varphi}\right) \\=\partial_{r, r}+0+0+\frac{1}{r} \partial_{r}+\frac{1}{r^{2}} \partial_{\theta, \theta}+0+\frac{1}{r} \partial_{r}+\frac{\cot \theta}{r^{2}} \partial_{\theta}+\frac{1}{r^{2} \sin ^{2} \theta} \partial_{\varphi, \varphi} \\=\partial_{r, r}+\frac{2}{r} \partial_{r}+\frac{1}{r^{2}} \partial_{\theta, \theta}+\frac{\cot \theta}{r^{2}} \partial_{\theta}+\frac{1}{r^{2} \sin ^{2} \theta} \partial_{\varphi, \varphi}\end{gathered}\]</span></p><blockquote><p>这与球坐标系下拉普拉斯算子的一般表达式（来源于网络）等价 <span class="math display">\[\Delta=\frac{1}{r^{2}} \frac{\partial}{\partial r}\left(r^{2} \frac{\partial u}{\partial r}\right)+\frac{1}{r^{2} \sin \theta} \frac{\partial}{\partial \theta}\left(\sin \theta \frac{\partial u}{\partial \theta}\right)+\frac{1}{r^{2} \sin ^{2} \theta} \frac{\partial^{2} u}{\partial \varphi^{2}}\]</span> # <span class="math inline">\(\large\textcolor{blue}{微积分第四次作业\ \small(W\times f)}\ \ \ \ \ \ _\textcolor{blue}{2022.3.22}\)</span></p></blockquote><h2 id="教材第一章总复习11">教材第一章总复习11</h2><p>已知偏微分方程 (输运方程) <span class="math inline">\(\left\{\begin{array}{l}\dfrac{\partial z}{\partial t}=a \dfrac{\partial z}{\partial x}+b \dfrac{\partial z}{\partial y}, \\ z(x, y, 0)=z_{0}(x, y),\end{array}\right.\)</span> 证明它的解为 <span class="math inline">\(z=\)</span> <span class="math inline">\(z_{0}(x+a t, y+b t) .\)</span></p><hr /><p>解：显然当 <span class="math inline">\(z=z_{0}(x+at,y+bt)\)</span> 时，<span class="math inline">\(\dfrac{\partial z}{\partial t}=\dfrac{\partial z}{\partial x}\cdot a+\dfrac{\partial z}{\partial y}\cdot b\)</span> 满足条件</p><p>令 <span class="math inline">\(z(s)=z(x-as,y-bs,t+s)\)</span>，满足 <span class="math inline">\(\dfrac{\partial z}{\partial s}=-a\dfrac{\partial z}{\partial x}-b\dfrac{\partial z}{\partial y}+\dfrac{\partial z}{\partial t}=0\)</span>，则对每个 <span class="math inline">\(x,y,t\)</span></p><p>都有 <span class="math inline">\(z(x-as,y-bs,t+s)=z(0)=z(x,y,t)\)</span>，令 <span class="math inline">\(t=-s\)</span> 代入得 <span class="math display">\[z(x+at,y+bt,0)=z_0(x+at,y+bt)=z(x,y,t)\]</span> 则 <span class="math inline">\(z(x,y,t)=z_0(x+at,y+bt)\)</span> 为满足条件的唯一解</p><h2 id="教材第一章总复习121">教材第一章总复习12(1)</h2><p>（1）设函数 <span class="math inline">\(f, g \in C^{2}\)</span>, 证明: <span class="math inline">\(u(x, y, z, t)=\dfrac{1}{r}(f(t+r)-g(t-r))\)</span> 满足弦振动方程</p><p><span class="math inline">\(\dfrac{\partial^{2} u}{\partial t^{2}}=\dfrac{\partial^{2} u}{\partial x^{2}}+\dfrac{\partial^{2} u}{\partial y^{2}}+\dfrac{\partial^{2} u}{\partial z^{2}}\)</span>, 其中 <span class="math inline">\(r=\sqrt{x^{2}+y^{2}+z^{2}}\)</span>;</p><hr /><p>证明：对 <span class="math inline">\(u(x, y, z, t)=\dfrac{1}{r}(f(t+r)-g(t-r))\)</span> 求偏导有 <span class="math display">\[\begin{gathered}\dfrac{\partial u}{\partial t}=\dfrac{f&#39;(t+r)-g&#39;(t-r)}{r},\dfrac{\partial^2 u}{\partial t^2}=\dfrac{f&#39;&#39;(t+r)-g&#39;&#39;(t-r)}{r}\\\dfrac{\partial u}{\partial x}=\dfrac{f&#39;(t+r)\cdot x+g&#39;(t-r)\cdot x-(f(t+r)-g(t-r))\cdot \dfrac{x}{r}}{x^2+y^2+z^2}\\\dfrac{\partial^2 u}{\partial x^2}=\dfrac{(f&#39;(t+r)+g&#39;(t-r)+f&#39;&#39;(t+r)\cdot \dfrac{x^2}{r}-g&#39;&#39;(t-r)\cdot \dfrac{x^2}{r})\cdot r^2}{(x^2+y^2+z^2)^2}\\+\dfrac{-(f&#39;(t+r)+g&#39;_r(t-r))\cdot \dfrac{x^2}{r^2}\cdot r^2-(f(t+r)-g(t-r))\cdot \dfrac{y^2+z^2}{r^3}\cdot r^2}{(x^2+y^2+z^2)^2}\\-\dfrac{(f&#39;(t+r)\cdot x+g&#39;(t-r)\cdot x-(f(t+r)-g(t-r))\cdot \dfrac{x}{r})\cdot 2x}{(x^2+y^2+z^2)^2}\\\end{gathered}\]</span> <span class="math display">\[\begin{gathered}=\dfrac{-(f(t+r)-g(t-r))\cdot (\dfrac{-2x^2+y^2+z^2}{r})+(-3x^2+r^2)\cdot (f&#39;(t+r)+g&#39;(t-r))}{r^4}\\+\dfrac{(f&#39;&#39;(t+r)-g&#39;&#39;(t-r))\cdot x^2r}{r^4}\end{gathered}\]</span> 则对 <span class="math inline">\(x,y,z\)</span> 求和有 <span class="math display">\[\begin{gathered}\dfrac{\partial^{2} u}{\partial x^{2}}+\dfrac{\partial^{2} u}{\partial y^{2}}+\dfrac{\partial^{2} u}{\partial z^{2}}=\dfrac{-(f(t+r)-g(t-r))\cdot \displaystyle \sum\dfrac{-2x^2+y^2+z^2}{r}}{r^4}\\+\dfrac{(f&#39;(t+r)+g&#39;(t-r))\cdot \displaystyle \sum (-3x^2+r^2)}{r^4}+\dfrac{(f&#39;&#39;(t+r)-g&#39;&#39;(t-r))\cdot \displaystyle \sum x^2r}{r^4}\\=0+0+\dfrac{f&#39;&#39;(t+r)-g&#39;&#39;(t-r)}{r}=\dfrac{\partial ^2u}{\partial t^2}\end{gathered}\]</span></p><h2 id="教材第一章总复习15">教材第一章总复习15</h2><p>设 <span class="math inline">\(f(x, y)\)</span> 是可微函数, 且满足以下条件 <span class="math inline">\(\lim\limits _{x^{2}+y^{2} \rightarrow+\infty} \dfrac{f(x, y)}{\sqrt{x^{2}+y^{2}}}=+\infty\)</span>, 试证明: 对于任意的 <span class="math inline">\(\boldsymbol{v}=\left\{v_{1}, v_{2}\right\}\)</span>, 都存在点 <span class="math inline">\(\left(x_{0}, y_{0}\right)\)</span>, 使得 <span class="math inline">\(\operatorname{grad} f\left(x_{0}, y_{0}\right)=v\)</span>.</p><hr /><p>证明：对 <span class="math inline">\(\forall \ v_1,v_2\in R,\boldsymbol v=\{v_1,v_2\}\)</span>，定义 <span class="math inline">\(g(x,y)=f(x,y)-(v_1x+v_2y)\)</span></p><p>则 <span class="math inline">\(\mbox{grad}\ f(x_0,y_0)=\boldsymbol v\Longleftrightarrow \mbox{grad}\ g(x_0,y_0)=0\)</span>，而 <span class="math inline">\(\dfrac{|x_0x+y_0y|}{\sqrt{x^2+y^2}}\leq \dfrac{\sqrt{x_0^2+y_0^2}\cdot \sqrt{x^2+y^2}}{\sqrt{x^2+y^2}}\)</span></p><p>后者为一常量 <span class="math inline">\(&lt;+\infty\)</span>，则 <span class="math inline">\(\lim\limits_{x^2+y^2\to +\infty}\dfrac{g(x,y)}{\sqrt{x^2+y^2}}=+\infty\)</span>，由极限定义知 <span class="math display">\[\forall \ M&gt;0,\exists\ N&gt;0,\forall \ x^2+y^2&gt;N,\dfrac{g(x,y)}{\sqrt{x^2+y^2}}&gt;M\]</span> 则任取 <span class="math inline">\(M_0\)</span>，令 <span class="math inline">\(\mathbb{S}=\{(x,y)\mid x^2+y^2\leq N\}\)</span>，该集合为定义在 <span class="math inline">\(\mathbb{R}^2\to \mathbb{R}\)</span> 上的有界闭集</p><p>对应值域有最小值 <span class="math inline">\(f(x_1,y_1)=m_{min}\)</span>，结合上述可知，该坐标为整个定义域上的最小值</p><p>则一定 <span class="math inline">\(\exists \ x_1,y_1,s.t.\mbox{grad}\ g(x_1,y_1)=0\)</span>，从而原命题成立</p><h2 id="讲义2.4.8">讲义2.4.8</h2><p>求 <span class="math inline">\(\partial^{2} \operatorname{det}(A)\)</span> 以及 <span class="math inline">\(\operatorname{det}\)</span> 在 <span class="math inline">\(I\)</span> 处的 <span class="math inline">\(2\)</span> 阶 <span class="math inline">\(Taylor\)</span> 展开式。(提示: <span class="math inline">\(A A^{* T}=\)</span> <span class="math inline">\(\left.\operatorname{det}(A) I_{\circ}\right)\)</span></p><hr /><p>解：由 <span class="math inline">\(D\det A(B_1)=\tr(A^{*T}B_1)=\det A\cdot \tr(A^{-1}B_1)\)</span>，继续变化 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(B_2\)</span> 求导有</p><p><span class="math inline">\(D(\tr(A^{-1}B_1))(B_2)=\tr((A+B_2)^{-1}B_1)-\tr(A^{-1}B_1)\)</span> 由可逆运算的一阶“泰勒”展开</p><p><span class="math inline">\((A+B_2)^{-1}=(A(I+A^{-1}B_2))^{-1}=(I+A^{-1}B_2)^{-1}A^{-1}=(I-A^{-1}B_2+o(B_2))A^{-1}\)</span></p><p>则有 <span class="math inline">\(D(\tr(A^{-1}B_1))(B_2)=-\tr(A^{-1}B_2A^{-1}B_1)\)</span>，则由链式法则对 <span class="math inline">\(\det A\)</span> 的二阶展开式 <span class="math display">\[\partial ^2\det A=\det A\cdot (\tr(A^{-1}B_2)\cdot \tr(A^{-1}B_1)-\tr (A^{-1}B_2A^{-1}B_1))\]</span> 则 $$ 在 <span class="math inline">\(I\)</span> 处的 <span class="math inline">\(Taylor\)</span> 展开式有 <span class="math inline">\(1+\tr(B)+\dfrac{1}{2}(\tr^2(B)-\tr(B^2))+o(\tr(B^2))\)</span></p><h2 id="讲义2.5.3">讲义2.5.3</h2><p>求以下函数的极值和最值</p><ol type="1"><li><p><span class="math inline">\(u=\sin x+\sin y+\sin z-\sin (x+y+z)(0 \leq x, y, z \leq \pi)\)</span></p></li><li><p><span class="math inline">\(f(\mathbf{x})=\dfrac{\langle A \mathbf{x}, \mathbf{x}\rangle}{\langle\mathbf{x}, \mathbf{x}\rangle}(\mathbf{x} \neq \mathbf{0})\)</span>, 其中 <span class="math inline">\(A\)</span> 是一个对称矩阵。</p></li><li><p><span class="math inline">\(x^{y}-(x-1) y+(x-1)^{2}(x&gt;0, y \in \mathbb{R})\)</span> 。</p></li></ol><hr /><p>解：<span class="math inline">\((1)\)</span> 由对该三元函数求一阶导得</p><p><span class="math display">\[\dfrac{\partial u}{\partial x}=\cos x-\cos (x+y+z),\dfrac{\partial u}{\partial y}=\cos y-\cos (x+y+z),\dfrac{\partial u}{\partial z}=\cos z-\cos (x+y+z)\]</span> 当三者均为 <span class="math inline">\(0\)</span> 时有 <span class="math display">\[\cos x=\cos y=\cos z=\cos (x+y+z),x,y,z\in[0,{\pi}]\]</span> 由于 <span class="math inline">\(\cos x\)</span> 函数在 <span class="math inline">\([0,\pi]\)</span> 区间上是单调的，从而 <span class="math inline">\(x=y=z\)</span>，代入三倍角公式有 <span class="math display">\[\cos x=\cos (3x)=-3\cos x+4\cos ^3x\]</span> 求二阶导 <span class="math display">\[\dfrac{\partial ^2 u}{\partial x^2}=-\sin x+\sin (x+y+z),\dfrac{\partial ^2 u}{\partial x \partial y}=\sin (x+y+z),\dfrac{\partial ^2 u}{\partial x\partial z}=\sin (x+y+z)\\\dfrac{\partial ^2 u}{\partial ^2y}=-\sin y+\sin (x+y+z),\dfrac{\partial ^2 u}{\partial y\partial z}=\sin (x+y+z),\dfrac{\partial ^2 u}{\partial z^2}=-\sin z+\sin (x+y+z)\\\]</span> 解得 <span class="math inline">\(x=0\ 或\ \dfrac{\pi}{2}\)</span>，而当 <span class="math inline">\(x=0\)</span> 为边界点，不可能为极值点，代入 <span class="math inline">\(x=\dfrac{\pi}{2}\)</span> 计算 <span class="math inline">\(Hesse\)</span> 矩阵有 <span class="math display">\[x=\dfrac{\pi}{2},\begin{bmatrix}    \dfrac{\partial ^2 u}{\partial x^2} &amp;\dfrac{\partial ^2 u}{\partial x\partial y}&amp;\dfrac{\partial ^2 u}{\partial x\partial z}\\    \dfrac{\partial ^2 u}{\partial y\partial x} &amp;\dfrac{\partial ^2 u}{\partial y^2}&amp;\dfrac{\partial ^2 u}{\partial y\partial z}\\    \dfrac{\partial ^2 u}{\partial z\partial x}&amp;\dfrac{\partial ^2 u}{\partial z\partial y}&amp;\dfrac{\partial ^2 u}{\partial z^2}\end{bmatrix}=\begin{bmatrix}-2&amp;-1&amp;-1\\-1&amp;-2&amp;-1\\-1&amp;-1&amp;-2\end{bmatrix}\]</span> 计算该矩阵的特征值 <span class="math display">\[\det(\boldsymbol H-\lambda \boldsymbol I)=\begin{vmatrix}-2-\lambda&amp;-1&amp;-1\\-1&amp;-2-\lambda&amp;-1\\-1&amp;-1&amp;-2-\lambda\end{vmatrix}=-(\lambda+1)^2(\lambda+4)，\lambda=-1,-1,-4\]</span> 从而 <span class="math inline">\(\boldsymbol H\)</span> 矩阵负定，从而 <span class="math inline">\(u(x,y,z)=\sin x+\sin y+\sin z-\sin (x+y+z)\)</span> 在 <span class="math inline">\((\dfrac{\pi}{2},\dfrac{\pi}{2},\dfrac{\pi}{2})\)</span> 有极大值 <span class="math inline">\(4\)</span>，同时也是最大值，对最小值有三角恒等式 <span class="math display">\[\sin  (x)+\sin  (y)+\sin  (z)-\sin  (x+y+z)=4 \sin  \left(\frac{x+y}{2}\right) \sin  \left(\frac{x+z}{2}\right) \sin  \left(\frac{y+z}{2}\right)\]</span> 代入取值范围有 <span class="math inline">\(\sin (\dfrac{x+y}{2}),\sin (\dfrac{x+z}{2}),\sin (\dfrac{y+z}{2})\geq 0\)</span>，则最小值为 <span class="math inline">\(0\)</span></p><p>综上所述原函数有极大值 <span class="math inline">\(4\)</span>，无极小值，有最大值 <span class="math inline">\(4\)</span>，最小值 <span class="math inline">\(0\)</span></p><p><span class="math inline">\((2)\)</span> 对该函数求导有 <span class="math display">\[\mathbf{d} f(\mathbf{x}) \mathbf{v}=\frac{2 \mathbf{v}^{T} A \mathbf{x}}{\mathbf{x}^{T} \mathbf{x}}-\frac{\mathbf{x}^{T} A \mathbf{x}}{\left(\mathbf{x}^{T} \mathbf{x}\right)^{2}} 2 \mathbf{v}^{T} \mathbf{x}=\frac{2 \mathbf{v}^{T}}{\mathbf{x}^{T} \mathbf{x}}[A \mathbf{x}-f(\mathbf{x}) \mathbf{x}]\]</span> <span class="math inline">\(\mathrm{d} f(\mathbf{x}) \mathbf{v}=0(\forall \mathbf{v})\)</span> 当且仅当 <span class="math inline">\(A \mathbf{x}=f(\mathbf{x}) \mathbf{x}\)</span>, 即 <span class="math inline">\(\mathbf{x}\)</span> 是 <span class="math inline">\(A\)</span> 的特征向量。 此时, <span class="math inline">\(f(\mathbf{x})\)</span> 是相应的特征值。 在 <span class="math inline">\(A\)</span> 的单位特征向量 <span class="math inline">\(\mathrm{x}_{0}\)</span> 处, <span class="math inline">\(\mathbf{v}=\mu \mathbf{x}_{0}+(1+\mu) \mathbf{v}^{\perp}\)</span> <span class="math display">\[f\left(\mathbf{x}_{0}+\mathbf{v}\right)=\lambda+\left(\mathbf{v}^{\perp}\right)^{T}(A-\lambda I) \mathbf{v}^{\perp}+o\left(\left\|\mathbf{v}^{\perp}\right\|^{2}\right)\]</span> 如果 <span class="math inline">\(\lambda\)</span> 是 <span class="math inline">\(A\)</span> 的最大特征值（或最小特征值), 则 <span class="math inline">\(\mathrm{x}_{0}\)</span> 是 <span class="math inline">\(f\)</span> 的最大值点 (相应地，最小值点)。如果特征值 <span class="math inline">\(\lambda\)</span> 既非 <span class="math inline">\(A\)</span> 的最大特征 值也非最小特征值, 则 <span class="math inline">\(\mathbf{x}_{0}\)</span> 不是 <span class="math inline">\(f\)</span> 的极值点。</p><p><span class="math inline">\((3)\)</span> 对二元函数 <span class="math inline">\(z(x,y)=x^y-(x-1)y+(x-1)^2\)</span> 求偏导等于 <span class="math inline">\(0\)</span> 有 <span class="math display">\[\begin{gathered}\dfrac{\partial z}{\partial x}=yx^{y-1}-y+2(x-1)=0,\dfrac{\partial z}{\partial y}=x^{y}\ln x-(x-1)=0\\\dfrac{\partial ^2z}{\partial x^2}=y(y-1)x^{y-2}+2,\dfrac{\partial ^2z}{\partial y^2}=x^{y}\ln ^2x,\dfrac{\partial ^2z}{\partial x\partial y}=x^{y-1}+yx^{y-1}\ln x-1\end{gathered}\]</span> 固定 <span class="math inline">\(y_0\)</span> 有 <span class="math inline">\(y_0\leq0\)</span> 或 <span class="math inline">\(y_0\leq 1\)</span> 时 <span class="math inline">\(\dfrac{\partial ^2z}{\partial x^2}\geq2&gt;0\)</span>，则 <span class="math inline">\(\dfrac{\partial z}{\partial x}\)</span> 随 <span class="math inline">\(x\)</span> 单调递增，有且仅有 <span class="math inline">\(x=1\)</span> 该根</p><p>若 <span class="math inline">\(0&lt;y_0&lt;1\)</span> ，有 <span class="math inline">\(y-2&lt;0\)</span>，<span class="math inline">\(\dfrac{\partial ^3z}{\partial x^3}=y(y-1)(y-2)x^{y-3}&gt;0\)</span>，<span class="math inline">\(\dfrac{\partial ^2z}{\partial x^2}\)</span> 随 <span class="math inline">\(x\)</span> 单调递增</p><p>取点 <span class="math inline">\(\dfrac{\partial ^2z}{\partial x^2}\big{|}_{x\to 0^{+}}\to -\infty\)</span>，<span class="math inline">\(\dfrac{\partial ^2z}{\partial x^2}\big{|}_{x=1}=2&gt;0\)</span>，由零点存在定理， <span class="math display">\[\exists\ !\ x_{0}\in (0,1),s.t.\dfrac{\partial ^2z}{\partial x^2}\big{|}_{x=x_0}=0\]</span> 则 <span class="math inline">\(\dfrac{\partial z}{\partial x}\)</span> 当 <span class="math inline">\(x\in (0,x_0)\)</span> 单调递减，当 <span class="math inline">\(x\in (x_0,+\infty)\)</span> 单调递增，又 <span class="math inline">\(\dfrac{\partial z}{\partial x}\big{|}_{x=1}=0\)</span> 则有</p><p><span class="math inline">\(\dfrac{\partial z}{\partial x}\big{|}_{x=x_0}&lt;0\)</span> 结合单调性可知，<span class="math inline">\(\dfrac{\partial z}{\partial x}\)</span> 在 <span class="math inline">\((0,+\infty)\)</span> 上有且仅有两个零点，一者 <span class="math inline">\(x_1\in (0,x_0)\)</span> ，一者</p><p>为 <span class="math inline">\(0\)</span> ，则 <span class="math inline">\(z\)</span> 关于 <span class="math inline">\(x\)</span> 在区间 <span class="math inline">\((0,x_1),(x_1,1),(1+\infty)\)</span> 上分别单调递增、单调递减、单调递增</p><p>但对于 <span class="math inline">\(x_1\neq 1\)</span> 其在固定 <span class="math inline">\(y\)</span> 的截面上为极大值，而在固定 <span class="math inline">\(x\)</span> 的截面时 <span class="math inline">\(\dfrac{\partial ^2z}{\partial y^2}=x^{y}\ln^2 x&gt;0\)</span> 为极小值</p><p>从而对所有的 <span class="math inline">\(x_1\)</span> 均为函数的鞍点，非极值点。而只要极值点坐标 <span class="math inline">\(x=1\)</span>，代入 <span class="math inline">\(\mbox{Hesse}\)</span> 矩阵有 <span class="math display">\[\mathbf{H}=\left[\begin{array}{cc}\dfrac{\partial^{2} z}{\partial x^{2}} &amp; \dfrac{\partial^{2} z}{\partial x \partial y} \\ \dfrac{\partial^{2} z}{\partial x \partial y} &amp; \dfrac{\partial^{2} z}{\partial y^{2}}\end{array}\right]=\left[\begin{array}{cc}y^{2}-y+2 &amp; 0 \\ 0 &amp; 0\end{array}\right]\]</span> 为正定矩阵，从而所有 <span class="math inline">\(x=1\)</span> 的点（一根直线）都是极小值点，极小值为 <span class="math inline">\(1\)</span>，无极大值</p><p><span class="math inline">\(y\leq 0\)</span> 或 <span class="math inline">\(y\geq 1\)</span>，<span class="math inline">\(x=1\)</span> 为最小值，<span class="math inline">\(0&lt;y&lt;1\)</span> 时，由单调性 <span class="math inline">\(\min z(x,y)=\min(1,z(x\to 0,y))\)</span></p><p>而 <span class="math inline">\(z(0,y)=1-y&gt;0\)</span>，从而 <span class="math inline">\(z(x,y)\)</span> 有最小值 <span class="math inline">\(1\)</span>，无最大值，其图像如下</p><p><img src="https://pic.imgdb.cn/item/62383ad327f86abb2a42d545.jpg" style="zoom:50%;" /></p><h2 id="讲义2.5.4">讲义2.5.4</h2><p>设 <span class="math inline">\(\gamma\)</span> 是由抛物线 <span class="math inline">\(y=c^{2}-x^{2}(-c \leq x \leq c)\)</span> 和 <span class="math inline">\(x\)</span> 轴上的线段组成的简单封闭曲线。求 <span class="math inline">\(\gamma\)</span> 的内接四边形的最大面积。</p><hr /><p>解：由于抛物线为凸函数，若四个点均在对称轴一侧，则固定其中三个点，将第四点移动到另一侧显然面积会增加；又若依据对称轴恰好一侧为三个点，一侧为一个点，则按照 <span class="math inline">\(y\)</span> 轴坐标大小排序中间两个点相连总有斜率 <span class="math inline">\(k\)</span>，若 <span class="math inline">\(k=0\)</span>，则可以调整上下任何一个点到以抛物线对称轴为对称中心的对称点使得面积一样；若 <span class="math inline">\(k\neq 0\)</span>，则总有一侧的点转移至相应对称点后总面积增加。综上，内接四边形面积最大时对称轴分开一定每侧两个点。（假设对称轴上的点划分到右侧）</p><p>设横坐标从左往右依次为 <span class="math inline">\(-c\leq x_1&lt;x_2&lt;0\leq x_3&lt;x_4\leq c\)</span>，固定 <span class="math inline">\(x_x,x_3,x_4\)</span> 有内接四边形面积仅与横坐标为 <span class="math inline">\(x_1\)</span> 的点到经过 <span class="math inline">\(x_3,x_4\)</span> 直线的距离有关，令直线方程 <span class="math inline">\(y=kx+b,k&lt;0,b&gt;0\)</span></p><p>点到直线距离公式 <span class="math inline">\(d=\dfrac{|kx_1+x_1^2-c^2+b|}{\sqrt{k^2+1}}\)</span>，其中 <span class="math inline">\(k=-(x_3+x_4)\in(-2c,0)\)</span>，<span class="math inline">\(b=x_3x_4+c^2\)</span></p><p>代入 <span class="math inline">\(d=\dfrac{|kx_1+x_1^2+x_3x_4|}{\sqrt{k^2+1}}\)</span>，有 <span class="math inline">\(|kx_1+x_1^2+x_3x_4|\leq |k||c|+c^2+x_3x_4\)</span>，条件 <span class="math inline">\(x_1=-c\)</span></p><p>由对称性可知 <span class="math inline">\(x_1=-c,x_4=c\)</span>。划分为两个三角形相加得到 <span class="math display">\[S\left(x_{2}, x_{3}\right)=\frac{1}{2} \cdot 2 c \cdot\left(c^{2}-x_{2}^{2}\right)+\frac{1}{2} \operatorname{det}\left|\begin{array}{cc}c-x_{2} &amp; x_{2}^{2}-c^{2} \\ x_{3}-x_{2} &amp; x_{2}^{2}-x_{3}^{2}\end{array}\right|=c^{3}+\frac{1}{2}\left(\left(x_{3}-x_{2}\right) c^{2}-\left(x_{2}^{2}+x_{3}^{2}\right) c+\left(x_{3}-x_{2}\right) x_{2} x_{3}\right)\]</span> 有 <span class="math inline">\(\dfrac{\partial S}{\partial x_2}=-\dfrac{1}{2}c^2-cx_2+\dfrac{1}{2}x_3^2-x_2x_3,\dfrac{\partial S}{\partial x_3}=\dfrac{1}{2}c^2-cx_3-\dfrac{1}{2}x_2^2+x_2x_3\)</span></p><p>当两者等于 <span class="math inline">\(0\)</span> 时，<span class="math inline">\(-2x_2+x_3=2x_3-x_2=c\)</span>，则 <span class="math inline">\(x_2=-\dfrac{1}{3}c\)</span>，<span class="math inline">\(x_3=\dfrac{1}{3}c\)</span></p><p>对应 <span class="math inline">\(\mbox{Hesse}\)</span> 矩阵为 <span class="math inline">\(\mathbf{H}=\left[\begin{array}{cc}\dfrac{\partial^{2} S}{\partial x^{2}} &amp; \dfrac{\partial^{2} S}{\partial x \partial y} \\ \dfrac{\partial^{2} S}{\partial x \partial y} &amp; \dfrac{\partial^{2} S}{\partial y^{2}}\end{array}\right]=\left[\begin{array}{cc}-c-x_{3} &amp; x_{3}-x_{2} \\ x_{3}-x_{2} &amp; -c+x_{2}\end{array}\right]=\frac{c}{3}\left[\begin{array}{cc}-2 &amp; 2 \\ 2 &amp; -4\end{array}\right]\)</span></p><p>为极大值，且最大值点在极大值处取到，<span class="math inline">\(S_{\max}=\dfrac{32}{27}c^3\)</span></p><h2 id="讲义2.5.5">讲义2.5.5</h2><p>证明: <span class="math inline">\(f(x, y)=-y+x^{2}+x y+x^{4}+y^{4}\)</span> 有唯一极值点, 并判断该极值点的类型。</p><hr /><p>证明：对该二元函数求偏导得 <span class="math display">\[\begin{gathered}\dfrac{\partial f}{\partial x}=2x+y+4x^{3},\dfrac{\partial f}{\partial y}=-1+x+4y^3\end{gathered}\]</span> 则极值点对应 <span class="math inline">\(y=-2x(1+2x^2),4y^3=1-x\)</span>，对应 <span class="math inline">\(\mbox{Hesse}\)</span> 矩阵有</p><p><span class="math display">\[\mathbf{H}=\left[\begin{array}{cc}\dfrac{\partial^{2} z}{\partial x^{2}} &amp; \dfrac{\partial^{2} z}{\partial x \partial y} \\ \dfrac{\partial^{2} z}{\partial x \partial y} &amp; \dfrac{\partial^{2} z}{\partial y^{2}}\end{array}\right]=\left[\begin{array}{cc}2+8 x^{2} &amp; 1 \\ 1 &amp; 12 y^{2}\end{array}\right]\]</span> 则由于 <span class="math inline">\(2+8x^2&gt;2&gt;0\)</span>，则该对称矩阵 <span class="math inline">\(\mathbf{H}\)</span> 只能为正定矩阵，其行列式大于等于 <span class="math inline">\(0\)</span> <span class="math display">\[24y^2(1+4x^2)\geq1 \]</span> 联立对应方程为 <span class="math inline">\(-32x^3(1+2x^2)^3=1-x\)</span>，则解不为 <span class="math inline">\(0\)</span>， <span class="math inline">\(f(x)=32x^3(1+2x^2)^3-x+1\)</span></p><p><span class="math inline">\(f&#39;(x)=32(3x^2(1+2x^2)^3)+x^3\cdot 12x(1+2x^2)^2-1=96x^2(1+2x^2)^2(1+6x^2)-1\)</span></p><p>考虑 <span class="math inline">\(x&gt;0\)</span> 的情况，<span class="math inline">\(f&#39;(x)\)</span> 在 <span class="math inline">\(x&gt;0\)</span> 时单调递增，<span class="math inline">\(f(0)=-1\)</span>，且有<span class="math inline">\(f(\dfrac{1}{4})&gt;6-1&gt;0\)</span>，由零点存在定理 <span class="math inline">\(\exists \ x_0\in (0,\dfrac{1}{4}),f&#39;(x_0)=0\)</span>，且有对 <span class="math inline">\(x&gt;0\)</span>，<span class="math inline">\(f(x)\)</span> 在<span class="math inline">\((0,x_0)\)</span> 单调递减，在 <span class="math inline">\((x_0,+\infty)\)</span></p><p>单调递增。而 <span class="math inline">\(f(\dfrac{1}{4})=\dfrac{1}{2}\cdot \dfrac{9}{8}^3-\dfrac{3}{4}=-\dfrac{39}{1024}&lt;0\)</span>，有 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((\dfrac{1}{4},+\infty)\)</span> 单调递增</p><p>且 <span class="math inline">\(f(1)&gt;1\)</span>，<span class="math inline">\(f(x_0)&lt;f(\dfrac{1}{4})&lt;0\)</span>，则在 <span class="math inline">\(x&gt;0\)</span> 处存在两个零点 <span class="math inline">\(x_1,x_2\)</span>，且有 <span class="math inline">\(x_1,x_2&lt;1\)</span></p><p>放缩不等式有 <span class="math inline">\(48y^2\cdot \dfrac{y}{-2x}=24y^2(2+4x^2)\geq24y^2(1+4x^2)\geq 1\)</span>，代入 <span class="math inline">\(4y^3=1-x\)</span></p><p>得到 <span class="math inline">\(\dfrac{6(1-x)}{-x}\geq 1\Longrightarrow \dfrac{1}{x}\leq \dfrac{5}{6}\)</span>，若 <span class="math inline">\(x&gt;0\)</span>，则至少需要 <span class="math inline">\(x\geq 1.2\)</span> 才能满足正定矩阵条件，矛盾</p><p>从而 <span class="math inline">\(x&lt;0\)</span>，由导函数知 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\((-x_0,0)\)</span> 单调递减，<span class="math inline">\(f(x_0)&gt;f(0)&gt;1\)</span>，而在 <span class="math inline">\((-\infty,x_0)\)</span></p><p>单调递增，从而由零点唯一性定理，存在唯一负数 <span class="math inline">\(x_3&lt;0\)</span>，使得 <span class="math inline">\(f(x_3)=0\)</span></p><p>此时有放缩 <span class="math inline">\(1-\dfrac{1}{x}\geq \dfrac{1}{3}\Longrightarrow \dfrac{12y^3}{-x}=24y^2\dfrac{y}{-2x}\geq 1\Longrightarrow 24y^2(1+2x^2)\geq 1\)</span></p><p>则满足条件 <span class="math inline">\(24y^2(1+4y^2)\geq 24y^2(1+2y^2)\geq 1\)</span>，则只有一个极值点，为极小值点，图像如下</p><p><img src="https://pic.imgdb.cn/item/62379e545baa1a80ab92ae28.jpg" style="zoom:50%;" /></p><h2 id="讲义2.8-习题讨论课3.3">讲义2.8 习题讨论课3.3</h2><p>求以下函数在指定点的 <span class="math inline">\(Peano\)</span> 余项 <span class="math inline">\(Taylor\)</span> 展开：</p><p><span class="math inline">\((a)\)</span> <span class="math inline">\(x^{y}\)</span> 在 <span class="math inline">\((x, y)=(1,0)\)</span> 处展开到二阶;</p><p><span class="math inline">\((b)\)</span> <span class="math inline">\(\lambda x+\mathrm{e}^{-\left(x^{2}+y^{2}\right)}\)</span> 在它的临界点处展开到二阶。</p><hr /><p>解：<span class="math inline">\((a)\)</span> 对多元函数 <span class="math inline">\(z(x,y)=x^y\)</span>，有一阶导： <span class="math display">\[\dfrac{\partial z}{\partial x}=y\cdot x^{y-1}=0,\dfrac{\partial z}{\partial y}=\ln (x)\cdot x^y=0\]</span> 二阶导： <span class="math display">\[\dfrac{\partial^2 z}{\partial x^2}=y(y-1)\cdot x^{y-2}=0,\dfrac{\partial ^2 z}{\partial y^2}=\ln ^2(x)\cdot x^y=0,\dfrac{\partial ^2 z}{\partial x\partial y}=x^{y-1}+y\ln x\cdot x^{y-1}=1\]</span> 从而展开有 <span class="math display">\[z=1+(\dfrac{\partial }{\partial x}+\dfrac{\partial }{\partial y})z+\dfrac{1}{2!}(\dfrac{\partial }{\partial x}+\dfrac{\partial }{\partial y})^2z=1+(x-1)y\]</span> 即有带 <span class="math inline">\(\mbox{peano}\)</span> 余项的 <span class="math inline">\(\mbox{Taylor}\)</span> 展开式为 <span class="math inline">\(z=1+y(x-1)+o(x^2+y^2)\)</span></p><p><span class="math inline">\((b)\)</span> 对多元函数 <span class="math inline">\(z(x,y)=\lambda x+e^{-(x^2+y^2)}\)</span>​ 有一阶导 <span class="math display">\[\dfrac{\partial z}{\partial x}=\lambda-2xe^{-(x^2+y^2)},\dfrac{\partial z}{\partial y}=-2ye^{-(x^2+y^2)}\]</span> 对于临界点两者取零 <span class="math inline">\(y=0,\lambda =2xe^{-x^2}=f(x)\)</span> 有对 <span class="math inline">\(f(x)\)</span> 求导 <span class="math inline">\(f&#39;(x)=(2-4x^2)e^{-x^2}\)</span></p><p><span class="math inline">\(x\in (-\infty,-\dfrac{\sqrt{2}}{2})\ \cap\ (\dfrac{\sqrt{2}}{2},+\infty),f&#39;(x)&lt;0\)</span>，<span class="math inline">\(f(x)\)</span> 单调递减；<span class="math inline">\(x\in (-\dfrac{\sqrt{2}}{2},\dfrac{\sqrt{2}}{2})\)</span></p><p><span class="math inline">\(f&#39;(x)&gt;0\)</span>，<span class="math inline">\(f(x)\)</span> 单调递增。当 <span class="math inline">\(x\to -\infty\)</span> 时，<span class="math inline">\(2xe^{-x^2}\to 0^{-}\)</span>，<span class="math inline">\(f(-\dfrac{\sqrt{2}}{2})=-\sqrt{\dfrac{2}{e}}\)</span></p><p><span class="math inline">\(f(\dfrac{\sqrt{2}}{2})=\sqrt{\dfrac{2}{e}}\)</span>，结合单调性有 <span class="math inline">\(f(x)\in (-\sqrt{\dfrac{2}{e}},\sqrt{\dfrac{2}{e}})\)</span>，当且仅当 <span class="math inline">\(|\lambda|\leq \sqrt{\dfrac{2}{e}}\)</span> 时有临界点</p><p>而该多元函数的二阶导有 <span class="math display">\[\dfrac{\partial^2 z}{\partial x^2}=(4x^2-2)e^{-(x^2+y^2)},\dfrac{\partial^2 z}{\partial y^2}=(4y^2-2)e^{-(x^2+y^2)},\dfrac{\partial^2 z}{\partial x \partial y}=4xye^{-(x^2+y^2)}\]</span> 记满足 <span class="math inline">\(2xe^{-x^2}=\lambda\)</span> 方程的解为 <span class="math inline">\(x_0\)</span>（若有多个解，考虑其中一个解）对原函数展开有 <span class="math display">\[\begin{gathered}\lambda x+e^{-(x^2+y^2)}=\lambda x_0+e^{-x_0^2}+\dfrac{1}{2}(\dfrac{\partial }{\partial x}+\dfrac{\partial }{\partial y})^2z=\lambda x_0+e^{-x_0^2}+(2x_0^2-1)e^{-x_0^2}(x-x_0)\\-e^{-x_0^2}y+0+o(x^2+y^2)=\lambda(x_0+\dfrac{1-y}{2x_0}+(2x_0-\dfrac{1}{x_0})(x-x_0))+o(x^2+y^2)\end{gathered}\]</span></p><h2 id="讲义2.8-习题讨论课3.4">讲义2.8 习题讨论课3.4</h2><p>对参数 <span class="math inline">\(\lambda\)</span>, 讨论函数 <span class="math inline">\(\lambda x+\mathrm{e}^{-\left(x^{2}+y^{2}\right)}\)</span> 的极值情况。</p><hr /><p>解：由上一题可知，当且仅当 <span class="math inline">\(-\sqrt{\dfrac{2}{e}}\leq \lambda \leq \sqrt{\dfrac{2}{e}}\)</span> 时有临界点，而对应 <span class="math inline">\(\mbox{Hesse}\)</span> 矩阵有 <span class="math display">\[\mathbf{H}=\left[\begin{array}{cc}\dfrac{\partial^{2} z}{\partial x^{2}} &amp; \dfrac{\partial^{2} z}{\partial x \partial y} \\ \dfrac{\partial^{2} z}{\partial x \partial y} &amp; \dfrac{\partial^{2} z}{\partial y^{2}}\end{array}\right]=2 e^{-\left(x^{2}+y^{2}\right)}\left[\begin{array}{cc}2 x^{2}-1 &amp; 2 x y \\ 2 x y &amp; 2 y^{2}-1\end{array}\right]\]</span> 求解对应特征值 <span class="math display">\[\det(\mathbf{H-\lambda \mathbf{I}})=(2x^2-1-\lambda)\cdot (2y^2-1-\lambda)-4x^2y^2=(\lambda+1)^2-2(\lambda+1)(x^2+y^2)\]</span> 则特征值为 <span class="math inline">\(\lambda_1=-1,\lambda_2=2x^2+2y^2-1\)</span>，则若函数存在极值点，只能 <span class="math inline">\(\lambda_1,\lambda_2\)</span> 均小于零</p><p>为极大值点，此时 <span class="math inline">\(2x^2+2y^2\leq1\Longrightarrow x^2\leq\dfrac{1}{2}\)</span>，由上一题的单调性可知 <span class="math inline">\(-\sqrt{\dfrac{2}{e}}\leq \lambda \leq \sqrt{\dfrac{2}{e}}\)</span></p><p>综上所述，<span class="math inline">\(-\sqrt{\dfrac{2}{e}}\leq \lambda \leq \sqrt{\dfrac{2}{e}}\)</span> 时有极大值点，令 <span class="math inline">\(2xe^{-x^2}=\lambda\)</span> 绝对值不超过 <span class="math inline">\(\dfrac{\sqrt{2}}{2}\)</span> 的解为 <span class="math inline">\(x_0\)</span>，该极大值点位于 <span class="math inline">\((x_0,0)\)</span>，极大值为 <span class="math inline">\(e^{-x_0^2}+\lambda x_0=\lambda(x_0+\dfrac{1}{2x_0})\)</span>，否则无极值点</p><h1 id="largetextcolorblue微积分第五次作业-smallwtimes-f-_textcolorblue2022.3.29"><span class="math inline">\(\large\textcolor{blue}{微积分第五次作业\ \small(W\times f)}\ \ \ \ \ \ _\textcolor{blue}{2022.3.29}\)</span></h1><h2 id="讲义3.1.4">讲义3.1.4</h2><p>证明 <span class="math inline">\(-y+x^{2}+x y+x^{4}+y^{4}=0\)</span> 在 <span class="math inline">\((0,0)\)</span> 的一个邻域内定义了一个 <span class="math inline">\(C^{\infty}\)</span> 隐函数 <span class="math inline">\(y=h(x)\)</span>, 并求 <span class="math inline">\(h\)</span> 在 <span class="math inline">\(x=0\)</span> 处的四阶泰勒展开式。</p><hr /><p>解：对 <span class="math inline">\(-y+x^2+xy+x^4+y^4=0\)</span> 令 <span class="math inline">\(x,y\to 0\)</span> 使用 <span class="math inline">\(o\)</span> 语言有 <span class="math display">\[-y+x^2+o(y)+o(x^2)+o(y)=0\Longrightarrow y=x^2+o(x^2)\]</span> 令 <span class="math inline">\(y=x^2+u\)</span> 代入有 <span class="math display">\[-u+x^2(x+u)+x^4+(x^2+u)^4=0=-u+x^3+o(u)+o(x^3)+o(x^3)+o(u)\]</span> 则 <span class="math inline">\(u=x^3+o(x^3)\)</span>，令 <span class="math inline">\(y=x^2+x^3+v\)</span> 代入有 <span class="math display">\[-x^3-v+x(x^2+x^3+v)+x^4+(x^2+x^3+v)^4=-v+2x^4+o(v)+o(x^4)=0\]</span> 则 <span class="math inline">\(v=2x^4+o(x^4)\)</span>，从而在 <span class="math inline">\((0,0)\)</span> 处四阶泰勒展开为 <span class="math inline">\(y=x^2+x^3+2x^4+o(x^4)\)</span></p><h2 id="讲义3.1.5">讲义3.1.5</h2><p>设 <span class="math inline">\(f: U \times V \rightarrow \mathbb{R}\)</span> 是 <span class="math inline">\(C^{2}\)</span> 函数, <span class="math inline">\(\mathbf{x}_{0}\)</span> 是 <span class="math inline">\(f\left(\cdot, \lambda_{0}\right)\)</span> 的非退化临界点, 即 <span class="math inline">\(f\left(\mathbf{x}, \lambda_{0}\right)\)</span> 关于 <span class="math inline">\(\mathbf{x}\)</span> 在 <span class="math inline">\(\mathbf{x}_{0}\)</span> 处的 <span class="math inline">\(Hesse\)</span> 矩阵是可逆的。证明对足够接近 <span class="math inline">\(\lambda_{0}\)</span> 的所有 <span class="math inline">\(\lambda\)</span>, <span class="math inline">\(f(\mathbf{x}, \lambda)\)</span> 关于 <span class="math inline">\(\mathbf{x}\)</span> 在 <span class="math inline">\(\mathbf{x}_{0}\)</span> 附近有唯一的临界点, 并且该临界点的类型与 <span class="math inline">\(\mathbf{x}_{0}\)</span> 作为 <span class="math inline">\(f\left(\cdot, \lambda_{0}\right)\)</span> 的临界点的类型是一样的。</p><hr /><p>证明：由 <span class="math inline">\(\dfrac{\partial f}{\partial \mathbf{x}}=\vec{0},\dfrac{\partial f}{\partial \lambda}=0\)</span> 有 <span class="math inline">\(\dfrac{\partial f_1}{\partial \mathbf{x}^{i}}(\mathbf{x},\lambda)=0,\dfrac{\partial f_1}{\partial \lambda}(\mathbf{x},\lambda)=0\)</span>，该组隐函数确定了 <span class="math inline">\(\lambda=\lambda(\mathbf{x})\)</span></p><p>这是由于 <span class="math inline">\(f(\mathbf{x}_0,\lambda)\)</span> 在 <span class="math inline">\(\mathbf{x}=\mathbf{x}_0\)</span> 处的 <span class="math inline">\(Hesse\)</span> 矩阵是可逆的，从而在 <span class="math inline">\(\mathbf{x}_0\)</span> 附近，都能找到唯一临界点 <span class="math inline">\(\lambda\)</span></p><p>又由于 <span class="math inline">\(\det(\mathbf{H})\big|_{\lambda_0,\mathbf{x}_0}\neq 0\)</span> 且 <span class="math inline">\(\det\)</span> 函数是连续的，从而总能找到 <span class="math inline">\(\lambda\)</span> 附近的领域，使得 <span class="math inline">\(\det \mathbf{H}\)</span> 在该</p><p>领域内是保号的，正定对称矩阵附近仍为正定对称矩阵，负定也为负定，从而临界点类型是一样的</p><h2 id="讲义3.1.7">讲义3.1.7</h2><p>设 <span class="math inline">\(\lambda_{0}\)</span> 是矩阵 <span class="math inline">\(A_{0}\)</span> 的一个单重特征值 (即 <span class="math inline">\(p\left(\lambda_{0}\right)=0, p^{\prime}\left(\lambda_{0}\right) \neq 0\)</span>, 其中 <span class="math inline">\(p(\lambda)=\)</span> <span class="math inline">\(\left.\operatorname{det}\left(\lambda I-A_{0}\right)\right), \mathbf{x}_{0}\)</span> 是 <span class="math inline">\(A_{0}\)</span> 对应于 <span class="math inline">\(\lambda_{0}\)</span> 的一个单位特征向量。证明存在 <span class="math inline">\(\delta&gt;0\)</span> 使得对任意矩阵 <span class="math inline">\(A\)</span>, 只要 <span class="math inline">\(\left\|A-A_{0}\right\|&lt;\delta, A\)</span> 就有唯一的特征值 <span class="math inline">\(\lambda(A)\)</span> 和相应的单位特征向量 <span class="math inline">\(\mathbf{x}(A)\)</span> 使得 <span class="math inline">\(\lambda\left(A_{0}\right)=\lambda_{0}, \mathbf{x}\left(A_{0}\right)=\mathbf{x}_{0}\)</span>, 并且 <span class="math inline">\(\lambda(A)\)</span> 和 <span class="math inline">\(\mathbf{x}(A)\)</span> 关于 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(C^{\infty}\)</span> 的。</p><hr /><p>证明：由 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(\lambda\)</span> 由下列隐函数方程确定， <span class="math inline">\(f(A,\lambda)=\det(\lambda I-A)=p_{A}(\lambda)=0\)</span></p><p>而由题设条件，该方程满足 <span class="math inline">\(\dfrac{\partial f}{\partial \lambda}\big |_{\lambda=\lambda_0}=p&#39;(\lambda_0)\neq 0\)</span>，且在该处只有 <span class="math inline">\(n\)</span> 次求导后的结果是非零的，从而该方程在 <span class="math inline">\(A,\lambda_0\)</span> 领域所确定的 <span class="math inline">\(\lambda(A)\)</span> 关于 <span class="math inline">\(A\)</span> 只能达到 <span class="math inline">\(C^{n}\)</span></p><p>而确定 <span class="math inline">\(\lambda\)</span> 后，<span class="math inline">\(g(A,\lambda,\vec{\mathbf{x}})=g(A,\lambda(A),\vec{\mathbf{x}})=(A-\lambda I)\vec{\mathbf{x}}=0\)</span>，有 <span class="math inline">\(\dfrac{\partial g}{\partial \mathbf{x^i}}=(A-\lambda I)_{i}\)</span></p><p>为 <span class="math inline">\((A-\lambda I)\)</span> 第 <span class="math inline">\(i\)</span> 列，若其为 <span class="math inline">\(0\)</span>，由行列式性质 <span class="math inline">\(p_{A}(\lambda I-A)=0\)</span>，与题设矛盾，从而均不为 <span class="math inline">\(0\)</span></p><p>则确定了隐函数方程 <span class="math inline">\(\mathbf{x}=\mathbf{x}(A,\lambda(A))=\mathbf{x}(A)\)</span> ，对高阶导由线性性质，只有对角元上有非零元素，</p><p>从而 <span class="math inline">\(\dfrac{\partial ^nf}{\partial \mathbf{x}^n}\)</span> 确定的线性映射都是可逆的，从而 <span class="math inline">\(\mathbf{x}(A)\)</span> 为 <span class="math inline">\(C^{\infty }\)</span> 的</p><h2 id="讲义3.2.1">讲义3.2.1</h2><p>设 <span class="math display">\[f\left(x_{1}, x_{2}\right)=\left(x_{1} x_{2},\left(1-x_{1}\right) x_{2}\right) .\]</span> 证明 <span class="math inline">\(f\)</span> 是 <span class="math inline">\((0,1) \times(0,1)\)</span> 到 <span class="math inline">\(\left\{\left(y_{1}, y_{2}\right) \mid y_{1}&gt;0, y_{2}&gt;0, y_{1}+y_{2}&lt;1\right\}\)</span> 的微分同胚。</p><hr /><p>证明：对于变换 <span class="math inline">\(\begin{cases}y_1=x_1x_2\\y_2=(1-x_1)x_2\end{cases}\)</span> 反解得 <span class="math inline">\(x_1=\dfrac{y_1}{y_1+y_2},x_2=y_1+y_2\)</span></p><p>则有 <span class="math inline">\(y_1+y_2&lt;1\)</span> 对应 <span class="math inline">\(x_1&lt;1,x_2&lt;1\)</span>，则 <span class="math inline">\(f\)</span> 在 <span class="math inline">\((0,1)\longmapsto(0,1)\)</span> 上是双射，满足一一对应，从而</p><p><span class="math inline">\(f\)</span> 微分同胚</p><h2 id="讲义3.2.2">讲义3.2.2</h2><p>记 <span class="math inline">\(\mathcal{S}_{n}\)</span> 为所有 <span class="math inline">\(n\)</span> 阶对称矩阵组成的线性空间, <span class="math inline">\(\mathcal{P}_{n}\)</span> 为所有 <span class="math inline">\(n\)</span> 阶对称正定矩阵组成的集合。证明</p><p><span class="math inline">\((a)\)</span> <span class="math inline">\(\mathcal{P}_{n}\)</span> 是 <span class="math inline">\(\mathcal{S}_{n}\)</span> 的开子集;</p><p><span class="math inline">\((b)\)</span> 对任意 <span class="math inline">\(A \in \mathcal{P}_{n}\)</span>, 存在唯一的 <span class="math inline">\(A^{1 / 2} \in \mathcal{P}_{n}\)</span> 使得 <span class="math inline">\(\left(A^{1 / 2}\right)^{2}=A\)</span>, 并且 <span class="math inline">\(A^{1 / 2}\)</span> 关于 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(C^{\infty}\)</span> 的。</p><hr /><p>证明：<span class="math inline">\((a)\)</span> 显然 <span class="math inline">\(\mathcal{S}_{n}\)</span> 是 <span class="math inline">\(\mathcal{P}_{n}\)</span> 的真子集，而对于 <span class="math inline">\(A\in \mathcal{P}\)</span> 为对称正定矩阵，由线性代数知识 <span class="math display">\[A\ 对称正定\Longleftrightarrow \forall \ \mathbf{x}\in \mathbb{R}^n,\mathbf{x}^TA\mathbf{x}&gt;0\]</span> 考虑 <span class="math inline">\(f(A)=\mathbf{x^T}A\mathbf{x}\)</span> 关于 <span class="math inline">\(A\)</span> 是连续的，由于对所有 <span class="math inline">\(\mathbf{x}\)</span> 该连续函数 <span class="math inline">\(f(A)&gt;0\)</span>，</p><p>则总能找到 <span class="math inline">\(A\)</span> 的领域使得所有的 <span class="math inline">\(f(A+E)&gt;0\)</span>，即所有 <span class="math inline">\(n\)</span> 阶对称正定矩阵组成的集合为开集</p><p><span class="math inline">\((b)\)</span> 先证存在性，令 <span class="math inline">\(A=L\mbox{diag}(\lambda_1,\lambda_2,\cdots,\lambda_n)L^{T},A^{\frac{1}{2}}:=L\mbox{diag}(\sqrt{\lambda_1},\sqrt{\lambda_2},\cdots,\sqrt{\lambda_n})L^{T}\)</span></p><p>此时有 <span class="math inline">\((A^{\frac{1}{2}})^2=L\mbox{diag}(\sqrt{\lambda_1},\sqrt{\lambda_2},\cdots,\sqrt{\lambda_n})L^{T}L\mbox{diag}(\sqrt{\lambda_1},\sqrt{\lambda_2},\cdots,\sqrt{\lambda_n})L^{T}=A\)</span></p><p>再证唯一性，若有 <span class="math inline">\(B_1^2=B_2^2=A\)</span>，且 <span class="math inline">\(B_1,B_2\in \mathcal{P}_n\)</span>，令 <span class="math inline">\(B_1=L_1D_1L_1^{T},B_2=L_2D_2L_2^{T}\)</span></p><p>代入有 <span class="math inline">\(L_1D_1^2L_1^{T}=L_2D_2^2L_2^{T}=A\Longrightarrow L_2^{-1}L_1=D_2^2L_2^{T}(L_1^{T})^{-1}(D_1^{-1})^2\)</span></p><p>左侧为上三角矩阵，右侧为下三角矩阵，从而 <span class="math inline">\(L_2^{-1}L_1=I\Longrightarrow L_1=L_2,D_1=D_2\)</span></p><p>即 <span class="math inline">\(B\)</span> 存在且唯一。由该“求根”映射为双射，其逆映射 <span class="math inline">\(A^{\frac{1}{2}}\longmapsto A\)</span> 无穷可微</p><p>这是因为 <span class="math inline">\(D(A^2)(B)=(A+B)^2-A^2=AB+BA+o(\|B\|)\)</span>，显然可以不断微分下去</p><p>由逆映射定理知，<span class="math inline">\(A^{\frac{1}{2}}\)</span> 关于 <span class="math inline">\(A\)</span> 也是 <span class="math inline">\(C^{\infty}\)</span> 的</p><h2 id="讲义3.3.1">讲义3.3.1</h2><p>设 <span class="math inline">\(f, g, h\)</span> 都是自变量 <span class="math inline">\(x, y\)</span> 的函数, 证明</p><p><span class="math inline">\((a)\)</span> <span class="math inline">\(\left(\dfrac{\partial f}{\partial g}\right)_{x}=\left(\dfrac{\partial f}{\partial y}\right)_{x} /\left(\dfrac{\partial g}{\partial y}\right)_{x}\)</span>;</p><p><span class="math inline">\((b)\)</span> <span class="math inline">\(\left(\dfrac{\partial y}{\partial x}\right)_{f}=-\left(\dfrac{\partial f}{\partial x}\right)_{y} /\left(\dfrac{\partial f}{\partial y}\right)_{x}\)</span>;</p><p><span class="math inline">\((c)\)</span> <span class="math inline">\(\left(\dfrac{\partial f}{\partial x}\right)_{g}=\left(\dfrac{\partial f}{\partial x}\right)_{y}+\left(\dfrac{\partial f}{\partial y}\right)_{x}\left(\dfrac{\partial y}{\partial x}\right)_{g}\)</span> 。</p><hr /><p>证明：<span class="math inline">\((a)\)</span> 由所证明式子保持 <span class="math inline">\(x\)</span> 不变，则有 <span class="math inline">\(df=\dfrac{\partial f}{\partial y}dy,dg=\dfrac{\partial f}{\partial y}dy\)</span>，两者相比得 <span class="math display">\[\dfrac{df}{dg}_{x=\tiny \mbox{Const}}=(\dfrac{\partial f}{\partial g})_x=\dfrac{(\dfrac{\partial f}{\partial y})_{x}}{(\dfrac{\partial g}{\partial y})_x}\]</span> <span class="math inline">\((b)\)</span> 对 <span class="math inline">\(f=f(x,y)\)</span> 全微分有 <span class="math inline">\(df=\dfrac{\partial f}{\partial x}dx+\dfrac{\partial f}{\partial y}dy\)</span>，当 <span class="math inline">\(f\)</span> 不变时计算 <span class="math inline">\((\dfrac{\partial y}{\partial x})_f\)</span> 得 <span class="math display">\[0=\dfrac{\partial f}{\partial x}dx+\dfrac{\partial f}{\partial y}dy\Longrightarrow (\dfrac{\partial y}{\partial x})_f=-\dfrac{(\dfrac{\partial f}{\partial x})_{y}}{(\dfrac{\partial f}{\partial y})_x}\]</span> <span class="math inline">\((c)\)</span> 当 <span class="math inline">\(g\)</span> 不变时有，<span class="math inline">\(0=\dfrac{\partial g}{\partial x}dx+\dfrac{\partial g}{\partial y}dy\)</span>，代入 <span class="math inline">\(df=\dfrac{\partial f}{\partial x}dx+\dfrac{\partial f}{\partial y}dy\)</span> 消去 <span class="math inline">\(dy\)</span> 后有 <span class="math display">\[df=\dfrac{\partial f}{\partial x}dx+\dfrac{\partial f}{\partial y}\cdot (-\dfrac{\dfrac{\partial g}{\partial x} }{\dfrac{\partial g}{\partial y}}dx)\]</span> 其中 <span class="math inline">\(dg=\dfrac{\partial g}{\partial x}dx+\dfrac{\partial g}{\partial y}dy\)</span>，则固定 <span class="math inline">\(g\)</span> 不变有，<span class="math inline">\((\dfrac{\partial y}{\partial x})_g=-\dfrac{\dfrac{\partial g}{\partial x} }{\dfrac{\partial g}{\partial y}}\)</span> 代入有 <span class="math display">\[(\dfrac{\partial f}{\partial x})_g=(\dfrac{\partial f}{\partial x})_y+(\dfrac{\partial f}{\partial y})_x(\dfrac{\partial y}{\partial x})_g\]</span></p><h2 id="讲义3.3.2">讲义3.3.2</h2><p>设 <span class="math inline">\(f_{1}, \ldots, f_{n} ; u_{1}, \ldots, u_{n}\)</span> 都是独立变量 <span class="math inline">\(x_{1}, \ldots, x_{n}\)</span> 的函数。证明</p><p><span class="math inline">\((a)\)</span> <span class="math inline">\(\operatorname{det} \dfrac{\partial\left(f_{1}, \ldots, f_{n}\right)}{\partial\left(u_{1}, \ldots, u_{n}\right)}=\operatorname{det} \dfrac{\partial\left(f_{1}, \ldots, f_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)} / \operatorname{det} \dfrac{\partial\left(u_{1}, \ldots, u_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)}\)</span>;</p><p><span class="math inline">\((b)\)</span> <span class="math inline">\(\left(\dfrac{\partial f_{1}}{\partial x_{1}}\right)_{f_{2}, \ldots, f_{n}}=\operatorname{det} \dfrac{\partial\left(f_{1}, \ldots, f_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)} / \operatorname{det} \dfrac{\partial\left(f_{2}, \ldots, f_{n}\right)}{\partial\left(x_{2}, \ldots, x_{n}\right)}\)</span>;</p><p><span class="math inline">\((c)\)</span> <span class="math inline">\(\left(\dfrac{\partial f_{1}}{\partial u_{1}}\right)_{u_{2}, \ldots, u_{n}}=\operatorname{det} \dfrac{\partial\left(f_{1}, u_{2}, \ldots, u_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)} / \operatorname{det} \dfrac{\partial\left(u_{1}, \ldots, u_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)}\)</span> 。</p><hr /><p>证明：<span class="math inline">\((a)\)</span> 由各组微体积元之比为 <span class="math display">\[\begin{gathered}df_1df_2\cdots df_n=\det(\dfrac{\partial\left(f_{1}, \ldots, f_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)})dx_1dx_2\cdots dx_n\\df_1df_2\cdots df_n=\det(\dfrac{\partial\left(f_{1}, \ldots, f_{n}\right)}{\partial\left(u_{1}, \ldots, u_{n}\right)})du_1du_2\cdots du_n\\du_1du_2\cdots du_n=\det(\dfrac{\partial\left(u_{1}, \ldots, u_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)})dx_1dx_2\cdots dx_n\\\end{gathered}\]</span> 从而得到 <span class="math inline">\(\operatorname{det} \dfrac{\partial\left(f_{1}, \ldots, f_{n}\right)}{\partial\left(u_{1}, \ldots, u_{n}\right)}=\dfrac{df_1\cdots df_n}{du_1\cdots du_n}=\operatorname{det} \dfrac{\partial\left(f_{1}, \ldots, f_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)} / \operatorname{det} \dfrac{\partial\left(u_{1}, \ldots, u_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)}\)</span></p><p><span class="math inline">\((b)\)</span> 由固定 <span class="math inline">\(f_2,f_3,\cdots,f_n\)</span> 有 <span class="math inline">\(df_2=df_3=\cdots=df_n=0\)</span> <span class="math display">\[df_2=\dfrac{\partial f_2}{\partial x_1}dx_1+\cdots+\dfrac{\partial f_2}{\partial x_n}dx_n,df_3=\dfrac{\partial f_3}{\partial x_1}dx_1+\cdots+\dfrac{\partial f_3}{\partial x_n}dx_n\cdots ,df_n=\cdots\]</span> 移项写成矩阵的形式有 <span class="math inline">\(\dfrac{\partial (f_2,f_3\cdots,f_n)}{\partial (x_2,x_3\cdots,x_n)}\begin{pmatrix}dx_2\\dx_3\\\vdots\\dx_n\end{pmatrix}=A\begin{pmatrix}dx_2\\dx_3\\\vdots\\dx_n\end{pmatrix}=-\begin{pmatrix}\dfrac{\partial f_2}{\partial x_2}\\\dfrac{\partial f_3}{\partial x_3}\\\vdots\\\dfrac{\partial f_n}{\partial x_n}\end{pmatrix}dx_1\)</span> 代入计算有</p><p><span class="math inline">\(df_1=\dfrac{\partial f_1}{\partial x_1}dx_1+\cdots+\dfrac{\partial f_1}{\partial x_n}dx_n=dx_1(\dfrac{\partial f_1}{\partial x_1}-\begin{pmatrix}\dfrac{\partial f_1}{\partial x_2}\\\dfrac{\partial f_1}{\partial x_3}\\\vdots\\\dfrac{\partial f_1}{\partial x_n}\end{pmatrix}^{T}A^{-1}\begin{pmatrix}\dfrac{\partial f_2}{\partial x_2}\\\dfrac{\partial f_3}{\partial x_3}\\\vdots\\\dfrac{\partial f_n}{\partial x_n}\end{pmatrix})=dx_1(\dfrac{\partial f_1}{\partial x_1}-\vec{v}_1^{T}A^{-1}\vec{v}_2)\)</span></p><p>由矩阵分块 <span class="math inline">\(B=\operatorname{det} \dfrac{\partial\left(f_{1}, \ldots, f_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)}=\begin{pmatrix}\dfrac{\partial f_1}{\partial x_1}&amp;\vec{v_1}^{T}\\\vec{v}_2&amp;A\end{pmatrix}\)</span> <span class="math display">\[\dfrac{\det B}{\det A}=\dfrac{\det \begin{pmatrix}\dfrac{\partial f_1}{\partial x_1}&amp;\vec{v_1}^{T}\\\vec{v}_2&amp;A\end{pmatrix}}{\det A}=\dfrac{\det \begin{pmatrix}\dfrac{\partial f_1}{\partial x_1}-\vec{v}_1^{T}A^{-1}\vec{v}_2&amp;\vec{v_1}^{T}\\\vec{0}&amp;A\end{pmatrix}}{\det A}=(\dfrac{\partial f_1}{\partial x_1})_{f_2,\cdots,f_n}\]</span> 即有 <span class="math inline">\(\left(\dfrac{\partial f_{1}}{\partial x_{1}}\right)_{f_{2}, \ldots, f_{n}}=\operatorname{det} \dfrac{\partial\left(f_{1}, \ldots, f_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)} / \operatorname{det} \dfrac{\partial\left(f_{2}, \ldots, f_{n}\right)}{\partial\left(x_{2}, \ldots, x_{n}\right)}\)</span></p><p><span class="math inline">\((3)\)</span>​ 由固定 <span class="math inline">\(u_2,u_3,\cdots,u_n\)</span> 有 <span class="math inline">\(du_2=du_3=\cdots=du_n=0\)</span> <span class="math display">\[du_2=\dfrac{\partial u_2}{\partial x_1}dx_1+\cdots+\dfrac{\partial u_2}{\partial x_n}dx_n,du_3=\dfrac{\partial u_3}{\partial x_1}dx_1+\cdots+\dfrac{\partial u_3}{\partial x_n}dx_n\cdots ,du_n=\cdots\]</span> 移项写成矩阵形式有 <span class="math inline">\(\dfrac{\partial (u_2,u_3\cdots,u_n)}{\partial (x_2,x_3\cdots,x_n)}\begin{pmatrix}dx_2\\dx_3\\\vdots\\dx_n\end{pmatrix}=A\begin{pmatrix}dx_2\\dx_3\\\vdots\\dx_n\end{pmatrix}=-\begin{pmatrix}\dfrac{\partial u_2}{\partial x_2}\\\dfrac{\partial u_3}{\partial x_3}\\\vdots\\\dfrac{\partial u_n}{\partial x_n}\end{pmatrix}dx_1\)</span>，代入</p><p>由上问结论可推知，<span class="math inline">\(du_1=\dfrac{\partial u_1}{\partial x_1}dx_1+\cdots+\dfrac{\partial u_1}{\partial x_n}dx_n=dx_1\dfrac{\operatorname{det} \dfrac{\partial\left(u_{1}, \ldots, u_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)}}{\det A}\)</span></p><p><span class="math inline">\(df_1=\dfrac{\partial f_1}{\partial x_1}dx_1+\cdots+\dfrac{\partial f_1}{\partial x_n}dx_n=dx_1(\dfrac{\partial f_1}{\partial x_1}-\begin{pmatrix}\dfrac{\partial f_1}{\partial x_2}\\\dfrac{\partial f_1}{\partial x_3}\\\vdots\\\dfrac{\partial f_1}{\partial x_n}\end{pmatrix}^{T}A^{-1}\begin{pmatrix}\dfrac{\partial u_2}{\partial x_2}\\\dfrac{\partial u_3}{\partial x_3}\\\vdots\\\dfrac{\partial u_n}{\partial x_n}\end{pmatrix})=dx_1(\dfrac{\partial f_1}{\partial x_1}-\vec{v}_1^{T}A^{-1}\vec{v}_2)\)</span></p><p>由矩阵分块 <span class="math inline">\(C=\operatorname{det} \dfrac{\partial\left(f_{1}, u_{2}, \ldots, u_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)}=\begin{pmatrix}\dfrac{\partial f_1}{\partial x_1}&amp;\vec{v_1}^{T}\\\vec{v}_2&amp;A\end{pmatrix}\)</span> <span class="math display">\[\dfrac{\det C}{\det A}=\dfrac{\det \begin{pmatrix}\dfrac{\partial f_1}{\partial x_1}&amp;\vec{v_1}^{T}\\\vec{v}_2&amp;A\end{pmatrix}}{\det A}=\dfrac{\det \begin{pmatrix}\dfrac{\partial f_1}{\partial x_1}-\vec{v}_1^{T}A^{-1}\vec{v}_2&amp;\vec{v_1}^{T}\\\vec{0}&amp;A\end{pmatrix}}{\det A}=(\dfrac{\partial f_1}{\partial x_1})_{u_2,\cdots,u_n}\]</span></p><p><span class="math display">\[\left(\dfrac{\partial f_{1}}{\partial u_{1}}\right)_{u_{2}, \ldots, u_{n}}=\dfrac{\det C}{\det A}\cdot \dfrac{\det A}{\det \dfrac{\partial\left(u_{1}, \ldots, u_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)}}=\dfrac{\operatorname{det} \dfrac{\partial\left(f_{1}, u_{2}, \ldots, u_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)} }{\operatorname{det} \dfrac{\partial\left(u_{1}, \ldots, u_{n}\right)}{\partial\left(x_{1}, \ldots, x_{n}\right)}}\]</span></p><h2 id="讲义3.4.3">讲义3.4.3</h2><p>绘制平面地图有很多方法, <span class="math inline">\(Mercator\)</span> 投影是其中之一。如图所示, 它把球面上的点 <span class="math inline">\(P(x, y, z)\)</span> 映为从球心出发的射线 <span class="math inline">\(O P\)</span> 与一个圆柱面的交点 <span class="math inline">\(P^{\prime}(\lambda x, \lambda y, \lambda z)\)</span>, 然后在柱面上再做一个变换得到点 <span class="math inline">\(Q(\lambda x, \lambda y, f(\lambda z))\)</span>, 该圆柱面与球面相切于赤道。这样除南北两极外, 地球上的点 <span class="math inline">\(P\)</span> 与柱面上的点 <span class="math inline">\(Q\)</span> 一一对应, 把圆柱面沿母线剪开就得到一张地图。求函数 <span class="math inline">\(f\)</span> 的表达式使得 <span class="math inline">\(Mercator\)</span> 地图上所画的两条相交道路的夹角与实际道路的夹角大小相等。两条相交曲线的夹角被定义为它们的切线所形成的夹角(锐角或直角)。(提示：线性变换 <span class="math inline">\(A: \mathbb{R}^{n} \rightarrow \mathbb{R}^{n}\)</span> 保角当且仅当它把正交且长度相等的向量映为正交且长度相等的向量, 从而存在常数 <span class="math inline">\(C&gt;0\)</span> 使得内积 <span class="math inline">\(\left.\langle A \mathbf{u}, A \mathbf{v}\rangle=C\langle\mathbf{u}, \mathbf{v}\rangle, \forall \mathbf{u}, \mathbf{v} \in \mathbb{R}^{n}\right)\)</span></p><p><img src="https://pic.imgdb.cn/item/623d734727f86abb2add8b61.jpg" style="zoom:25%;" /></p><hr /><p>解：设球面为 <span class="math inline">\(x^2+y^2+z^2=R^2\)</span>，对其上一点 <span class="math inline">\((x_0,y_0,z_0)\)</span> 与圆柱面交线 <span class="math inline">\((\lambda x_0,\lambda y_0,\lambda z_0)\)</span></p><p>满足 <span class="math inline">\(\lambda^2(x_0^2+y_0^2)=R^2\)</span> 代入变换得 <span class="math inline">\(Q(\dfrac{Rx_0}{\sqrt{x_0^2+y_0^2}},\dfrac{Ry_0}{\sqrt{x_0^2+y_0^2}},f(\dfrac{Rz_0}{\sqrt{x_0^2+y_0^2}}))\)</span></p><p>考虑经度、纬度恒为定值的两条微元，取纬度 <span class="math inline">\(\varphi\sim \varphi+d\varphi\)</span> 处 <span class="math inline">\(d\theta\)</span> 的正交微圆弧，令其长度相同</p><p><span class="math inline">\(d\theta\cdot R\cos\varphi=Rd\varphi\Longrightarrow d\theta=\dfrac{d\varphi}{\cos \varphi}\)</span>，该两条圆弧映射后的长度分别为 $Rd$ 和 <span class="math inline">\(dz\)</span></p><p>两者相等有 <span class="math inline">\(Rd\theta=dz=R\dfrac{d\varphi}{\cos \varphi}\)</span> 两边积分得 <span class="math inline">\(z(\varphi)=\displaystyle \int R\dfrac{d\varphi}{\cos \varphi}=R\ln (\dfrac{1+\sin \varphi}{\cos \varphi})+C\)</span></p><p>代入 <span class="math inline">\(\varphi = 0\)</span> 时 <span class="math inline">\(z=0\)</span>，有 <span class="math inline">\(C=0,z(\varphi)=R\ln (\dfrac{1+\sin \varphi}{\cos \varphi})\)</span>，<span class="math inline">\(\lambda z_0=\dfrac{Rz_0}{\sqrt{x_0^2+y_0^2}}=\dfrac{Rz_0}{\sqrt{R^2-z_0^2}}\)</span></p><p>令 <span class="math inline">\(x=\lambda z_0\)</span> 反解得 <span class="math inline">\(z_0=\dfrac{Rx}{\sqrt{R^2+x^2}},\dfrac{1+\sin \varphi}{\cos \varphi }=\dfrac{R+z_0}{\sqrt{R^2-z_0^2}}=\dfrac{x+\sqrt{x^2+ R^2}}{R}\)</span></p><p>从而 <span class="math inline">\(f:x\longmapsto R\cdot\mbox{arcsinh}\ \dfrac{x}{R}\)</span>，为反双曲三角正弦函数</p><h2 id="教材1.6.4">教材1.6.4</h2><p>设方程 <span class="math inline">\(f\left(u^{2}-x^{2}, u^{2}-y^{2}, u^{2}-z^{2}\right)=0\)</span> 确定了函数 <span class="math inline">\(u=u(x, y, z)\)</span>, 其中 <span class="math inline">\(f\)</span> 可微,证明： <span class="math display">\[\frac{1}{x} \frac{\partial u}{\partial x}+\frac{1}{y} \frac{\partial u}{\partial y}+\frac{1}{z} \frac{\partial u}{\partial z}=\frac{1}{u} .\]</span></p><hr /><p>证明：由在方程 <span class="math inline">\(f\left(u^{2}-x^{2}, u^{2}-y^{2}, u^{2}-z^{2}\right)=0\)</span> 下计算得 <span class="math display">\[\begin{gathered}\dfrac{\partial u}{\partial x}=-\dfrac{\dfrac{\partial f}{\partial x}}{\dfrac{\partial f}{\partial u}}=-\dfrac{-2xf_{1}&#39;}{2u(f_1&#39;+f_2&#39;+f_3&#39;)},\dfrac{\partial u}{\partial y}=-\dfrac{\dfrac{\partial f}{\partial y}}{\dfrac{\partial f}{\partial u}}=-\dfrac{-2yf_{1}&#39;}{2u(f_1&#39;+f_2&#39;+f_3&#39;)},\\\dfrac{\partial u}{\partial z}=-\dfrac{-2zf_{1}&#39;}{2u(f_1&#39;+f_2&#39;+f_3&#39;)}\rightarrow \frac{1}{x} \frac{\partial u}{\partial x}+\frac{1}{y} \frac{\partial u}{\partial y}+\frac{1}{z} \frac{\partial u}{\partial z}=\dfrac{f_1&#39;+f_2&#39;+f_3&#39;}{u(f_1&#39;+f_2&#39;+f_3&#39;)}=\dfrac{1}{u}\end{gathered}\]</span></p><h2 id="教材1.7.12">教材1.7.1(2)</h2><p>求下列曲面在给定点的切平面方程和法线方程.</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(z=\arctan \dfrac{y}{x}\)</span>, 点 <span class="math inline">\(P\left(1,1, \dfrac{\pi}{4}\right)\)</span>;</p><hr /><p>解：方程 <span class="math inline">\(f(x,y,z)=z-\arctan(\dfrac{y}{x})=0\)</span> 在点 <span class="math inline">\((1,1,\dfrac{\pi}{4})\)</span> 处的法向量为 <span class="math display">\[\vec{n}=(\dfrac{\partial f}{\partial x},\dfrac{\partial f}{\partial y},\dfrac{\partial f}{\partial z})=(\dfrac{y}{x^2+y^2},\dfrac{-x}{x^2+y^2},1)=(\dfrac{1}{2},-\dfrac{1}{2},1)\]</span> 从而切平面方程为 <span class="math inline">\(\dfrac{1}{2}(x-1)-\dfrac{1}{2}(y-1)+(z-\dfrac{\pi}{4})=0\)</span>，即 <span class="math inline">\(x-y+2z=\dfrac{\pi}{2}\)</span></p><p>法线方程 <span class="math inline">\(\dfrac{x-1}{\dfrac{1}{2}}=\dfrac{y-1}{-\dfrac{1}{2}}=\dfrac{z-\dfrac{\pi}{4}}{1}\)</span></p><h2 id="教材1.7.42">教材1.7.4(2)</h2><p>证明下列各题</p><p><span class="math inline">\((2)\)</span> 曲面 <span class="math inline">\(\sqrt{x}+\sqrt{y}+\sqrt{z}=\sqrt{a}\)</span> 的任意一点处的切平面在各坐标轴上的截距之和为 <span class="math inline">\(a\)</span> ；</p><hr /><p>解：方程 <span class="math inline">\(f(x,y,z)=\sqrt{x}+\sqrt{y}+\sqrt{z}-\sqrt{a}=0\)</span> 在任意一点 <span class="math inline">\((x_0,y_0,z_0)\)</span> 处的法向量为 <span class="math display">\[\vec{n}=(\dfrac{\partial f}{\partial x},\dfrac{\partial f}{\partial y},\dfrac{\partial f}{\partial z})=(\dfrac{1}{2\sqrt{x}},\dfrac{1}{2\sqrt{y}},\dfrac{1}{2\sqrt{z}})=(\dfrac{1}{2\sqrt{x_0}},\dfrac{1}{2\sqrt{y_0}},\dfrac{1}{2\sqrt{z_0}})\]</span> 则其切平面方程 <span class="math inline">\(\dfrac{x-x_0}{2\sqrt{x_0}}+\dfrac{y-y_0}{2\sqrt{y_0}}+\dfrac{z-z_0}{2\sqrt{z_0}}=0\)</span>，则在 <span class="math inline">\(x,y,z\)</span> 轴上的截距分别为</p><p><span class="math inline">\(x_{inter}=x_0+({\sqrt{y_0}+\sqrt{z_0}}) \sqrt{x_0},y_{inter}=y_0+({\sqrt{x_0}+\sqrt{z_0}}) \sqrt{y_0},z_{inter}=z_0+({\sqrt{x_0}+\sqrt{y_0}})\sqrt{z_0}\)</span></p><p>从而 <span class="math inline">\(x_{inter}+y_{inter}+z_{inter}=x_0+y_0+z_0+2(\sqrt{x_0y_0}+\sqrt{x_0z_0}+\sqrt{y_0z_0})=\sqrt{a}^2=a\)</span></p><h1 id="largetextcolorblue微积分第六次作业-smallwtimes-f-_textcolorblue2022.4.5"><span class="math inline">\(\large\textcolor{blue}{微积分第六次作业\ \small(W\times f)}\ \ \ \ \ \ _\textcolor{blue}{2022.4.5}\)</span></h1><h2 id="习题1.9.8">习题1.9.8</h2><p>求函数 <span class="math inline">\(u=x^{2}+2 y^{2}+z^{2}-2 x y-2 y z\)</span> 在区域 <span class="math inline">\(x^{2}+y^{2}+z^{2} \leqslant 4\)</span> 内的最值.</p><hr /><p>解：由 <span class="math inline">\(u=(x-y)^2+(y-z)^2\geq 0\)</span>，当 <span class="math inline">\(x=y=z=0\)</span> 时能取到最小值 <span class="math inline">\(0\)</span></p><p>而若最大值在 <span class="math inline">\(x^2+y^2+z^2=r^2&lt;4\)</span> 时取到，为 <span class="math inline">\((x_0,y_0,z_0)\)</span> 则线性扩大 <span class="math inline">\(\dfrac{2}{r}\)</span> 倍，<span class="math inline">\(u\)</span> 扩大 <span class="math inline">\(\dfrac{4}{r^2}\)</span> 倍</p><p>从而最大值在 <span class="math inline">\(x^2+y^2+z^2=4\)</span> 时取到，由拉格朗日乘子法 <span class="math display">\[f(x,y,z)=(x-y)^2+(y-z)^2+\lambda(x^2+y^2+z^2-4)\]</span> 有 <span class="math inline">\(\begin{cases}\dfrac{\partial f}{\partial x}=2(x-y)+2\lambda x=0\\\dfrac{\partial f}{\partial y}=-2(x-y)+2(y-z)+2\lambda y=0\\\dfrac{\partial f}{\partial z}=-2(y-z)+2\lambda z=0\end{cases}\)</span>，则有 <span class="math inline">\(\lambda =\dfrac{y}{x}-1=\dfrac{y}{z}-1=\dfrac{x+z}{y}-2\)</span></p><p>若 <span class="math inline">\(y=0\)</span>，则 <span class="math inline">\(\lambda=-1,x=-z\)</span>，代入 <span class="math inline">\(u=x^2+z^2=4\)</span></p><p>若 <span class="math inline">\(y\neq 0\)</span>，得 <span class="math inline">\(x=z,2x^2=xy+y^2\)</span> <span class="math inline">\(,x^2+y^2+z^2=2x^2+y^2=4=xy+2y^2,x=\dfrac{4}{y}-2y\)</span></p><p>有方程 <span class="math inline">\(4-y^2=2(\dfrac{4}{y}-2y)^2=\dfrac{32}{y^2}-32+8y^2\Longrightarrow 9y^4-36y^2+32=0,y^2=\dfrac{8}{3},\dfrac{4}{3}\)</span> <span class="math display">\[u=2(x-y)^2=6(y^2-x^2)=6(-3y^2-\dfrac{16}{y^2}+16)\]</span> 代入计算最大为 <span class="math inline">\(6(-6-8+16)=12\)</span> 此时 <span class="math inline">\(y=\dfrac{2\sqrt{6}}{3},x=-\dfrac{\sqrt{6}}{3}=z\)</span></p><p>综上所述，<span class="math inline">\(u\)</span> 在 <span class="math inline">\(x^2+y^2+z^2\leq 4\)</span> 的最小值为 <span class="math inline">\(0\)</span>，最大值为 <span class="math inline">\(12\)</span></p><h2 id="习题1.9.92">习题1.9.9(2)</h2><p>求旋转抛物面 <span class="math inline">\(z=x^{2}+y^{2}\)</span> 与平面 <span class="math inline">\(x+y-z=1\)</span> 的最短距离;</p><hr /><p>解：显然从几何上，固定旋转抛物面上的点，该点到平面 <span class="math inline">\(x+y-z=1\)</span> 的最小距离为垂线段 <span class="math display">\[d=\dfrac{|x_0+y_0-z_0-1|}{\sqrt{1^2+1^2+1^2}}=\dfrac{\sqrt{3}}{3}|x_0+y_0-z_0-1|=\dfrac{\sqrt{3}}{3}|x_0+y_0-x_0^2-y_0^2-1|\]</span> 而由配方法 <span class="math inline">\(x_0-x_0^2=-(x_0-\dfrac{1}{2})^2+\dfrac{1}{4}\leq \dfrac{1}{4}\)</span>，则 <span class="math inline">\(x_0+y_0-x_0^2-y_0^2-1\leq -\dfrac{1}{2}\)</span></p><p>从而取等时对应绝对值最小，则 <span class="math inline">\(d_{\min }=\dfrac{\sqrt{3}}{6}\)</span></p><h2 id="习题1.9.101">习题1.9.10(1)</h2><p>水渠的断面为等腰梯形, 在渠道表面抺上水泥, 当断面面积一定时, 梯形的上、下底及腰的长度比例为多少时, 所用水泥最省?</p><hr /><p>解：显然所用水泥质量正比于 <span class="math inline">\(C_{\mbox{trapesoid}}=l_1+2l_{\mbox{waist}}\)</span></p><p>面积为定值 <span class="math inline">\(S=\dfrac{1}{2}(l_1+l_2)\cdot h\)</span>，勾股定理 <span class="math inline">\(l_{\mbox{waist}}=\sqrt{h^2+(\dfrac{l_2-l_1}{2})^2}\)</span> <span class="math display">\[C=l_1+l_2+\sqrt{4h^2+(l_2-l_1)^2}=l_1+\sqrt{\dfrac{16S^2}{(l_1+l_2)^2}+(l_2-l_1)^2}\]</span> 对 <span class="math inline">\(l_2\)</span> 求导得 <span class="math inline">\(-\dfrac{32S^2}{(l_1+l_2)^3}+2(l_2-l_1)=0,8h^2=2(l_2-l_1)(l_1+l_2)\)</span></p><p>即有 <span class="math inline">\(h^2=\dfrac{1}{4}(l_2^2-l_1^2),l_{\mbox{waist}}=\dfrac{1}{2}\sqrt{(l_2-l_1)\cdot 2l_2},C=l_1+\sqrt{2l_2(l_2-l_1)}\)</span></p><p>在约束条件 <span class="math inline">\(16S^2=(l_2-l_1)(l_2+l_1)^3\)</span> 下求 <span class="math inline">\(C(l_1,l_2)=l_1+\sqrt{2l_2(l_2-l_1)}\)</span> 的最小值</p><p>作拉格朗日函数 <span class="math inline">\(f(l_1,l_2,\lambda )=l_1+\sqrt{2l_2(l_2-l_1)}+\lambda(l_2-l_1)(l_2+l_1)^3\)</span>，极值点对应</p><p><span class="math inline">\(\begin{cases}\dfrac{\partial f}{\partial l_1}=1+\dfrac{-2l_2}{2\sqrt{2l_2(l_2-l_1)}}+\lambda(l_2+l_1)^2(2l_2-4l_1)=0\\\dfrac{\partial f}{\partial l_2}=\dfrac{4l_2-2l_1}{2\sqrt{2l_2(l_2-l_1)}}+\lambda(l_2+l_1)^2(4l_2-2l_1)=0\end{cases}\)</span></p><p>令 <span class="math inline">\(\eta=\dfrac{l_2}{l_1}\)</span> 有 <span class="math inline">\(\dfrac{\sqrt{2\eta(\eta-1)}-\eta}{2\eta-1}=\dfrac{\eta-2}{2\eta-1}\)</span>，解得 <span class="math inline">\(\eta=2\)</span>，代入 <span class="math inline">\(l_1:l_2:l_{\mbox{waist}}=1:2:1\)</span></p><h2 id="习题2.2.22">习题2.2.2(2)</h2><p>求下列函数的导函数。 <span class="math inline">\(F(y)=\displaystyle \int_{a+y}^{b+y} \frac{\sin y x}{x} \mathrm{~d} x\)</span>;</p><hr /><p>解：对 <span class="math inline">\(F(y)=\displaystyle\int_{a+y}^{b+y}\dfrac{sin(yx)}{x}dx\)</span>，其对 <span class="math inline">\(x\)</span> 的导函数分为两部分，分类讨论 <span class="math display">\[F&#39;(y)=\dfrac{sin(y(b+y))}{b+y}-\dfrac{sin(y(a+y))}{a+y}+\int_{a+y}^{b+y}cos(xy)dx\]</span> ## 习题2.2.5.(1)</p><p><span class="math inline">\(\displaystyle \int_{0}^{1} \frac{\arctan x}{x} \frac{1}{\sqrt{1-x^{2}}} \mathrm{~d} x\left(\right.\)</span> 提示: <span class="math inline">\(\displaystyle \frac{\arctan x}{x}=\int_{0}^{1} \frac{1}{1+x^{2} y^{2}} \mathrm{~d} y\)</span> ）</p><hr /><p>解：由提示变换 <span class="math inline">\(\dfrac{\arctan x}{x}=\displaystyle\int_0^1\dfrac{1}{1+x^2y^2}dy\)</span>，化为二重积分得 <span class="math display">\[\int_0^1\dfrac{\arctan x}{x}\dfrac{1}{\sqrt{1-x^2}}dx=\int_0^1\displaystyle\int_0^1\dfrac{1}{1+x^2y^2}\dfrac{1}{\sqrt{1-x^2}}dxdy\]</span> 代换 <span class="math inline">\(x=\sin\varphi,\varphi\in[0,\dfrac{\pi}{2}]\)</span>，有 <span class="math inline">\(\dfrac{1}{1+x^2y^2}\dfrac{1}{\sqrt{1-x^2}}dx=\dfrac{d\varphi}{1+y^2\sin^2\varphi}=\dfrac{\cos^2\varphi \cdot d(\tan \varphi)}{(1+y^2)\sin^2\varphi+\cos^2 \varphi}\)</span> <span class="math display">\[\begin{gathered}\int_0^1\dfrac{\arctan x}{x}\dfrac{1}{\sqrt{1-x^2}}dx=\int_0^1(\int_0^{\frac{\pi}{2}}\dfrac{d(\tan \varphi)}{1+(1+y^2)\tan^2\varphi})dy=\\\int_0^1(\dfrac{\arctan (\sqrt{1+y^2}\tan \varphi)}{\sqrt{1+y^2}})\big |_0^{\frac{\pi}{2}}dy=\dfrac{\pi}{2}\int_0^1\dfrac{dy}{\sqrt{1+y^2}}=\\\dfrac{\pi}{2}\ln(y+\sqrt{1+y^2})\big |_0^1=\dfrac{\pi}{2}\ln(1+\sqrt{2})\end{gathered}\]</span></p><h2 id="习题2.3.1">习题2.3.1</h2><p>计算下列积分.</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\displaystyle \int_{0}^{+\infty} \frac{\mathrm{e}^{-a x^{2}}-\mathrm{e}^{-b x^{2}}}{x} \mathrm{~d} x(a, b&gt;0)\)</span>;</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\displaystyle \int_{0}^{+\infty} \frac{\cos a x-\cos b x}{x^{2}} \mathrm{~d} x(a, b&gt;0)\)</span></p><hr /><p>解：<span class="math inline">\((1)\)</span> 解：<span class="math inline">\(\displaystyle \int_0^{+\infty}\dfrac{e^{-ax^2}-e^{-bx^2}}{x}dx=\int_0^{+\infty}\dfrac{1}{x}dx\int_a^bx^2e^{-x^2y}dy=\int_0^{+\infty}\int_a^bxe^{-x^2y}dxdy\)</span> <span class="math display">\[\int_0^{+\infty}xe^{-x^2y}dx=\dfrac{1}{2}\int_0^{+\infty}e^{-x^2y}d(x^2)=-\dfrac{1}{2y}\cdot e^{-x^2y}\big |_0^{+\infty}=\dfrac{1}{2y}\\\int_0^{+\infty}\dfrac{e^{-ax^2}-e^{-bx^2}}{x}dx=\int_a^{b}\dfrac{1}{2y}dy=\dfrac{1}{2}\ln (\dfrac{b}{a})\]</span> <span class="math inline">\((3)\)</span> <span class="math inline">\(\displaystyle \int_0^{+\infty}\dfrac{\cos ax-\cos bx}{x^2}dx\ =-\int_0^{+\infty}\dfrac{1}{x^2}dx\int_b^{a}x\sin(xy)dy=\int_0^{+\infty}\int_a^b\dfrac{\sin (xy)}{x}dxdy\)</span> <span class="math display">\[\mbox{set}\ \ t=xy\in[0,+\infty),\int_0^{+\infty}\dfrac{\sin (xy)}{x}dx=\int_0^{+\infty}\dfrac{y\sin t}{t}d(\dfrac{t}{y})=\int_0^{+\infty}\dfrac{\sin t}{t}dt=\dfrac{\pi}{2}\]</span> 代入得 <span class="math inline">\(\displaystyle \int_0^{+\infty}\dfrac{\cos ax-\cos bx}{x^2}dx=\int_a^b\dfrac{\pi}{2}dy=\dfrac{\pi}{2}(b-a)\)</span></p><h2 id="习题2.1.4">习题2.1.4</h2><p>讨论下列积分在所给区间上的一致收敛性.</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\displaystyle \int_{-\infty}^{+\infty} \frac{\cos y x}{1+x^{2}} \mathrm{~d} x(-\infty&lt;y&lt;+\infty)\)</span>;</p><p><span class="math inline">\((9)\)</span> <span class="math inline">\(\displaystyle \int_{1}^{+\infty} x^{1-y} \mathrm{~d} x(0&lt;y&lt;+\infty)\)</span>;</p><p><span class="math inline">\((10)\)</span> <span class="math inline">\(\displaystyle \int_{0}^{+\infty} \frac{\sin x^{2}}{x^{p}} \mathrm{~d} x(0 \leqslant p&lt;+\infty)\)</span>.</p><hr /><p>解：<span class="math inline">\((2)\)</span> 由 <span class="math inline">\(|\dfrac{\cos yx}{1+x^2}|\leq \dfrac{1}{1+x^2}\)</span>，且有 $<em>{-}^{+}dx=x|</em>{-}^{+}=$</p><p>对于 <span class="math inline">\(\displaystyle \int_{-\infty}^{+\infty}|\dfrac{\cos yx}{1+x^2}|dx=2\int_0^{+\infty}|\dfrac{\cos yx}{1+x^2}|dx\)</span> 收敛，由柯西收敛准则 <span class="math display">\[\forall\  \epsilon &gt;0,\exists\ A&gt;0,s.t.\forall \ A_1&gt;A_2&gt;A,\int_{A_1}^{A_2}|\dfrac{\cos yx}{1+x^2}|dx&lt;\epsilon\]</span> 放缩绝对值有 <span class="math inline">\(\forall\  \epsilon &gt;0,\exists\ A&gt;0,s.t.\forall\displaystyle \ A_1&gt;A_2&gt;A,|\int_{A_1}^{A_2}\dfrac{\cos yx}{1+x^2}dx|\leq \int_{A_1}^{A_2}|\dfrac{\cos yx}{1+x^2}|dx&lt;\epsilon\)</span></p><p>由柯西收敛准则得原广义含参积分收敛</p><p><span class="math inline">\((9)\)</span> 当 <span class="math inline">\(0&lt;y\leq 2\)</span> 时 <span class="math inline">\(x^{1-y}\geq x^{-1}=\dfrac{1}{x}\)</span>，则 <span class="math display">\[\exists\ \epsilon_0=\ln 2,\forall \ A&gt;1,s.t.\exists \ A_2&gt;2A_1&gt;A,\displaystyle \int _{A_1}^{A_2}x^{1-y}dx&gt;\int_{A_1}^{A_2}\dfrac{1}{x}dx=\ln x\big |_{A_1}^{A_2}&gt;\epsilon_0\]</span> 此时广义含参积分不收敛；若当 <span class="math inline">\(2&lt;y\)</span> 时，直接计算有 <span class="math inline">\(\dfrac{1}{2-y}\cdot (0-1)=\dfrac{1}{y-2}\)</span> 收敛</p><p><span class="math inline">\((10)\)</span> 代换 <span class="math inline">\(t=x^2\in [0,\infty)\)</span>，<span class="math inline">\(\displaystyle \int_{0}^{+\infty}\dfrac{\sin x^2}{x^p}dx=\int_{0}^{+\infty}\dfrac{\sin t}{t^{\frac{p}{2}}}d(\sqrt{t})=\int_{0}^{+\infty}\dfrac{\sin t}{t^{\frac{p+1}{2}}}dt\)</span></p><p>其中 <span class="math inline">\(\alpha=\dfrac{p+1}{2}\geq \dfrac{1}{2},\displaystyle \int_{1}^{+\infty}\dfrac{\sin t}{t^{\alpha}}dt=\int_{1}^{+\infty}\dfrac{-d(\cos t)}{t^{\alpha }}=-\dfrac{\cos t}{t^{\alpha }}\big |_{1}^{+\infty}-\int_{1}^{+\infty}\dfrac{\alpha dt}{t^{\alpha+1}}\)</span></p><p><span class="math inline">\(=\cos 1-\alpha \displaystyle \int_{1}^{+\infty}\dfrac{\cos t dt}{t^{\alpha +1}}\)</span>，而放缩 <span class="math inline">\(\displaystyle \int_{1}^{+\infty}|\dfrac{\cos t}{t^{\alpha +1}}|dt\leq \int_{1}^{+\infty}\dfrac{dt}{t^{\alpha +1}}=\dfrac{1}{\alpha }\)</span>，后者绝对收敛</p><p>从而 <span class="math inline">\(\displaystyle \int_{1}^{+\infty}\dfrac{\sin t}{t^{\alpha}}dt\)</span> 一致收敛，只需考虑 <span class="math inline">\(\displaystyle \int_{0}^{1}\dfrac{\sin t}{t^{\alpha}}dt\)</span>，这与 <span class="math inline">\(\lim\limits_{t\to 0}\dfrac{\sin t }{t^{\alpha }}\)</span> 的收敛性相同</p><p>当且仅当 <span class="math inline">\(\alpha =\dfrac{p+1}{2}\leq 1\)</span> 即 <span class="math inline">\(0\leq p\leq 1\)</span> 时原广义含参积分收敛，<span class="math inline">\(1&lt;p\)</span> 时不收敛</p><h1 id="largetextcolorblue微积分第七次作业-smallwtimes-f-_textcolorblue2022.4.24"><span class="math inline">\(\large\textcolor{blue}{微积分第七次作业\ \small(W\times f)}\ \ \ \ \ \ _\textcolor{blue}{2022.4.24}\)</span></h1><h2 id="习题3.2.3">习题3.2.3</h2><p>比较下列各组积分值的大小.</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\displaystyle \iint_{D} \ln (x+y) \mathrm{d} x \mathrm{~d} y ,\displaystyle \iint_{D} x y \mathrm{~d} x \mathrm{~d} y\)</span>, <span class="math inline">\(D\)</span> 由直线 <span class="math inline">\(x=0, y=0, x+y=\dfrac{1}{2}\)</span>, <span class="math inline">\(x+y=1\)</span></p><p>围成.</p><hr /><p>解：去掉边界积分结果不变，由于 <span class="math inline">\(x+y&lt; 1\)</span>，则 <span class="math inline">\(\ln (x+y)&lt; 0\)</span> 而 <span class="math inline">\(xy&gt; 0\)</span>，且积分区域 <span class="math inline">\(x,y&gt;0\)</span></p><p>从而 <span class="math inline">\(\ln(x+y)dxdy&lt;xydxdy\)</span> 则 <span class="math inline">\(\displaystyle \iint_{D} \ln (x+y) \mathrm{d} x \mathrm{~d} y&lt;\displaystyle \iint_{D} x y \mathrm{~d} x \mathrm{~d} y\)</span></p><h2 id="习题3.3.6">习题3.3.6</h2><p>计算下列二重积分.</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\displaystyle \iint_{D} x y^{2} \mathrm{~d} x \mathrm{~d} y, D=\left\{(x, y) \mid 4 x \geqslant y^{2}, x \leqslant 1\right\}\)</span>;</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\displaystyle \iint_{D} \frac{1}{\sqrt{2 a-x}} \mathrm{~d} x \mathrm{~d} y, D=\left\{(x, y) \mid(x-a)^{2}+(y-a)^{2} \leqslant 1,0 \leqslant x, y \leqslant a\right\}\)</span>;</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(\displaystyle \iint_{D} x \cos (x y) \mathrm{d} x \mathrm{~d} y, D=\left\{(x, y) \mid x^{2}+y^{2} \leqslant R^{2}\right\}\)</span>;</p><p><span class="math inline">\((9)\)</span> <span class="math inline">\(\displaystyle \iint_{D} y^{2} \mathrm{~d} x \mathrm{~d} y, D\)</span> 由 <span class="math inline">\(\left\{\begin{array}{l}x=a(t-\sin t), \\ y=a(1-\cos t),\end{array} \quad 0 \leqslant t \leqslant 2 \pi\right.\)</span> 以及 <span class="math inline">\(x\)</span> 轴围成;</p><hr /><p>解：<span class="math inline">\((1)\)</span> 积分区域图像如右 <span class="math inline">\(\begin{cases}x\geq \dfrac{1}{4}y^2\\x\leq 1\end{cases}\)</span> <img src="https://pic.imgdb.cn/item/6263ee9a239250f7c50284a2.jpg" style="zoom:1.8%;" /> <span class="math display">\[\displaystyle \iint_{D} x y^{2} \mathrm{~d} x \mathrm{~d} y=\int_{0}^1dx\int_{-2\sqrt{x}}^{2\sqrt{x}}xy^2dy=\int_0^1x\cdot \dfrac{2}{3}(2\sqrt{x})^3dx=\dfrac{16}{3}\int_0^1x^{\frac{5}{2}}dx=\dfrac{32}{21}\]</span> <span class="math inline">\((2)\)</span> 积分区域 <span class="math inline">\(\begin{cases}(x-a)^2+(y-a)^2\leq a^2\\0\leq x,y\leq a\end{cases}\)</span> 图像如右 <img src="https://pic.imgdb.cn/item/6263e7c5239250f7c5f194bc.jpg" style="zoom:40%;" /> <span class="math display">\[\begin{gathered}\underset{D}{\iint}\dfrac{1}{\sqrt{2a-x}}dxdy=\int_0^{a}dx\int_{a-\sqrt{x(2a-x)}}^a\dfrac{1}{\sqrt{2a-x}}dy\\=\int_0^{a}\sqrt{x(2a-x)}\cdot \dfrac{1}{\sqrt{2a-x}}dx=\dfrac{2}{3}a^{\frac{3}{2}}\end{gathered}\]</span></p><p><span class="math inline">\((4)\)</span> 积分区域 <span class="math inline">\(D:x^2+y^2\leq R^2\)</span> 图像如右 <img src="https://pic.imgdb.cn/item/6263ef15239250f7c503b0f1.jpg" style="zoom:40%;" /></p><p>拆成两部分 <span class="math inline">\(\displaystyle \underset{D}{\iint}x\cos (xy)dxdy=\underset{D\ \cap\ \{x|x\leq 0\}}{\iint}x\cos (xy)dxdy+\underset{D\ \cap\ \{x|x&gt;0\}}{\iint}x\cos (xy)dxdy\)</span></p><p>对 <span class="math inline">\(f(x,y)=x\cos (xy)\)</span> 有 <span class="math inline">\(f(x,y)=-f(-x,y)\)</span> 为关于 <span class="math inline">\(x\)</span> 的奇函数，则 <span class="math inline">\(\displaystyle \underset{D}{\iint}x\cos (xy)dxdy=0\)</span></p><p><span class="math display">\[\underset{D}{\iint}|\cos (x+y)|dxdy=\underset{D&#39;}{\iint}|\cos (x+y)|\dfrac{D (x,y)}{D(v,u)}dvdu=\underset{D}{\iint}|\cos (x+y)|\begin{vmatrix}\dfrac{1}{2}&amp;\dfrac{1}{2}\\{-}\dfrac{1}{2}&amp;\dfrac{1}{2}\end{vmatrix}dudv\\=\dfrac{1}{2}\underset{D}{\iint}|\cos (x+y)|dvdu=\dfrac{1}{2}\cdot 4\int_0^{\pi}|\cos u|du\int_0^{u}dv=2\cdot 2\int_0^{\frac{\pi}{2}}ud(\sin u)=2\pi-4\]</span></p><p><span class="math inline">\((9)\)</span> 解：滚轮线 <span class="math inline">\(\begin{cases}x=a(t-\sin t)\\y=a(1-\cos t)\end{cases}\ \small t\in[0,2\pi],\normalsize D\scriptsize:\normalsize \begin{cases}y\leq f(x)\\0\leq y\end{cases}\)</span> 图像 <img src="https://pic.imgdb.cn/item/6263efe8239250f7c505f791.jpg" style="zoom:35%;" /></p><p><span class="math inline">\(\displaystyle\underset{D}{\iint}y^2dxdy=\int_0^{2\pi a} dx\int_{0}^{f(x)} y^2dy=\dfrac{1}{3}\int_0^{2\pi a} f(x)^3dx\)</span>，换成参数 <span class="math inline">\(t\)</span> 积分得 <span class="math display">\[\dfrac{1}{3}\int_0^{2\pi}   a^{4}(1-\cos t)^{3}d(t-\sin t)=\dfrac{a^4}{3}\int_0^{2\pi}(1-\cos t)^4dt=\dfrac{a^4}{3}\int_{-\pi}^{\pi}(1+\cos x)^4dx=\\\dfrac{a^4}{3}\int_{-\pi}^{\pi}(1+4\cos x+6\cos ^2x+4\cos ^3x+\cos^4x)dx=\dfrac{a^4}{3}\int_{-\pi}^{\pi}(1+6\cos ^2x+\cos^4x)dx\\=\dfrac{a^4}{3}(2\pi+\int_{-\pi}^{\pi}3(1+\cos 2x)dx+\int_{-\pi}^{\pi}\dfrac{(1+\cos 2x)^2}{4}dx=\dfrac{a^4}{3}(8\pi+\int_{-\pi}^\pi{\dfrac{1+\dfrac{1}{2}}{4}}dx+0)\\=\dfrac{a^4}{3}(8\pi+\dfrac{3\pi}{4})=\dfrac{35\pi}{12}a^4\ \ \ \ (答案有误，分母缺少3)\]</span></p><h2 id="习题3.3.12">习题3.3.12</h2><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\displaystyle \iint_{D}(x+y) \mathrm{d} x \mathrm{~d} y, D\)</span> 是由 <span class="math inline">\(x^{2}+y^{2}=x+y\)</span> 围成的平面区域</p><hr /><p>解：该区域为一个圆 <span class="math inline">\((x-\dfrac{1}{2})^2+(y-\dfrac{1}{2})^2=(\dfrac{\sqrt{2}}{2})^2\)</span> 换元 <span class="math inline">\(\begin{cases}x=\dfrac{1}{2}+r\cos \theta\\y=\dfrac{1}{2}+r\sin \theta\end{cases}\)</span></p><p>得到 <span class="math inline">\(dxdy=rd\theta dr\)</span> 计算有 <span class="math inline">\(\displaystyle \iint _{D}(x+y)dxdy=\iint _{D}(1+r\cos \theta+r\sin \theta)rd\theta dr\)</span> <span class="math display">\[\begin{gathered}\iint _{D}(1+r\cos \theta+r\sin \theta)rd\theta dr=\int_0^{\frac{\sqrt{2}}{2}}dr\int_{0}^{2 \pi}(1+r\cos \theta+r\sin \theta)\cdot rd\theta\\=\int_0^{\frac{\sqrt{2}}{2}}dr(2\pi+0+0)\cdot r=\pi r^2\big |_{0}^{\frac{\sqrt{2}}{2}}=\dfrac{\pi}{2}\end{gathered}\]</span></p><h2 id="习题3.3.16">习题3.3.16</h2><p>设函数 <span class="math inline">\(f(t)\)</span> 连续, 证明：</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\displaystyle \iint_{|x|+|y| \leqslant 1} f(x y) \mathrm{d} x \mathrm{~d} y=\ln 2 \int_{1}^{2} f(t) \mathrm{d} t, D\)</span> 是由 <span class="math inline">\(x y=1, x y=2, y=x, y=4 x\)</span> 所围成</p><p>第一象限的区域.</p><hr /><p>解：代换 <span class="math inline">\(xy=u,\dfrac{y}{x}=v\)</span>，逆变换 <span class="math inline">\(x=\sqrt{\dfrac{u}{v}},y=\sqrt{uv}\)</span> ，则雅克比行列式 <span class="math display">\[\dfrac{D(x,y)}{D(u,v)}=\begin{vmatrix}\dfrac{\partial x}{\partial u}&amp;\dfrac{\partial x}{\partial v}\\\dfrac{\partial y}{\partial u}&amp;\dfrac{\partial x}{\partial v}\end{vmatrix}=\begin{vmatrix}\dfrac{1}{2\sqrt{uv}}&amp;-\dfrac{1}{2}\sqrt{\dfrac{u}{v^3}}\\\dfrac{1}{2}\sqrt{\dfrac{v}{u}}&amp;\dfrac{1}{2}\sqrt{\dfrac{u}{v}}\end{vmatrix}=\dfrac{1}{2v}\]</span> 原区域 <span class="math inline">\(D:\begin{cases}1\leq xy\leq 2\\1\leq \dfrac{y}{x}\leq 4\end{cases}\)</span> 变换后对应 <span class="math inline">\(D&#39;:\begin{cases}1\leq u\leq 2\\1\leq v\leq 4\end{cases}\)</span> 图像如右 <img src="https://pic.imgdb.cn/item/6263f6fc239250f7c518191f.jpg" style="zoom:33%;" /> <span class="math display">\[\underset{D}{\iint}f(xy)dxdy=\underset{D&#39;}{\iint}f(u)\cdot \dfrac{1}{2v}dudv=\int_1^2f(u)du\int_1^4\dfrac{dv}{2v}=\ln 2\int_1^2f(t)dt\]</span></p><h2 id="习题3.4.5">习题3.4.5</h2><p>计算下列三重积分的值.</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\displaystyle \iiint_{\Omega} x y^{2} z^{3} \mathrm{~d} x \mathrm{~d} y \mathrm{~d} z, \Omega\)</span> 是由马鞍面 <span class="math inline">\(z=x y\)</span> 与平面 <span class="math inline">\(y=x, x=1, z=0\)</span> 所围成空间区域;</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\displaystyle \iiint_{\Omega} x \cos (y+z) \mathrm{d} x \mathrm{~d} y \mathrm{~d} z, \Omega\)</span> 是由曲面 <span class="math inline">\(x=\sqrt{y}\)</span> 与平面 <span class="math inline">\(x=0, z=0, y+z\)</span> <span class="math inline">\(=\dfrac{\pi}{2}\)</span> 围成区域;</p><hr /><p>解：<span class="math inline">\((1)\)</span> 从 <span class="math inline">\(z=0\)</span> 连续变化到 <span class="math inline">\(z=1\)</span>，图中画出 <span class="math inline">\(z=\dfrac{1}{2}\)</span> 的情况 <img src="https://pic.imgdb.cn/item/6263f954239250f7c51dc060.jpg" style="zoom:33%;" /></p><p>对每个 <span class="math inline">\(z\)</span> 二重积分得到 <span class="math display">\[\begin{gathered}\displaystyle \iiint_{\Omega} x y^{2} z^{3} \mathrm{~d} x \mathrm{~d} y \mathrm{~d} z=\int_0^1dz\int_{\sqrt{z}}^1dx\int_{\frac{z}{x}}^xxy^2z^3dy=\int_0^1z^3dz\int_{\sqrt{z}}^1xdx\dfrac{y^3}{3}\big|_{\frac{z}{x}}^x\\=\dfrac{1}{3}\int_0^1z^3dz\int_{\sqrt{z}}^1xdx(x^3-\dfrac{z^3}{x^3})=\dfrac{1}{3}\int_0^1z^3dz(\dfrac{1}{5}x^5+\dfrac{z^3}{x})\big|_{\sqrt{z}}^1\\=\dfrac{1}{3}\int_0^1z^3(\dfrac{1}{5}-\dfrac{1}{5}z^{\frac{5}{2}}+z^3-z^{\frac{5}{2}})dz=\dfrac{1}{3}(\dfrac{1}{20}-\dfrac{6}{5}\cdot \dfrac{2}{13}+\dfrac{1}{7})=\dfrac{1}{364}\end{gathered}\]</span> <span class="math inline">\((3)\)</span> 对 <span class="math inline">\(z=0\)</span> 连续变化到 <span class="math inline">\(z=\dfrac{\pi}{2}\)</span> ，图像如右 <img src="https://pic.imgdb.cn/item/62649243239250f7c53a84e3.jpg" style="zoom:33%;" /> <span class="math display">\[\begin{gathered}\displaystyle \iiint_{\Omega} x \cos (y+z) \mathrm{d} x \mathrm{~d} y \mathrm{~d} z=\int_0^{\frac{\pi}{2}}dz\int_0^{\frac{\pi}{2}-z}dy\int_0^{\sqrt{y}}x\cos (y+z)dx\\=\dfrac{1}{2}\int_0^{\frac{\pi}{2}}dz\int_0^{\frac{\pi}{2}-z}dy\cdot y\cos (y+z)=\dfrac{1}{2}\int_0^{\frac{\pi}{2}}dz(y\sin (y+z)\big |_{0}^{\frac{\pi}{2}-z}-\int_0^{\frac{\pi}{2}-z}\sin (y+z)dy)\\=\dfrac{1}{2}\int_0^{\frac{\pi}{2}}dz((\dfrac{\pi}{2}-z)+\cos (y+z)\big |_{0}^{\frac{\pi}{2}-z})=\dfrac{1}{2}\int_0^{\frac{\pi}{2}}((\dfrac{\pi}{2}-z)-\cos z)dz\\=\dfrac{1}{2}(\dfrac{\pi^2}{4}-\dfrac{\pi^2}{8})-\dfrac{1}{2}=\dfrac{\pi^2-8}{16}\end{gathered}\]</span></p><h2 id="习题3.4.6">习题3.4.6</h2><p>计算累次积分 <span class="math inline">\(\displaystyle I=\int_{0}^{1} \mathrm{~d} x \int_{0}^{x} \mathrm{~d} y \int_{0}^{y} \frac{\cos z}{(1-z)^{2}} \mathrm{~d} z\)</span> 的值.</p><hr /><p>解：三维图形为三棱锥，图像如右（使用 <span class="math inline">\(\mbox{meshlab}\)</span> 绘图） <img src="https://pic.imgdb.cn/item/62649b46239250f7c5468dff.jpg" style="zoom:20%;" /></p><p>在 <span class="math inline">\(z=z_0\)</span> 切面上由面积相似比等于高之比的平方 <span class="math inline">\(\eta=(1-z)^2\)</span>，从而有 <span class="math display">\[\int_0^{1}dx\int_0^xdy\int_0^y\dfrac{\cos z}{(1-z)^2}dz=\int_0^1\dfrac{\cos z}{(1-z)^2}\cdot Sdz=\int_0^1\dfrac{\cos z}{(1-z)^2}\dfrac{1}{2}(1-z)^2dz=\dfrac{\sin 1}{2}\]</span></p><h2 id="习题3.4.7">习题3.4.7</h2><p>计算下列三重积分的值.</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(\displaystyle \iiint_{\Omega} x \mathrm{e}^{\frac{x^{2}+y^{2}+z^{2}}{a^{2}}} \mathrm{~d} x \mathrm{~d} y \mathrm{~d} z, \Omega=\left\{(x, y, z) \mid x^{2}+y^{2}+z^{2} \leqslant a^{2}, x, y, z \geqslant 0\right\}\)</span></p><hr /><p>解：使用球坐标 <span class="math inline">\((x,y,z)=(r,\theta,\varphi)\)</span> 有 <span class="math inline">\(dxdydz=r^2\sin \theta dr d\theta d\varphi\)</span> 计算积分有 <span class="math display">\[\begin{gathered}\displaystyle \iiint_{\Omega} x \mathrm{e}^{\frac{x^{2}+y^{2}+z^{2}}{a^{2}}} \mathrm{~d} x \mathrm{~d} y \mathrm{~d} z=\displaystyle \iiint_{\Omega} r\sin \theta\sin \varphi e^{\frac{r^2}{a^2}}r^2\sin \theta  dr d\theta d\varphi\\= \int_{0}^{\frac{\pi}{2}}\dfrac{1-\cos 2\theta}{2} d\theta \int_{0}^{a}r^{3}e^{\frac{r^2}{a^2}}dr=\int_0^{a^2}\dfrac{\pi}{8}te^{\frac{t}{a^2}}dt=\dfrac{\pi}{8}(a^2t-a^4)e^{\frac{t}{a^2}}\big |_{0}^{a^2}=\dfrac{ \pi a^4}{8}\end{gathered}\]</span></p><h2 id="习题3.4.10">习题3.4.10</h2><p><span class="math inline">\(f(t)\)</span> 在 <span class="math inline">\((-\infty,+\infty)\)</span> 连续, <span class="math inline">\(f(t)=3\displaystyle \iiint_{x^{2}+y^{2}+z^{2} \leqslant t^{2}} f\left(\sqrt{x^{2}+y^{2}+z^{2}}\right) \mathrm{d} x \mathrm{~d} y \mathrm{~d} z+\)</span> <span class="math inline">\(\left|t^{3}\right|\)</span>, 求 <span class="math inline">\(f(t)\)</span></p><hr /><p>解：积分区域为球体 <span class="math inline">\(x^2+y^2+z^2\leq t^2\)</span>，换取球坐标 <span class="math inline">\((x,y,z)\longrightarrow(\rho,\theta,\varphi)\)</span>，有体积元变换 <span class="math display">\[dxdydz=\rho^2\sin \theta d\rho d\theta d\varphi\]</span></p><p><span class="math display">\[f(t)=3\int_0^{2\pi}\int_0^{\pi}\int_0^tf(\rho)\rho^2\sin \theta d\rho d\theta d\varphi+|t^3|\\=3\cdot2\cdot2\pi\int_0^tf(\rho)\rho^2d\rho+|t^3|=12\pi\int_0^tf(\rho)\rho^2d\rho+|t^3|\]</span></p><p>两边对 <span class="math inline">\(t\)</span> 求导得 <span class="math display">\[f&#39;(t)=12\pi t^2 f(t)+\mbox{sign}(t)\cdot 3t^2,\mbox{where}\ \mbox{sign}(x)=\begin{cases}1,x&gt;0\\0,x=0\\-1,x&lt;0\end{cases}\]</span> 其特解与 <span class="math inline">\(t\)</span> 的符号有关 <span class="math inline">\(\begin{cases}t&gt;0,f_0=-\dfrac{1}{4\pi}\\t&lt;0,f_0=\dfrac{1}{4\pi}\end{cases}\)</span>，其通解满足方程 <span class="math display">\[\dfrac{df}{dt}=12\pi t^2f\Longrightarrow \int\dfrac{df}{f}=\int12\pi t^2dt\ ,\ \ln f=4\pi t^3+C \ \therefore f(t)=\begin{cases}C_1e^{4\pi t^3}-\dfrac{1}{4\pi},t&gt;0\\C_2e^{4\pi t^3}+\dfrac{1}{4\pi},t&lt;0\end{cases}\]</span> 由 <span class="math inline">\(f(t)\)</span> 在 <span class="math inline">\((-\infty,+\infty)\)</span> 连续得 <span class="math inline">\(C_1-\dfrac{1}{4\pi}=C_2+\dfrac{1}{4\pi}\)</span>，有 <span class="math inline">\(C_1=C_2+\dfrac{1}{2\pi}\)</span>，对 <span class="math inline">\(t&gt;0\)</span> 代入原积分 <span class="math display">\[\begin{gathered}f(t)=C_1e^{4\pi t^2}-\dfrac{1}{4\pi}=12\pi\int_0^t(C_1e^{4\pi \rho^3}-\dfrac{1}{4\pi})\rho^2d\rho+t^3\\=\int_0^tC_1e^{4\pi\rho^3}d(4\pi \rho^3)+0=C_1(e^{4\pi t^2}-1)\end{gathered}\]</span> 比对得 <span class="math inline">\(C_1=\dfrac{1}{4\pi}\)</span>，<span class="math inline">\(C_2=-\dfrac{1}{4\pi}\)</span>，从而 <span class="math inline">\(f(t)=\dfrac{|e^{4\pi t^3}-1|}{4\pi}\)</span></p><h2 id="习题3.5.1">习题3.5.1</h2><p>求下列曲面的面积.</p><p><span class="math inline">\((2)\)</span> 锥面 <span class="math inline">\(z=\sqrt{x^{2}+y^{2}}\)</span> 在柱面 <span class="math inline">\(z^{2}=2 x\)</span> 内的部分;</p><hr /><p>解：<span class="math inline">\(z=\sqrt{x^2+y^2}\)</span> 和 <span class="math inline">\(z^2=2x\)</span> 在 <span class="math inline">\(y=0\)</span> 处截图如下 <img src="https://pic.imgdb.cn/item/62651620239250f7c56a0d11.jpg" style="zoom:30%;" /></p><p>取柱坐标 <span class="math inline">\((x,y,z)\longmapsto(\rho,\theta,z)\)</span> 则锥面 <span class="math inline">\(z=\rho,z^2=2\rho \cos \theta\)</span> 其要求 <span class="math inline">\(\rho \leq 2\cos \theta\)</span> 为圆</p><p><span class="math inline">\(\sqrt{1+\left(\dfrac{\partial z}{\partial x}\right)^{2}+\left(\dfrac{\partial z}{\partial y}\right)^{2}}=\sqrt{2}\)</span> 则 <span class="math inline">\(S=\displaystyle \iint_D\sqrt{2}dxdy=\sqrt{2}\cdot S_{圆}=\sqrt{2}\pi\)</span></p><h2 id="习题3.5.2">习题3.5.2</h2><p>求下列曲面所包围的均匀物体的质心.</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(z=4-x^{2}(x \geqslant 0), x=0, y=0, z=0, y=6\)</span>.</p><hr /><p>解：由对称性该物体的质心 <span class="math inline">\(y\)</span> 坐标为 <span class="math inline">\(3\)</span> ，且质心的 <span class="math inline">\(x,z\)</span> 坐标与平面内抛物三角形相同 <span class="math display">\[x_c=\dfrac{\displaystyle \int_0^2x(4-x^2)dx}{\displaystyle \int_0^2(4-x^2)dx}=\dfrac{4}{\frac{16}{3}}=\dfrac{3}{4},z_c=\dfrac{\displaystyle \int_0^2\dfrac{4-x^2}{2}(4-x^2)dx}{\displaystyle \int_0^2(4-x^2)dx}=\dfrac{\frac{128}{15}}{\frac{16}{3}}=\dfrac{8}{5}\]</span> 则质心坐标为 <span class="math inline">\((\dfrac{3}{4},3,\dfrac{8}{5})\)</span></p><h2 id="习题4.2.1">习题4.2.1</h2><p>计算下列曲线积分.</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(\displaystyle \int_{L}\left(x^{\frac{4}{3}}+y^{\frac{4}{3}}\right) \mathrm{d} l\)</span>, 其中 <span class="math inline">\(L\)</span> 为星形线 <span class="math inline">\(\left\{\begin{array}{l}x=a \cos ^{3} t, \\ y=a \sin ^{3} t,\end{array} \quad 0 \leqslant t \leqslant 2 \pi\right.\)</span>.</p><hr /><p>解：由曲线微元 <span class="math inline">\(dl=\sqrt{dx^2+dy^2}=3a|\cos t\sin t|\)</span> 代入有 <span class="math display">\[\begin{gathered}\int_{L}(x^{\frac{4}{3}}+y^{\frac{4}{3}})3a|\cos t\sin t |dt=3\int_0^{2\pi}a^{\frac{7}{3}}(\cos^4 t+\sin ^4 t)|\cos t\sin t|dt\\=12a^{\frac{7}{3}}\int_0^{\frac{\pi}{2}}(1-\dfrac{1}{4}\sin^2 2t)\dfrac{1}{2}\sin 2tdt=12a^{\frac{7}{3}}(\dfrac{1}{2}-\int_0^{\frac{\pi}{2}}\dfrac{1}{8}(1-\cos 4t )\sin 2tdt)\\=12a^{\frac{7}{3}}(\dfrac{3}{8}-\dfrac{1}{8}\int_0^{\frac{\pi}{2}}\dfrac{\sin 6t-\sin 2t}{2}dt=12a^{\frac{7}{3}}(\dfrac{3}{8}-\dfrac{1}{8}(-\dfrac{1}{12}\cos 6t+\dfrac{1}{4}\cos 2t)\big |_0^{\frac{\pi}{2}})\\=12a^{\frac{7}{3}}(\dfrac{3}{8}-\dfrac{1}{8}(\dfrac{1}{6}-\dfrac{1}{2}))=4a^{\frac{7}{3}}\end{gathered}\]</span></p><h2 id="习题4.2.2">习题4.2.2</h2><p>计算下列曲线积分.</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(\displaystyle \int_{L} x \mathrm{~d} l\)</span>, 其中 <span class="math inline">\(L\)</span> 为球面 <span class="math inline">\(x^{2}+y^{2}+z^{2}=4\)</span> 在第一象限部分的边界.</p><hr /><p>解：由题设求和即为 <span class="math inline">\(y=\sqrt{4-x^2}\)</span> 位于 <span class="math inline">\(xy\)</span> 象限和 <span class="math inline">\(xz\)</span> 象限的部分，有 <span class="math inline">\(\begin{cases}x=2\cos \theta\\y=2\sin \theta\end{cases},\theta\in [0,\dfrac{\pi}{2}]\)</span> <span class="math display">\[\int_{L}xdl=2\cdot \int_0^{\frac{\pi}{2}}2\cos \theta\cdot 2d\theta=2\cdot 4=8\]</span></p><h2 id="习题4.3.3">习题4.3.3</h2><p>求抛物面 <span class="math inline">\(2 z=x^{2}+y^{2}\)</span> 在 <span class="math inline">\(z \in[0,1]\)</span> 部分的质量, 其中质量面密度为 <span class="math inline">\(\sigma=z\)</span>.</p><hr /><p>解：由面积微元，<span class="math display">\[\sqrt{1+\left(\dfrac{\partial z}{\partial x}\right)^{2}+\left(\dfrac{\partial z}{\partial y}\right)^{2}}=\sqrt{1+x^2+y^2}\]</span> 代入质量面密度 <span class="math display">\[\begin{gathered}m=\iint \sqrt{1+x^2+y^2}\cdot zdxdy=\int_{0}^{2\pi}d\theta\int_0^{\sqrt{2}}\sqrt{1+r^2}\dfrac{r^2}{2}rdr\\=\dfrac{\pi}{2}\int_0^{\sqrt{2}}r^{2}\sqrt{1+r^2}d(r^2)=\dfrac{\pi}{2}\int_0^2t\sqrt{1+t}dt=\dfrac{\pi}{2}(\dfrac{2}{3}t(1+t)^{\frac{3}{2}}-\dfrac{4}{15}(1+t)^{\frac{5}{2}})\big|_0^{2}\\=\dfrac{\pi}{2}(\dfrac{4}{3}\cdot 3\sqrt{3}-\dfrac{4}{15}(9\sqrt{3}-1))=\dfrac{(12\sqrt{3}+2)\pi}{15}\end{gathered}\]</span></p><h2 id="习题4.3.11">习题4.3.11</h2><p>证明: (<span class="math inline">\(\mbox{Poisson}\)</span> 公式) <span class="math inline">\(\displaystyle \iint_{S} f(a x+b y+c z) \mathrm{d} S=2 \pi \int_{-1}^{1} f\left(\sqrt{a^{2}+b^{2}+c^{2}} t\right) \mathrm{d} t\)</span>, 其中</p><p><span class="math inline">\(S=\left\{(x, y, z) \mid x^{2}+y^{2}+z^{2}=1\right\}, f\)</span> 是连续函数.</p><hr /><p>证明：对球面的面积微元 <span class="math inline">\(z=\pm \sqrt{1-x^2-y^2}\)</span> <span class="math inline">\(\sqrt{1+\left(\dfrac{\partial z}{\partial x}\right)^{2}+\left(\dfrac{\partial z}{\partial y}\right)^{2}}=\dfrac{1}{\sqrt{1-x^2-y^2}}\)</span></p><p>由球面的对称性，旋转球面的基向量到 <span class="math inline">\(\dfrac{1}{\sqrt{a^2+b^2+c^2}}\)</span> 方向，积分结果为定值 <span class="math display">\[\begin{gathered}\displaystyle \iint_{S} f(a x+b y+c z) \mathrm{d} S=\iint_{S} f(\sqrt{a^2+b^2+c^2}z) \mathrm{d} S=2\iint_{S_{xy}}\dfrac{f(\sqrt{a^2+b^2+c^2}z)}{\sqrt{1-x^2-y^2}}dxdy\\=2\int_0^{2\pi}d\theta\int_0^{1}\dfrac{f(\sqrt{a^2+b^2+c^2}\sqrt{1-r^2})}{\sqrt{1-r^2}}rdr\\=4\pi\int_{0}^{1}f(\sqrt{a^2+b^2+c^2}\sqrt{1-r^2})d(\sqrt{1-r^2})=2 \pi \int_{-1}^{1} f\left(\sqrt{a^{2}+b^{2}+c^{2}} t\right) \mathrm{d} t\end{gathered}\]</span></p><h1 id="largetextcolorblue微积分第八次作业-smallwtimes-f-_textcolorblue2022.5.15"><span class="math inline">\(\large\textcolor{blue}{微积分第八次作业\ \small(W\times f)}\ \ \ \ \ \ _\textcolor{blue}{2022.5.15}\)</span></h1><h2 id="习题4.5.3">习题4.5.3</h2><p><span class="math inline">\((5)\)</span> <span class="math inline">\(\displaystyle \iint_{S^{+}} z^{2} \mathrm{~d} x \wedge \mathrm{d} y\)</span>, 其中 <span class="math inline">\(S^{+}\)</span>是 <span class="math inline">\(z=\sqrt{R^{2}-x^{2}-y^{2}}\)</span> 被柱面 <span class="math inline">\(x^{2}+y^{2}=R x\)</span> 所截部分的上侧.</p><hr /><p>解：原积分化为二重积分，代入条件 <span class="math inline">\(z^2=R^2-x^2-y^2\)</span> <span class="math display">\[\begin{gathered}\displaystyle \iint_{S^{+}} z^{2} \mathrm{~d} x \wedge \mathrm{d} y=\iint_{D}(R^2-x^2-y^2)dxdy=2\pi \int_{0}^{\frac{R}{2}}(R^2-(\dfrac{R}{2}+r\cos \varphi)^2-(\dfrac{R}{2}+r\sin \varphi)^2)rdr\\2\pi \int_{0}^{\frac{R}{2}}(\dfrac{3}{4}R^2-r^2)rdr=2\pi(\dfrac{3}{32}-\dfrac{1}{4}\cdot \dfrac{1}{16})R^4=\dfrac{5\pi}{32}R^4\end{gathered}\]</span></p><h2 id="习题4.5.5">习题4.5.5</h2><p>求流速场 <span class="math inline">\(\boldsymbol{V}=x y \boldsymbol{i}+y z \boldsymbol{j}+z x \boldsymbol{k}\)</span> 由里往外穿过球面 <span class="math inline">\(x^{2}+y^{2}+z^{2}=1\)</span> 在第一象限部分的流量.</p><hr /><p>解：记平面区域 <span class="math inline">\(D\)</span> 为圆心在原点，半径为 <span class="math inline">\(1\)</span> 的圆在第一象限的部分，由对称性有 <span class="math display">\[Q=\iint_{D} x y \mathrm{~d} y \wedge \mathrm{d} z+y z \mathrm{~d} z \wedge \mathrm{d} x+z x \mathrm{~d} x \wedge \mathrm{d} y=3 \iint_{D} z x \mathrm{~d} x \wedge \mathrm{d} y=3\iint_{D}\sqrt{1-x^2-y^2}xdxdy\]</span> 化为极坐标进行积分（中间使用三角换元）有 <span class="math display">\[Q=3\iint_{D}\sqrt{1-r^2}r\cos \varphi rdrd\varphi=3\int_{0}^{\frac{\pi}{2}}\cos \varphi d\varphi \int_0^1\sqrt{1-r^2}r^2dr=3\int_{0}^{\frac{\pi}{2}}\sin ^2\theta \cos ^2\theta d\theta=\dfrac{3\pi}{16}\]</span></p><h2 id="习题4.5.7">习题4.5.7</h2><p><span class="math inline">\(\displaystyle \iint_{S^{+}}\left(x^{2}+y^{2}\right) \mathrm{d} x \wedge \mathrm{d} y+y^{2} \mathrm{~d} y \wedge \mathrm{d} z+z^{2} \mathrm{~d} z \wedge \mathrm{d} x\)</span>, 其中 <span class="math inline">\(S\)</span> 是螺旋面 <span class="math inline">\(x=\)</span> <span class="math inline">\(u \cos v, y=u \sin v, z=a v\)</span> 在 <span class="math display">\[D_{u v}=\{(u, v) \mid 0 \leqslant u \leqslant 1,0 \leqslant v \leqslant 2 \pi\}\]</span> 的部分, 上侧为正.</p><hr /><p>解：代入微分式，<span class="math inline">\(\mathrm{d} x \mathrm{~d} y=u \mathrm{~d} u \mathrm{~d} v, \mathrm{~d} y \mathrm{~d} z=a \sin v \mathrm{~d} u \mathrm{~d} v, \mathrm{~d} z \mathrm{~d} x=-a \cos v \mathrm{~d} u \mathrm{~d} v\)</span> 化为二重积分</p><p><span class="math display">\[\begin{gathered}\iint_{S^{+}}\left(x^{2}+y^{2}\right) \mathrm{d} x \wedge \mathrm{d} y+y^{2} \mathrm{~d} y \wedge \mathrm{d} z+z^{2} \mathrm{~d} z \wedge \mathrm{d} x=\iint_{D uv}\left(u^{3}+a u^{2} \sin ^{3} v-a^{3} v^{2} \cos v\right) \mathrm{d} u \mathrm{~d} v\\=\iint_{D_{uv}}(u^3-a^3v^2\cos v)\mathrm{d} u \mathrm{~d} v+0=\int_0^1u^3\mathrm{d} u \int_0^{2\pi}\mathrm{~d} v-a^3\int_0^{2\pi}v^2\cos v\mathrm{~d} v=\dfrac{\pi}{2}-4\pi a^3\end{gathered}\]</span></p><h2 id="习题4.7.2">习题4.7.2</h2><p>计算曲面积分 <span class="math inline">\(\displaystyle {\int\kern{-8pt}\int \kern{-23mu} \bigcirc}_{S^{+}} \frac{x \mathrm{~d} y \wedge \mathrm{d} z+y \mathrm{~d} z \wedge \mathrm{d} x+z \mathrm{~d} x \wedge \mathrm{d} y}{\left(x^{2}+y^{2}+z^{2}\right)^{\frac{3}{2}}}\)</span>, 其中 <span class="math inline">\(S^{+}\)</span>为:</p><p><span class="math inline">\((1)\)</span> 不包含也不经过原点的半径为 <span class="math inline">\(R\)</span> 的球面外侧;</p><p><span class="math inline">\((2)\)</span> 不包含也不经过原点的任意封闭曲面的外侧;</p><p><span class="math inline">\((3)\)</span> 球面 <span class="math inline">\(x^{2}+y^{2}+z^{2}=\varepsilon^{2}(\varepsilon&gt;0)\)</span>;</p><p><span class="math inline">\((4)\)</span> 包含原点在其内部的任意封闭曲面的外侧.</p><hr /><p>解：<span class="math inline">\((1)\)</span> 令 <span class="math inline">\(r=\sqrt{x^2+y^2+z^2}\)</span> 有 <span class="math inline">\(\boldsymbol V=(\dfrac{x}{r^3},\dfrac{y}{r^3},\dfrac{z}{r^3})\)</span> 且由高斯公式 <span class="math display">\[\displaystyle \iint_{\partial \Omega^{+}} \boldsymbol{V} \cdot \mathrm{d} \boldsymbol{S}=\iiint_{\Omega}\left(\frac{\partial X}{\partial x}+\frac{\partial Y}{\partial y}+\frac{\partial Z}{\partial z}\right) \mathrm{d} x \mathrm{~d} y \mathrm{~d} z=\iiint_{\Omega}\left(\dfrac{3r^2-3x^2-3y^2-3z^2}{r^5}\right) \mathrm{d} x \mathrm{~d} y \mathrm{~d} z\]</span> 可得，无论是否为球面，只要不包含原点，积分结果为 <span class="math inline">\(0\)</span></p><p><span class="math inline">\((2)\)</span> 由上问知，积分结果为 <span class="math inline">\(0\)</span></p><p><span class="math inline">\((3)\)</span> 直接化为二重积分，注意球面上下积分贡献为 <span class="math inline">\(2\)</span> 倍 <span class="math display">\[\displaystyle I=\frac{3}{\epsilon^{3}} {\int\kern{-8pt}\int \kern{-23mu} \bigcirc}_{S^{+}} z \mathrm{~d} x \wedge \mathrm{d} y=\frac{3}{\epsilon^{3}} \cdot 2\int_{0}^{\frac{\pi}{2}} \int_{0}^{2 \pi} \epsilon^{3} \sin \theta \cos ^{2} \theta \mathrm{d} \varphi \mathrm{d} \theta=4 \pi\]</span> <span class="math inline">\((4)\)</span> 取两个封闭曲面，一个为以原点为圆心的球，此球总能完全属于该封闭曲面，另一个封闭曲面挖掉洞</p><p><span class="math inline">\(I=0+4\pi=4\pi\)</span>，这与静电场点电荷对应的高斯定理 <span class="math inline">\(\displaystyle 4\pi KQ_{in}={\int\kern{-8pt}\int \kern{-23mu} \bigcirc}\boldsymbol{E}\cdot dS\)</span> 等价</p><h2 id="习题4.7.5">习题4.7.5</h2><p>利用 <span class="math inline">\(\mbox{Stokes}\)</span> 公式计算下列积分.</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\displaystyle \oint_{L^{+}} y \mathrm{~d} x+z \mathrm{~d} y+x \mathrm{~d} z\)</span>, 其中 <span class="math inline">\(L\)</span> 是球面 <span class="math inline">\(x^{2}+y^{2}+z^{2}=R^{2}\)</span> 与平面 <span class="math inline">\(x+y+\)</span> <span class="math inline">\(z=0\)</span> 的交线, 从 <span class="math inline">\(z\)</span> 轴正向</p><p>看上去为逆时针方向;</p><hr /><p>解：由 <span class="math inline">\(\mbox{Stokes}\)</span> 公式计算将曲线积分化成二重积分结合椭圆面积二次型知识有 <span class="math display">\[\begin{gathered}I=-3 \iint_{D} 1 \mathrm{~d} x \mathrm{~d} y=-3 \cdot\left(\pi ab\right)\quad 2x^2+2y^2+2xy=R^2\Longrightarrow \lambda_{1,2}=3,1,a=1,b=\dfrac{1}{\sqrt{3}}\\\therefore I =-\sqrt{3} \pi R^{2}\end{gathered}\]</span></p><h2 id="第四章总复习题-7">第四章总复习题 7</h2><p>证明: 由闭曲面 <span class="math inline">\(S\)</span> 包围的空间体的体积为 <span class="math inline">\(V=\displaystyle \frac{1}{3} {\int\kern{-8pt}\int \kern{-23mu} \bigcirc}_{S}(x \cos \alpha+y \cos \beta+\)</span> <span class="math inline">\(z \cos \gamma) \mathrm{d} S\)</span>, 其中</p><p><span class="math inline">\(\boldsymbol{n}=(\cos \alpha, \cos \beta, \cos \gamma)\)</span> 为 <span class="math inline">\(S\)</span> 的单位外法向量.</p><hr /><p>解：由高斯公式可得 <span class="math display">\[\displaystyle V=\iiint_D\mathrm dx\mathrm dy\mathrm dz=\dfrac{1}{3}\iint_Sx\mathrm dy\wedge\mathrm dz+y\mathrm dz\wedge\mathrm dx+z\mathrm dx\wedge\mathrm dy=\frac{1}{3}{\int\kern{-8pt}\int \kern{-23mu} \bigcirc}_S(x\cos\alpha+y\cos\beta+z\cos\gamma)\mathrm dS\]</span></p><h2 id="第四章总复习题-10">第四章总复习题 10</h2><p>设 <span class="math inline">\(u\)</span> 为有界开集 <span class="math inline">\(\Omega \subset \mathbb{R}^{3}\)</span> 上的调和函数即 <span class="math inline">\(\displaystyle \left(\Delta u \equiv \frac{\partial^{2} u}{\partial x^{2}}+\frac{\partial^{2} u}{\partial y^{2}}+\frac{\partial^{2} u}{\partial z^{2}}=0\right)\)</span>, 证明:</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\displaystyle u\left(\boldsymbol{r}_{0}\right)=\frac{1}{4 \pi} \iint_{\partial \Omega}\left(u \frac{\cos \langle\boldsymbol{r}, \boldsymbol{n}\rangle}{r^{2}}+\frac{1}{r} \frac{\partial u}{\partial \boldsymbol{n}}\right) \mathrm{d} S\)</span>, 其中 <span class="math inline">\(\boldsymbol{r}_{0}\)</span> 为 <span class="math inline">\(\Omega\)</span> 内任意一点, <span class="math inline">\(\boldsymbol{r}\)</span> 为 <span class="math inline">\(\boldsymbol{r}_{0}\)</span> 到 <span class="math inline">\(\partial \Omega\)</span> 上点的向量,</p><p><span class="math inline">\(r=\|\boldsymbol{r}\|, \boldsymbol{n}\)</span> 为 <span class="math inline">\(\Omega\)</span> 的单位外法向;</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\displaystyle \iint_{\partial \Omega}\left(\frac{1}{r} \frac{\partial u}{\partial \boldsymbol{n}}-u \frac{\partial \frac{1}{r}}{\partial \boldsymbol{n}}\right) \mathrm{d} S=\iint_{\partial \Omega_{0}}\left(\frac{1}{r} \frac{\partial u}{\partial \boldsymbol{n}}-u \frac{\partial \frac{1}{r}}{\partial \boldsymbol{n}}\right) \mathrm{d} S\)</span>,</p><p>其中 <span class="math inline">\(\boldsymbol{M}\left(x_{0}, y_{0}, z_{0}\right) \in \Omega, \Omega_{0}=B(\boldsymbol{M}, \rho) \subset \Omega, \boldsymbol{r}=\left(x-x_{0}\right) \boldsymbol{i}+\left(y-y_{0}\right) \boldsymbol{j}+(z-\)</span> <span class="math inline">\(\left.z_{0}\right) \boldsymbol{k}, r=\|\boldsymbol{r}\|\)</span>.</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 由于 <span class="math inline">\(\dfrac{\partial }{\partial x}(\dfrac{1}{r})=-\dfrac{x-x_0}{r^3}\)</span>，<span class="math inline">\(\dfrac{\partial^2}{\partial x^2}(\dfrac{1}{r})=\dfrac{3(x-x_0)^2-r^2}{r^5}\)</span> 可以得到</p><p><span class="math inline">\(\Delta(\dfrac{1}{r})=\dfrac{3(x-x_0)^2+3(y-y_0)^2+3(z-z_0)^2-3r^2}{r^5}=0\)</span> 取 <span class="math inline">\(\Omega\)</span> 内部的一个以 <span class="math inline">\(\boldsymbol r_0\)</span> 为球心，<span class="math inline">\(\epsilon&gt;0\)</span> 为半径</p><p>的小球，球面记为<span class="math inline">\(S_{\epsilon}\)</span>. <span class="math inline">\(S_{\epsilon}\)</span>和<span class="math inline">\(\Omega\)</span>围成的区域记为<span class="math inline">\(D\)</span>. 将表达式化为梯度形式（其中 <span class="math inline">\(\nabla(\dfrac{1}{r})=-\dfrac{\boldsymbol{r}}{r^3}\)</span>） <span class="math display">\[u \frac{\cos \langle\mathbf{r}, \mathbf{n}\rangle}{r^{2}}+\frac{1}{r} \frac{\partial u}{\partial \mathbf{n}}=u \frac{\mathbf{r}}{r^{3}} \cdot \mathbf{n}+\frac{1}{r} \nabla u \cdot \mathbf{n}=\left(\frac{1}{r} \nabla u-u \nabla\left(\frac{1}{r}\right)\right) \cdot \mathbf{n}\]</span> 从而利用 <span class="math inline">\(\mbox{Guass}\)</span> 公式对不包含该瑕点 <span class="math inline">\(\boldsymbol{r}_0\)</span> 的区域 <span class="math inline">\(D\)</span> 有（<strong>从而证明了 <span class="math inline">\((2)\)</span> 问 </strong>） <span class="math display">\[\begin{gathered}\iint_{\partial \Omega}\left(u \frac{\cos \langle\mathbf{r}, \mathbf{n}\rangle}{r^{2}}+\frac{1}{r} \frac{\partial u}{\partial \mathbf{n}}\right) \mathrm{d} S-\iint_{S_{\epsilon}}\left(u \frac{\cos \langle\mathbf{r}, \mathbf{n}\rangle}{r^{2}}+\frac{1}{r} \frac{\partial u}{\partial \mathbf{n}}\right) \mathrm{d} S \\=\iiint_{D}\left(\frac{1}{r} \Delta u-u \Delta\left(\frac{1}{r}\right)\right) \mathrm{d} x \mathrm{~d} y \mathrm{~d} z=0\end{gathered}\]</span> 从而转换为求 <span class="math inline">\(S_{\epsilon}\)</span> 上的积分问题 <span class="math display">\[\begin{gathered}\iint_{\partial \Omega}\left(u \frac{\cos \langle\mathbf{r}, \mathbf{n}\rangle}{r^{2}}+\frac{1}{r} \frac{\partial u}{\partial \mathbf{n}}\right) \mathrm{d} S =\iint_{S_{\epsilon}}\left(u \frac{\cos \langle\mathbf{r}, \mathbf{n}\rangle}{r^{2}}+\frac{1}{r} \frac{\partial u}{\partial \mathbf{n}}\right) \mathrm{d} S =\iint_{S_{\epsilon}} \frac{u}{\epsilon^{2}} \mathrm{~d} S+\frac{1}{\epsilon} \iint_{S_{\epsilon}} \frac{\partial u}{\partial \mathbf{n}} \mathrm{d} S \\=4 \pi u\left(r_{1}\right)+\frac{1}{\epsilon} \iint_{S_{\epsilon}} \nabla u \cdot \mathbf{n d} S=4 \pi u\left(r_{1}\right)+\frac{1}{\epsilon} \iiint_{B_{\epsilon}} \Delta u \mathrm{~d} x \mathrm{~d} y \mathrm{~d} z=4 \pi u\left(r_{1}\right)\end{gathered}\]</span> <span class="math inline">\((2)\)</span> 由上问知，<span class="math inline">\(\displaystyle \iint_{\partial \Omega}\left(u \frac{\cos \langle\mathbf{r}, \mathbf{n}\rangle}{r^{2}}+\frac{1}{r} \frac{\partial u}{\partial \mathbf{n}}\right) \mathrm{d} S-\iint_{S_{\epsilon}}\left(u \frac{\cos \langle\mathbf{r}, \mathbf{n}\rangle}{r^{2}}+\frac{1}{r} \frac{\partial u}{\partial \mathbf{n}}\right) \mathrm{d} S =0\)</span> 从而 <span class="math display">\[\displaystyle \iint_{\partial \Omega}\left(\frac{1}{r} \frac{\partial u}{\partial \boldsymbol{n}}-u \frac{\partial \frac{1}{r}}{\partial \boldsymbol{n}}\right) \mathrm{d} S=\iint_{\partial \Omega_{0}}\left(\frac{1}{r} \frac{\partial u}{\partial \boldsymbol{n}}-u \frac{\partial \frac{1}{r}}{\partial \boldsymbol{n}}\right) \mathrm{d} S\]</span> # <span class="math inline">\(\large\textcolor{blue}{微积分第九次作业\ \small(W\times f)}\ \ \ \ \ \ _\textcolor{blue}{2022.5.6}\)</span></p><h2 id="习题4.4.2">习题4.4.2</h2><p>计算下列第二类曲线积分.</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\displaystyle \oint_{L^{+}} \dfrac{(x+y) \mathrm{d} x+(y-x) \mathrm{d} y}{x^{2}+y^{2}}\)</span>, 其中 <span class="math inline">\(L^{+}\)</span>是 <span class="math inline">\(x^{2}+y^{2}=a^{2}\)</span>, 逆时针为正向;</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\displaystyle \oint_{L^{+}} \dfrac{\mathrm{d} x+\mathrm{d} y}{|x|+|y|}\)</span>, 其中 <span class="math inline">\(L^{+}\)</span>是以 <span class="math inline">\((1,0),(0,1),(-1,0),(0,-1)\)</span> 为顶点的正方形,逆时针为正向;</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(\displaystyle \int_{L^{+}}\left(y^{2}-z^{2}\right) \mathrm{d} x+\left(z^{2}-x^{2}\right) \mathrm{d} y+\left(x^{2}-y^{2}\right) \mathrm{d} z\)</span>, 其中 <span class="math inline">\(L^{+}\)</span> 是球面 <span class="math inline">\(x^{2}+y^{2}+\)</span> <span class="math inline">\(z^{2}=1\)</span> 在第一象限的部分与三个坐标平面的交线,其正向为从点 <span class="math inline">\((1,0,0)\)</span> 出发, 经过点 <span class="math inline">\((0,1,0)\)</span>, 到点 <span class="math inline">\((0,0,1)\)</span>, 再回到 <span class="math inline">\((1,0,0)\)</span>;</p><hr /><p>解：<span class="math inline">\((2)\)</span> 令 <span class="math inline">\(x=a\cos \theta,y=a\sin \theta\)</span> 代入有 <span class="math display">\[\displaystyle \oint_{L^{+}} \dfrac{(x+y) \mathrm{d} x+(y-x) \mathrm{d} y}{x^{2}+y^{2}}=\oint_{L^{+}}((\cos \theta+\sin \theta )(-\sin \theta)+(\sin \theta-\cos \theta)(\cos \theta))d\theta=-2\pi\]</span> <span class="math inline">\((3)\)</span> 对 <span class="math inline">\(x+y=\pm 1\)</span> 第一象限和第三象限的所有点均满足 <span class="math inline">\(dx+dy=0\)</span>，而对第二象限和第四象限</p><p>满足通过原点对称的两个点 <span class="math inline">\((x,y)\longmapsto(-x,-y)\)</span> <span class="math inline">\((\dfrac{dx+dy}{|x|+|y|})_{L_{2}}=-(\dfrac{dx+dy}{|x|+|y|})_{L_{4}}\)</span> 从而原式 <span class="math inline">\(=0\)</span></p><p><span class="math inline">\((4)\)</span> 第一条线 <span class="math inline">\(\displaystyle \int_{L^{+}}y^2dx-x^2dy=\displaystyle \int_{L^{+}}(-\sin ^3\theta-\cos ^3\theta )d\theta=-\dfrac{4}{3}\)</span> 后两条线相同，原式 <span class="math inline">\(=-4\)</span></p><h2 id="习题4.4.3">习题4.4.3</h2><p>计算 <span class="math inline">\(\displaystyle \int_{L^{+}} \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{r}\)</span>.</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(\boldsymbol{F}\)</span> 为由原点处质量为 <span class="math inline">\(m\)</span> 的质点所形成的空间引力场 (对单位质量质点的引力 <span class="math inline">\(), L\)</span> 是由点 <span class="math inline">\((1,1,1)\)</span> 到点</p><p><span class="math inline">\(\left(x_{0}, y_{0}, z_{0}\right)\)</span> 的直线段. <span class="math inline">\(\left(x_{0}, y_{0}, z_{0}\right.\)</span> 不同时为零. <span class="math inline">\()\)</span></p><hr /><p>解：由题意计算<span class="math inline">\(W=\displaystyle \int_{L_{1}(\boldsymbol{A})}^{(\boldsymbol{B})} \frac{Gm x \mathrm{~d} x}{\left(x^{2}+y^{2}+z^{2}\right)^{\frac{3}{2}}}+\frac{Gm y \mathrm{~d} y}{\left(x^{2}+y^{2}+z^{2}\right)^{\frac{3}{2}}}+\frac{Gm z \mathrm{~d} z}{\left(x^{2}+y^{2}+z^{2}\right)^{\frac{3}{2}}}\)</span></p><p>取直线上 <span class="math inline">\(t\)</span> 比例的点 <span class="math inline">\(\boldsymbol{r}=(1-t)(1,1,1)+t(x_0,y_0,z_0)\)</span> 解得 <span class="math inline">\(W=Gm(\dfrac{1}{\sqrt{3}}-\dfrac{1}{\sqrt{x_0^2+y_0^2+z_0^2}})\)</span></p><h2 id="习题4.4.4">习题4.4.4</h2><p>今有一平面力场 <span class="math inline">\(\boldsymbol{F}\)</span>, 大小等于点 <span class="math inline">\((x, y)\)</span> 到坐标原点的距离, 方向指向坐标原点.</p><p><span class="math inline">\((2)\)</span> 计算质点 <span class="math inline">\(P\)</span> 沿上述椭圆逆时针绕一圈时,力 <span class="math inline">\(\boldsymbol{F}\)</span> 所做的功.</p><hr /><p>解：该力为 <span class="math inline">\(\boldsymbol F=(x,y)\)</span> 有势能函数 <span class="math inline">\(\boldsymbol U=\dfrac{x^2+y^2}{2}\)</span> 从而绕一圈做功 <span class="math inline">\(W=0\)</span></p><h2 id="习题4.6.1">习题4.6.1</h2><p>利用 <span class="math inline">\(\mbox{Green}\)</span> 公式计算下列曲线积分.</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(\displaystyle \oint_{L^{+}} \mathrm{e}^{x}[(1-\cos y) \mathrm{d} x-(y-\sin y) \mathrm{d} y]\)</span>, 其中 <span class="math inline">\(L\)</span> 是区域 <span class="math inline">\(\{(x, y) \mid 0 \leqslant x \leqslant\)</span> <span class="math inline">\(\pi, 0 \leqslant y \leqslant \sin x\}\)</span> 的正向边界.</p><hr /><p>解：由格林公式 <span class="math inline">\(\displaystyle \oint_{L^{+}} \mathrm{e}^{x}[(1-\cos y) \mathrm{d} x-(y-\sin y) \mathrm{d} y]=\iint -e^x(y-\sin y)-e^x\sin ydxdy\)</span></p><p><span class="math inline">\(\displaystyle =-\iint e^xydxdy=-\int_0^{\pi}e^{x}dx\int_0^{\sin x}ydy=-\dfrac{1}{2}\int_0^{\pi}\sin ^2xe^xdx=-\dfrac{1}{4}\int_0^{\pi}(1-\cos 2x)e^xdx\)</span></p><p>而 <span class="math inline">\(\displaystyle \int\cos 2xe^xdx=\dfrac{1}{2}\int e^xd(\sin 2x)=\dfrac{1}{2}e^x\sin 2x-\dfrac{1}{2}\int e^x \sin 2xdx=\dfrac{1}{2}e^x\sin 2x+\dfrac{1}{4}\int e^x d(\cos 2x)\)</span></p><p><span class="math inline">\(=\displaystyle \dfrac{1}{2}e^x\sin 2x+\dfrac{1}{4}e^x\cos 2x-\dfrac{1}{4}\int e^x\cos 2xdx\Longrightarrow \int e^x\cos 2xdx=\dfrac{2\sin 2x+\cos 2x}{5}e^x+C\)</span></p><p>从而原式 <span class="math inline">\(=(-\dfrac{1}{4}e^{x}+\dfrac{2\sin 2x+\cos 2x}{20}e^x)\big |_{0}^{\pi}=-\dfrac{1}{4}(e^{\pi}-1)+\dfrac{1}{20}(e^{\pi}-1)=-\dfrac{e^{\pi}-1}{5}\)</span></p><blockquote><p>答案有误，<span class="math inline">\(-\dfrac{e^{\pi}-1}{5}\)</span> 与 <span class="math inline">\(\mbox{Mathematica}\)</span> 软件计算结果相同（计算耗时 <span class="math inline">\(47\mbox{s}\)</span> ）</p><p><img src="https://pic.imgdb.cn/item/6272955e0947543129ec4d73.jpg" style="zoom:100%;" /></p></blockquote><h2 id="习题4.6.4">习题4.6.4</h2><p>计算下列区域的面积.</p><p><span class="math inline">\((1)\)</span> 星形线 <span class="math inline">\(\left\{\begin{array}{l}x=a \cos ^{3} t, \\ y=a \sin ^{3} t,\end{array}\ \  0 \leqslant t \leqslant 2 \pi\right.\)</span> 所围区域 <span class="math inline">\((a&gt;0)\)</span>;</p><hr /><p>解：由 <span class="math inline">\(\mbox{Green}\)</span> 公式计算将二重积分化成曲线积分有 <span class="math display">\[\begin{gathered}S=\displaystyle \iint_{D} dxdy=\dfrac{1}{2}\int_{\partial D}xdy-ydx=\dfrac{a^2}{2}\int_0^{2\pi}\cos ^3t\cdot 3\sin ^2t\cos tdt+\sin ^3t\cdot 3\cos ^2t\sin tdt\\=\dfrac{3a^2}{2}\int_0^{2\pi}\sin ^2t\cos ^2 tdt=\dfrac{3a^2}{8}\int_0^{2\pi}\dfrac{1-\cos 4t}{2}dt=\dfrac{3}{8}a^2\cdot \pi=\dfrac{3\pi}{8}a^2\end{gathered}\]</span></p><h2 id="习题4.6.7">习题4.6.7</h2><p>设 <span class="math inline">\(D\)</span> 是平面区域, <span class="math inline">\(\partial D\)</span> 为逐段光滑曲线, <span class="math inline">\(f \in C^{2}(D)\)</span>, 证明: <span class="math inline">\(\displaystyle \oint_{\partial D} \frac{\partial f}{\partial \boldsymbol{n}} \mathrm{d} l=\)</span> <span class="math inline">\(\displaystyle \iint_{D}\left(\frac{\partial^{2} f}{\partial x^{2}}+\frac{\partial^{2} f}{\partial y^{2}}\right) \mathrm{d} x \mathrm{~d} y\)</span></p><hr /><p>证明：由沿梯度方向的导数 <span class="math inline">\(\dfrac{\partial f}{\partial\boldsymbol{n}}=\dfrac{\partial f}{\partial x}\hat{n}_{x}+\dfrac{\partial f}{\partial y}\hat{n}_{y}=\dfrac{\partial f}{\partial x}(\dfrac{dy}{dl})+\dfrac{\partial f}{\partial y}(-\dfrac{dx}{dl})\)</span></p><p>其中 <span class="math inline">\(\vec{n}\)</span> 方向与 <span class="math inline">\((dx,dy)\)</span> 方向垂直且满足为单位向量，从而为 <span class="math inline">\(\vec{n}=(\dfrac{dy}{dl},-\dfrac{dx}{dl})\)</span> 再代入格林公式即得证 <span class="math display">\[\oint_{\partial D} \frac{\partial f}{\partial \boldsymbol{n}} \mathrm{d} l=\oint_{\partial D}(\dfrac{\partial f}{\partial x}(\dfrac{dy}{dl})+\dfrac{\partial f}{\partial y}(-\dfrac{dx}{dl}))dl=\oint_{\partial D}(\dfrac{\partial f}{\partial x}dy-\dfrac{\partial f}{\partial y}dx)=\displaystyle \iint_{D}\left(\frac{\partial^{2} f}{\partial x^{2}}+\frac{\partial^{2} f}{\partial y^{2}}\right) \mathrm{d} x \mathrm{~d} y\]</span></p><h2 id="习题4.6.8">习题4.6.8</h2><p>设 <span class="math inline">\(D\)</span> 是平面区域, <span class="math inline">\(\partial D\)</span> 为逐段光滑曲线, <span class="math inline">\(n\)</span> 为 <span class="math inline">\(D\)</span> 的单位外法向, <span class="math inline">\(u, v \in\)</span> <span class="math inline">\(C^{2}(D)\)</span>, 证明：</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\displaystyle \oint_{\partial D} \frac{\partial u}{\partial \boldsymbol{n}} \mathrm{d} l=\iint_{D} \Delta u \mathrm{~d} x \mathrm{~d} y\)</span>;</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\displaystyle \oint_{\partial D} v \frac{\partial u}{\partial \boldsymbol{n}} \mathrm{d} l=\iint_{D} v \Delta u \mathrm{~d} x \mathrm{~d} y-\iint_{D} \nabla u \cdot \nabla v \mathrm{~d} x \mathrm{~d} y\)</span>;</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\displaystyle \oint_{\partial D}\left|\begin{array}{cc}\dfrac{\partial u}{\partial \boldsymbol{n}} &amp; \dfrac{\partial v}{\partial \boldsymbol{n}} \\ u &amp; v\end{array}\right| \mathrm{d} l=\iint_{D}\left|\begin{array}{cc}\Delta u &amp; \Delta v \\ u &amp; v\end{array}\right| \mathrm{d} x \mathrm{~d} y\)</span>.</p><p>其中 <span class="math inline">\(\Delta=\dfrac{\partial^{2}}{\partial x^{2}}+\dfrac{\partial^{2}}{\partial y^{2}}, \nabla=\dfrac{\partial}{\partial x} i+\dfrac{\partial}{\partial y} j\)</span>.</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 由 <span class="math inline">\(4.6.7\)</span> 可知，对 <span class="math inline">\(u\in C^2(D)\)</span>，<span class="math inline">\(\displaystyle \oint_{\partial D} \frac{\partial u}{\partial \boldsymbol{n}} \mathrm{d} l=\displaystyle \iint_{D}\left(\frac{\partial^{2} u}{\partial x^{2}}+\frac{\partial^{2} u}{\partial y^{2}}\right) \mathrm{d} x \mathrm{~d}y=\iint_{D} \Delta u \mathrm{~d} x \mathrm{~d} y\)</span></p><p><span class="math inline">\((2)\)</span> 代入 <span class="math inline">\(\dfrac{\partial u}{\partial \boldsymbol{n}}dl=\dfrac{\partial u}{\partial x}dy-\dfrac{\partial u}{\partial y}dx\)</span> 有 <span class="math inline">\(\displaystyle \oint_{\partial D} v \frac{\partial u}{\partial \boldsymbol{n}} \mathrm{d} l=\oint_{\partial D} v (\dfrac{\partial u}{\partial x}dy-\dfrac{\partial u}{\partial y}dx)\)</span> 由格林公式 <span class="math display">\[\begin{gathered}\oint_{\partial D} v (\dfrac{\partial u}{\partial x}dy-\dfrac{\partial u}{\partial y}dx)=\iint_{D}(\dfrac{\partial v}{\partial x}\dfrac{\partial u}{\partial x}+v\dfrac{\partial ^2u}{\partial x^2})-(-\dfrac{\partial v}{\partial y}\dfrac{\partial u}{\partial y}-v\dfrac{\partial ^2u}{\partial y^2})dxdy\\=\iint_{D} (v(\dfrac{\partial ^2u}{\partial x^2}+\dfrac{\partial ^2u}{\partial y^2})+(\dfrac{\partial v}{\partial x}\dfrac{\partial u}{\partial x}+\dfrac{\partial v}{\partial y}\dfrac{\partial u}{\partial y}))dxdy=\iint_{D} v \Delta u \mathrm{~d} x \mathrm{~d} y+\iint_{D} \nabla u \cdot \nabla v \mathrm{~d} x \mathrm{~d} y\end{gathered}\]</span> <span class="math inline">\((3)\)</span> 由行列式公式 <span class="math inline">\(\displaystyle \oint_{\partial D}\left|\begin{array}{cc}\dfrac{\partial u}{\partial \boldsymbol{n}} &amp; \dfrac{\partial v}{\partial \boldsymbol{n}} \\ u &amp; v\end{array}\right| \mathrm{d} l=\displaystyle \oint_{\partial D}(v\dfrac{\partial u}{\partial \boldsymbol{n}}-u\dfrac{\partial v}{\partial \boldsymbol{n}}) \mathrm{d} l\)</span> 代入 <span class="math inline">\(\small (2)\)</span> 问结论 <span class="math display">\[\displaystyle \oint_{\partial D}(v\dfrac{\partial u}{\partial \boldsymbol{n}}-u\dfrac{\partial v}{\partial \boldsymbol{n}}) \mathrm{d} l=\iint_{D}((v\Delta u-\nabla u\cdot \nabla v)-(u\Delta v-\nabla u\cdot \nabla v))dxdy=\iint_{D}\left|\begin{array}{cc}\Delta u &amp; \Delta v \\ u &amp; v\end{array}\right| \mathrm{d} x \mathrm{~d} y\]</span></p><h2 id="习题4.6.10">习题4.6.10</h2><p>求解下列常微分方程.</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\displaystyle \left(x^{2}-y\right) \mathrm{d} x-\left(x+\sin ^{2} y\right) \mathrm{d} y=0\)</span>;</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\displaystyle \mathrm{e}^{y} \mathrm{~d} x+\left(x \mathrm{e}^{y}-2 y\right) \mathrm{d} y=0\)</span>;</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\displaystyle \frac{x \mathrm{~d} x+y \mathrm{~d} y}{\sqrt{x^{2}+y^{2}}}=\frac{y \mathrm{~d} x-x \mathrm{~d} y}{x^{2}}\)</span>;</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(\displaystyle \left(\cos x+\frac{1}{y}\right) \mathrm{d} x+\left(\frac{1}{y}-\frac{x}{y^{2}}\right) \mathrm{d} y=0\)</span>.</p><hr /><p>解：<span class="math inline">\((1)\)</span> 由 <span class="math inline">\(\dfrac{\partial (x^2-y)}{\partial y}=\dfrac{\partial (-x-\sin ^2y)}{\partial x}=-1\)</span> 为全微分方程，并注意到 <span class="math display">\[d(\dfrac{1}{3}x^3-xy-(\dfrac{1}{2}y-\dfrac{1}{4}\sin 2y))=\left(x^{2}-y\right) \mathrm{d} x-\left(x+\sin ^{2} y\right) \mathrm{d} y=0\]</span> 则原方程解为 <span class="math inline">\(\dfrac{1}{3}x^3-xy-(\dfrac{1}{2}y-\dfrac{1}{4}\sin 2y)+C=0,C\in R\)</span></p><p><span class="math inline">\((2)\)</span> 由 <span class="math inline">\(\dfrac{\partial (e^y)}{\partial y}=\dfrac{\partial (xe^y-2y)}{\partial x}=e^y\)</span> 为全微分方程，并注意到 <span class="math display">\[d(xe^y-y^2)=\mathrm{e}^{y} \mathrm{~d} x+\left(x \mathrm{e}^{y}-2 y\right) \mathrm{d} y=0\]</span> 则原方程解为 <span class="math inline">\(xe^y-y^2+C=0,C\in R\)</span></p><p><span class="math inline">\((3)\)</span> 由 <span class="math inline">\(\dfrac{\partial (\dfrac{x}{\sqrt{x^2+y^2}}-\dfrac{y}{x^2})}{\partial y}=\dfrac{\partial (\dfrac{y}{\sqrt{x^2+y^2}}+\dfrac{1}{x})}{\partial x}=-\dfrac{xy}{(x^2+y^2)^{\frac{3}{2}}}-\dfrac{1}{x^2}\)</span> 为全微分方程，并注意到 <span class="math display">\[d(\sqrt{x^2+y^2}-\dfrac{y}{x})=\frac{x \mathrm{~d} x+y \mathrm{~d} y}{\sqrt{x^{2}+y^{2}}}-\frac{y \mathrm{~d} x-x \mathrm{~d} y}{x^{2}}=0\]</span> 则原方程解为 <span class="math inline">\(\sqrt{x^2+y^2}-\dfrac{y}{x}+C=0,C\in R\)</span></p><p><span class="math inline">\((4)\)</span> 由 <span class="math inline">\(\dfrac{\partial (\cos x+\dfrac{1}{y})}{\partial y}=\dfrac{\partial (\dfrac{1}{y}-\dfrac{x}{y^2})}{\partial x}=-\dfrac{1}{y^2}\)</span> 为全微分方程，并注意到 <span class="math display">\[d(\sin x+\dfrac{x}{y}+\ln y)=\left(\cos x+\frac{1}{y}\right) \mathrm{d} x+\left(\frac{1}{y}-\frac{x}{y^{2}}\right) \mathrm{d} y=0\]</span> 则原方程解为 <span class="math inline">\(\sin x+\dfrac{x}{y}+\ln y+C=0,C\in R\)</span></p><h2 id="习题4.6.11">习题4.6.11</h2><p>解下列方程.</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\((y \cos x-x \sin x) \mathrm{d} x+(y \sin x+x \cos x) \mathrm{d} y=0\)</span>;</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\((x+y) \mathrm{d} x+(y-x) \mathrm{d} y=0\)</span>;</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(\left(3 x^{3}+y\right) \mathrm{d} x+\left(2 x^{2} y-x\right) \mathrm{d} y=0\)</span>;</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\((x+y)(\mathrm{d} x-\mathrm{d} y)=\mathrm{d} x+\mathrm{d} y\)</span>;</p><p><span class="math inline">\((5)\)</span> <span class="math inline">\(\left(x^{2}-\sin ^{2} y\right) \mathrm{d} x+x \sin 2 y \mathrm{~d} y=0\)</span>.</p><hr /><p>解：<span class="math inline">\((1)\)</span>​ 记 <span class="math inline">\(M=y \cos x-x \sin x, N=y \sin x+x \cos x\)</span>, 有 <span class="math display">\[\frac{\partial M}{\partial y}=\cos x, \frac{\partial N}{\partial x}=y \cos x+\cos x-x \sin x,\]</span> 则方程不是恰当的. 但观察到 <span class="math inline">\(\dfrac{\dfrac{\partial M}{\partial y}-\dfrac{\partial N}{\partial x}}{-M}=1\)</span>, 对应原方程有积分因子 <span class="math inline">\(\mu=\mathrm{e}^{\int1 d y}=\mathrm{e}^{y}\)</span>. 两边乘以 <span class="math inline">\(\mu=e^{y}\)</span> <span class="math display">\[\begin{gathered}\left(y \mathrm{e}^{y} \cos x \mathrm{~d} x+y \mathrm{e}^{y} \sin x \mathrm{~d} y\right)+\left(\mathrm{e}^{y} x \cos x \mathrm{~d} y-\mathrm{e}^{y} x \sin x \mathrm{~d} x\right)=0\\\mathrm{d}\left[(y-1) \mathrm{e}^{y} \sin x+\mathrm{e}^{y} x \cos x\right]=0 .\end{gathered}\]</span> 则原方程的通解为 <span class="math inline">\(\mathrm{e}^{y}(y-1) \sin x+\mathrm{e}^{y} x \cos x=C, C\in R\)</span></p><p><span class="math inline">\((2)\)</span> 两边除以 <span class="math inline">\(x^2+y^2\)</span> 有 <span class="math inline">\(\dfrac{x+y}{x^2+y^2}dx+\dfrac{y-x}{x^2+y^2}dy=0\)</span> 且 <span class="math inline">\(\dfrac{\partial (\dfrac{x+y}{x^2+y^2})}{\partial y}=\dfrac{\partial (\dfrac{y-x}{x^2+y^2})}{\partial x}=\dfrac{x^2-2xy-y^2}{(x^2+y^2)^2}\)</span></p><p>从而变换后的方程为全微分方程，并注意到 <span class="math display">\[d(\dfrac{1}{2}\ln(x^2+y^2)-\arctan (\dfrac{y}{x}))=\dfrac{x+y}{x^2+y^2}dx+\dfrac{y-x}{x^2+y^2}dy=0\]</span> 则原方程的解为 <span class="math inline">\(\ln(\sqrt{x^2+y^2})-\arctan (\dfrac{y}{x})=C,C\in R\)</span></p><p><span class="math inline">\((3)\)</span> 两边同时除以 <span class="math inline">\(x^2\)</span>（消去 <span class="math inline">\(x^2y\)</span> 中含 <span class="math inline">\(x\)</span> 项 ），得到 <span class="math inline">\((3+\dfrac{y}{x^2})dx+(2y-\dfrac{1}{x})dy=0\)</span> 且有</p><p><span class="math inline">\(\dfrac{\partial (3+\dfrac{y}{x^2})}{\partial y}=\dfrac{\partial (2y-\dfrac{1}{x})}{\partial x}=\dfrac{1}{x^2}\)</span> 为全微分方程，注意到 <span class="math display">\[d(3x-\dfrac{y}{x}+y^2)=0\]</span> 则原方程的解为 <span class="math inline">\(3x-\dfrac{y}{x}+y^2=C,C\in R\)</span></p><p><span class="math inline">\((4)\)</span> 两边除以 <span class="math inline">\(x+y\)</span> 有 <span class="math inline">\(dx-dy=\dfrac{dx+dy}{x+y}\)</span> 后者有 <span class="math inline">\(\dfrac{\partial (\dfrac{1}{x+y})}{\partial y}=\dfrac{\partial (\dfrac{1}{x+y})}{\partial x}=-\dfrac{1}{(x+y)^2}\)</span> 为全微分</p><p><span class="math inline">\(d(x-y)=\dfrac{dx+dy}{x+y}=d(\ln(|x+y|))\)</span>，则原方程的解为 <span class="math inline">\(x-y=\ln|x+y|+C,C\in R\)</span></p><p><span class="math inline">\((5)\)</span>​ 记 <span class="math inline">\(M=x^2-\sin ^2y, N=x\sin 2y\)</span>, 有 <span class="math display">\[\frac{\partial M}{\partial y}=-\sin 2y, \frac{\partial N}{\partial x}=\sin 2y\]</span> 则方程不是恰当的. 观察到 <span class="math inline">\(\dfrac{\dfrac{\partial M}{\partial y}-\dfrac{\partial N}{\partial x}}{-N}=-\dfrac{2}{x}=f(x)\)</span>, 对应原方程有积分因子 <span class="math inline">\(\mu=\mathrm{e}^{-\int\frac{2}{x} dx}=\dfrac{1}{x^2}\)</span> <span class="math display">\[\begin{gathered}(1-\dfrac{\sin ^2y}{x^2})dx+\dfrac{\sin 2y}{x}dy=0\Longrightarrow d(x+\dfrac{\sin ^2y}{x})=0\end{gathered}\]</span> 则原方程的通解为 <span class="math inline">\(x+\dfrac{\sin ^2y}{x}=C, C\in R\)</span></p><h2 id="第四章总复习题-4">第四章总复习题 4</h2><p>设 <span class="math inline">\(L \subset \mathbb{R}^{2}\)</span> 为光滑闭曲线, 逆时针为正向, <span class="math inline">\(\boldsymbol{n}\)</span> 为 <span class="math inline">\(L\)</span> 的外法线单位向量, <span class="math inline">\(\boldsymbol{a}\)</span> 为一固定向量, 求证: <span class="math display">\[\oint_{L} \cos \langle\boldsymbol{n}, \boldsymbol{a}\rangle \mathrm{d} l=0\]</span></p><hr /><p>证明：由 <span class="math inline">\(\boldsymbol{n}=\dfrac{1}{dl}(dy,-dx)\)</span> 则代入有 <span class="math inline">\(\displaystyle \oint_{L} \cos \langle\boldsymbol{n}, \boldsymbol{a}\rangle \mathrm{d} l=\oint_{L} a_xdy-a_ydx\)</span> 由格林公式 <span class="math display">\[\oint_{L} a_xdy-a_ydx=\iint_{D}(0-0)dxdy=0\]</span></p><h2 id="第四章总复习题-6">第四章总复习题 6</h2><p>设 <span class="math inline">\(L\)</span> 为一单连通区域 <span class="math inline">\(D \subset \mathbb{R}^{2}\)</span> 的边界, <span class="math inline">\(P_{0}\)</span> 为一定点, <span class="math inline">\(P \in L, \boldsymbol v=\overrightarrow{P_{0} P}, v=\)</span> <span class="math inline">\(\|\boldsymbol v\|, \boldsymbol{n}\)</span> 为 <span class="math inline">\(L\)</span> 的外法线单位向量, 证明 <span class="math display">\[\oint_{L} \frac{\cos \langle\boldsymbol{n}, v\rangle}{v} \mathrm{~d} l= \begin{cases}2\pi, &amp; P_{0} \in D, \\ 0, &amp; P_{0} \notin D .\end{cases}\]</span></p><hr /><p>证明：代入 <span class="math inline">\(\boldsymbol v =\boldsymbol p-\boldsymbol p_0=(x,y)-\boldsymbol p_0,\boldsymbol{n}=\dfrac{1}{dl}(dy,-dx)\)</span> 令 <span class="math inline">\(\boldsymbol p_0=(x_0,y_0)\)</span>有 <span class="math display">\[\displaystyle \oint_{L} \frac{\cos \langle\boldsymbol{n}, v\rangle}{v} \mathrm{~d} l=\oint_{L} \dfrac{(x-x_0)dy-(y-y_0)dx}{(\sqrt{(x-x_0)^2+(y-y_0)^2})^2}=\oint_{L} \dfrac{(x-x_0)dy-(y-y_0)dx}{(x-x_0)^2+(y-y_0)^2}\]</span> 由格林公式化为二重积分 <span class="math display">\[\begin{gathered}\oint_{L} \dfrac{(x-x_0)dy-(y-y_0)dx}{(x-x_0)^2+(y-y_0)^2}=\iint_{D}(\dfrac{(x-x_0)^2+(y-y_0)^2-(x-x_0)\cdot 2(x-x_0)}{((x-x_0)^2+(y-y_0)^2)^2}\\-(-\dfrac{(x-x_0)^2+(y-y_0)^2-(y-y_0)\cdot 2(y-y_0)}{((x-x_0)^2+(y-y_0)^2)^2}))dxdy=\iint_{D}\dfrac{0\cdot dxdy}{(x-x_0)^2+(y-y_0)^2}\end{gathered}\]</span> 当 <span class="math inline">\((x,y)\)</span> 保持不等于 <span class="math inline">\((x_0,y_0)\)</span> 时，上述二重积分恒为 <span class="math inline">\(0\)</span>，只需满足 <span class="math inline">\(P_0\)</span> 不在二重积分区域内，此时 <span class="math inline">\(P_0\not\in D\)</span></p><p>而当 <span class="math inline">\(P_0\not\in D\)</span> 时，令 <span class="math inline">\(x-x_0=r\cos \theta,y-y_0=r\sin \theta\)</span>，二重积分有瑕点，对线积分计算 <span class="math display">\[\oint_{L} \dfrac{(x-x_0)dy-(y-y_0)dx}{(x-x_0)^2+(y-y_0)^2}=\oint_{L} \dfrac{r\cos \theta d(r\sin \theta)-r\sin \theta d(r\cos \theta)}{r^2}=\oint_{L}\dfrac{r^2}{r^2}d\theta\]</span> 由于瑕点 <span class="math inline">\(r=0\)</span> 为零测度集，从而 <span class="math inline">\(\displaystyle \int_{0}^{2\pi}d\theta=2\pi\)</span>，综上有 <span class="math inline">\(\displaystyle \oint_{L} \frac{\cos \langle\boldsymbol{n}, v\rangle}{v} \mathrm{~d} l= \begin{cases}2\pi, &amp; P_{0} \in D, \\ 0, &amp; P_{0} \notin D .\end{cases}\)</span></p><h2 id="第四章总复习题-9">第四章总复习题 9</h2><p>设 <span class="math inline">\(u\)</span> 为开集 <span class="math inline">\(D \subset R^{2}\)</span> 上的调和函数. 即 <span class="math inline">\(\left(\Delta u \equiv \dfrac{\partial^{2} u}{\partial x^{2}}+\dfrac{\partial^{2} u}{\partial y^{2}}=0\right)\)</span>, 证明:</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\displaystyle u\left(x_{0}, y_{0}\right)=\frac{1}{2 \pi} \oint_{\partial D}\left(u \frac{\partial \ln r}{\partial \boldsymbol{n}}-\ln r \frac{\partial u}{\partial \boldsymbol{n}}\right) \mathrm{d} l\)</span>, 其中 <span class="math inline">\(\left(x_{0}, y_{0}\right) \in D, \boldsymbol{r}\)</span> 为 <span class="math inline">\(\left(x_{0}, y_{0}\right)\)</span> 到 <span class="math inline">\(\partial D\)</span> 上点的向量,</p><p><span class="math inline">\(r=\|\boldsymbol{r}\|, \boldsymbol{n}\)</span> 为 <span class="math inline">\(D\)</span> 的单位外法向量;</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\displaystyle u\left(x_{0}, y_{0}\right)=\frac{1}{2 \pi R} \oint_{L} u(x, y) \mathrm{d} l\)</span>, 其中 <span class="math inline">\(L\)</span> 是以 <span class="math inline">\(\left(x_{0}, y_{0}\right)\)</span> 为中心, <span class="math inline">\(R\)</span> 为半径位于 <span class="math inline">\(D\)</span> 中的任意一个圆周.</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 当 <span class="math inline">\((x, y) \neq\left(x_{0}, y_{0}\right)\)</span> 时, <span class="math inline">\(v=\ln r=\ln \sqrt{\left(x-x_{0}\right)^{2}+\left(y-y_{0}\right)^{2}}\)</span> 为调和函数,</p><p>(可以计算拉普拉斯 <span class="math inline">\(\Delta v=\dfrac{\partial^{2} v}{\partial x^{2}}+\dfrac{\partial^{2} v}{\partial y^{2}}=\dfrac{1}{r^{4}}\left[\left(y-y_{0}\right)^{2}-\left(x-x_{0}\right)^{2}\right]+\dfrac{1}{r^{4}}\left[\left(x-x_{0}\right)^{2}-\right.\)</span> <span class="math inline">\(\left.\left(y-y_{0}\right)^{2}\right]=0\)</span> )</p><p>因此, 以 <span class="math inline">\(\left(x_{0}, y_{0}\right)\)</span> 为中心挖去半径为 <span class="math inline">\(\varepsilon&gt;0\)</span> (充分小)的圆形区域 <span class="math inline">\(S_{r}\)</span>, 则在剩下的区域（记作 <span class="math inline">\(D_{1}\)</span> ), 对 <span class="math inline">\(u, v\)</span> 可应用</p><p><span class="math inline">\(\small 4.6.8(3)\)</span> 中结论：<span class="math inline">\(\displaystyle \oint_{\partial D}\left|\begin{array}{cc}\dfrac{\partial u}{\partial \boldsymbol{n}} &amp; \dfrac{\partial v}{\partial \boldsymbol{n}} \\ u &amp; v\end{array}\right| \mathrm{d} l=\iint_{D}\left|\begin{array}{cc}\Delta u &amp; \Delta v \\ u &amp; v\end{array}\right| \mathrm{d} x \mathrm{~d} y\)</span> <span class="math display">\[\oint_{L \uparrow+c_{r}\downarrow } \left(u \frac{\partial \ln r}{\partial n}-\ln r \frac{\partial u}{\partial n}\right) \mathrm{d} l=\iint_{D}\left|\begin{array}{cc}\Delta u &amp; \Delta \ln r \\u &amp; \ln r\end{array}\right| \mathrm{d} x \mathrm{~d} y=\iint_{D}\left|\begin{array}{cc}0 &amp; 0 \\u &amp; \ln r\end{array}\right| \mathrm{d} x \mathrm{~d} y=0\]</span> 从而拆开左边环路积分并移项有 <span class="math display">\[\begin{gathered}\oint_{L\uparrow }\left(u \frac{\partial \ln r}{\partial n}-\ln r \frac{\partial u}{\partial n}\right) \mathrm{d} l=\oint_{c_{g}\uparrow } \left(u \frac{\partial \ln r}{\partial n}-\ln r \frac{\partial u}{\partial n}\right) \mathrm{d} l=\oint_{c_{g}\uparrow } u \frac{\partial \ln r}{\partial n}-\oint_{c_{g}\uparrow } \ln r \frac{\partial u}{\partial n} \mathrm{~d} s \stackrel{\triangle}{=}I_{1}+I_{2}\end{gathered}\]</span> 利用 <span class="math inline">\(\mbox{Green}\)</span> 公式计算 <span class="math inline">\(I_2\)</span> <span class="math display">\[\begin{aligned}I_{2} =\oint_{c_{g}\uparrow } \ln r \frac{\partial u}{\partial n} \mathrm{~d} l=\ln \varepsilon \oint_{c_{g}\uparrow }\left[\frac{\partial u}{\partial x} \cos (n, x)+\frac{\partial u}{\partial y} \cos (n, y)\right] \mathrm{d} l=\ln \varepsilon \iint_{S_{\epsilon}} \Delta u \mathrm{~d} x \mathrm{~d} y=0 .\end{aligned}\]</span> 注意在 <span class="math inline">\(C_{g}\)</span> 上 <span class="math display">\[\left.\frac{\partial \ln r}{\partial n}\right|_{r=e}=\left.\frac{\partial \ln r}{\partial r}\right|_{r=e}=\left.\frac{1}{r}\right|_{r=e}=\frac{1}{\varepsilon}\]</span> 因此 <span class="math display">\[I_{1}=\oint_{C_{\varepsilon}} u \frac{\partial \ln r}{\partial n} \mathrm{~d} s=\frac{1}{\varepsilon} \oint_{c_{\varepsilon}} u \mathrm{~d} s\]</span> 将 <span class="math inline">\(I_2,I_1\)</span> 结果代入并利用中值定理得到 <span class="math display">\[\begin{gathered}\frac{1}{2 \pi} \oint_{L}\left(u \frac{\partial \ln r}{\partial n}+\ln r \frac{\partial u}{\partial n}\right) \mathrm{d} s=\frac{1}{2 \pi \varepsilon} \oint_{C_{\varepsilon}} u \mathrm{~d} s=\frac{1}{2 \pi \varepsilon} u(Q) \oint_{c_{\varepsilon}} \mathrm{d} s\end{gathered}\]</span> 取 <span class="math inline">\(\epsilon \to 0\)</span> 便得到 <span class="math inline">\(u(Q)\to u(x_0,y_0)\)</span></p><p><span class="math inline">\((2)\)</span> 在 <span class="math inline">\(\displaystyle u\left(x_{0}, y_{0}\right)=\frac{1}{2 \pi} \oint_{\partial D}\left(u \frac{\partial \ln r}{\partial \boldsymbol{n}}-\ln r \frac{\partial u}{\partial \boldsymbol{n}}\right) \mathrm{d} l\)</span> 中取 <span class="math inline">\(L=C_{r}\)</span>，为半径为 <span class="math inline">\(R\)</span> 的正圆，有 <span class="math display">\[\oint_{\partial D}\ln r \frac{\partial u}{\partial \boldsymbol{n}}\mathrm{d} l=\ln R\oint_{\partial D}\frac{\partial u}{\partial \boldsymbol{n}}\mathrm{d} l=\ln R \oint_{\partial D}(\frac{\partial u}{\partial x}dy-\frac{\partial u}{\partial y}dx)=0\]</span> 前者有 <span class="math inline">\(R=r=\sqrt{x^2+y^2}\)</span> 代入 <span class="math inline">\(\dfrac{\partial \ln r}{\partial \boldsymbol{n}}=\dfrac{x}{(\sqrt{x^2+y^2})^2}\dfrac{dy}{dl}-\dfrac{y}{(\sqrt{x^2+y^2})^2}\dfrac{dx}{dl}=\dfrac{x}{R^2}\dfrac{dy}{dl}-\dfrac{y}{R^2}\dfrac{dx}{dl}\)</span></p><p>有 <span class="math inline">\(x(x_0,y_0)=\dfrac{1}{2\pi R}\displaystyle \oint u\dfrac{xdy-ydx}{R}=\dfrac{1}{2\pi R}\displaystyle \oint u dl\)</span></p><blockquote><p>在物理中，该公式代表在一个无电荷分布静电场 <span class="math inline">\(\nabla^2 \varphi=0\)</span> 中，任意平面圆的平均电势等于圆心的电势</p><p>物理证明：在平面圆心中央放置一个带电量为 <span class="math inline">\(\mathcal{q_1}\)</span> 的点电荷，其周围半径为 <span class="math inline">\(R\)</span> 的一固定圆环均匀放置</p><p>总电量为 <span class="math inline">\(\mathcal{q}_2\)</span> 的电荷，两者电荷量 <span class="math inline">\(\to 0\)</span>，对原始电场分布几乎无影响（以任意 $$ 精度保持解析性）</p><p>由静电场中的格林互逆定理 <span class="math display">\[\sum\varphi(q_1)q_2=\sum\varphi(q_2)q_1\]</span> 代入静电能 $(q_1)q_2=(_0+K)q_2,(q_2)q_2=Kq_1+() $</p><p>令 <span class="math inline">\(q_1=q_2\to 0\)</span>，便可以得到 <span class="math inline">\(\varphi_0=\dfrac{1}{2\pi}\displaystyle \int\varphi(\theta)d\theta\)</span></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>多元微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多元微积分作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elementary number theory homework 1-15</title>
    <link href="/2022/06/17/Math/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E4%BD%9C%E4%B8%9A%E5%90%88%E9%9B%86%EF%BC%881-15%EF%BC%89/"/>
    <url>/2022/06/17/Math/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E4%BD%9C%E4%B8%9A%E5%90%88%E9%9B%86%EF%BC%881-15%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>作业 <span class="math inline">\(\mathbf{PDF}\)</span> 文件下载请点击这里 <a href="https://lr-tsinghua11.github.io/pdf/初等数论作业合集（1-15）.pdf">初等数论作业</a></p><h1 id="largetextcolorblue初等数论第一次作业-_textcolorblue2022.2.22"><span class="math inline">\(\large\textcolor{blue}{初等数论第一次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.2.22}\)</span></h1><h2 id="习题-1.1.1">习题 1.1.1</h2><p>设 <span class="math inline">\(n\)</span> 是奇数, 则 <span class="math inline">\(8 \mid n^{2}-1\)</span>.</p><hr /><p>证明：由 <span class="math inline">\(n\)</span> 是奇数，则令 <span class="math inline">\(n=2k+1\)</span>，有 <span class="math inline">\(n^2-1=(2k+1)^2-1=4k(k+1)\)</span>，由于 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(k+1\)</span> 一奇一偶，从而 <span class="math inline">\(2\mid k(k+1)\)</span>，则 <span class="math inline">\(8\mid n^2-1\)</span></p><h2 id="习题1.1.2">习题1.1.2</h2><p>设 <span class="math inline">\(n \geqslant 3\)</span> 是奇数, 证明: <span class="math inline">\(\left(1+\dfrac{1}{2}+\dfrac{1}{3}+\cdots+\dfrac{1}{n-1}\right)(n-1) !\)</span> 被 <span class="math inline">\(n\)</span> 整除.</p><hr /><p>证明：由 <span class="math inline">\(n\in \mbox{odd}\)</span> 则可以依次首尾相加得到 <span class="math display">\[1+\dfrac{1}{2}+\cdots+\dfrac{1}{n-1}=(1+\dfrac{1}{n-1})+(\dfrac{1}{2}+\dfrac{1}{n-2})+\cdots+(\dfrac{1}{\dfrac{n-1}{2}}+\dfrac{1}{\dfrac{n+1}{2}})\\=n\cdot(\dfrac{1}{1\cdot(n-1)}+\dfrac{1}{2\cdot(n-2)}+\cdots+\dfrac{1}{\dfrac{n-1}{2}\cdot\dfrac{n+1}{2}})\]</span> 而 <span class="math inline">\((n-1)!\)</span> 均有 <span class="math inline">\(1,2,\cdots,n-1\)</span> 的因子，从而 <span class="math inline">\(n\mid (1+\dfrac{1}{2}+\cdots+\dfrac{1}{n-1})(n-1)!\)</span></p><h2 id="习题1.1.3">习题1.1.3</h2><p>设 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span> 为正整数, <span class="math inline">\(m \geqslant 3\)</span>. 证明: <span class="math inline">\(2^{m}-1 \not\mid 2^{n}+1\)</span>.</p><hr /><blockquote><p>引理 <span class="math inline">\(1.1.1\)</span> <span class="math inline">\(q\in Z,x-1\mid x^{q}-1\)</span>，这是由于 <span class="math inline">\(1+x+\cdots+x^{q-1}=\dfrac{x^{q}-1}{x-1}\in Z\)</span></p></blockquote><p>证明：显然当 <span class="math inline">\(m&gt;n\)</span> 时结论不成立，假设结论不成立 <span class="math inline">\(2^{m}-1\mid 2^{n}+1\)</span>，由带余除法定理有 <span class="math inline">\(n=mq+r,r&lt;m\)</span> <span class="math display">\[\because 2^{n}+1=2^{mq+r}+1=2^{r}\cdot (2^{mq}-1)+2^{r}+1,2^{m}-1\mid 2^{mq}-1\\\therefore 2^{m}-1\mid 2^{r}+1\ 而\ r&lt;m,2^{m}-1&gt;2^{r}+1\Longleftrightarrow 2^{m}&gt;2^{r}+2\Longleftrightarrow 2^{m}-2^{r}&gt;2^{m-1}\geq4&gt;2 \]</span> 从而假设不成立，<span class="math inline">\(2^{m}-1\nmid 2^{n}+1\)</span></p><h2 id="习题1.1.4">习题1.1.4</h2><p>设 <span class="math inline">\(q\)</span> 是大于 1 的整数. 证明:</p><p><span class="math inline">\((i)\)</span> 每个正整数 <span class="math inline">\(n\)</span> 可以惟一地表示成 <span class="math display">\[n=a_{0}+a_{1} q+a_{2} q^{2}+\cdots+a_{k} q^{k},\]</span> 其中 <span class="math inline">\(a_{i}\)</span> 是满足 <span class="math inline">\(0 \leqslant a_{i} \leqslant q-1\)</span> 的整数 <span class="math inline">\((0 \leqslant i \leqslant k)\)</span>, 并且 <span class="math inline">\(a_{k} \neq\)</span> 0. 这叫作 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(q\)</span> 进制表示.</p><p><span class="math inline">\((ii)\)</span> <span class="math inline">\(a_{i}=\left[\dfrac{n}{q^{i}}\right]-q\left[\dfrac{n}{q^{i+1}}\right](0 \leqslant i \leqslant k)\)</span>.</p><hr /><p>证明：<span class="math inline">\((i)\)</span> 带余除法定理令 <span class="math inline">\(n=b_0+m_1q,0\leq b_0\leq q-1\)</span>，对 <span class="math inline">\(m_i\)</span> 重复上述步骤有 <span class="math display">\[m_1=b_1+m_2q,0\leq b_1\leq q-1\cdots ,m_k=b_k,0\leq b_k\leq q-1\]</span> 则回代得到 <span class="math inline">\(n=b_0+q(b_1+q(b_2+\cdots+(b_k)))\)</span>，展开得到 <span class="math inline">\(n=a_0+a_1q+\cdots+a_kq^k\)</span></p><p>唯一性的证明：若有两种表示方法 <span class="math inline">\(n=a_0+a_1q+\cdots+a_kq^k=c_0+c_1q+\cdots+c_kq^k\)</span>，有 <span class="math inline">\(q\mid a_0-c_0\)</span>，则由于 <span class="math inline">\(0\leq a_0,c_0\leq q-1\)</span> 得 <span class="math inline">\(a_0=c_0\)</span>，代入消去有 <span class="math inline">\(a_1+a_2q+\cdots+a_kq^k=c_1+c_2q+\cdots+c_kq^k\)</span>，同理有 <span class="math inline">\(a_i=c_i\)</span>，则表示方法唯一</p><p><span class="math inline">\((ii)\)</span> 由 <span class="math inline">\((i)\)</span> 中表示有 <span class="math inline">\(n=a_0+a_1q+\cdots+a_kq^k\)</span>，两边除以 <span class="math inline">\(q^{i}\)</span> 有 <span class="math display">\[\dfrac{n}{q^{i}}=\dfrac{a_0}{q^{i}}+\dfrac{a_1}{q^{i-1}}+\cdots a_i+a_{i+1}q+a_{i+2}q^2+\cdots+a_{k}q^{k-i}\]</span> 由 <span class="math inline">\(0\leq a_i\leq q-1\)</span> 且有取整函数的定义可知 <span class="math inline">\([\dfrac{n}{q^{i}}]=a_i+a_{i+1}q+a_{i+2}q^2+\cdots+a_{k}q^{k-i}\)</span></p><p>除以 <span class="math inline">\(q^{i+1}\)</span> 重复上述步骤得 <span class="math inline">\([\dfrac{n}{q^{i+1}}]=a_{i+1}+a_{i+2}q+\cdots+a_{k}q^{k-i-1}\)</span>，比对上述两式得 <span class="math inline">\(a_i=[\dfrac{n}{q^{i}}]-q[\dfrac{n}{q^{i+1}}]\)</span></p><h2 id="习题1.1.5">习题1.1.5</h2><p>设 <span class="math inline">\(\alpha_{1}, \cdots, \alpha_{n}\)</span> 为实数 <span class="math inline">\((n \geqslant 2)\)</span>, 证明： <span class="math display">\[\begin{aligned}{\left[\alpha_{1}\right]+\left[\alpha_{2}\right]+\cdots+\left[\alpha_{n}\right] } &amp; \leqslant\left[\alpha_{1}+\alpha_{2}+\cdots+\alpha_{n}\right] \\&amp; \leqslant\left[\alpha_{1}\right]+\left[\alpha_{2}\right]+\cdots+\left[\alpha_{n}\right]+n-1\end{aligned}\]</span></p><hr /><p>证明：记 <span class="math inline">\(\alpha_i=[\alpha_i]+\{\alpha_i\},\forall \ x\in R,\{x\}\in[0,1)\)</span>，从而有 <span class="math inline">\(\displaystyle [\sum_{i=1}^n\alpha_i]=\sum_{i=1}^n[\alpha_i]+[\sum_{i=1}^{n}\{\alpha_i\}]\geq\sum_{i=1}^n[\alpha_i]\)</span></p><p>而 <span class="math inline">\(\displaystyle [\sum_{i=1}^{n}\{\alpha_i\}]&lt;[\sum_{i=1}^{n}1]=n\)</span>，由取整特性 <span class="math inline">\(\displaystyle [\sum_{i=1}^{n}\{\alpha_i\}]\leq n-1\)</span>，则 <span class="math inline">\(\displaystyle\sum_{i=1}^n[\alpha_i]\leq [\sum_{i=1}^n\alpha_i]\leq \displaystyle\sum_{i=1}^n[\alpha_i]+n-1\)</span></p><h2 id="习题1.1.11">习题1.1.11</h2><p>设 <span class="math inline">\(n\)</span> 为正整数, <span class="math inline">\(n \geqslant 2\)</span>. 如果 <span class="math inline">\(n\)</span> 没有小于或等于 <span class="math inline">\(\sqrt{n}\)</span> 的素数因子, 则 <span class="math inline">\(n\)</span> 为素数.</p><hr /><p>证明：反证法，若 <span class="math inline">\(n\)</span> 为合数，则 <span class="math inline">\(n\)</span> 有素因子 <span class="math inline">\(q\)</span>，则 <span class="math inline">\(n=mq,m,q\in Z\)</span>，由于 <span class="math inline">\(n\)</span> 没有 <span class="math inline">\(\leq\sqrt{n}\)</span> 的素数因子 <span class="math display">\[\therefore m,q&gt;\sqrt{n},mq&gt;n\]</span> 与假设矛盾，从而 <span class="math inline">\(n\)</span> 为素数</p><h2 id="习题1.1.12">习题1.1.12</h2><p>对每个整数 <span class="math inline">\(n \geqslant 3, n\)</span> 和 <span class="math inline">\(n !\)</span> 之间必有素数. 由此证明素数有无限多个.</p><hr /><p>证明：反证法，假设 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(n!\)</span> 之间全为合数，则 <span class="math inline">\(n!-1\)</span> 为合数，其一定有素数因子，由假设知 <span class="math inline">\(n+1，n+2,\cdots,n!\)</span> 全为合数，不可能是 <span class="math inline">\(n!-1\)</span> 的素数因子，另一方面，<span class="math inline">\(\forall \ n\geq a\geq 2,a\mid n!\)</span>，从而 <span class="math display">\[P=\{p\mid p\in[2,n]\ \cap\ \mbox{p is prime} \},\forall \ x\in P,x\nmid n!-1\]</span> 则 <span class="math inline">\(n!-1\)</span> 没有小于其自身的素数因子，从而 <span class="math inline">\(n!-1\)</span> 为素数，与假设矛盾，从而 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(n!\)</span> 之间一定有素数</p><p>从 <span class="math inline">\(3\)</span> 开始， <span class="math inline">\((3,3!)\)</span> 之间有素数，<span class="math inline">\((3!,(3!)!)\)</span> 之间有素数，进而构造数列 <span class="math display">\[a_1=3,a_{n+1}=a_n!\]</span> 有 <span class="math inline">\((a_n,a_{n+1})\)</span> 之间必有素数，且区间之间无交集，将自然数集分成无穷多个区间，从而有无穷多个素数</p><h2 id="习题1.2.1">习题1.2.1</h2><p>设 <span class="math inline">\(n\)</span> 是正整数, 证明: <span class="math inline">\(\dfrac{21 n+4}{14 n+3}\)</span> 是既约分数.</p><hr /><p>证明：反证法，假设 <span class="math inline">\(\dfrac{21n+4}{14n+3}\)</span> 不是既约分数，则 <span class="math inline">\(21n+4\)</span> 和 <span class="math inline">\(14n+3\)</span> 有共同素因子 <span class="math inline">\(d\)</span> ，即 <span class="math display">\[\because (21n+4,14n+3)=d,21n+4=dm,14n+3=dn\\\therefore 3\cdot dn-2\cdot dm=42n+9-(42n+8)=1=d(3n-2m)\]</span> 而 <span class="math inline">\(d\)</span> 为大于 <span class="math inline">\(1\)</span> 的素因子，<span class="math inline">\(1\nmid d\)</span>，从而与假设矛盾，则 <span class="math inline">\(\dfrac{21n+4}{14n+3}\)</span> 是既约分数</p><h2 id="习题1.2.2">习题1.2.2</h2><p>设 <span class="math inline">\(m, n\)</span> 为正整数, <span class="math inline">\(m\)</span> 为奇数,证明： <span class="math display">\[\left(2^{m}-1,2^{n}+1\right)=1\]</span></p><hr /><p>证明：令 <span class="math inline">\((2^{m}-1,2^{n}+1)=d\)</span>，且有 <span class="math inline">\(2^{m}-1=dx,2^{n}+1=dy,x,y\in Z\)</span>，<span class="math inline">\(d\)</span> 为奇数 <span class="math display">\[\because 2^m=dx+1,2^n=dy-1\ \therefore 2^{mn}=(dx+1)^{n}=(dy-1)^m\]</span> 将其二项式展开有 <span class="math inline">\(\displaystyle \sum_{i=0}^nC_n^i(dx)^i=\sum_{i=0}^mC_m^i(dy)^i(-1)^{m-i}\)</span>，两边同时除以 <span class="math inline">\(d\)</span> 得到 <span class="math display">\[\displaystyle \sum_{i=1}^nC_n^id^{i-1}x^{i}+\dfrac{1}{d}=\sum_{i=1}^mC_m^id^{i-1}y^i(-1)^{m-i}+(-1)^m\cdot d^{-1}\]</span> 由于 <span class="math inline">\(m\)</span> 是奇数，若 <span class="math inline">\(d\geq 3\)</span>，两边取整有 <span class="math inline">\(\dfrac{1}{d}=1-\dfrac{1}{d}\)</span>，矛盾，从而 <span class="math inline">\(d=1\)</span></p><h2 id="习题1.2.3">习题1.2.3</h2><p>设 <span class="math inline">\(m, n, a\)</span> 均为正整数, <span class="math inline">\(a \geqslant 2\)</span>, 证明: <span class="math display">\[\left(a^{m}-1, a^{n}-1\right)=a^{(m, n)}-1 \text {. }\]</span></p><hr /><p>证明：令 <span class="math inline">\((m,n)=d\)</span>，且有 <span class="math inline">\(m=dx,n=dy,(x,y)=1\)</span>，由引理 <span class="math inline">\(1.1.1\)</span> 知 <span class="math display">\[a^{d}-1\mid a^{dx}-1,\ a^{dx}-1=(a^d-1)\cdot(1+a^d+a^{2d}+\cdots+a^{(x-1)d})\\a^{d}-1\mid a^{dy}-1,\ a^{dy}-1=(a^d-1)\cdot(1+a^d+a^{2d}+\cdots+a^{(y-1)d}),\\\]</span> 考虑辗转相除法，不妨设 <span class="math inline">\(x&gt;y\)</span>， <span class="math display">\[1+a^d+a^{2d}+\cdots+a^{(x-1)d}=a^{(x-y)d}(1+a^d+\cdots+a^{(y-1)d})+1+a^d+a^{2d}+\cdots+a^{(x-y-1)d}\]</span> 继续判断 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的大小关系，辗转相除，而 <span class="math inline">\((x,y)=1\)</span>，则 <span class="math display">\[(1+a^d+a^{2d}+\cdots+a^{(x-1)d},1+a^d+a^{2d}+\cdots+a^{(y-1)d})=1\]</span> 从而 <span class="math inline">\(a^{d}-1=a^{(m,n)}-1\)</span> 即为 <span class="math inline">\(a^{m}-1\)</span> 和 <span class="math inline">\(a^{n}-1\)</span> 的最大公因数</p><h1 id="largetextcolorblue初等数论第二次作业-_textcolorblue2022.3.2"><span class="math inline">\(\large\textcolor{blue}{初等数论第二次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.3.2}\)</span></h1><h2 id="习题1.2.4">习题1.2.4</h2><p>设 <span class="math inline">\(a,b,c\in Z,a\neq 0\)</span>。则 <span class="math inline">\(a\mid bc\)</span> 当且仅当 <span class="math inline">\(\dfrac{a}{(a,b)}\mid c\)</span></p><hr /><p>证明：取 <span class="math inline">\(d=(a,b)\)</span>，令 <span class="math inline">\(a=dx,b=dy\)</span>，且有 <span class="math inline">\((x,y)=1\)</span></p><p><span class="math inline">\((1)\)</span> 若 <span class="math inline">\(a\mid bc\)</span>， <span class="math inline">\(\exists \ t\in Z,\ bc=at\ \therefore yc=xt \ \ x\mid yc\)</span>，由于 <span class="math inline">\((x,y)=1\)</span>，得 <span class="math inline">\(x\mid c\)</span>，即 <span class="math inline">\(\dfrac{a}{(a,b)}\mid c\)</span>；</p><p><span class="math inline">\((2)\)</span> 若 <span class="math inline">\(\dfrac{a}{(a,b)}\mid c\)</span>，则 <span class="math inline">\(\exists \ t\in Z,\ c=\dfrac{a}{(a,b)}\cdot t\ \therefore (a,b)\cdot c=at=dc=dxt\)</span>，即 <span class="math inline">\(c=xt\)</span>， 两边乘</p><p>以 <span class="math inline">\(b=dy\)</span> 得 <span class="math inline">\(bc=xydt=ayt\)</span>，从而 <span class="math inline">\(a\mid bc\)</span>。</p><p>综上，<span class="math inline">\(a\mid bc \Longleftrightarrow \dfrac{a}{(a,b)}\mid c\)</span></p><h2 id="习题1.2.5">习题1.2.5</h2><p><span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span> 是互素的正整数，证明：</p><p><span class="math inline">\(\ \ \ (1)\)</span> 对每个整数 <span class="math inline">\(a\)</span>，<span class="math inline">\((a,mn)=(a,m)(a,n)\)</span>；</p><p><span class="math inline">\(\ \ \ (2)\)</span> <span class="math inline">\(mn\)</span> 的每个正因子 <span class="math inline">\(d\)</span> 均可唯一地表示成 <span class="math inline">\(d=d_1d_2\)</span>，其中 <span class="math inline">\(d_1\)</span> 和 <span class="math inline">\(d_2\)</span> 分别为 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span> 的正因子。</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 对 <span class="math inline">\((a,mn)=(a,m)\cdot(\dfrac{a}{(a,m)},\dfrac{mn}{(a,m)})\)</span>，由于 <span class="math inline">\(\dfrac{a}{(a,m)}\)</span> 和 <span class="math inline">\(\dfrac{m}{(a,m)}\)</span> 互素，则 <span class="math display">\[(a,mn)=(a,m)\cdot (\dfrac{a}{(a,m)},\dfrac{mn}{(a,m)})=(a,m)\cdot \normalsize (\dfrac{a}{(a,m)},n)令\ a=k_1x,m=k_2x\ \\ \because (m,n)=1\therefore(k_2x,n)=(x,n)=1,(\dfrac{a}{(a,m)},n)=(k_1,n)=(k_1x,n)=(a,n)\]</span> 则有 <span class="math inline">\((a,mn)=(a,m)(a,n)\)</span></p><p><span class="math inline">\((2)\)</span> 由算术基本定理，令 $m=p_1^{_1}p_2^{_2}p_r^{_r},n=q_1^{_1}q_2^{_2}q_k^{_k},1_i,_i $，由 <span class="math inline">\((m,n)=1\)</span></p><p><span class="math inline">\(\forall \ 1\leq i\leq r,1\leq j\leq k,p_i\neq q_j\)</span>，否则设相等素数为 <span class="math inline">\(p_{i_{0}}\)</span> <span class="math inline">\((m,n)\geq p_{i_0}&gt;1\)</span> 矛盾，则有新序列集合</p><p><span class="math inline">\(\mathbb{S}=\{p_1,\cdots,p_r,q_1,\cdots,q_k\}\)</span>，有 <span class="math inline">\(mn=p_1^{\alpha_1}\cdots p_r^{\alpha_r}\cdot q_1^{\beta_1}\cdots q_k^{\beta_k}\)</span>，若 <span class="math inline">\(d\)</span> 为 <span class="math inline">\(mn\)</span> 的因子，则</p><p>总有 <span class="math inline">\(d=p_1^{\gamma_1}\cdots p_{r}^{\gamma_{r}}\cdot q_{1}^{\lambda_{1}}\cdots q_{k}^{\lambda_{k}},0\leq\gamma_{i},\lambda_{i}\)</span>，则分离 <span class="math inline">\(d_1=p_1^{\gamma_1}\cdots p_{r}^{\gamma_{r}},d_2=q_{1}^{\lambda_{1}}\cdots q_{k}^{\lambda_{k}}\)</span></p><p>使得 <span class="math inline">\(d=d_1d_2\)</span>，且由于 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(q_i\)</span> 完全不同，该分解存在且唯一</p><h2 id="习题1.2.6">习题1.2.6</h2><p>设 <span class="math inline">\(n\)</span> 为正整数，<span class="math inline">\(a,b\)</span> 是不全为零的整数，证明：</p><p><span class="math inline">\(\ \ \ (1)\)</span> <span class="math inline">\((a^n,b^n)=(a,b)^n\)</span>；</p><p><span class="math inline">\(\ \ \ (2)\)</span> 若 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 是互素的正整数，<span class="math inline">\(ab=c^n,c\in Z\)</span>，则 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都是正整数的 <span class="math inline">\(n\)</span> 次方幂。</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 记 <span class="math inline">\((a,b)=d\)</span>，则有 <span class="math inline">\(a=dx,b=dy,x,y\in Z\)</span>，从而 <span class="math inline">\(a^n=d^nx^n,b^n=d^ny^n\)</span></p><p>从而 <span class="math inline">\(d^n\mid a^n,d^n\mid b^n,d^n\mid (a^n,b^n)\)</span>，则令 <span class="math inline">\((a^n,b^n)=td^n,t\in Z\)</span>，代入上式有</p><p><span class="math inline">\(\dfrac{a^n}{(a^n,b^n)}=tx^n,\ \dfrac{b^n}{(a^n,b^n)}=ty^n\)</span>，结合 <span class="math inline">\((x^n,y^n)=1\)</span> 有 <span class="math inline">\(1=(\dfrac{a^n}{(a^n,b^n)},\dfrac{b^n}{(a^n,b^n)})=t\)</span>，</p><p><span class="math inline">\(\therefore (a^n,b^n)=1\cdot d^n=(a,b)^n\)</span></p><p><span class="math inline">\((2)\)</span> 由算术基本定理，令 $a=p_1^{_1}p_2^{_2}p_r^{_r},b=q_1^{_1}q_2^{_2}q_k^{_k},1_i,_i $，由 <span class="math inline">\((a,b)=1\)</span></p><p><span class="math inline">\(\forall \ 1\leq i\leq r,1\leq j\leq k,p_i\neq q_j\)</span>​，否则设相等素数为 <span class="math inline">\(p_{i_{0}}\)</span> <span class="math inline">\((m,n)\geq p_{i_0}&gt;1\)</span> 矛盾，则有新序列集合</p><p><span class="math inline">\(\mathbb{S}=\{p_1,\cdots,p_r,q_1,\cdots,q_k\}\)</span>，有 <span class="math inline">\(ab=p_1^{\alpha_1}\cdots p_r^{\alpha_r}\cdot q_1^{\beta_1}\cdots q_k^{\beta_k}=c^n\)</span>，同理对 <span class="math inline">\(c\)</span> 分解有</p><p><span class="math inline">\(c=m_1^{\gamma_1}\cdots m_l^{\gamma_{l}}\)</span>，代入有 <span class="math inline">\(p_1^{\alpha_1}\cdots p_r^{\alpha_r}\cdot q_1^{\beta_1}\cdots q_k^{\beta_k}=m_1^{n\gamma_1}\cdots m_l^{n\gamma_{l}}\)</span>，由算术基本定理有</p><p><span class="math inline">\(\alpha_{i}=n\gamma_{a_{i}},\beta_{i}=n\gamma_{b_{i}}\)</span>，则 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 均能写成某个正整数的 <span class="math inline">\(n\)</span> 次幂</p><h2 id="习题1.29">习题1.29</h2><p>求 <span class="math inline">\(963x+657y=(963,657)\)</span> 的全部整数解。</p><hr /><p>解：由欧几里得辗转相除法有 <span class="math display">\[963=657+306\longrightarrow 657=306\times 2+45\longrightarrow 306=45\times 6+36\\\longrightarrow 45=36\times 1+9\longrightarrow 36=9\times 4\]</span> 从而 <span class="math inline">\((963,657)=9\)</span>，依次反向欧几里得算法有 <span class="math display">\[9=45-36\times 1=45-(306-45\times 6)=45\times 7-306=(657-306\times 2)\times7-306\\=657\times 7-306\times 15=657\times 7-306\times 15=657\times 7-(963-657)\times 15\\=963\times(-15)+657\times22\]</span> 则 <span class="math inline">\(963x+657y=(963,657)=9\)</span>，可以化为 <span class="math inline">\(107x+73y=1\)</span>，从而其解为 <span class="math display">\[\begin{cases}x=-15+73t\\y=22-107t\end{cases}\ \ \ \ t\in Z\]</span></p><h2 id="习题1.2.10">习题1.2.10</h2><p>求下列方程的全部整数解：</p><p><span class="math inline">\(\ \ \ (1)\)</span> <span class="math inline">\(6x+20y-15z=23\)</span>；</p><p><span class="math inline">\(\ \ \ (2)\)</span> <span class="math inline">\(25x+13y+7z=2\)</span>。</p><hr /><p><span class="math inline">\((1)\)</span> 由 <span class="math inline">\((20,15)=5\)</span>，则 <span class="math inline">\(6x+20y-15z=23\Longleftrightarrow \begin{cases}20y-15z=5\omega\cdots\boldsymbol ①\\6x+5\omega=23\cdots\boldsymbol ②\end{cases}\)</span></p><p>对 <span class="math inline">\(\boldsymbol ②\)</span>，由 <span class="math inline">\(6=5\times 1+1\)</span>，则 <span class="math inline">\(1=6\times1+5\times(-1)\)</span>，则 <span class="math inline">\(\boldsymbol ②\)</span> 解为 <span class="math inline">\(\begin{cases}x=23+5t\\\omega=-23-6t\end{cases}\)</span></p><p>代入 <span class="math inline">\(\boldsymbol ①\)</span> 变形为 <span class="math inline">\(4y-3z=\omega=-23-6t\)</span>，由 <span class="math inline">\(4=3\times1+1\)</span>，则解 <span class="math inline">\(\begin{cases}y=\omega+3u\\z=\omega+4u\end{cases}\)</span></p><p>从而 <span class="math inline">\(6x+20y-15z=23\)</span> 的通解为 <span class="math inline">\(\begin{cases}x=23+5t\\y=-23-6t+3u\\z=-23-6t+4u\end{cases}\ \ \ \ \ t,u\in Z\)</span></p><p><span class="math inline">\((2)\)</span> 由 <span class="math inline">\((13,7)=1\)</span>，则 <span class="math inline">\(25x+13y+7z=2\Longleftrightarrow \begin{cases}13y+7z=\omega\cdots\boldsymbol ①\\25x+\omega=1\cdots\boldsymbol ②\end{cases}\)</span></p><p>对 <span class="math inline">\(\boldsymbol ②\)</span>，由 <span class="math inline">\(25=25\times 1\)</span>，则 <span class="math inline">\(1=25\times 0+1\times1\)</span>，则 <span class="math inline">\(\boldsymbol ②\)</span> 解为 <span class="math inline">\(\begin{cases}x=t\\\omega=1-25t\end{cases}\)</span></p><p>代入 <span class="math inline">\(\boldsymbol ①\)</span> 变形为 <span class="math inline">\(13y+7z=\omega=1-25t\)</span>，由 <span class="math inline">\(1=7\times 2-13\)</span>，则解 <span class="math inline">\(\begin{cases}y=-\omega+7u\\z=2\omega-13u\end{cases}\)</span></p><p>从而 <span class="math inline">\(25x+13y+7z=2\)</span> 的通解为 <span class="math inline">\(\begin{cases}x=t\\y=-1+25t+7u\\z=2-50t-13u\end{cases}\ \ \ \ \ t,u\in Z\)</span></p><h2 id="习题1.2.12">习题1.2.12</h2><p>设 <span class="math inline">\(f(x)=x^n+a_1x^{n-1}+\cdots +a_{n-1}x+a_n\)</span> 为首项系数为 <span class="math inline">\(1\)</span> 的整系数多项式，</p><p>则 <span class="math inline">\(f(x)\)</span> 的每个有理根必为整数。</p><hr /><p>证明：若整系数多项式 <span class="math inline">\(x^n+a_1x^{n-1}+\cdots+a_{n-1}x+a_n=0\)</span> 有理根为 <span class="math inline">\(\dfrac{p}{q}(p,q\in Z,q\neq 0)\)</span> <span class="math display">\[\because (p,q)=1,(\dfrac{p}{q})^{n}+a_1(\dfrac{p}{q})^{n-1}+\cdots+a_{n-1}\dfrac{p}{q}+a_n=0\\\therefore p^{n}=-(a_1p^{n-1}q+\cdots+a_{n-1}pq^{n-1}+a_nq^{n})\therefore q\mid p^{n}\Longrightarrow q=1\]</span> 从而所有有理根必为整数</p><h2 id="习题1.2.13">习题1.2.13</h2><p>设 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span> 为正整数，则在 <span class="math inline">\(n,2n,\cdots,mn\)</span> 这 <span class="math inline">\(m\)</span> 个数当中恰有 <span class="math inline">\((m,n)\)</span> 个是 <span class="math inline">\(m\)</span> 的倍数。</p><hr /><p>证明：令 <span class="math inline">\(d=(m,n)\)</span>，且 <span class="math inline">\(m=dx,n=dy,(x,y)=1\)</span>，从而 <span class="math inline">\(kn,k=1,2,\cdots,m\)</span> 满足</p><p><span class="math inline">\(m\mid kn,dx\mid kdy\Longrightarrow x\mid ky\)</span>，由于 <span class="math inline">\((x,y)=1\)</span>，则 <span class="math inline">\(x\mid k\)</span>，即 <span class="math inline">\(k\)</span> 是 <span class="math inline">\(x\)</span> 的倍数，即 <span class="math inline">\(k=xt,t\in Z\)</span></p><p>而 <span class="math inline">\(m=dx\)</span>，恰好为 <span class="math inline">\(1\cdot x,2\cdot x\cdots ,d\cdot x\)</span> ，恰共有 <span class="math inline">\(d =(m,n)\)</span> 个</p><h2 id="习题1.2.16">习题1.2.16</h2><p>设 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span> 是互素的非零整数。证明对整数 <span class="math inline">\(a\)</span>，若 <span class="math inline">\(m\mid a,n\mid a\)</span>，则 <span class="math inline">\(mn\mid a\)</span></p><hr /><p>证明：已知 <span class="math inline">\((m,n)=1\)</span>，由 <span class="math inline">\(m,n\mid a\)</span>，设 <span class="math inline">\(a=mx=ny,x,y\in Z\)</span>，有 <span class="math inline">\((mx,nx)=x(m,n)=x\)</span></p><p>代入 <span class="math inline">\(mx=ny\)</span> 得 <span class="math inline">\(x=(ny,nx)=n(y,x)\)</span>，则 <span class="math inline">\(n\mid x,mn\mid mx=a\)</span>，即 <span class="math inline">\(mn\mid a\)</span></p><h2 id="习题1.3.3">习题1.3.3</h2><p>设 <span class="math inline">\(a,b,c\)</span> 为正整数，证明</p><p><span class="math inline">\(\ \ \ (1)\)</span> <span class="math inline">\((a,[b,c])=[(a,b),(a,c)]\)</span>；</p><p><span class="math inline">\(\ \ \ (2)\)</span> <span class="math inline">\([a,(b,c)]=([a,b],[a,c])\)</span>。</p><hr /><p>证明：由算术基本定理，设 <span class="math inline">\(a,b,c\)</span> 三者分解下所有质因数的交集为 <span class="math inline">\(\{p_1\cdots p_N\}\)</span>，且三者对应的</p><p>幂次为 <span class="math inline">\(\{a_n\},\{b_n\},\{c_{n}\},0\leq a_i,b_i,c_i\in Z\)</span>，即 <span class="math inline">\(a,b,c=\displaystyle \prod p_{i}^{a_i,b_i,c_i}\)</span></p><p><span class="math inline">\((1)\)</span> <span class="math inline">\((a,[b,c])=\displaystyle \prod p_{i}^{\min(a_i,\max({b_i,c_i}))}\)</span> 和 <span class="math inline">\([(a,b),(a,c)]=\displaystyle \prod p_{i}^{\max(\min(a_i,b_i),\min(a_i,c_i))}\)</span></p><p><span class="math inline">\((a,[b,c])=[(a,b),(a,c)]\Longleftrightarrow \min(a_i,\max(b_i,c_i))=\max(\min(a_i,b_i),\min(a_i,c_i))\)</span></p><p>而对后者，调换 <span class="math inline">\(b\)</span> 和 <span class="math inline">\(c\)</span> 对等式左右两边都不变，不妨设 <span class="math inline">\(b\leq c\)</span>，从而分类以下三种情况： <span class="math display">\[\begin{gathered}i) a \leq b \leq c;\ \ \ \ ii) b \leq a \leq c;\ \ \ \ iii) b \leq c \leq a\\i) \max \{a, \min \{b, c\}\}=\max \{a, b\}=b, \min \{\max \{a, b\}, \max \{a, c\}\}=\min \{b, c\}=b;\\ii) \max \{a, \min \{b, c\}\}=\max \{a, b\}=a, \min \{\max \{a, b\}, \max \{a, c\}\}=\min \{a, c\}=a;\\iii) \max \{a, \min \{b, c\}\}=\max \{a, b\}=a, \min \{\max \{a, b\}, \max \{a, c\}\}=\min \{a, a\}=a;\end{gathered}\]</span> 从而后者成立，有 <span class="math inline">\((a,[b,c])=[(a,b),(a,c)]\)</span> 成立</p><p><span class="math inline">\((2)\)</span> 仿照 <span class="math inline">\(\small (1)\)</span> 讨论 <span class="math inline">\(\max(a_i,\min(b_i,c_i))=\min(\max(a_i,b_i),\max(a_i,c_i))\)</span>，也不妨设 <span class="math inline">\(b\leq c\)</span> <span class="math display">\[\begin{gathered}i) a \leq b \leq c;\ \ \ \ ii) b \leq a \leq c;\ \ \ \ iii) b \leq c \leq a\\i) \min \{a, \max \{b, c\}\}=\min \{a, c\}=a, \max \{\min \{a, b\}, \min \{a, c\}\}=\max \{a, a\}=a;\\ii) \min \{a, \max \{b, c\}\}=\min \{a, c\}=a, \max \{\min \{a, b\}, \min \{a, c\}\}=\max \{b, a\}=a;\\iii) \min \{a, \max \{b, c\}\}=\min \{a, c\}=c, \max \{\min \{a, b\}, \min \{a, c\}\}=\max \{b, c\}=c;\\\end{gathered}\]</span> 从而同理可得 <span class="math inline">\([a,(b,c)]=([a,b],[a,c])\)</span></p><h2 id="习题1.3.4">习题1.3.4</h2><p>不存在整数 <span class="math inline">\(m\geq 2\)</span> ，使得 <span class="math inline">\(m^2\mid n\)</span> 的正整数 <span class="math inline">\(n\)</span> 为无平方因子，证明：</p><p><span class="math inline">\(\ \ \ (1)\)</span> 正整数 <span class="math inline">\(n\)</span> 是无平方因子当且仅当 <span class="math inline">\(n=1\)</span> 或者是不素因子的乘积；</p><p><span class="math inline">\(\ \ \ (2)\)</span> 每个正整数 <span class="math inline">\(n\)</span> 可以唯一地表示成 <span class="math inline">\(n=m^2\cdot n&#39;\)</span>，其中 <span class="math inline">\(m^2\)</span> 为平方数，而 <span class="math inline">\(n&#39;\)</span> 为无平方因子整数。</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 若 <span class="math inline">\(n=1\)</span> ，<span class="math inline">\(\forall m\geq 2,\ m^2\nmid n\)</span>，从而 <span class="math inline">\(1\)</span> 为无平方因子，若 <span class="math inline">\(n\geq 2\)</span>，由算术基本定理</p><p>令 <span class="math inline">\(n=p_1^{\alpha_1}\cdot p_2^{\alpha_2}\cdots p_r^{\alpha_r}\)</span>，若 <span class="math inline">\(\exists\ \alpha _i\geq 2\)</span>，则取 <span class="math inline">\(p_i^{2}\mid p_{i}^{\alpha_{i}}\mid n\)</span>，则不是无平方因子，从而</p><p><span class="math inline">\(\forall \ \alpha_{i}\leq 1\)</span>，而 <span class="math inline">\(\alpha_i=0\)</span> 无意义（<span class="math inline">\(p_{i}^{0}=1\)</span>），从而此时 <span class="math inline">\(n\)</span> 为不同素因子乘积</p><p>又若 <span class="math inline">\(n=1\)</span> 或者 <span class="math inline">\(n\)</span> 为不同素因子乘积，显然满足无平方因子条件，从而两者等价</p><p><span class="math inline">\((2)\)</span> 若 <span class="math inline">\(n\)</span> 为无平方因子，则 <span class="math inline">\(n=1^2\cdot n&#39;\)</span> 满足条件，若 <span class="math inline">\(n\)</span> 不为无平方因子，由 <span class="math inline">\(\small (1)\)</span> 得，<span class="math inline">\(\exists\ \alpha_i\geq 2\)</span></p><p>则挑选 <span class="math inline">\(\mathbb{A}=\{i\mid \alpha_i\geq 2\}\)</span>，对 <span class="math inline">\(\forall\ x\in \mathbb{A}\)</span> 取 $<em>{i}=2,</em>{i}=_i-_i=0,1 $</p><p>则所有非 <span class="math inline">\(\mathbb{A}\)</span> 中的 <span class="math inline">\(\alpha_{j}\)</span> 以及 <span class="math inline">\(\gamma_{i}\)</span> 对应素数幂次的乘积组成无平方因子 <span class="math inline">\(n&#39;=\displaystyle \prod_{\alpha_{j}\notin\mathbb{A}}p_{j}^{\alpha_{j}}\cdot \prod_{\alpha_{i}\in\mathbb{A}}p_{i}^{\gamma_{i}}\)</span></p><p>其余组成完全平方数 <span class="math inline">\(m^2=\displaystyle \prod_{\alpha_{i}\in\mathbb{A}}p_{i}^{\beta_{i}}=\prod_{\alpha_{i}\in\mathbb{A}}p_{i}^{2\lfloor\frac{\alpha_i}{2}\rfloor}\)</span>，即 <span class="math inline">\(m=\displaystyle \prod_{\alpha_{i}\in\mathbb{A}}p_{i}^{\lfloor\frac{\alpha_i}{2}\rfloor}\)</span>，使得 <span class="math inline">\(n=m^2\cdot n&#39;\)</span></p><p>下证其唯一性：若有两组 <span class="math inline">\((m_1,n&#39;_1),(m_2,n_2&#39;)\)</span> 使得 <span class="math inline">\(n=m_1^2n_1&#39;=m_2^2n_2&#39;\)</span>，由 <span class="math inline">\(\small(1)\)</span> 知</p><p><span class="math inline">\(n_1\)</span> 和 <span class="math inline">\(n_2\)</span> 为 <span class="math inline">\(1\)</span> 或者是不同素数的乘积，若两者不相同，则两边消去相同部分后总会剩余成单素数</p><p>即 <span class="math inline">\(n&#39;&#39;=m_1^2\displaystyle \prod p_i=m_2^2\prod q_i\)</span>，考察 <span class="math inline">\(p_i\)</span> 对应的幂次有左侧为奇次幂，右侧为偶次幂</p><p>这与 <span class="math inline">\(n&#39;&#39;\)</span> 的算术基本定理矛盾，从而每个正整数能唯一地表示成完全平方数和无平方因子的乘积</p><h1 id="largetextcolorblue初等数论第三次作业-_textcolorblue2022.3.8"><span class="math inline">\(\large\textcolor{blue}{初等数论第三次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.3.8}\)</span></h1><h2 id="习题1.2.1-1">习题1.2.1</h2><p>设 <span class="math inline">\(m\)</span> 为正整数, <span class="math inline">\((a, m)=1\)</span>. 我们用 <span class="math inline">\(a^{-1}\)</span> 表示同余方程 <span class="math inline">\(a x \equiv 1\)</span> <span class="math inline">\((\bmod m)\)</span> 的任何一个整数解 (即</p><p><span class="math inline">\(\left.a^{-1} \in \mathbf{Z}, a a^{-1} \equiv 1(\bmod m)\right)\)</span>. 证明：</p><ol type="1"><li><p>若 <span class="math inline">\((a, m)=(b, m)=1\)</span>, 则 <span class="math inline">\(a \equiv b(\bmod m)\)</span> $$ <span class="math inline">\(a^{-1} \equiv\)</span> <span class="math inline">\(b^{-1}(\bmod m)\)</span>；</p></li><li><p>若 <span class="math inline">\(\{r_{1}, r_{2}, \cdots, r_{\varphi(m)}\}\)</span> 是模 <span class="math inline">\(m\)</span> 的缩系, 则 <span class="math inline">\(\{r_{1}^{-1}, r_{2}^{-1}, \cdots, r_{\varphi(m)}^{-1}\}\)</span> 也是模 <span class="math inline">\(m\)</span> 的缩系。</p></li></ol><hr /><p>证明：<span class="math inline">\((1)\)</span> 若 <span class="math inline">\(a\equiv b(\mbox{mod}\  m)\)</span>，即 <span class="math inline">\(a-b=k_1m,k_1\in Z\)</span>，令 <span class="math inline">\(a^{-1}\)</span> 与 <span class="math inline">\(b^{-1}\)</span> 中最小的正整数为</p><p><span class="math inline">\(a_{-},b_{-}\)</span>，对上式乘以 <span class="math inline">\(a_{-},b_{-}\)</span> 得 <span class="math inline">\(aa_{-}b_{-}-a_{-}(bb_{-})=k_1ma_{-}b_{-}\)</span>，两边对 <span class="math inline">\(m\)</span> 求同余有</p><p><span class="math inline">\(a_{-}\equiv b_{-}(\mbox{mod}\ m)\)</span>，而 <span class="math inline">\(\overline{a^{-1}}=a_{-}+km,k\in Z,\overline{b^{-1}}=b_{-}+km,k\in Z\)</span></p><p>则 <span class="math inline">\(a\equiv b(\mbox{mod}\  m)\Longrightarrow a^{-1}\equiv b^{-1}(\mbox{mod}\  m)\)</span>，由对称性（<span class="math inline">\((a^{-1})^{-1}=a\)</span>），两者等价</p><p><span class="math inline">\((2)\)</span> 由 <span class="math inline">\(r_{i}r_{i}^{-1}\equiv 1(\mbox{mod}\ m)\)</span>，若 <span class="math inline">\((r_{i}^{-1},m)\geq 2\)</span>，则 <span class="math inline">\((r_{i}r_{i}^{-1},m)\geq 2\)</span>，与 <span class="math inline">\(r_{i}r_{i}^{-1}\equiv 1(\mbox{mod}\ m)\)</span></p><p>矛盾，从而所有的 <span class="math inline">\(r_{i}^{-1}\)</span> 与 <span class="math inline">\(m\)</span> 互素；又若 $ ij,r_{i}<sup>{-1}=r_{j}</sup>{-1} $，由 <span class="math inline">\((1)\)</span> 得 <span class="math inline">\(r_{i}=r_{j}\)</span> ，矛盾</p><p>而 <span class="math inline">\(m\)</span> 的缩系有 <span class="math inline">\(\varphi(m)\)</span> 个，从而 <span class="math inline">\(\{r_{1}^{-1},\cdots ,r_{\varphi (m)}^{-1}\}\)</span> 也为缩系</p><h2 id="习题1.2.2-1">习题1.2.2</h2><p>设正整数 <span class="math inline">\(n\)</span> 的十进制表示为</p><p><span class="math display">\[n=a_{0}+a_{1} \cdot 10+a_{2} \cdot 10^{2}+\cdots+a_{k} \cdot 10^{k},\]</span></p><p>证明: <span class="math inline">\(\left\{\begin{array}{l}n \equiv a_{0}+a_{1}+\cdots+a_{k}(\bmod 9), \\ n \equiv a_{0}-a_{1}+a_{2}-\cdots+(-1)^{k} a_{k}(\bmod 11) .\end{array}\right.\)</span> 用这些结果来计算 <span class="math inline">\(12345 \times 6789\)</span> 被 <span class="math inline">\(9\)</span> 和</p><p>被 <span class="math inline">\(11\)</span> 除所得的余数。</p><hr /><p>证明：由 <span class="math inline">\(u=\displaystyle \sum_{i=0}^ka_i10^{i}\)</span>，且 <span class="math inline">\(10^{i}\equiv(9+1)^{i}\equiv1+9^{i}\equiv1(\mbox{mod}\ m)\)</span></p><p><span class="math inline">\(10^{i}\equiv (11-1)^{i}\equiv(-1)^{i}+11^{i}\equiv (-1)^{i}(\mbox{mod}\ m)\)</span>，代入则得到</p><p><span class="math display">\[\left\{\begin{array}{l}n \equiv \displaystyle \sum_{i=0}^ka_i(\bmod 9), \\ n \equiv \displaystyle \sum_{i=0}^k(-1)^{i}a_i(\bmod 11) .\end{array}\right.\]</span> 代入计算 <span class="math inline">\(12345\times 6789\equiv 15\times 30\equiv 0(\mbox{mod}\ 9)\)</span>，<span class="math inline">\(12345\times 6789\equiv 3\times2\equiv 6(\mbox{mod}\ 11)\)</span></p><h2 id="习题1.2.6-1">习题1.2.6</h2><p>证明：当 <span class="math inline">\(n \geqslant 3\)</span> 时, <span class="math inline">\(\varphi(n)\)</span> 为偶数。</p><hr /><p>证明：<span class="math inline">\(\boldsymbol ①\)</span> 若 <span class="math inline">\(n\)</span> 有奇素数因子，则 <span class="math inline">\(\varphi(n)=\displaystyle \prod_{i}(p_{i}^{\alpha_{i}}-p_{i}^{\alpha _{i}-1})\)</span> 中对奇素数因子 <span class="math inline">\((p_{i}^{\alpha_{i}}-p_{i}^{\alpha _{i}-1})\)</span></p><p>总为偶数，从而此时 $(n)( 2) $</p><p><span class="math inline">\(\boldsymbol ②\)</span> 若 <span class="math inline">\(n\)</span> 没有奇素数因子，由于 <span class="math inline">\(n\geq 3\)</span>，则 <span class="math inline">\(n=2^{k},k\geq 2\)</span>，此时 <span class="math inline">\(\varphi(n)=2^{k-1}\)</span> 也为偶数</p><p>从而 <span class="math inline">\(\forall\ n\geq 3\)</span>，<span class="math inline">\(\varphi(n)\)</span> 为偶数</p><h2 id="习题1.2.7">习题1.2.7</h2><p>设 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span> 是正整数，<span class="math inline">\(m=n t(t \in \mathbf{Z})\)</span>. 证明: 模 <span class="math inline">\(n\)</span> 的每个同余类都是模 <span class="math inline">\(m\)</span> 的 <span class="math inline">\(t\)</span> 个同余类之并。</p><hr /><p>证明：对 <span class="math inline">\(m\)</span> 中特定 <span class="math inline">\(\overline{a}\)</span> ，取 <span class="math inline">\(\overline{a},\overline{a}+\overline{n},\cdots ,\overline{a}+(t-1)\overline{n}\)</span> 共 <span class="math inline">\(t\)</span> 个同余类，这些元素均模 <span class="math inline">\(n\)</span> 余数为 <span class="math inline">\(a\)</span> 模</p><p><span class="math inline">\(n\)</span>，而 <span class="math inline">\(\overline{a}\)</span> 取遍 <span class="math inline">\(0,1,\cdots,n-1\)</span>，得到模 <span class="math inline">\(n\)</span> 的每个同余类。</p><h2 id="习题1.2.10-1">习题1.2.10</h2><p>设 <span class="math inline">\(a, m \in \mathbf{Z}, m \geqslant 2,(a, m)=1\)</span>. 计算 <span class="math inline">\(\displaystyle \sum_{x=0}^{m-1}\left[\frac{a x}{m}\right]\)</span>.</p><hr /><p>解：由于 <span class="math inline">\(\{ax\big |x=0,1,\cdots ,m-1\}\)</span> 为 <span class="math inline">\(m\)</span> 的完系，则拆开 <span class="math inline">\(\displaystyle \left[\frac{a x}{m}\right]=\dfrac{ax}{m}-\{\dfrac{ax}{m}\}\)</span>，则 <span class="math display">\[\begin{gathered}\displaystyle \sum_{x=0}^{m-1}\left[\frac{a x}{m}\right]=\dfrac{a}{m}\sum_{x=0}^{m-1}x-\dfrac{1}{m}(0+1+\cdots +(m-1))=\dfrac{a}{m}\cdot\dfrac{m(m-1)}{2}-\dfrac{m(m-1)}{2m}\\=\dfrac{a(m-1)}{2}-\dfrac{m-1}{2}=\dfrac{(a-1)(m-1)}{2}\end{gathered}\]</span></p><blockquote><p>更一般地，对 <span class="math inline">\(\forall \ a,m\in \mathbf{Z}\)</span>，都有 <span class="math inline">\(\displaystyle \sum_{x=0}^{m-1}\left[\frac{a x}{m}\right]=\dfrac{am-a-m+(a,m)}{2}\)</span></p></blockquote><h2 id="习题2.2.1">习题2.2.1</h2><p>设 <span class="math inline">\(\alpha\)</span> 是环 <span class="math inline">\(Z_{m}\)</span> 中非零元素。若存在 <span class="math inline">\(Z_{m}\)</span> 中非零元素 <span class="math inline">\(\beta(\neq \overline{0})\)</span>, 使得 <span class="math inline">\(\alpha \beta=\overline{0}\)</span>, 称 <span class="math inline">\(\alpha\)</span> 是零因子，证明：</p><p><span class="math inline">\((1)\)</span> 非零元素 <span class="math inline">\(\alpha\)</span> 是零因子当且仅当 <span class="math inline">\(\alpha\)</span> 不可逆. 从而 <span class="math inline">\(Z_{m}\)</span> 由彼此不同的三类元素构成：<span class="math inline">\(\overline{0}, \varphi(m)\)</span> 个可逆</p><p>元和 <span class="math inline">\(m-\varphi(m)-1\)</span> 个零因子;</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(Z_{m}\)</span> 中没有零因子当且仅当 <span class="math inline">\(m\)</span> 是素数。</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 若 <span class="math inline">\(\alpha (\neq \overline{0})\)</span> 是零因子，反证法，若 $$ 可逆，则 <span class="math inline">\(\alpha\alpha^{-1}\equiv 1(\mbox{mod}\ m)\)</span>，两边乘以 <span class="math inline">\(\beta(\neq \overline{0})\)</span></p><p>得 <span class="math inline">\(\alpha \beta \alpha^{-1}\equiv \beta(\mbox{mod}\ m)\)</span>，左边为 <span class="math inline">\(0\)</span>，右边不为 <span class="math inline">\(0\)</span>，矛盾，从而 $$ 不可逆；又若 $$ 不可逆，则有</p><p><span class="math inline">\(\forall \ \beta\neq 0,\alpha \beta\neq 1\)</span>。则考虑 <span class="math inline">\(\{0,\overline{\alpha },\overline{2\alpha},\cdots,\overline{(m-1)\alpha}\}\)</span> ，该集合不为模 <span class="math inline">\(m\)</span> 的同余类，否则一定能</p><p>找到 <span class="math inline">\(\overline{1}\)</span> 与 $$ 不可逆的条件矛盾，则 <span class="math inline">\(\exists\ i,j\in[1,m-1],\overline{i\alpha}=\overline{j\alpha}\)</span>，从而取 <span class="math inline">\(\beta=i-j\)</span>，$$ 为零因子</p><p><span class="math inline">\((2)\)</span> 若 <span class="math inline">\(m\)</span> 为素数，<span class="math inline">\(\varphi(m)=m-1\)</span>，则有 <span class="math inline">\(m-\varphi(m)-1=0\)</span> 个零因子</p><p>若 <span class="math inline">\(m-\varphi(m)-1=0\)</span> 成立，则 <span class="math inline">\(\varphi(m)=m-1\)</span>，若 <span class="math inline">\(m\)</span> 为合数，<span class="math inline">\(m=ab\)</span>，则 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 为零因子，</p><p><span class="math inline">\(\varphi(m)\leq m-1-2\)</span> 矛盾</p><h2 id="习题2.2.2">习题2.2.2</h2><p><span class="math inline">\((1)\)</span> 对于环 <span class="math inline">\(Z_{m}\)</span> 中任何元素 <span class="math inline">\(\alpha\)</span>，<span class="math inline">\(m\)</span> 个 <span class="math inline">\(\alpha\)</span> 相加为 <span class="math inline">\(\overline{0}\)</span>.</p><p><span class="math inline">\((2)\)</span> 设 <span class="math inline">\(p\)</span> 为素数. 对于域 <span class="math inline">\(Z_{p}\)</span> 中非零元素 <span class="math inline">\(\alpha\)</span> 和正整数 <span class="math inline">\(n\)</span>，证明： <span class="math inline">\(n\)</span> 个 <span class="math inline">\(\alpha\)</span> 相加为 <span class="math inline">\(\overline{0}\)</span> 当且仅当 <span class="math inline">\(p \mid n\)</span>。</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 由 <span class="math inline">\(\alpha_{i}=\alpha_{0}+k_{i}\cdot m\)</span>，这些 <span class="math inline">\(m\)</span> 个 $$ 之和为 <span class="math inline">\(m\alpha_{0}+m\displaystyle \sum_{i=1}^{m}k_{i}\)</span>，均模 <span class="math inline">\(m\)</span> 余 <span class="math inline">\(0\)</span></p><p>而且对于 <span class="math inline">\(\overline{0}\)</span> 中的所有元素 <span class="math inline">\(Km\)</span>，都能找到 <span class="math inline">\(k_{i}\)</span> 使得 <span class="math inline">\(\alpha_{0}+\displaystyle \sum_{k=1}^{m}k_{i}=K\)</span>，则相加为 <span class="math inline">\(\overline{0}\)</span></p><p><span class="math inline">\((2)\)</span> 若 <span class="math inline">\(p\mid n\)</span>，有 <span class="math inline">\(n\)</span> 个 $$ 相加后模 <span class="math inline">\(m\)</span> 为 <span class="math inline">\(0\)</span>，则 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(\alpha\)</span> 相加为 <span class="math inline">\(\overline{0}\)</span>；又若 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(\alpha\)</span> 相加为 <span class="math inline">\(\overline{0}\)</span> 时</p><p>令 <span class="math inline">\(\alpha_{i}=\alpha_{0}+k_{i}\cdot m\)</span>，相加后模 <span class="math inline">\(m\)</span> 得 <span class="math inline">\(n\alpha_{0}\equiv 0(\mbox{mod}\ p)\)</span>，而 <span class="math inline">\(\alpha_{0}=0,1,\cdots ,p-1\)</span></p><p><span class="math inline">\((\alpha_{0},p)=1\)</span>，则 <span class="math inline">\(n\equiv 0(\mbox{mod}\ p)\)</span>，即 <span class="math inline">\(p\mid n\)</span></p><h2 id="习题2.2.3">习题2.2.3</h2><p>证明当 <span class="math inline">\(p\)</span> 为奇素数时，<span class="math inline">\(2^{p-1} \cdot\left(\left(\dfrac{p-1}{2}\right) !\right)^{2} \equiv(-1)^{\frac{p+1}{2}}(\bmod p)\)</span>。</p><hr /><p>证明：<span class="math inline">\(2^{p-1}(\dfrac{p-1}{2}\cdot\dfrac{p-3}{2}\cdots\dfrac{4}{2}\cdot \dfrac{2}{2})^{2}=(p-1)^{2}(p-3)^2\cdots 4^2\cdot 2^2\)</span>，使用<strong>补偿法</strong>有 <span class="math display">\[\begin{gathered}(p-1)^2(p-3)^2\cdots4^2\cdot2^2\equiv2\cdot 4\cdot 6\cdots(p-1)\cdot (p-1)\cdot (p-3)\cdots 4\cdot 2\\\equiv2\cdot 4\cdot 6\cdots (p-1)\cdot (p-(p-1))\cdot (p-(p-3))\cdots (p-4)\cdot (p-2)\cdot (-1)^{\frac{p-1}{2}}\\\equiv2\cdot 4\cdots (p-1)\cdot 3\cdot 5\cdots (p-2)\cdot (-1)^{\frac{p-1}{2}}\equiv (p-1)!(-1)^{\frac{p-1}{2}}\equiv (-1)^{\frac{p+1}{2}}(\mbox{mod}\ p)\end{gathered}\]</span> 其中使用威尔逊定理，对素数 <span class="math inline">\(p\)</span> ，有 <span class="math inline">\((p-1)!\equiv-1(\mbox{mod}\ p)\)</span></p><h2 id="习题2.2.4">习题2.2.4</h2><p>对于整数 <span class="math inline">\(m \geqslant 2\)</span>, 证明: <span class="math inline">\((m-1) ! \equiv-1(\bmod m)\)</span> 当且仅当 <span class="math inline">\(m\)</span> 是素数。 (判别 <span class="math inline">\(m\)</span> 是否为素数)</p><hr /><p>证明：若 <span class="math inline">\(m\)</span> 为素数，则由威尔逊定理得 <span class="math inline">\((m-1)!\equiv -1(\mbox{mod}\ m)\)</span>；若 <span class="math inline">\(m\)</span> 为合数，则 <span class="math inline">\(m=ab\)</span>，</p><p>其中 <span class="math inline">\(2\leq a\leq b\)</span>，则 <span class="math inline">\(1\leq a,b\leq m-1\)</span>，从而 <span class="math inline">\((m-1)!\)</span> 中一定能凑齐 <span class="math inline">\(m\)</span>，此时模为 <span class="math inline">\(0\)</span></p><h2 id="习题2.2.5">习题2.2.5</h2><p>若 <span class="math inline">\(Z_{m}^{*}=\left\{\alpha_{1}, \cdots, \alpha_{\phi(m)}\right\}\)</span>，则 <span class="math inline">\(Z_{m}^{*}=\left\{\alpha_{1}^{-1}, \cdots, \alpha_{\phi(m)}^{-1}\right\}\)</span>。如何将它转述成同余的语言?</p><hr /><p>证明：缩系等价性证明在习题 <span class="math inline">\(1.2.1\)</span> 中。定义 <span class="math inline">\(\alpha_{i}x_i\equiv 1(\mbox{mod}\ m)\)</span> 中 <span class="math inline">\(x_{i}\)</span> 的可取值为 <span class="math inline">\(\alpha_{i}^{-1}\)</span></p><p>转述为 <span class="math inline">\((\alpha_{i},m)=1\)</span>，所有 <span class="math inline">\(\alpha_{i}\)</span> 构成 <span class="math inline">\(Z_{m}^*\)</span>，由 <span class="math inline">\(\alpha_{i}x_{i}\equiv 1(\mbox{mod}\ m)\)</span>中，所有 <span class="math inline">\(x_{i}\)</span> 也构成 <span class="math inline">\(Z_{m}^*\)</span></p><h2 id="习题2.3.1">习题2.3.1</h2><p>设 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span> 是互素的正整数，证明： <span class="math inline">\(m^{\varphi(n)}+n^{\varphi(m)}\equiv1(\bmod m n)\)</span>。</p><hr /><p>证明：由欧拉-费马定理，<span class="math inline">\(m^{\varphi(n)}\equiv1(\mbox{mod}\ n),n^{\varphi(m)}\equiv1(\mbox{mod}\ m)\)</span>，且由<span class="math inline">\(\varphi(x)\geq 1\)</span>，得</p><p><span class="math inline">\(m^{\varphi(n)}\equiv0(\mbox{mod}\ m),n^{\varphi(m)}\equiv0(\mbox{mod}\ n)\)</span>，从而 <span class="math display">\[m^{\varphi(n)}+n^{\varphi(m)}\equiv 1(\bmod m),m^{\varphi(n)}+n^{\varphi(m)}\equiv 1(\bmod n)\]</span> 则 <span class="math inline">\(m^{\varphi(n)}+n^{\varphi(m)}=1+mk_1=1+nk_2\)</span>，由于 <span class="math inline">\((m,n)=1\)</span>，则 <span class="math inline">\(n\mid k_1\)</span>，原式成立</p><h2 id="习题2.3.2">习题2.3.2</h2><p><span class="math inline">\((1)\)</span> 对每个与 <span class="math inline">\(10\)</span> 互素的整数 <span class="math inline">\(a\)</span>, 证明: <span class="math inline">\(a^{20} \equiv 1(\bmod 100)\)</span>；</p><p><span class="math inline">\((2)\)</span> 求 <span class="math inline">\(3^{193}\)</span> 的十进制表达式中的个位和十位数字。</p><hr /><p>解：<span class="math inline">\((1)\)</span> 由 <span class="math inline">\(\varphi(4)=2,\varphi(25)=20\)</span>，结合 <span class="math inline">\((a,4)=(a,25)=1\)</span> 有 <span class="math inline">\(a^{20}\equiv 1(\bmod 25)\)</span>，</p><p><span class="math inline">\(a^2\equiv 1(\bmod 4)\)</span>，<span class="math inline">\(a^{20}\equiv (a^2)^{10}\equiv 1(\bmod 4)\)</span>，而 <span class="math inline">\((4,25)=1\)</span>，则 <span class="math inline">\(a^{20}\equiv 1(\bmod 100)\)</span></p><p><span class="math inline">\((2)\)</span> 由 <span class="math inline">\(3^{193}\equiv 3^{160}\cdot 3^{33}\equiv 27^{11}\equiv 2^{11}\equiv 23(\bmod 25)\)</span>，且 <span class="math inline">\(3^{193}\equiv (-1)^{193}\equiv 3(\bmod 4)\)</span>，</p><p>从而最后两位为 <span class="math inline">\(23\)</span></p><h2 id="习题2.3.3">习题2.3.3</h2><p><span class="math inline">\((1)\)</span> 设 <span class="math inline">\(a, b \in \mathbf{Z}, n \geqslant 1, p\)</span> 为素数。如果 <span class="math inline">\(a \equiv b\left(\bmod p^{n}\right)\)</span>，证明：对每个整数 <span class="math inline">\(k \geqslant 0\)</span>，</p><p><span class="math display">\[a^{p^{k}} \equiv b^{p^{k}}\left(\bmod p^{n+k}\right)\]</span> <span class="math inline">\((2)\)</span> 证明: 对每个奇数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(k \geqslant 1, a^{2^{k}} \equiv 1\left(\bmod 2^{k+2}\right)\)</span>.</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 令 <span class="math inline">\(b=a+x\cdot p^{n},x\in Z\)</span>，代入使用二项式展开有 <span class="math display">\[b^{p^{k}}-a^{p^{k}}=(a+x\cdot p^{n})^{p^{k}}-a^{p^{k}}=\displaystyle \sum_{i=1}^{k}C_{p^{k}}^{i}b^{i}(x\cdot p^{n})^{p^{k}-i}\]</span> 其中 <span class="math inline">\(p^{k}\mid C_{p^{k}}^{i}\)</span>，且有 <span class="math inline">\(p^{n}\mid (x\cdot p^{n})^{p^{k}-i}\)</span>，从而 <span class="math inline">\(a^{p^{k}} \equiv b^{p^{k}}\left(\bmod p^{n+k}\right)\)</span></p><p><span class="math inline">\((2)\)</span> 由 <span class="math inline">\(a\)</span> 为奇数，令 <span class="math inline">\(a=2i+1\)</span>，则 <span class="math inline">\(a^{2}=4i(i+1)+1\)</span>，且 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(i+1\)</span> 一奇一偶，从而</p><p><span class="math inline">\(a^{2}\equiv 1(\bmod 2^{3})\)</span>，代入 <span class="math inline">\(\small (1)\)</span> 中结论有 <span class="math inline">\((a^2)^{2^k}\equiv 1(\bmod 2^{3+k})\)</span>，令 <span class="math inline">\(k&#39;=k+1\geq 1\)</span> 则有</p><p><span class="math inline">\(k&#39; \geqslant 1, a^{2^{k&#39;}} \equiv 1\left(\bmod 2^{k&#39;+2}\right)\)</span>，得证</p><h1 id="largetextcolorblue初等数论第四次作业-_textcolorblue2022.3.15"><span class="math inline">\(\large\textcolor{blue}{初等数论第四次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.3.15}\)</span></h1><h2 id="习题2.1.3">习题2.1.3</h2><p>解下列同余方程。</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(8 x \equiv 5(\bmod 23)\)</span>; <span class="math inline">\((2)\)</span> <span class="math inline">\(60 x \equiv 7(\bmod 37)\)</span>.</p><hr /><p>解：<span class="math inline">\((1)\)</span> 由 <span class="math inline">\((8,23)=1\)</span>，则在 <span class="math inline">\(Z_{23}\)</span> 中有唯一解，利用费马小定理 <span class="math display">\[x\equiv 8^{\varphi(23)-1}\cdot 5\equiv 8^{21}\cdot 5\equiv 64^{10}\cdot 40\equiv 5^{10}\cdot( -6)\equiv -(25)^{5}\cdot 6\equiv -2^{5}\cdot 6\equiv 15\pmod {23}\]</span> <span class="math inline">\((2)\)</span> 由 <span class="math inline">\((60,37)=1\)</span>，则在 <span class="math inline">\(Z_{37}\)</span> 中有唯一解，利用费马小定理 <span class="math display">\[\begin{gathered}x\equiv 60^{\varphi(37)-1}\cdot 7\equiv(-14)^{35}\cdot 7\equiv 196^{17}\cdot 13\equiv 11^{17}\cdot 13\\\equiv 10^{8}\cdot (-5)\equiv -5\cdot 11^4 \equiv -5\cdot 10^2\equiv (-5)\cdot (-11)\equiv 18\pmod{37}\end{gathered}\]</span></p><h2 id="习题2.1.4">习题2.1.4</h2><p>对每个整数 <span class="math inline">\(n\)</span>，证明： <span class="math display">\[\begin{gathered}(1) n^{2} \neq 2(\bmod 3);&amp;(2) n^{2} \equiv 0 或 1(\bmod 4);\\(3) n^{3} \equiv 0,1 或 -1(\bmod 9) ;&amp;(4) n^{4} \equiv 0 或 1(\bmod 16).\end{gathered}\]</span></p><hr /><p>证明：<span class="math inline">\((1)\)</span> 由费马小定理，若 <span class="math inline">\((n,3)=1,n^{\varphi(3)}\equiv n^2\equiv 1\pmod 3\)</span>，且若 <span class="math inline">\((n,3)&gt;1\)</span>，则 <span class="math inline">\(3\mid n\)</span>，</p><p>此时有 <span class="math inline">\(n^2\equiv 0\pmod 3\)</span>，则 <span class="math inline">\(n^2\neq2 \pmod 3\)</span></p><p><span class="math inline">\((2)\)</span> 由费马小定理，若 <span class="math inline">\((n,4)=1,n^{\varphi(4)}\equiv n^2\equiv 1\pmod 4\)</span>，且若 <span class="math inline">\((n,4)&gt;0\)</span>，有 <span class="math inline">\(2\mid 4\)</span></p><p>此时有 <span class="math inline">\(n^2\equiv 0\pmod 4\)</span>，则 <span class="math inline">\(n^2\equiv 0或1 \pmod 4\)</span></p><p><span class="math inline">\((3)\)</span> 由费马小定理，若 <span class="math inline">\((n,9)=1,n^{\varphi(9)}\equiv n^6\equiv 1\pmod 9\)</span>，即此时 <span class="math inline">\(n^{3}\equiv \pm 1\pmod 9\)</span></p><p>若 <span class="math inline">\((n,9)&gt;1\)</span>，则 <span class="math inline">\(3\mid 9\)</span>，此时 <span class="math inline">\(n^3\equiv 0\pmod 9\)</span>，则 <span class="math inline">\(n^3\equiv 0,\pm 1\pmod 9\)</span></p><p><span class="math inline">\((4)\)</span> 由费马小定理，若 <span class="math inline">\((n,16)=1,n^{\varphi(16)}\equiv n^{8}\equiv 1\pmod {16}\)</span>，此时分解因式有 <span class="math display">\[(n^4-1)(n^4+1)\equiv 0\pmod{16}\]</span> 而 <span class="math inline">\(n^4\equiv 1\pmod{8}\)</span>，故 <span class="math inline">\(n^4\equiv 1,9\pmod{16}\)</span> 综上有 <span class="math inline">\(n^4\equiv 0,1\pmod{16}\)</span></p><h2 id="习题2.1.5">习题2.1.5</h2><p>设 <span class="math inline">\(a\)</span> 为奇数, <span class="math inline">\(n \geqslant 1 .\)</span> 证明: <span class="math inline">\(a^{2^{n}} \equiv 1\left(\bmod 2^{n+2}\right)\)</span></p><hr /><p>证明：（<strong>使用归纳法，二项式展开较复杂</strong>）对 <span class="math inline">\(n=1\)</span> 时成立（第一次作业第一题）</p><p>若 <span class="math inline">\(n=k\)</span> 时成立，即 <span class="math inline">\(a^{2^{k}}\equiv 1\pmod {2^{k+2}}\)</span>则存在 <span class="math inline">\(t\in Z ,a^{2^{k}}=1+2^{k+2}\cdot t\)</span>，则 <span class="math display">\[a^{2^{k+1}}\equiv(a^{2^{k}})^2\equiv(1+2^{k+2}t)^2\equiv1+2^{k+3}t+2^{2k+4}t^2\equiv 1\pmod{2^{k+3}}\]</span> 由数学归纳法知，对 <span class="math inline">\(\forall \ n\geq 1\)</span> 均成立</p><h2 id="习题2.4.1">习题2.4.1</h2><p>解下列同余方程：<span class="math inline">\((1)\)</span> <span class="math inline">\(32 x \equiv 12(\bmod 8)\)</span>; <span class="math inline">\((2)\)</span> <span class="math inline">\(28 x \equiv 124(\bmod 116)\)</span>; $  5 x ()$</p><hr /><p>解：<span class="math inline">\((1)\)</span> 由判定 <span class="math inline">\((32,8)=8\nmid 12\)</span>，则在 <span class="math inline">\(Z_{8}\)</span> 下无解</p><p><span class="math inline">\((2)\)</span> 由判定 <span class="math inline">\((28,116)=4\mid 124\)</span>，则在 <span class="math inline">\(Z_{116}\)</span> 下有 <span class="math inline">\(4\)</span> 组解， <span class="math inline">\(7x\equiv 31\pmod{29}\)</span>，由费马小定理 <span class="math display">\[x\equiv 7^{\varphi(29)-1}\cdot 31\equiv 7^{27}\cdot 2\equiv 49^{13}\cdot 14\equiv -9^{13}\cdot 14\equiv 6^{6}\cdot 19\equiv 7^{3}\cdot 19\equiv 21\pmod {29}\]</span> 则解为 <span class="math inline">\(x\equiv 21,50,79,108\)</span></p><p><span class="math inline">\((3)\)</span> 由判定 <span class="math inline">\((5,81)=1\mid 44\)</span>，则在 <span class="math inline">\(Z_{81}\)</span> 下有 <span class="math inline">\(1\)</span> 组解，有 <span class="math inline">\(5x\equiv 44\equiv 125\pmod{81}\)</span></p><p>得 <span class="math inline">\(x\equiv 25\pmod{81}\)</span></p><h2 id="习题2.4.2">习题2.4.2</h2><p>解下列同余方程组：</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(\left\{\begin{array}{l}x \equiv 1(\bmod 3), \\ x \equiv 1(\bmod 5), \\ x \equiv 2(\bmod 7) ;\end{array} \quad\right.\)</span> <span class="math inline">\((2)\)</span> <span class="math inline">\(\left\{\begin{array}{l}x \equiv 2(\bmod 4), \\ x \equiv 3(\bmod 5) \\ x \equiv 7(\bmod 9)\end{array}\right.\)</span></p><hr /><p>解：<span class="math inline">\((1)\)</span> 由中国剩余定理，有 <span class="math inline">\(M_1=35,M_2=21,M_3=15\)</span>，而对应有 <span class="math display">\[35M_1^{-1}\equiv 1\pmod{3},\ 21M_{2}^{-1}\equiv 1\pmod{5},\ 15M_{3}^{-1}\equiv 1\pmod{7}\]</span> 得 <span class="math inline">\(M_1^{-1}=2,M_{2}^{-1}=1,M_{3}^{-1}=1\)</span>，则 <span class="math inline">\(x\equiv 35\cdot 2\cdot 1+21\cdot 1\cdot 1+15\cdot 1\cdot 2\equiv 16\pmod{105}\)</span></p><p><span class="math inline">\((2)\)</span> 由中国剩余定理，有 <span class="math inline">\(M_1=45,M_2=36,M_3=20\)</span>，而对应有 <span class="math display">\[45M_1^{-1}\equiv 1\pmod{4},\ 36M_{2}^{-1}\equiv 1\pmod{5},\ 20M_{3}^{-1}\equiv 1\pmod{9}\]</span> 得 <span class="math inline">\(M_1^{-1}=1,M_{2}^{-1}=1,M_{3}^{-1}=5\)</span>，则 <span class="math inline">\(x\equiv 45\cdot 1\cdot 2+36\cdot 1\cdot 3+20\cdot 5\cdot 7\equiv 178\pmod{180}\)</span></p><h2 id="习题2.4.3">习题2.4.3</h2><p>用中国剩余定理解同余方程 <span class="math inline">\(37 x \equiv 31(\bmod 77)\)</span>.</p><hr /><p>解：由 <span class="math inline">\(77=7\cdot 11\)</span>，对质因数 <span class="math inline">\(7\)</span> 而言， <span class="math inline">\(37x\equiv 31\equiv185\pmod{7}\)</span>，则 <span class="math inline">\(x\equiv 5\pmod{7}\)</span></p><p>对质因数 <span class="math inline">\(11\)</span> 而言，<span class="math inline">\(37x\equiv 31\equiv 185\pmod{11}\)</span>，则 <span class="math inline">\(x\equiv 5\pmod{11}\)</span></p><p>则由中国剩余定理，显然 <span class="math inline">\(x\equiv 5\pmod{77}\)</span>，为原方程的解，且该解唯一</p><h2 id="习题2.4.4">习题2.4.4</h2><p>求 <span class="math inline">\(2^{400}\)</span> 被 <span class="math inline">\(319\)</span> 除的余数.</p><hr /><p>解：<span class="math inline">\(319=11\cdot 29\)</span>，对质因数 <span class="math inline">\(11\)</span> ，<span class="math inline">\(2^{400}\equiv32^{80}\equiv (-1)^{80}\equiv 1\pmod{11}\)</span>，对质因数 <span class="math inline">\(29\)</span> <span class="math display">\[2^{400}\equiv 32^{80}\equiv 3^{80}\equiv 27^{26}\cdot 9\equiv 2^{26}\cdot 9\equiv 32^{5}\cdot 18\equiv 3^{5}\cdot 18\equiv 27^2\cdot 6\equiv 24\pmod{29}\]</span> 则转化成一次同余方程组 <span class="math inline">\(\begin{cases}2^{400}\equiv 1\pmod{11}\\2^{400}\equiv 24\pmod{29}\end{cases}\)</span>，由中国剩余定理有</p><p><span class="math inline">\(M_1=29,M_2=11,M_1^{-1}\cdot 29\equiv 1\pmod{11},M_2^{-1}\cdot 11\equiv 1\pmod{29}\)</span></p><p>解得 <span class="math inline">\(M_1^{-1}=8,M_{2}^{-1}=8\)</span>，则 <span class="math inline">\(2^{400}\equiv 29\cdot 8+11\cdot 8\cdot 24\equiv 2344\equiv 111\pmod{319}\)</span></p><h2 id="习题2.4.5">习题2.4.5</h2><p>设 <span class="math inline">\(m_{1}, m_{2}\)</span> 是正整数, <span class="math inline">\(b_{1}, b_{2} \in \mathbf{Z}\)</span>. 证明: 同余方程组 <span class="math display">\[\left\{\begin{array}{l}x \equiv b_{1}\left(\bmod m_{1}\right), \\x \equiv b_{2}\left(\bmod m_{2}\right)\end{array}\right.\]</span> 有整数解的充分必要条件是 <span class="math inline">\(\left(m_{1}, m_{2}\right) \mid b_{1}-b_{2}\)</span>，且此条件成立时, 解为模 <span class="math inline">\(\left[m_{1}, m_{2}\right]\)</span> 的一个同余类.</p><hr /><p>证明：<span class="math inline">\((1)\)</span> <strong>充要性</strong>：若 <span class="math inline">\(\left\{\begin{array}{l}x \equiv b_{1}\left(\bmod m_{1}\right), \\x \equiv b_{2}\left(\bmod m_{2}\right)\end{array}\right.\)</span> 有整数解，则 <span class="math inline">\(x=m_1y_1+b_1=m_2y_2+b_2\)</span>，</p><p>两边除以 <span class="math inline">\((m_1,m_2)\)</span> 得到 <span class="math inline">\(\dfrac{b_1-b_2}{(m_1,m_2)}=\dfrac{m_2y_2-m_1y_1}{(m_1,m_2)}\in Z\)</span>，此时有 <span class="math inline">\((m_1,m_2)\mid b_1-b_2\)</span></p><p>若 <span class="math inline">\((m_1,m_2)\mid b_1-b_2\)</span>，有 <span class="math inline">\(\dfrac{m_2y_2-m_1y_1}{(m_1,m_2)}=\dfrac{b_1-b_2}{(m_1,m_2)}\in Z\)</span>，而 <span class="math inline">\((\dfrac{m_1}{(m_1,m_2)},\dfrac{m_2}{(m_1,m_2)})=1\)</span></p><p>由辗转相除法知，一定存在 <span class="math inline">\(y_{10},y_{20}\)</span>，使得 <span class="math inline">\(\dfrac{-m_1}{(m_1,m_2)}y_{10}+\dfrac{m_2}{(m_1,m_2)}y_{20}=1\)</span></p><p>则扩大 <span class="math inline">\(\dfrac{b_1-b_2}{(m_1,m_2)}\)</span> 倍得到 <span class="math inline">\(y_1,y_2\)</span> 的解，从而原同余方程组有解</p><p><span class="math inline">\((2)\)</span> <strong>同余类</strong>：若上述条件成立时，对 <span class="math inline">\(\dfrac{-m_1}{(m_1,m_2)}y_{10}+\dfrac{m_2}{(m_1,m_2)}y_{20}=1\)</span> 有 <span class="math inline">\(y_{10}\)</span> 对应解</p><p>所在同余类为模 <span class="math inline">\(\dfrac{m_2}{(m_1,m_2)}\)</span> ，而 <span class="math inline">\(x=m_1y_1+b_1\)</span> 则解为模 <span class="math inline">\(\dfrac{m_1m_2}{(m_1,m_2)}=[m_1,m_2]\)</span></p><h2 id="习题2.4.6">习题2.4.6</h2><p>设 <span class="math inline">\(m_{1}\)</span> 和 <span class="math inline">\(m_{2}\)</span> 是互素的正整数. 证明:</p><p><span class="math inline">\((1)\)</span> 若 <span class="math inline">\(S_{1}\)</span> 和 <span class="math inline">\(S_{2}\)</span> 分别是模 <span class="math inline">\(m_{1}\)</span> 和模 <span class="math inline">\(m_{2}\)</span> 的完系. 则 <span class="math display">\[S=\left\{m_{1} x_{1}+m_{2} x_{2} \mid x_{1} \in S_{2}, x_{2} \in S_{1}\right\}\]</span> 是模 <span class="math inline">\(m_{1} m_{2}\)</span> 的完系;</p><ol start="2" type="1"><li>若 <span class="math inline">\(S_{1}\)</span> 和 <span class="math inline">\(S_{2}\)</span> 分别是模 <span class="math inline">\(m_{1}\)</span> 和模 <span class="math inline">\(m_{2}\)</span> 的缩系, 则 <span class="math display">\[S=\left\{m_{1} x_{1}+m_{2} x_{2} \mid x_{1} \in S_{2}, x_{2} \in S_{1}\right\}\]</span> 是模 <span class="math inline">\(m_{1} m_{2}\)</span> 的缩系. (由此可知 <span class="math inline">\(\varphi\left(m_{1} m_{2}\right)=\varphi\left(m_{1}\right) \varphi\left(m_{2}\right)\)</span> )</li></ol><hr /><p>解：<span class="math inline">\((1)\)</span> 对 <span class="math inline">\(S\)</span> 中的每个元素 <span class="math inline">\(x_1=m_2y_1+t_1\in S_2,x_2=m_1y_2+t_2\in S_1\)</span></p><p><span class="math inline">\(m_1x_1+m_2x_2=m_1m_2(y_1+y_2)+t_1m_1+t_2m_2\)</span>，其中， <span class="math inline">\(y_1+y_2\in Z\)</span> 能取遍所有整数</p><p>又由 <span class="math inline">\((m_1,m_2)=1\)</span>，由辗转相除法知 <span class="math inline">\(\exists\ t_{10},t_{20}\in Z\)</span>，使得 <span class="math inline">\(t_{10}m_1+t_{20}m_2=1\)</span>，</p><p>从而 <span class="math inline">\(t_1m_1+t_2m_2\)</span> 也能取遍 <span class="math inline">\(0,1,\cdots ,m_1m_2-1\)</span>，则 <span class="math inline">\(S\)</span> 为模 <span class="math inline">\(m_1m_2\)</span> 的完系</p><p><span class="math inline">\((2)\)</span> 与 <span class="math inline">\(\small(1)\)</span> 相比，对 <span class="math inline">\(t_1m_1+t_2m_2\)</span> 中 <span class="math inline">\(t_1,t_2\)</span> 不是任意整数，需满足 <span class="math inline">\((t_1,m_2)=1,(t_2,m_1)=1\)</span></p><p>此时 <span class="math inline">\(t_1m_1+t_2m_2\nmid m_1m_2\)</span>，且由辗转相除法知，存在 <span class="math inline">\(t_{10},t_{20}\)</span> 使得 <span class="math inline">\(t_{10}m_1+t_{20}m_2=1\)</span></p><p>且反证法若 <span class="math inline">\(d=(t_{10},m_2)&gt;1\)</span>，则上式对 <span class="math inline">\(d\)</span> 同余有 <span class="math inline">\(1\equiv 0\pmod{d}\)</span>，矛盾，<span class="math inline">\(t_{10},t_{20}\)</span> 满足条件</p><p>对 <span class="math inline">\(\forall \ 0\leq x\leq m_1m_2-1,(x,m_1m_2)=1\)</span> <span class="math inline">\((x,m_1)=(x,m_2)=1\)</span>，取 <span class="math inline">\(xt_{10},xt_{20}\)</span> 满足条件</p><p>从而 <span class="math inline">\(S\)</span> 为 <span class="math inline">\(m_1m_2\)</span> 的缩系</p><h2 id="习题2.4.7">习题2.4.7</h2><p>设 <span class="math inline">\(n\)</span> 为正整数，证明：必有连续 <span class="math inline">\(n\)</span> 个正整数，其中每个整数均被某个大于 <span class="math inline">\(1\)</span> 的整数的平方所除尽。</p><hr /><p>证明：构造一次同余方程 <span class="math inline">\(\begin{cases}x\equiv 0\pmod{2^2}\\x\equiv -1\pmod{3^2}\\x\equiv -2\pmod{5^2}\\\qquad\vdots\\x\equiv -(n-1)\pmod{p_{n}^2}\end{cases}\)</span>，其中 <span class="math inline">\(p_n\)</span> 为第 <span class="math inline">\(n\)</span> 个素数</p><p>对 <span class="math inline">\(\forall \ p_i,p_j,(p_i^{2},p_j^2)=1\)</span>，由中国剩余定理，一定有最小正整数解 <span class="math inline">\(x_{min}(n)\)</span> 满足上述方程</p><p>该 <span class="math inline">\(x_{min}\)</span> 能保证序列 <span class="math inline">\(x_{min},x_{min}+1,\cdots,x_{min}+(n-1)\)</span> 中任何数能被某个大于 <span class="math inline">\(1\)</span> 的整数平方整除</p><h1 id="largetextcolorblue初等数论第五次作业-_textcolorblue2022.3.22"><span class="math inline">\(\large\textcolor{blue}{初等数论第五次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.3.22}\)</span></h1><h2 id="习题3.1.2">习题3.1.2</h2><p><span class="math inline">\(a\)</span> 对模 <span class="math inline">\(m\)</span> 和模 <span class="math inline">\(n\)</span> 的阶分别为 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span>, 证明: <span class="math inline">\(a\)</span> 对模 <span class="math inline">\([m, n]\)</span> 的阶为 <span class="math inline">\([s, t]\)</span>.</p><hr /><p>证明：由 <span class="math inline">\(a\)</span> 对模 <span class="math inline">\(m\)</span> 和 模 <span class="math inline">\(n\)</span> 的阶为 <span class="math inline">\(s,t\)</span>，则 <span class="math inline">\(a^{s}\equiv 1\pmod m,a^{t}\equiv 1\pmod n\)</span></p><p>则令 <span class="math inline">\(a\)</span> 对 <span class="math inline">\([m,n]\)</span> 的阶为 <span class="math inline">\(r\)</span>，即 <span class="math inline">\(a^{r}\equiv 1\pmod{[m,n]}\)</span>，有 <span class="math inline">\(m,n\mid [m,n]\)</span>，则 <span class="math inline">\(s,t\mid r\)</span>，则 <span class="math inline">\([s,t]\mid r\)</span></p><p>又 <span class="math inline">\(a^{[s,t]}\equiv (a^{s})^{\frac{[s,t]}{s}}\equiv 1\pmod{m},a^{[s,t]}\equiv (a^{t})^{\frac{[s,t]}{t}}\equiv 1\pmod{n}\)</span>，则 <span class="math inline">\(a^{[s,t]}\equiv 1\mod{[m,n]}\)</span></p><p>从而 <span class="math inline">\(r\mid [s,t]\)</span>，则 <span class="math inline">\(r=[s,t]\)</span>，即 <span class="math inline">\(a\)</span> 对模 <span class="math inline">\([m,n]\)</span> 的阶为 <span class="math inline">\([s,t]\)</span></p><h2 id="习题3.1.5">习题3.1.5</h2><p>若 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(a\)</span> 均是正整数, <span class="math inline">\(a \geqslant 2\)</span>. 证明: <span class="math inline">\(n \mid \varphi\left(a^{n}-1\right)\)</span>.</p><hr /><p>证明：考虑 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(a^{n}-1\)</span> 的阶 <span class="math inline">\(r\)</span>，有 <span class="math inline">\(a^{n}\equiv 1\pmod{a^{n}-1}\)</span>，则 <span class="math inline">\(r\mid n\)</span>，若 <span class="math inline">\(r=\dfrac{n}{d},d\geq 2\)</span></p><p>但 <span class="math inline">\(a^{r}=\sqrt[d]{a^{n}}\leq a^{n}-1\)</span>，则此时 <span class="math inline">\(a^{r}\not\equiv 1\pmod{a^{n}-1}\)</span>，从而 <span class="math inline">\(d=1\)</span>，即 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(a^{n}-1\)</span> 阶为 <span class="math inline">\(n\)</span></p><p>由 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(a^{n}-1\)</span> 阶一定为 <span class="math inline">\(\varphi(a^{n}-1)\)</span> 的因子，从而 <span class="math inline">\(n\mid \varphi(a^{n}-1)\)</span></p><h2 id="习题3.1.6">习题3.1.6</h2><p>如果 <span class="math inline">\(n \geqslant 2\)</span>, 证明: <span class="math inline">\(n \not\mid 2^{n}-1\)</span>.</p><hr /><p>证明：由于 <span class="math inline">\(2^n-1\equiv 1\pmod{2}\)</span>，若 <span class="math inline">\(2\mid n\)</span>，则 <span class="math inline">\(n\not\mid 2^{n}-1\)</span>，若 <span class="math inline">\(2\not\mid n\)</span>，令 <span class="math inline">\(n\)</span> 最小奇素数因子 <span class="math inline">\(p\)</span></p><p>则 <span class="math inline">\(n=pt,t\in Z\)</span>，反证法若 <span class="math inline">\(n\mid 2^n-1\)</span>，令 <span class="math inline">\(2^n=1+nx=2^{pt}=1+ptx,x\in Z\)</span></p><p>有 <span class="math inline">\(2^{pt}\equiv 1\pmod{p}\)</span>，而费马小定理给出 <span class="math inline">\(2^{p-1}\equiv 1\pmod{p},2^p\equiv 2\pmod{p}\)</span> 由 <span class="math inline">\(pt\mid p-1\)</span> 矛盾</p><h2 id="习题3.1.7">习题3.1.7</h2><p>设 <span class="math inline">\(p\)</span> 是奇素数, <span class="math inline">\(n \geqslant 1\)</span>. 证明: <span class="math display">\[\sum_{k=1}^{p-1} k^{n} \equiv \begin{cases}-1(\bmod p), &amp; \text { 如果 } p-1 \mid n, \\ 0(\bmod p), &amp; \text { 如果 } p-1 \not\mid n .\end{cases}\]</span></p><hr /><p>证明：由于 <span class="math inline">\(p\)</span> 为奇素数，令其原根为 <span class="math inline">\(g\)</span>，则 <span class="math inline">\(Z_{p}=\{1,2,\cdots ,p-1\}=\{g,g^2,\cdots,g^{p-1}\}\)</span></p><p>从而求和式 <span class="math inline">\(\displaystyle \sum_{k=1}^{p-1}k^{n}\equiv \sum_{k=1}^{p-1}g^{n}\pmod{p}\)</span>，若 <span class="math inline">\(p-1\mid n\)</span>，由费马小定理 <span class="math inline">\(g^{n}\equiv g^{p-1}\equiv 1\pmod{p}\)</span></p><p>此时 <span class="math inline">\(\displaystyle \sum_{k=1}^{p-1}k^{n}\equiv \sum_{k=1}^{p-1}1\equiv -1\pmod{p}\)</span>，若 <span class="math inline">\(p-1\not\mid n\)</span>，则由等比数列求和 <span class="math display">\[\sum_{k=1}^{p-1}g^n\equiv \dfrac{g^{n}(1-g^{p-1})}{1-g^{n}}\equiv \dfrac{g^{n}\cdot 0}{1-g^{n}}(1-g^{n}\neq 0)\equiv 0\pmod{p}\]</span> 从而 <span class="math inline">\(\sum_{k=1}^{p-1} k^{n} \equiv \begin{cases}-1(\bmod p), &amp; \text { if } p-1 \mid n, \\ 0(\bmod p), &amp; \text { if } p-1 \not\mid n .\end{cases}\)</span></p><h2 id="习题3.1.8">习题3.1.8</h2><p><span class="math inline">\((1)\)</span> 设 <span class="math inline">\(F_{n}=2^{2^{n}}+1\)</span> (费马数), <span class="math inline">\(n \geqslant 1\)</span>. 证明: <span class="math inline">\(F_{n}\)</span> 的每个素因子都有形式 <span class="math inline">\(2^{n+1} x+1(x \in \mathbf{Z})\)</span>.</p><p><span class="math inline">\((2)\)</span> 对任意给定的整数 <span class="math inline">\(l \geqslant 1\)</span>, 证明: 有无穷多个素数模 <span class="math inline">\(2^{l}\)</span> 余 1 .</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 对每个 <span class="math inline">\(F_{n}\)</span> 的奇素数因子 <span class="math inline">\(p\)</span>，有 <span class="math inline">\(2^{p-1}\equiv 1\pmod{p}\)</span>，而 <span class="math inline">\(2^{2^{n}}\equiv -1\pmod{p}\)</span>，两边平方</p><p><span class="math inline">\(2^{2^{n+1}}\equiv 1\pmod{p}\)</span>，从而令 <span class="math inline">\(2\)</span> 模 <span class="math inline">\(p\)</span> 的次数为 <span class="math inline">\(r\)</span>，则 <span class="math inline">\(r\mid2^{n+1}\)</span>，<span class="math inline">\(r=2^{k}\)</span>，显然 <span class="math inline">\(k\neq n\)</span>，因为</p><p><span class="math inline">\(2^{2^{n}}\equiv -1\pmod{p}\)</span>，若 <span class="math inline">\(k&lt;n\)</span>，则重复 <span class="math inline">\(n-k\)</span> 次平方操作得到 <span class="math inline">\(2^{2^{n}}\equiv 1\pmod{p}\)</span> 与条件矛盾</p><p>从而 <span class="math inline">\(r=2^{n+1}\)</span>，结合 <span class="math inline">\(2^{p-1}\equiv 1\pmod{p}\)</span> 可得 <span class="math inline">\(2^{n+1}\mid p-1\)</span></p><p><span class="math inline">\((2)\)</span> 对任意两个不相同的费马数，<span class="math inline">\(F_{m},F_{n}\)</span> ，不妨设 <span class="math inline">\(m\geq n,m=n+k,k\geq 1\in Z\)</span></p><p>则 <span class="math inline">\(F_{m}=2^{2^{m+n}}+1=(2^{2^{n}})^{2^k}+1=(F_{n}-1)^{2^k}+1=p(F_n)+2\)</span>，其中 <span class="math inline">\(p(F_n)\)</span> 为多项式</p><p>从而 <span class="math inline">\((F_{m},F_n)\mid 2\)</span>，又 <span class="math inline">\(x\not\mid F_{n},F_m\)</span>，则 <span class="math inline">\((F_m,F_n)=1\)</span>，即所有费马数两两互素，而每个 <span class="math inline">\(F_n\)</span></p><p>都至少有一个素因子模 <span class="math inline">\(2^{n+1}\)</span> 余 <span class="math inline">\(1\)</span>，且不同费马数素因子不重合，则对给定的 <span class="math inline">\(l\)</span>，取 <span class="math inline">\(n\geq l-1\)</span></p><p>则这些无穷个的费马数模 <span class="math inline">\(2^{n+1}\)</span> 余 <span class="math inline">\(1\)</span>，则也模 <span class="math inline">\(2^{l}\)</span> 余 <span class="math inline">\(1\)</span></p><h2 id="习题3.1.9">习题3.1.9</h2><p><span class="math inline">\((1)\)</span> 设 <span class="math inline">\(p\)</span> 为奇素数, <span class="math inline">\(a \geqslant 2\)</span>. 证明: 若 <span class="math inline">\(a^{p}-1\)</span> 的素因子 <span class="math inline">\(q\)</span> 不整除 <span class="math inline">\(a-1\)</span>，则必有形式 <span class="math inline">\(q=2 p x+1(x \in Z)\)</span>.</p><p><span class="math inline">\((2)\)</span> 设 <span class="math inline">\(p\)</span> 为给定的奇素数, 证明：形如 <span class="math inline">\(2 p x+1(x \in \mathbb{Z})\)</span> 的素数有无限多个.</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 由于 <span class="math inline">\(q\)</span> 为 <span class="math inline">\(a^{p}-1\)</span> 素因子，则 <span class="math inline">\(a^p\equiv 1\pmod{q}\)</span>，由 <span class="math inline">\(q\not\mid a-1\)</span>，得 <span class="math inline">\(a\not\equiv 1\pmod{q}\)</span></p><p>设 <span class="math inline">\(a\)</span> 为模 <span class="math inline">\(q\)</span> 的阶为 <span class="math inline">\(r\)</span>，则有 <span class="math inline">\(r\mid p\)</span>，又 <span class="math inline">\(r\neq 1\)</span>，从而 <span class="math inline">\(r=p\)</span>，有费马小定理 <span class="math inline">\(a^{q-1}\equiv 1\pmod{q}\)</span></p><p>从而 <span class="math inline">\(r=p\mid q-1\)</span>；另一方面考虑奇偶性，若 <span class="math inline">\(2 \mid a\)</span>，<span class="math inline">\(2\not \mid a^{p}-1\)</span>，素因子 <span class="math inline">\(q\)</span> 为奇数，若 <span class="math inline">\(2\not\mid a\)</span>，</p><p><span class="math inline">\(a^{p}-1\)</span> 有素因子 <span class="math inline">\(2\)</span>，但此时要求 <span class="math inline">\(q\)</span> 不整除 <span class="math inline">\(a-1\)</span>，从而 <span class="math inline">\(q\neq 2\)</span>，素因子 <span class="math inline">\(q\)</span> 也为奇数，则 <span class="math inline">\(q-1\)</span> 中</p><p>有素因子 <span class="math inline">\(2\)</span>，而 <span class="math inline">\(p\)</span> 为奇素数，从而 <span class="math inline">\(2p \mid q-1\)</span></p><p><span class="math inline">\((2)\)</span> 构造 <span class="math inline">\(a_1=2^{p}-1,a_n=(\displaystyle \prod_{i=1}^{n-1}a_i)^{p}-1\)</span>，满足两两互素，<span class="math inline">\(a^{p}-1\)</span> 总能有不整除 <span class="math inline">\(a-1\)</span> 的素因子</p><p>否则所有素因子 <span class="math inline">\(p_i=\dfrac{a-1}{k_i},k_i\geq 2\in Z\)</span>，相乘有 <span class="math inline">\(a^p-1=\dfrac{(a-1)^{x}}{\displaystyle \prod_{i=1}^{x}k_i}\)</span> 移项后有</p><p><span class="math inline">\((a^p-1)\displaystyle \prod _{i=1}^{x}k_i=(a-1)^x\)</span>，两边对 <span class="math inline">\(a\)</span> 取模得 <span class="math inline">\(-\displaystyle \prod_{i=1}^xk_i\equiv (-1)^x\pmod{a}\)</span> 矛盾</p><p>则两两互素的无穷整数数列 <span class="math inline">\(\{a_n\}\)</span> 中每个数都存在形如 <span class="math inline">\(2px+1\)</span> 的素因子，共无穷多个</p><h2 id="柯召讲义5.1">柯召讲义5.1</h2><p>证明: <span class="math inline">\(m\)</span> 是一个素数的充分必要条件是存在某个整数 <span class="math inline">\(a, a\)</span> 对模数 <span class="math inline">\(m\)</span> 的次数为 <span class="math inline">\(m-1\)</span>.</p><hr /><p>证明：<span class="math inline">\(1^{\circ}\)</span> 若 <span class="math inline">\(m\)</span> 为一个素数，由素数必有原根可知，<span class="math inline">\(\exists\ a\in Z\)</span>，使得 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(m\)</span> 的阶数为 <span class="math inline">\(m-1\)</span></p><p><span class="math inline">\(2^{\circ}\)</span> 若对某个 <span class="math inline">\(a\in Z\)</span>，<span class="math inline">\(a^{r}\equiv 1\pmod{m}\)</span> 的最小正整数（阶数 <span class="math inline">\(r\)</span> ）为 <span class="math inline">\(m-1\)</span>，有 <span class="math inline">\((a,m)=1\)</span></p><p>由费马小定理 <span class="math inline">\(a^{\varphi(m)}\equiv 1\pmod{m}\)</span>，得 <span class="math inline">\(m-1\mid \varphi(m)\)</span>，若 <span class="math inline">\(m\)</span> 不是素数，<span class="math inline">\(m\geq 2\)</span>，令 <span class="math display">\[m=p_1^{l_1}\cdots p_{s}^{l_s},\varphi(m)=m\prod _{i=1}^{s}(1-\dfrac{1}{p_i})\leq m\prod _{i=1}^{s}(1-\dfrac{1}{p_i^{l_i}})&lt; m(1-\prod_{i=1}^{s}\dfrac{1}{p_i^{l_i}})=m-1\]</span> 从而 <span class="math inline">\(m\)</span> 为素数</p><h2 id="柯召讲义5.2">柯召讲义5.2</h2><p>设 <span class="math inline">\(g\)</span> 是奇素数 <span class="math inline">\(p\)</span> 的一个原根, 证明: 当 <span class="math inline">\(p \equiv 1(\bmod 4)\)</span> 时, <span class="math inline">\(-g\)</span> 也是 <span class="math inline">\(p\)</span> 的一个原根; 当 <span class="math inline">\(p \equiv 3(\bmod 4)\)</span> 时, <span class="math inline">\(-g\)</span> 对 <span class="math inline">\(p\)</span> 的次数为 <span class="math inline">\(\dfrac{p-1}{2}\)</span>.</p><hr /><p>证明：若 <span class="math inline">\(g\)</span> 是奇素数 <span class="math inline">\(p\)</span> 的一个原根，则满足 <span class="math inline">\(g^{r}\equiv 1\pmod{p}\)</span> 的最小 <span class="math inline">\(r=p-1\)</span>，而 <span class="math inline">\(2\mid p-1\)</span></p><p>则 <span class="math inline">\((-g)^{p-1}\equiv g^{p-1}\equiv 1\pmod{p}\)</span>，且若存在 <span class="math inline">\(1\leq r&#39;&lt; p-1\)</span>，使得 <span class="math inline">\((-g)^{r&#39;}\equiv 1\pmod{p}\)</span></p><p><span class="math inline">\(r&#39;\)</span> 不能是偶数，否则与阶数矛盾，则 <span class="math inline">\(2\not \mid p\)</span>，有 <span class="math inline">\(g^{r&#39;}\equiv -1\pmod{p}\)</span>，则 <span class="math display">\[g^{2r&#39;}-1\equiv (g^{r&#39;}+1)\cdot (g^{r&#39;}-1)\equiv 0\pmod{p},g^{2r&#39;}\equiv 1\pmod{p}\]</span> 则 <span class="math inline">\(2r&#39;\mid r\)</span>，由于 <span class="math inline">\(r&#39;\)</span> 为奇数，若 <span class="math inline">\(p\equiv 1\pmod{4}\)</span>，则 <span class="math inline">\(4\mid p-1\)</span>，此时 <span class="math inline">\(r&#39;\)</span> 不存在，从而 <span class="math inline">\(-g\)</span> 也为原根</p><p>若 <span class="math inline">\(p\equiv 3\pmod{4}\)</span> ，有 <span class="math display">\[g^{p-1}-1\equiv (g^{\frac{p-1}{2}}-1)\cdot (g^{\frac{p-1}{2}}+1)\equiv 0\pmod{p}\]</span> 且 <span class="math inline">\(g^{\frac{p-1}{2}}\not \equiv 1\pmod{p}\)</span> 否则不满足阶数的性质，则 <span class="math inline">\((-g)^{\frac{p-1}{2}}\equiv 1\pmod{p}\)</span>，若 <span class="math inline">\(1\leq r&#39;&#39;&lt; \dfrac{p-1}{2}\)</span></p><p>使得 <span class="math inline">\((-g)^{r&#39;&#39;}\equiv 1\pmod{p}\)</span>，首先 <span class="math inline">\(r&#39;&#39;\)</span> 不为偶数，若 <span class="math inline">\(r&#39;&#39;\)</span> 为奇数，则 <span class="math inline">\(g^{r&#39;&#39;}\equiv -1\pmod{p}\)</span></p><p>从而平方 <span class="math inline">\(g^{2r&#39;&#39;}\equiv 1\pmod{p}\)</span>，则有 $22r''&lt;p-1 $ 使得 <span class="math inline">\(g^{2r&#39;&#39;}\equiv 1\pmod{p}\)</span> 与阶数矛盾</p><p>从而此时 <span class="math inline">\(-g\)</span> 对 <span class="math inline">\(p\)</span> 的阶数为 <span class="math inline">\(\dfrac{p-1}{2}\)</span></p><h1 id="largetextcolorblue初等数论第六次作业-_textcolorblue2022.4.1"><span class="math inline">\(\large\textcolor{blue}{初等数论第六次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.4.1}\)</span></h1><h2 id="习题3.1.1">习题3.1.1</h2><p>设 <span class="math inline">\(m \geqslant 2\)</span>, 整数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 模 <span class="math inline">\(m\)</span> 的阶分别为 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span>, 并且 <span class="math inline">\((s, t)=1\)</span>. 证明 <span class="math inline">\(a b\)</span> 模 <span class="math inline">\(m\)</span> 的阶为 <span class="math inline">\(s t\)</span>.</p><hr /><p>证明：设 <span class="math inline">\(ab\)</span> 模 <span class="math inline">\(m\)</span> 的阶为 <span class="math inline">\(r\)</span>，<span class="math inline">\((ab)^{r}\equiv 1\pmod{m}\)</span>，由 <span class="math inline">\((ab)^{st}\equiv (a^{s})^{r}\cdot (b^r)^{s}\equiv 1\pmod{m}\)</span></p><p>得 <span class="math inline">\(r\mid st\)</span>，则设 <span class="math inline">\(st=pr,p\in Z \mbox{\ and \ p is\  prime}\)</span>，由 <span class="math inline">\((s,t)=1\)</span>，则 <span class="math inline">\(p\mid s\)</span> 或 <span class="math inline">\(p \mid t\)</span>，不妨设 $ ps$</p><p>令 <span class="math inline">\(s=px,xt=r\)</span>，有 <span class="math inline">\((ab)^{r}\equiv (ab)^{xt}\equiv a^{xt}\cdot 1\equiv 1 \pmod{m}\)</span></p><p>则 <span class="math inline">\(s\mid xt\)</span>，由 <span class="math inline">\((s,t)=1\)</span>，得 <span class="math inline">\(s\mid x\)</span>，又 <span class="math inline">\(x\mid s\)</span>，可得 <span class="math inline">\(s=x,p=1\)</span>，即 <span class="math inline">\(r=st\)</span></p><h2 id="习题3.1.4">习题3.1.4</h2><p><span class="math inline">\((1)\)</span> 对于 <span class="math inline">\(p=5,7,11,13,23\)</span>, 求模 <span class="math inline">\(p\)</span> 的最小正原根.</p><p><span class="math inline">\((2)\)</span> 求模 <span class="math inline">\(7^{2}\)</span> 的全部原根.</p><hr /><p>解：<span class="math inline">\((1)\)</span> 由在 <span class="math inline">\(Z_5\)</span> 下 <span class="math inline">\(\{2,2^2,2^3,2^4\}=\{2,4,3,1\}\)</span> ，则 <span class="math inline">\(2\)</span> 为 <span class="math inline">\(5\)</span> 的最小正原根</p><p>在 <span class="math inline">\(Z_7\)</span> 下 <span class="math inline">\(\{2,2^2,2^3,2^4,2^5,2^6\}=\{2,4,1,2,4,1\},\{3,3^2,3^3,3^4,3^5,3^6\}=\{3,2,6,4,5,1\}\)</span></p><p>则 <span class="math inline">\(3\)</span> 为 <span class="math inline">\(7\)</span> 的最小正原根</p><p>在 <span class="math inline">\(Z_{11}\)</span> 下 <span class="math inline">\(\{2,2^2,2^3,2^4,2^5,2^6,2^7,2^8,2^9,2^{10}\}=\{2,4,8,5,10,9,7,3,6,1\}\)</span> ，则 <span class="math inline">\(2\)</span> 为 <span class="math inline">\(11\)</span> 的</p><p>最小正原根</p><p>在 <span class="math inline">\(Z_{13}\)</span> 下 <span class="math inline">\(\{2,2^2,2^3,2^4,2^5,2^6,2^7,2^8,2^9,2^{10},2^{11},2^{12}\}=\{2,4,8,3,6,12,11,9,5,10,7,1\}\)</span></p><p>则 <span class="math inline">\(2\)</span> 为 <span class="math inline">\(13\)</span> 的最小正原根</p><p>在 <span class="math inline">\(Z_{23}\)</span> 下 <span class="math inline">\(\{2,2^2,2^3,2^4,2^5,2^6,2^7,2^8,2^9,2^{10},2^{11}\}=\{2,4,8,16,9,18,13,3,6,12,1\}\)</span></p><p><span class="math inline">\(\{3,3^2,3^3,3^4\}=\{3,6,12,1\}\)</span> 对 <span class="math inline">\(5\)</span> 而言 <span class="math display">\[\begin{gathered}\{5,5^2,5^3,5^4,5^5,5^6,5^7,5^8,5^9,5^{10},5^{11},5^{12},5^{13},5^{14},5^{15},5^{16},5^{17},5^{18},5^{19},5^{20},5^{21},5^{22}\}=\\\{5,2,10,4,20,8,17,16,11,9,22,18,21,13,19,3,15,6,7,12,14,1\}\end{gathered}\]</span> 则 <span class="math inline">\(5\)</span> 为 <span class="math inline">\(23\)</span> 的最小正原根</p><p><span class="math inline">\((2)\)</span> 由定理， <span class="math inline">\(7\)</span> 有原根 <span class="math inline">\(3\)</span>，则 <span class="math inline">\(3\)</span> 和 <span class="math inline">\(10\)</span> 必有一个为 <span class="math inline">\(49\)</span> 的原根，有 <span class="math display">\[3^{2},3^{4},3^{6},3^{8},3^{12},3^{16},3^{24}\equiv 9,32,43,44,36,25,22\pmod{49}\]</span> 从而 <span class="math inline">\(3\)</span> 为 <span class="math inline">\(49\)</span> 的原根，有 <span class="math inline">\(\varphi(\varphi(49))=\varphi(42)=12\)</span> 个原根，有 <span class="math inline">\(3^{r},(r,42)=1\)</span> 均为原根，计算有</p><p><span class="math inline">\(\{3,3^{5},3^{11},3^{13},3^{17},3^{19},3^{23},3^{25},3^{29},3^{31},3^{37},3^{41}\}=\{3,47,12,10,26,38,40,17,5,45,24,33\}\)</span></p><p>则 <span class="math inline">\(49\)</span> 的所有原根为 <span class="math inline">\(\begin{equation}\boxed{3, 5, 10 , 12, 17 , 24 , 26 , 33 , 38 , 40 , 45, 47}\end{equation}\)</span>，共 <span class="math inline">\(12\)</span> 个</p><h2 id="习题3.2.1">习题3.2.1</h2><p>解同余方程:</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(x^{8} \equiv 3 \pmod{13}\)</span>;</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(x^{8} \equiv 3\pmod {143}\)</span>;</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(7^{x} \equiv 4\pmod{17}\)</span>.</p><hr /><p>解：<span class="math inline">\((1)\)</span> 由上题知 <span class="math inline">\(2\)</span> 为 <span class="math inline">\(13\)</span> 的一个原根，则原式等价于 <span class="math inline">\(8\mbox{ind}_2x\equiv \mbox{ind}_{2}3\pmod{12}\)</span></p><p>由 <span class="math inline">\(2^{4}\equiv 3\pmod{13}\)</span> 得 <span class="math inline">\(8\mbox{ind}_2x\equiv 4\pmod{12}\)</span> 且 <span class="math inline">\((8,12)=4\mid 4\)</span>，代换有</p><p><span class="math inline">\(2\mbox{ind}_2x\equiv 1\equiv 4\pmod{3}\)</span>，<span class="math inline">\(\mbox{ind}_2{x}\equiv 2,5,8,11\)</span>，得解为 <span class="math inline">\(x_1\equiv 4,6,7,9\pmod{13}\)</span></p><p><span class="math inline">\((2)\)</span> 结合 <span class="math inline">\(x^8\equiv 3\pmod{11}\)</span>，由 <span class="math inline">\(2\)</span> 为 <span class="math inline">\(11\)</span> 的一个原根，等价于 <span class="math inline">\(8\mbox{ind}_2x\equiv \mbox{ind}_23\equiv 8\pmod{10}\)</span></p><p>由 <span class="math inline">\((8,10)=2\mid 10\)</span>，则有两个解，<span class="math inline">\(\mbox{ind}_2x\equiv 1,6\pmod{10}\)</span>，则 <span class="math inline">\(x_2\equiv 2,9\pmod{11}\)</span></p><p>使用中国剩余定理，<span class="math inline">\(11^{-1}\equiv 6\pmod{13},13^{-1}\equiv 6\pmod{11}\)</span> 对应计算 <span class="math inline">\(x_1\cdot 6\cdot 13+x_2\cdot 6\cdot 11\)</span> <span class="math display">\[x\equiv 9,20,35,46,97,108,123,134 \pmod{143}\]</span> <span class="math inline">\((3)\)</span> 对 <span class="math inline">\(2\)</span> 计算 <span class="math inline">\(2^1,2^2,2^4,2^8\equiv 2,4,16,1\pmod{17}\)</span>，则 <span class="math inline">\(2\)</span> 不是 <span class="math inline">\(17\)</span> 的原根，同理对 <span class="math inline">\(3\)</span> 计算有</p><p><span class="math inline">\(3^1,3^2,3^4,3^8\equiv 3,9,13,16\pmod{17}\)</span>，则 <span class="math inline">\(3\)</span> 是 <span class="math inline">\(17\)</span> 的原根，则对 <span class="math inline">\(7^{x} \equiv 4\pmod{17}\)</span> 变换有</p><p><span class="math inline">\(x\mbox{ind}_{3}7\equiv \mbox{ind}_34\pmod{16}\)</span> 有 <span class="math inline">\(\mbox{ind}_37=11,\mbox{ind}_34=12\)</span>，则 <span class="math inline">\(11x\equiv 12\pmod{16}\)</span></p><p><span class="math inline">\((11,16)=1\mid 12\)</span> 只有一个整数解，得 <span class="math inline">\(x\equiv 4\pmod{17}\)</span></p><h2 id="习题3.2.2">习题3.2.2</h2><p><span class="math inline">\((1)\)</span> 写出模 <span class="math inline">\(37\)</span> 的全部 <span class="math inline">\(8\)</span> 次剩余和 <span class="math inline">\(15\)</span> 次剩余.</p><p><span class="math inline">\((2)\)</span> 写出模 <span class="math inline">\(11\)</span> 的全部二次剩余.</p><hr /><p>解：<span class="math inline">\((1)\)</span> 取 <span class="math inline">\(37\)</span> 的一个原根 <span class="math inline">\(2\)</span>，由 <span class="math inline">\((8,36)=4\)</span>，因此八次剩余 <span class="math inline">\(a\)</span> 满足的条件为： <span class="math inline">\(4 \mid \operatorname{ind}_{2} a\)</span> ，故</p><p><span class="math inline">\(\operatorname{ind}_{2} a=4,8,12, \cdots, 36\)</span> ，因此模 <span class="math inline">\(37\)</span> 的全部 <span class="math inline">\(8\)</span> 次剩余为: <span class="math inline">\(a \equiv 2^{4}, 2^{8}, \cdots, 2^{36}(\bmod 37)\)</span>； <span class="math display">\[a\equiv 16,34,26,9,33,10,12,7,1\pmod{37}\]</span> 而 <span class="math inline">\((15,36)=3\)</span> ，因此 <span class="math inline">\(15\)</span> 剩余 <span class="math inline">\(a\)</span> 满足的条件为：<span class="math inline">\(3 \operatorname{ind}_{2} a\)</span> ，故 <span class="math inline">\(\operatorname{ind}_{2} a=3,6, \cdots, 36\)</span> ，因此解为:</p><p><span class="math display">\[a \equiv 2^{3}, 2^{6}, \cdots, 2^{36}\equiv 8,27,31,26,23,36,29,10,6,11,14,1 (\bmod 37)\]</span> <span class="math inline">\((2)\)</span> 模 <span class="math inline">\(11\)</span> 的全部二次剩余为: <span class="math inline">\(1^{2}, 2^{2}, \cdots, 5^{2}\)</span> ，即 <span class="math inline">\(1,3,4,5,9\)</span></p><h2 id="习题3.2.3">习题3.2.3</h2><p>设 <span class="math inline">\(p\)</span> 为素数, <span class="math inline">\(p \equiv 2(\bmod 3), a\)</span> 和 <span class="math inline">\(b\)</span> 是整数. 证明： <span class="math inline">\(a^{3} \equiv b^{3}(\bmod p)\)</span> 当且仅当 <span class="math inline">\(a \equiv b(\bmod p)\)</span>.</p><hr /><p>证明：若 <span class="math inline">\((a,p)=p\)</span>，则 <span class="math inline">\(a\equiv b\equiv 0\pmod{p}\)</span>，否则 <span class="math inline">\((a,p)=1\)</span> 令 <span class="math inline">\(p=3k+2,k\geq 1\)</span>，有</p><p><span class="math inline">\(a^{3}\equiv b^{3}\equiv c\pmod{p}\)</span>，且 <span class="math inline">\((c,p)=1\)</span>，由欧拉定理 <span class="math inline">\(a^{3k+1}\equiv b^{3k+1}\equiv c^ka\equiv c^kb\equiv 1\pmod{p}\)</span></p><p>从而 <span class="math inline">\(a\equiv c^{-k}\equiv b\pmod{p}\)</span></p><blockquote><p>设 <span class="math inline">\(a^{3} \equiv b^{3} \equiv k(\bmod p)\)</span> ，因为 <span class="math inline">\((3, p-1)=1\)</span> ，故 <span class="math inline">\(x^{3} \equiv k(\bmod p)\)</span> 在模 <span class="math inline">\(p\)</span> 意义下仅有一个解， 故得证</p></blockquote><h2 id="习题3.2.4">习题3.2.4</h2><p>设 <span class="math inline">\(p\)</span> 为奇素数, 整数 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(p\)</span> 的阶为 <span class="math inline">\(3\)</span>，求 <span class="math inline">\(\dfrac{a}{a+1}\)</span> 模 <span class="math inline">\(p\)</span> 的阶.</p><hr /><p>解：由题设定义 <span class="math inline">\(a\)</span> 的数论倒数为 <span class="math inline">\(b\)</span>，即 <span class="math inline">\(ab\equiv 1\pmod{p}\)</span>，有 <span class="math inline">\((\dfrac{a}{a+1})^{-1}=1+\dfrac{1}{a}=1+b\)</span></p><p>由 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(x^{-1}\)</span> 模 <span class="math inline">\(p\)</span> 的阶是一样的，从而考虑 <span class="math inline">\(1+b\)</span> 模 <span class="math inline">\(p\)</span> 的阶，由满足 <span class="math inline">\(a^{r}\equiv 1\pmod{p}\)</span> 的最小正整数</p><p>为 <span class="math inline">\(3\)</span> ，也有 <span class="math inline">\(b^3\equiv 1\pmod{p}\)</span>，<span class="math inline">\(b^2+b+1\equiv 0\pmod{p}\)</span>，令 <span class="math inline">\(1+b\)</span> 模 <span class="math inline">\(p\)</span> 的阶为 <span class="math inline">\(r&#39;\)</span>，</p><p>有 <span class="math inline">\((1+b)^{r&#39;}\equiv 1\pmod{p}\)</span> ，有 <span class="math inline">\((1+b)^{1}\not\equiv 1\pmod{p},(1+b)^2\equiv b\not\equiv 1\pmod{p}\)</span></p><p>但 <span class="math inline">\((1+b)^3\equiv 3(b^2+b+1)-2+b^3\equiv -1\pmod{p}\)</span>，而 <span class="math inline">\((1+b)^4\equiv -1\not\equiv 1\pmod{p}\)</span></p><p><span class="math inline">\((1+b)^5\equiv -b\not\equiv 1\pmod{p}\)</span>，且 <span class="math inline">\((1+b)^{6}\equiv 1\pmod{p}\)</span>，则 <span class="math inline">\(\dfrac{a}{a+1}\)</span> 模 <span class="math inline">\(p\)</span> 的阶为 <span class="math inline">\(6\)</span></p><h2 id="习题4.1.2">习题4.1.2</h2><p>设 <span class="math inline">\(p\)</span> 为奇素数, <span class="math inline">\(n\)</span> 是最小正整数使得 <span class="math inline">\(\left(\dfrac{n}{p}\right)=-1\)</span>. 证明: <span class="math inline">\(n\)</span> 为素数</p><hr /><p>证明：由勒让德符号定义不存在整数 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(x^2\equiv n\pmod{p}\)</span>，取 <span class="math inline">\(p\)</span> 的原根 <span class="math inline">\(g\)</span> 有 <span class="math inline">\(n=g^{2j+1}\)</span></p><p>若 <span class="math inline">\(n\)</span> 为合数，即 <span class="math inline">\(n=n_1n_2\)</span>，由 <span class="math inline">\(\left(\dfrac{n}{p}\right)=\left(\dfrac{n_1}{p}\right)\left(\dfrac{n_2}{p}\right)\)</span> 可知 <span class="math inline">\(n_1\)</span> 和 <span class="math inline">\(n_2\)</span> 一定一者为 <span class="math inline">\(1\)</span>，另一者为 <span class="math inline">\(-1\)</span></p><p>而显然为 <span class="math inline">\(-1\)</span> 的一者对应的 <span class="math inline">\(n_i\)</span> 更小，与题设矛盾，从而 <span class="math inline">\(n\)</span> 为素数</p><h1 id="largetextcolorblue初等数论第七次作业-_textcolorblue2022.4.16"><span class="math inline">\(\large\textcolor{blue}{初等数论第七次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.4.16}\)</span></h1><h2 id="习题4.1.1">习题4.1.1</h2><p>设 <span class="math inline">\(p\)</span> 为奇素数, <span class="math inline">\(a, b \in \mathbf{Z},(a, p)=1\)</span>. 证明： <span class="math display">\[\sum_{n=0}^{p-1}\left(\frac{a n+b}{p}\right)=0\]</span></p><hr /><p>证明：由于 <span class="math inline">\((a,p)=1\)</span>，则 <span class="math inline">\(a,a+b,\cdots,a(p-1)+b\)</span> 构成模 <span class="math inline">\(p\)</span> 的完系，可用反证法证明</p><p>其中模 <span class="math inline">\(p\)</span> 的二次剩余和非二次剩余都为 <span class="math inline">\(\dfrac{p-1}{2}\)</span> 个，最后剩一个能被 <span class="math inline">\(p\)</span> 整除的</p><p>则 <span class="math inline">\(\displaystyle \sum_{n=0}^{p-1}\left(\frac{a n+b}{p}\right)=\dfrac{p-1}{2}+(-1)\cdot \dfrac{p-1}{2}+0=0\)</span></p><h2 id="习题4.1.3">习题4.1.3</h2><p>证明形如 <span class="math inline">\(8m+3,8m+5,8m+7\)</span> 的素数均有无穷多个</p><hr /><p>解：<span class="math inline">\((1)\)</span> 反证，假设 <span class="math inline">\(8m+3\)</span> 的素数有限个，设为 <span class="math inline">\(p_1.p_2,\cdots ,p_s\)</span> 构造 <span class="math inline">\(n=2(p_1p_2\cdots p_s)^2+1\)</span> ，</p><p>由 <span class="math inline">\(n\equiv 2\cdot (3^2)^{s}+1\equiv 3\pmod{8}\)</span>，则由假设 <span class="math inline">\(n\)</span> 为合数</p><p>设其素因子为 <span class="math inline">\(p\)</span>，有 <span class="math inline">\(2(p_1p_2\cdots p_s)^2\equiv -1\pmod{p}\)</span>，两边乘以 <span class="math inline">\(2\)</span>，取勒让德符号 <span class="math display">\[(\dfrac{-2}{p})=1=(\dfrac{2}{p})(\dfrac{-1}{p})=(-1)^{\frac{p^2-1}{8}+\frac{p-1}{2}}=(-1)^{\frac{(p-1)(p+5)}{8}}\]</span> 从而 <span class="math inline">\(2\mid \dfrac{(p-1)(p+5)}{8}\)</span>，从而 <span class="math inline">\(p\equiv 1,3\pmod{8}\)</span>。但 <span class="math inline">\(n\equiv 3\pmod{8}\)</span>，<span class="math inline">\(n\)</span> 的所有素因子不可能</p><p>均模 <span class="math inline">\(8\)</span> 余 <span class="math inline">\(3\)</span>，从而一定存在一个模 <span class="math inline">\(8\)</span> 余 <span class="math inline">\(3\)</span> 的素因子，而该素因子不为 <span class="math inline">\(p_1,\cdots ,p_s\)</span>，这是因为</p><p><span class="math inline">\(n\equiv 1\pmod{p_i}\)</span>，从而矛盾，<span class="math inline">\(8m+3\)</span> 型素数有无穷多个</p><p><span class="math inline">\((2)\)</span> 假设 <span class="math inline">\(8m+5\)</span> 的素数有限个，设为 <span class="math inline">\(p_1,p_2,\cdots,p_s\)</span>，构造 <span class="math inline">\(n=4(p_1\cdots p_s)^2+1\)</span> 有</p><p><span class="math inline">\(n\equiv 5\pmod{8}\)</span>，其为合数，设其素因子为 <span class="math inline">\(p\)</span></p><p>有 <span class="math inline">\((2p_1\cdots p_s)^2\equiv -1\pmod{p}\)</span>，取勒让德符号有 <span class="math inline">\((\dfrac{-1}{p})=1=(-1)^{\frac{p-1}{2}}\)</span></p><p>则 <span class="math inline">\(p\equiv 1,5\pmod{8}\)</span> 而 <span class="math inline">\(n\equiv 5\pmod{5}\)</span>，<span class="math inline">\(n\)</span> 的所有素因子不可能全为 <span class="math inline">\(1\)</span>，则其存在一个</p><p>不为 <span class="math inline">\(p_i\)</span> 的素因子，与假设矛盾，从而 <span class="math inline">\(8m+5\)</span> 型素数有无穷多个</p><p><span class="math inline">\((3)\)</span> 假设 <span class="math inline">\(8m+7\)</span> 的素数有限个，设为 <span class="math inline">\(p_1,p_2,\cdots,p_s\)</span>，构造 <span class="math inline">\(n=8(p_1\cdots p_s)^2-1\)</span> 有</p><p><span class="math inline">\(n\equiv 7\pmod{8}\)</span>，其为合数，设其素因子为 <span class="math inline">\(p\)</span></p><p>有 <span class="math inline">\((4p_1\cdots p_s)^2\equiv 2\pmod{p}\)</span>，使用勒让德符号有 <span class="math inline">\((\dfrac{2}{p})=1=(-1)^{\frac{p^2-1}{8}}\)</span></p><p>则 <span class="math inline">\(p\equiv 1,7\)</span>，又由于 <span class="math inline">\(n\equiv 7\pmod{8}\)</span>，<span class="math inline">\(n\)</span> 所有素因子不可能全为 <span class="math inline">\(1\)</span>，则其存在一个</p><p>不为 <span class="math inline">\(p_i\)</span> 的素因子，与假设矛盾，从而 <span class="math inline">\(8m+7\)</span> 型素数有无穷多个</p><h2 id="习题4.1.4">习题4.1.4</h2><p>设 <span class="math inline">\(p\)</span> 为奇素数. 证明: 有无穷多的素数是模 <span class="math inline">\(p\)</span> 的二次非剩余.</p><hr /><p>证明：假设满足是模 <span class="math inline">\(p\)</span> 二次非剩余的素数有限，为 <span class="math inline">\(p_1,p_2,\cdots p_s\)</span>，有 <span class="math inline">\((\dfrac{p_i}{p})=-1\)</span>，取模 <span class="math inline">\(p\)</span> 的</p><p>一个二次非剩余 <span class="math inline">\(a\)</span>，由中国剩余定理，满足 <span class="math inline">\(x\equiv a\pmod{p},x\equiv 1\pmod{p_i}\)</span> 同余方程的解</p><p>存在，设其中一个解为 <span class="math inline">\(x\)</span></p><p>则 <span class="math inline">\((\dfrac{x}{p})=(\dfrac{a}{p})=-1\)</span>，<span class="math inline">\(x\)</span> 必有素因子为二次非剩余，且使得该素因子与 <span class="math inline">\(p_i\)</span> 均互素，这样与</p><p>有限个满足条件的素数矛盾，从而有无穷多个素数模 <span class="math inline">\(p\)</span> 二次剩余</p><h2 id="习题4.1.5">习题4.1.5</h2><p>设 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q=2 p+1\)</span> 都是素数. 证明:</p><p><span class="math inline">\((1)\)</span> 当 <span class="math inline">\(p \equiv 1(\bmod 4)\)</span> 时, <span class="math inline">\(2\)</span> 是模 <span class="math inline">\(q\)</span> 的原根;</p><p><span class="math inline">\((2)\)</span> 当 <span class="math inline">\(p \equiv 3(\bmod 4)\)</span> 时,<span class="math inline">\(-2\)</span> 是模 <span class="math inline">\(q\)</span> 的原根.</p><hr /><p>解：<span class="math inline">\((1)\)</span> 由于 <span class="math inline">\(q-1=2p\)</span> 只有素因子 <span class="math inline">\(2\)</span> 和 <span class="math inline">\(p\)</span> ，有 <span class="math inline">\(2^2\equiv 4\not\equiv 1\pmod{q}\)</span> 而对<span class="math inline">\(2^{p}\equiv 2^{\frac{q-1}{2}}\)</span>，计算</p><p><span class="math inline">\((\dfrac{2}{q})=(-1)^{\frac{q^2-1}{8}}=(-1)^{\frac{p(p+1)}{2}}=-1\)</span>，则 <span class="math inline">\(2\)</span> 为模 <span class="math inline">\(q\)</span> 的二次非剩余，则取 <span class="math inline">\(q\)</span> 的原根 <span class="math inline">\(g\)</span>，有 <span class="math inline">\(2=g^{2j+1}\)</span>，代入计算 <span class="math inline">\(2^{p}=g^{(2j+1)p}=(g^{p})^{2j+1}=(g^{\frac{q-1}{2}})^{2j+1}=(-1)^{2j+1}=-1\)</span>，从而 <span class="math inline">\(2,p\)</span> 均不是模 <span class="math inline">\(p\)</span></p><p>下 <span class="math inline">\(2\)</span> 的阶数，从而 <span class="math inline">\(2\)</span> 为模 $p $ 的原根</p><p><span class="math inline">\((2)\)</span> 同上，只需考虑 <span class="math inline">\((-2)^{p}\)</span>，<span class="math inline">\(p\neq 2\)</span>，计算 <span class="math inline">\((\dfrac{-2}{q})=(\dfrac{-1}{q})(\dfrac{2}{q})=(-1)^{\frac{q-1}{2}}(-1)^{\frac{q^2-1}{8}}=-1\)</span>，</p><p>则取 <span class="math inline">\(q\)</span> 的原根 <span class="math inline">\(g\)</span>，有 <span class="math inline">\(-2=g^{2j+1}\)</span>，代入 <span class="math inline">\((-2)^{p}=(g^{\frac{q-1}{2}})^{2j}=(-1)^{2j+1}=-1\)</span></p><p>从而 <span class="math inline">\(2,p\)</span> 均不是模 <span class="math inline">\(p\)</span> 下 <span class="math inline">\(-2\)</span> 的阶数，从而 <span class="math inline">\(-2\)</span> 为模 $p $ 的原根</p><h2 id="习题4.1.6">习题4.1.6</h2><p>设 <span class="math inline">\(p\)</span> 为素数, <span class="math inline">\(p \equiv 3(\bmod 4)\)</span>. 记 <span class="math inline">\(q=2 p+1\)</span>. 则 <span class="math inline">\(q\)</span> 为素数当且仅当 <span class="math inline">\(q \mid 2^{p}-1\)</span>.</p><hr /><p>证明：由上题知，若 <span class="math inline">\(q\)</span> 为素数，<span class="math inline">\(-2\)</span> 为 <span class="math inline">\(q\)</span> 的原根 <span class="math display">\[2^{p}\equiv -(-2)^{p}\equiv -(-2)^{\frac{q-1}{2}}\equiv -(-1)\equiv 1\pmod{p}\]</span> 则 <span class="math inline">\(q\mid 2^{p}-1\)</span> 。又若 <span class="math inline">\(q\mid 2^{p}-1\)</span> ，由欧拉定理 <span class="math inline">\(2^{\varphi(q)}\equiv 1\pmod{q}\)</span>，即 <span class="math inline">\(q\mid 2^{\varphi(q)}-1\)</span></p><p>则 <span class="math inline">\(p\mid \varphi(q)=\varphi(2p+1)\)</span>，若 <span class="math inline">\(q\)</span> 不是素数，<span class="math inline">\(\varphi(2p+1)&lt;2p\)</span>，则 <span class="math inline">\(p=\varphi(2p+1)\)</span>，而对于奇数</p><p>的欧拉函数为偶数，从而矛盾，则 <span class="math inline">\(q\)</span> 为素数</p><h2 id="习题4.1.7">习题4.1.7</h2><p>设 <span class="math inline">\(p\)</span> 为奇素数. 证明： <span class="math display">\[\large \prod_{\substack{r=1 \\ \\ \\  \large (\frac{r}{p})=1}}^{p-1} \normalsize r \equiv-\left(\frac{-1}{p}\right)(\bmod p)\]</span></p><hr /><p>解：满足 <span class="math inline">\((\dfrac{r}{p})=1\)</span> 的所有 <span class="math inline">\(r\)</span> 为 <span class="math inline">\(g^0,g^2,\cdots ,g^{p-3}\)</span>。其中 <span class="math inline">\(g\)</span> 为 <span class="math inline">\(p\)</span> 的一个原根，则 <span class="math display">\[\displaystyle \prod r =g^{0+2+\cdots p-3}=g^{\frac{(p-3)(p-1)}{4}}=(g^{\frac{p-1}{2}})^{\frac{p-3}{2}}=(-1)^{\frac{p-3}{2}}\]</span> 而 <span class="math inline">\(-(\dfrac{-1}{p})=-(-1)^{\frac{p-1}{2}}=(-1)^{\frac{p-3}{2}}\)</span>，两者相等</p><h2 id="习题4.1.8">习题4.1.8</h2><p>设 <span class="math inline">\(p\)</span> 为素数,</p><p><span class="math inline">\((1)\)</span> 若 <span class="math inline">\(p \equiv 1(\bmod 4)\)</span>, 则 <span class="math display">\[\sum_{\substack{r=1 \\\left(\frac{r}{p}\right)=1}}^{p-1} r=\frac{p(p-1)}{4}, \quad \sum_{a=1}^{p-1} a\left(\frac{a}{p}\right)=0\]</span> (2) 若 <span class="math inline">\(p \equiv 3(\bmod 4)\)</span>, 并且 <span class="math inline">\(p \geqslant 7\)</span>, 则 <span class="math display">\[\sum_{\substack{r=1 \\\left(\frac{r}{p}\right)=1}}^{p-1} r \equiv 0(\bmod p), \sum_{r=1}^{p-1} a\left(\frac{a}{p}\right) \equiv 0(\bmod p) .\]</span></p><hr /><p>证明：<span class="math inline">\((1)\)</span> 由 <span class="math inline">\((\dfrac{p-x}{p})=(\dfrac{-x}{p})=(\dfrac{x}{p})(\dfrac{-1}{p})=(\dfrac{x}{p})(-1)^{\frac{p-1}{2}}=(\dfrac{x}{p})\)</span></p><p>从而 <span class="math inline">\((i,p-i)\)</span> 每对勒让德符号相同，从而所有满足 <span class="math inline">\((\dfrac{r}{p})=1\)</span> 的 <span class="math inline">\(r\)</span> 一定能配成和为 <span class="math inline">\(p\)</span> 的 <span class="math inline">\(\mbox{pairs}\)</span></p><p>且共有 <span class="math inline">\(\dfrac{p-1}{4}\)</span> 对，求和为 <span class="math inline">\(\dfrac{p(p-1)}{4}\)</span>，同理分离得到 <span class="math inline">\(\displaystyle \sum_{a=1}^{p-1}a(\dfrac{a}{p})=0+\sum_{\substack{r=1 \\\left(\frac{r}{p}\right)=1}}^{p-1} r-\sum_{\substack{r=1 \\\left(\frac{r}{p}\right)\neq 1}}^{p-1} r=0\)</span></p><p><span class="math inline">\((2)\)</span> 和上题类似，得到 <span class="math inline">\((\dfrac{p-x}{p})=-(\dfrac{x}{p})\)</span>，从而 <span class="math inline">\((i,p-i)\)</span> 勒让德符号相反，有记 <span class="math display">\[\sum_{\substack{r=1 \\\left(\frac{r}{p}\right)=1}}^{p-1} r \equiv A(\bmod p),\sum_{\substack{r=1 \\\left(\frac{r}{p}\right)\neq 1}}^{p-1} r \equiv B(\bmod p)\]</span> 取模 <span class="math inline">\(p\)</span> 的一个原根 <span class="math inline">\(g\)</span> ，则 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(p\)</span> 的一个二次非剩，<span class="math inline">\((\dfrac{g}{p})=-1\)</span> <span class="math display">\[\begin{aligned}&amp;\sum_{r=1,\left(\frac{r}{p}\right)=1}^{p-1} r \equiv 1+g^{2}+\cdots+g^{p-3} \equiv \frac{1-g^{\frac{p-1}{2}\cdot 2}}{1-g^{2}} \equiv 0 \quad(\bmod p) \\&amp;\sum_{a=1}^{p-1} a\left(\frac{a}{p}\right) \equiv \sum_{i=0}^{p-2} g^{i}\left(\frac{g^{i}}{p}\right) \equiv \sum_{i=0}^{p-2} g^{i}(-1)^{i} \equiv \sum_{i=0}^{p-1}(-g)^{i} \equiv \frac{1-g^{p-1}}{1+g} \equiv 0 \quad(\bmod p) .\end{aligned}\]</span></p><h2 id="习题4.2.1">习题4.2.1</h2><p>计算 <span class="math inline">\(\left(\dfrac{17}{23}\right),\left(\dfrac{19}{37}\right),\left(\dfrac{92}{101}\right)\)</span>.</p><hr /><p>由二次互反律计算有 <span class="math display">\[\left(\dfrac{17}{23}\right)=\left(\dfrac{23}{17}\right)(-1)^{11 \cdot 8}=\left(\dfrac{23}{17}\right)=\left(\dfrac{6}{17}\right)=\left(\dfrac{2}{17}\right)\left(\dfrac{3}{17}\right)\\=(-1)^{\frac{17^{2}-1}{8}}\left(\dfrac{17}{3}\right)(-1)^{8}=\left(\dfrac{17}{3}\right)=\left(\dfrac{2}{3}\right)=-1\\\left(\dfrac{19}{37}\right)=\left(\dfrac{37}{19}\right)(-1)^{9 \cdot 18}=\left(\dfrac{37}{19}\right)=\left(\dfrac{-1}{19}\right)=(-1)^{9}=-1\\\left(\dfrac{92}{101}\right)=\left(\dfrac{2}{101}\right)^{2}\left(\dfrac{23}{101}\right)=(-1)^{\dfrac{101^{2}-1}{8}}\left(\dfrac{23}{101}\right)=\\\left(\dfrac{23}{101}\right)=\left(\dfrac{101}{23}\right)(-1)^{50 \cdot 11}=\left(\dfrac{101}{23}\right)=\left(\dfrac{9}{23}\right)=\left(\dfrac{3}{23}\right)^{2}=1\]</span></p><h2 id="习题4.2.4">习题4.2.4</h2><p>若 <span class="math inline">\(p=10 m-1\)</span> 为素数, 证明: <span class="math inline">\(p \mid 5^{5 m-1}-1\)</span>.</p><hr /><p>证明：计算 <span class="math inline">\((\dfrac{5}{p})=(\dfrac{p}{5})(-1)^{2\cdot \frac{p-1}{2}}=(\dfrac{p}{5})=(\dfrac{-1}{5})=(-1)^2=1\)</span>，则 <span class="math inline">\(5\)</span> 是 <span class="math inline">\(p\)</span> 的二次剩余</p><p>令 <span class="math inline">\(g\)</span> 为 <span class="math inline">\(p\)</span> 的二次剩余，<span class="math inline">\(5\equiv g^{2j}\)</span>，有 <span class="math inline">\(5^{5m-1}\equiv (g^{2j})^{\frac{p-1}{2}}\equiv (g^{p-1})^{j}\equiv 1\pmod{p}\)</span></p><h2 id="习题4.2.5">习题4.2.5</h2><p>设 <span class="math inline">\(n \geqslant 2, p=2^{n}+1\)</span> 为素数. 证明：</p><p><span class="math inline">\((1)\)</span> 对每个 <span class="math inline">\(a \in \mathbf{Z}, a\)</span> 为模 <span class="math inline">\(p\)</span> 的原根当且仅当 <span class="math inline">\(\left(\dfrac{a}{p}\right)=-1\)</span>;</p><p><span class="math inline">\((2)\)</span> 证明 <span class="math inline">\(3\)</span> 和 <span class="math inline">\(7\)</span> 均为模 <span class="math inline">\(p\)</span> 的原根.</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 若 <span class="math inline">\(a\)</span> 为模 <span class="math inline">\(p\)</span> 的原根，有 <span class="math inline">\((\dfrac{a}{p})=-1\)</span>；若 <span class="math inline">\((\dfrac{a}{p})=-1\)</span>，若 <span class="math inline">\(a\)</span> 不是模 <span class="math inline">\(p\)</span> 的原根，则对</p><p><span class="math inline">\(p-1=2^n\)</span> 的因子为对应的阶，总有 <span class="math inline">\(a^{2}\equiv 1\pmod{p}\)</span>，这与 <span class="math inline">\((\dfrac{a}{p})=-1\)</span> 矛盾，从而 <span class="math inline">\(a\)</span> 是模 <span class="math inline">\(p\)</span> 的原根</p><p><span class="math inline">\((2)\)</span> 由于 <span class="math inline">\(p=2^{n}+1\)</span> 为素数，故 <span class="math inline">\(n=2^{k}\)</span> ，其中 <span class="math inline">\(k \geq 1\)</span>.</p><p>由 <span class="math inline">\((\dfrac{3}{p})=(\dfrac{p}{3})(-1)^{1\cdot \frac{p-1}{2}}=(\dfrac{p}{3})\)</span> ，而 <span class="math inline">\(2^{2^n}+1\equiv (-1)^{2^n}+1\equiv 2\pmod{3}\)</span></p><p>有 <span class="math inline">\((\dfrac{2}{3})=-1\)</span>，则 <span class="math inline">\((\dfrac{3}{p})=-1\)</span>，从而 <span class="math inline">\(3\)</span> 为模 <span class="math inline">\(p\)</span> 的原根；同理 <span class="math inline">\((\dfrac{7}{p})=(\dfrac{p}{7})\)</span></p><p>若 <span class="math inline">\(2^{k} \equiv 1(\bmod 3)\)</span> ，则 <span class="math inline">\(\left(\dfrac{2^{2^{k}}+1}{7}\right)=\left(\dfrac{\left(2^{3}\right)^{t} \cdot 2+1}{7}\right)=\left(\dfrac{3}{7}\right)=-\left(\dfrac{7}{3}\right)=-1\)</span>.</p><p>若 <span class="math inline">\(2^{k} \equiv-1(\bmod 3)\)</span> ，则 <span class="math inline">\(\left(\dfrac{2^{2^{k}}+1}{7}\right)=\left(\dfrac{\left(2^{3}\right)^{t} \cdot 2^{2}+1}{7}\right)=\left(\dfrac{5}{7}\right)=\left(\dfrac{7}{5}\right)=\left(\dfrac{2}{5}\right)=(-1)^{\frac{5^{2}-1}{8}}=-1\)</span>.</p><p>因此 <span class="math inline">\(\left(\dfrac{7}{p}\right)=-1\)</span> ，故 <span class="math inline">\(7\)</span> 是模 <span class="math inline">\(p\)</span> 的原根.</p><h1 id="largetextcolorblue初等数论第八次作业-_textcolorblue2022.4.23"><span class="math inline">\(\large\textcolor{blue}{初等数论第八次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.4.23}\)</span></h1><h2 id="习题4.2.2">习题4.2.2</h2><p>确定以 <span class="math inline">\(a\)</span> 为二次剩余的素数, 其中 <span class="math inline">\(a=-3,5\)</span> 和 <span class="math inline">\(15\)</span> .</p><hr /><p><span class="math inline">\(a=-3\)</span> 时，<span class="math inline">\(2\)</span> 满足题意，此外， <span class="math inline">\(\dfrac{1}{2} \varphi(3)=1\)</span>. 且 <span class="math inline">\(7\)</span> 满足题意，则解为奇素数 <span class="math inline">\(p=3 k+1\)</span> 和 <span class="math inline">\(2\)</span></p><p><span class="math inline">\(a=5\equiv 1\pmod{4}\)</span>，<span class="math inline">\(2\)</span> 满足题意. 此外， <span class="math inline">\(\dfrac{1}{2} \varphi(5)=2\)</span> ，且 <span class="math inline">\(11,19\)</span> 均满足题意. 故 <span class="math inline">\(2\)</span> 和奇素数 <span class="math inline">\(5 k \pm 1\)</span> 满足题意.</p><p><span class="math inline">\(a=15\)</span> 时， <span class="math inline">\(2\)</span> 满足题意. <span class="math inline">\(\dfrac{1}{2} \varphi(60)=8\)</span> ，且经过验证， <span class="math inline">\(7,11,17,43,53,59,109,181\)</span> 都满足.</p><p>解为 <span class="math inline">\(2\)</span> 和素数 <span class="math inline">\(60 k+1,60 k+7,60 k+11,60 k+17,60 k+43,60 k+49,60 k+53,60 k+59\)</span></p><h2 id="习题4.2.3">习题4.2.3</h2><p>设 <span class="math inline">\(p=4 k+1\)</span> 是素数, <span class="math inline">\(a\)</span> 是 <span class="math inline">\(k\)</span> 的因子, 证明: <span class="math inline">\(\left(\dfrac{a}{p}\right)=1\)</span>.</p><hr /><p>证明：由二次互反律 <span class="math inline">\((\dfrac{a}{p})=(\dfrac{p}{a})(-1)^{\frac{p-1}{2}\frac{a-1}{2}}=(\dfrac{p}{a})=(\dfrac{4k+1}{a})=(\dfrac{4ax+1}{a})=(\dfrac{1}{a})=1\)</span></p><h2 id="习题4.2.6">习题4.2.6</h2><p><span class="math inline">\((1)\)</span> 设 <span class="math inline">\(n=2^{m} a+1\)</span>, 其中 <span class="math inline">\(m \geqslant 2,1 \leqslant a&lt;2^{m}\)</span>. 如果 <span class="math inline">\(p\)</span> 为奇素数, 并且 <span class="math inline">\(\left(\dfrac{n}{p}\right)=-1\)</span>, 证明: <span class="math inline">\(n\)</span> 是素数当且仅当 <span class="math inline">\(p^{\frac{n-1}{2}} \equiv-1(\bmod n)\)</span>.</p><p><span class="math inline">\((2)\)</span> 设 <span class="math inline">\(n=2^{m}+1, m \geqslant 2\)</span>. 证明: <span class="math inline">\(n\)</span> 为素数当且仅当 <span class="math inline">\(3^{\frac{n-1}{2}} \equiv-1\)</span> <span class="math inline">\((\bmod n)\)</span>.</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 若 <span class="math inline">\(n\)</span> 为素数，由于 <span class="math inline">\(n=2^ma+1\)</span> 故 <span class="math inline">\(\left(\dfrac{n}{p}\right)=\left(\dfrac{p}{n}\right)=-1\)</span> ，故 <span class="math inline">\(p^{\frac{n-1}{2}} \equiv-1(\bmod n)\)</span>.</p><p>另一方面，若 <span class="math inline">\(p^ \frac{n-1}{2} \equiv-1(\bmod n)\)</span> ，任取 <span class="math inline">\(n\)</span> 的一个素因子 <span class="math inline">\(q ， q \geq 3\)</span>. 令 <span class="math inline">\(d\)</span> 为 <span class="math inline">\(p\)</span> 模 <span class="math inline">\(q\)</span> 的阶，由于</p><p><span class="math inline">\(p^{\frac{n-1}{2}} \equiv-1(\bmod q)\)</span> ，故 <span class="math inline">\(p^{2^{m-1} a} \equiv-1(\bmod q)\)</span> ，因此 <span class="math inline">\(2^{m}\mid d\)</span> ，又 <span class="math inline">\(d \mid q-1\)</span> ，则 <span class="math inline">\(2^{m} \mid q-1\)</span></p><p><span class="math inline">\(q \geq 2^{m}+1\)</span>. 由于 <span class="math inline">\(n=2^{m} a+1 ， a&lt;2^{m}\)</span> ，所以 <span class="math inline">\(q^2&gt;n\)</span>，这样的 <span class="math inline">\(q\)</span> 只能为 <span class="math inline">\(n\)</span> 本身，则 <span class="math inline">\(n\)</span> 为素数</p><p><span class="math inline">\((2)\)</span> 在 <span class="math inline">\(\small(1)\)</span> 中取 <span class="math inline">\(a=1, p=3\)</span> 当 <span class="math inline">\(n\)</span> 为素数时，满足 <span class="math inline">\(m\)</span> 为奇数，否则 <span class="math inline">\(3\)</span> 为 <span class="math inline">\(n\)</span> 的素因子，此时</p><p><span class="math inline">\(\left(\dfrac{2^{m}+1}{3}\right)=\left(\dfrac{2}{3}\right)=-1\)</span> ，故满足 <span class="math inline">\(\small(1)\)</span> 的条件，则 <span class="math inline">\(3^{\frac{n-1}{2}} \equiv-1\)</span></p><p>若 <span class="math inline">\(3^{\frac{n-1}{2}} \equiv-1\)</span>，由 <span class="math inline">\(\small (1)\)</span> 中的推导中没有使用到 <span class="math inline">\(\left(\dfrac{n}{p}\right)=-1\)</span> 条件知 <span class="math inline">\(n\)</span> 为素数</p><h2 id="习题4.3.2">习题4.3.2</h2><p>设 <span class="math inline">\(f(x, y)\)</span> 是关于 <span class="math inline">\(x, y\)</span> 的整系数多项式. <span class="math inline">\((x, y)=(a, b)\)</span> 和 <span class="math inline">\((c, d)\)</span> 均是同余方程</p><p><span class="math inline">\(f(x, y) \equiv 0(\bmod m)\)</span> 的整数解, 即 <span class="math inline">\(f(a, b) \equiv 0\)</span> <span class="math inline">\((\bmod m), f(c, d) \equiv 0(\bmod m)\)</span>.</p><p>称这两组解为模 <span class="math inline">\(m\)</span> 的同一个解, 是指 <span class="math inline">\(a \equiv c(\bmod m)\)</span>, 并且 <span class="math inline">\(b \equiv d(\bmod m)\)</span>.</p><p><span class="math inline">\((1)\)</span> 设 <span class="math inline">\(p\)</span> 为奇素数, <span class="math inline">\(a\)</span> 为整数. 证明:同余方程 <span class="math display">\[x^{2}-y^{2} \equiv a \quad(\bmod p)\]</span> 的模 <span class="math inline">\(p\)</span> 解数为 <span class="math inline">\(p-1\)</span> （若 <span class="math inline">\(p\not\mid a\)</span>） 或 <span class="math inline">\(2 p-1\)</span> （若 <span class="math inline">\(p\mid a\)</span>）.</p><p><span class="math inline">\((2)\)</span> 证明： <span class="math display">\[\sum_{y=0}^{p-1}\left(\frac{y^{2}+a}{p}\right)= \begin{cases}-1, &amp; \text { 若 } p \nmid a, \\ p-1, &amp; \text { 若 } p \mid a .\end{cases}\]</span></p><hr /><p>证明：<span class="math inline">\((1)\)</span> 当 <span class="math inline">\(p \nmid a\)</span> 时， <span class="math inline">\((x+y)(x-y) \equiv a(\bmod p)\)</span>. 设 <span class="math inline">\(x+y \equiv b(\bmod p)\)</span> ，其中 <span class="math inline">\((b, p)=1\)</span>.</p><p>则 <span class="math inline">\(x-y \equiv a b^{-1}(\bmod p)\)</span>. 从而 <span class="math inline">\((x, y)=\left(\dfrac{b+a b^{-1}}{2}, \dfrac{b-a b^{-1}}{2}\right)\)</span>. 因此解数为 <span class="math inline">\(b\)</span> 的个数 <span class="math inline">\(p-1\)</span>.</p><p>当 <span class="math inline">\(p \mid a\)</span> 时， <span class="math inline">\(p \mid(x+y)(x-y)\)</span> ，所以 <span class="math inline">\(x \equiv y(\bmod p)\)</span> 或 <span class="math inline">\(x \equiv-y(\bmod p)\)</span>.</p><p>共有 <span class="math inline">\((0,0),(b,-b),(-b, b)\)</span> 即 <span class="math inline">\(2\cdotp(p-1)+1=2p-1\)</span> 组解.</p><p><span class="math inline">\((2)\)</span> 设 <span class="math inline">\(x^{2} \equiv y^{2}+a(\bmod p) .\left(\dfrac{y^{2}+a}{p}\right)=1\)</span> 时，有两组解， <span class="math inline">\(\left(\dfrac{y^{2}+a}{p}\right)=-1\)</span> 时，无解</p><p>计算其总解数为 <span class="math inline">\(\sum_{y=0}^{p-1}\left(1+\left(\frac{y^{2}+a}{p}\right)\right)=p+\sum_{y=0}^{p-1}\left(\frac{y^{2}+a}{p}\right)= \begin{cases}p-1, &amp; p \nmid a \\ 2 p-1, &amp; p \mid a\end{cases}\)</span> 因此 <span class="math inline">\(\sum_{y=0}^{p-1}\left(\frac{y^{2}+a}{p}\right)= \begin{cases}-1, &amp; p \nmid a \\ p-1, &amp; p \mid a\end{cases}\)</span></p><h2 id="习题4.3.3">习题4.3.3</h2><p>设 <span class="math inline">\(p\)</span> 为奇素数, <span class="math inline">\(a, b, c \in \mathbf{Z}, p \nmid a, D=b^{2}-4 a c\)</span>. 证明: <span class="math display">\[\sum_{x=0}^{p-1}\left(\frac{a x^{2}+b x+c}{p}\right)=\left\{\begin{array}{l}-\left(\dfrac{a}{p}\right), \quad \text { 若 } p \not\mid D, \\(p-1)\left(\dfrac{a}{p}\right), \text { 若 } p \mid D .\end{array}\right.\]</span></p><hr /><p>证明：令 <span class="math inline">\(y=x+\dfrac{b}{2a}=x+b\cdot 2^{-1}\cdot a^{-1},a^{\prime}=c-b^2\cdot 4^{-1}\cdot a^{-1}\)</span> 代入上题结论得到 <span class="math display">\[\sum_{y=\frac{b}{2a}}^{\frac{b}{2a}+p-1}(\dfrac{ay^2+a&#39;}{p})=\sum_{y=0}^{p-1}(\dfrac{ay^2+a&#39;}{p})=(\dfrac{a}{p})\sum_{y=0}^{p-1}(\dfrac{y^2+a&#39;a^{-1}}{p})=\left\{\begin{array}{l}-\left(\dfrac{a}{p}\right), \quad \text { 若 } p \not\mid D, \\(p-1)\left(\dfrac{a}{p}\right), \text { 若 } p \mid D .\end{array}\right.\]</span></p><h2 id="习题4.2.4-1">习题4.2.4</h2><p>设 <span class="math inline">\(a, b, c \in \mathbf{Z}, p \not\mid a b\)</span>, 则同余方程 <span class="math display">\[a x^{2}+b y^{2} \equiv c \quad(\bmod p)\]</span> 模 <span class="math inline">\(p\)</span> 的解数为 <span class="math display">\[N=\left\{\begin{array}{l}p+(p-1)\left(\dfrac{-a b}{p}\right), \quad \text { 若 } p \mid c, \\p-\left(\dfrac{-a b}{p}\right), \quad \text { 若 } p \not\mid  c .\end{array}\right.\]</span></p><hr /><p>证明：<span class="math inline">\(a x^{2}+b y^{2} \equiv c(\bmod p)\)</span> 等价于 <span class="math inline">\(x^{2} \equiv-a^{-1} b y^{2}+a^{-1} c(\bmod p) .\)</span> <span class="math inline">\((a,p)=(b,p)=1\)</span> 解数 <span class="math display">\[\sum_{y=0}^{p-1}\left(1+\left(\frac{-a^{-1} b y^{2}+a^{-1} c}{p}\right)\right)=p+\sum_{y=0}^{p-1}\left(\frac{-a^{-1} b}{p}\right)\left(\frac{y^{2}-c b^{-1}}{p}\right)\\=p+\left(\frac{-a b}{p}\right) \sum_{y=0}^{p-1}\left(\frac{y^{2}-c b^{-1}}{p}\right)= \begin{cases}p+(p-1)\left(\dfrac{-a b}{p}\right), &amp; p \mid c \\ p-\left(\dfrac{-a b}{p}\right), &amp; p \nmid c\end{cases}\]</span> 其中用到上题结论 <span class="math inline">\(\displaystyle \sum_{x=0}^{p-1}\left(\frac{a x^{2}+b x+c}{p}\right)=\left\{\begin{array}{l} -\left(\dfrac{a}{p}\right), \quad \text { 若 } p \not\mid D, \\ (p-1)\left(\dfrac{a}{p}\right), \text { 若 } p \mid D . \end{array}\right.\)</span></p><h1 id="largetextcolorblue初等数论第九次作业-_textcolorblue2022.4.30"><span class="math inline">\(\large\textcolor{blue}{初等数论第九次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.4.30}\)</span></h1><h2 id="习题4.3.1">习题4.3.1</h2><p>解下列同余方程:</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(2 x^{2}+3 x+1 \equiv 0 \quad(\bmod 28)\)</span>;</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(x^{2} \equiv-1 \quad(\bmod 169)\)</span>;</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(x^{2} \equiv 2 \quad(\bmod 98)\)</span>;</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(3 x^{2}+x+6 \equiv 0 \quad(\bmod 45)\)</span>.</p><hr /><p>解：<span class="math inline">\((1)\)</span> <span class="math inline">\(28 \mid(2 x+1)(x+1)\)</span>. 且有 <span class="math inline">\((2 x+1, x+1)=(1, x+1)=1\)</span> 两者互素，且 <span class="math inline">\(28=4\times 7\)</span> 则</p><p><span class="math inline">\(2 x+1 \equiv 0(\bmod 4), x+1 \equiv 0(\bmod 7)\)</span> 或者 $2 x+1 (), x+1 () $</p><p>又或者 <span class="math inline">\(x+1\equiv 0\pmod{28}\)</span> 解得 <span class="math inline">\(x \equiv 3,27(\bmod 28)\)</span>.</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(x^{2} \equiv-1(\bmod 13)\)</span> 解得 <span class="math inline">\(x=13 k+5,13 k+8\)</span>. 代入 <span class="math inline">\((13 k+5)^{2} \equiv-1(\bmod 169)\)</span> 可以化简得</p><p><span class="math inline">\(10 k+2 \equiv 0(\bmod 13)\)</span>. 解得 <span class="math inline">\(k \equiv 5(\bmod 13)\)</span>. <span class="math inline">\((13 k+8)^{2} \equiv-1(\bmod 169)\)</span> 化简得: <span class="math inline">\(3 k \equiv-5(\bmod 13)\)</span></p><p>解得 <span class="math inline">\(k \equiv 7(\bmod 13)\)</span>. 从而 <span class="math inline">\(x \equiv 70,99(\bmod 169)\)</span>.</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(x^{2} \equiv 2(\bmod 98)\)</span> <span class="math inline">\(x\)</span> 为偶数. 设 <span class="math inline">\(x=2 k\)</span> ，则 <span class="math inline">\(2 k^{2} \equiv 1(\bmod 49)\)</span>. 即 <span class="math inline">\(k^{2} \equiv 25(\bmod 49)\)</span>. 考虑</p><p><span class="math inline">\(k^{2} \equiv 25(\bmod 7)\)</span> ，解得 <span class="math inline">\(k=7 m+2,7 m+5 .\)</span> 分别代入 <span class="math inline">\(k^{2} \equiv 25(\bmod 49)\)</span> 解得</p><p><span class="math inline">\(k \equiv 44,5(\bmod 49)\)</span>. 因此 <span class="math inline">\(x \equiv 10,88(\bmod 98) .\)</span></p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(3 x^{2}+x+6 \equiv 0(\bmod 45)\)</span>. 两边模 <span class="math inline">\(3\)</span> 有 <span class="math inline">\(x \equiv 0(\bmod 3)\)</span>. 令 <span class="math inline">\(x=3 y\)</span>. 代入 <span class="math inline">\(9 y^{2}+y+2 \equiv 0(\bmod 15) .\)</span></p><p>模 <span class="math inline">\(3\)</span> 知， <span class="math inline">\(y \equiv 1(\bmod 3)\)</span>. 设 <span class="math inline">\(y=3 z+1\)</span> ，代入可知 <span class="math inline">\(2 z^{2}-z-1 \equiv 0(\bmod 5)\)</span>. <span class="math inline">\((2 z+1)(z-1) \equiv 0(\bmod 5)\)</span>.</p><p>解得 <span class="math inline">\(z \equiv 1,2(\bmod 5)\)</span>. 从而 <span class="math inline">\(x \equiv 12,21(\bmod 45)\)</span>.</p><h2 id="习题5.1.1">习题5.1.1</h2><p>求下列方程的全部整数解：</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(2 x^{2}-5 y^{2}=7\)</span>; <span class="math inline">\((2)\)</span> <span class="math inline">\(x^{2}-2 x y^{2}+5 z^{3}+3=0\)</span>;</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(y^{2}=41 x^{3}+3\)</span>; <span class="math inline">\((4)\)</span> <span class="math inline">\(x^{2}-x y+y^{2}-x-y=0\)</span>;</p><p><span class="math inline">\((5)\)</span> <span class="math inline">\(y^{2}=x^{3}-6\)</span> <span class="math inline">\(\tiny\ \)</span> <span class="math inline">\((6)\)</span> <span class="math inline">\(y^{2}=x^{3}-x\)</span>.</p><hr /><p>解：<span class="math inline">\((1)\)</span> <span class="math inline">\(x^{2} \equiv 0,1,2,4(\bmod 7) .\)</span> 对原方程两边模 <span class="math inline">\(7\)</span> 知: <span class="math inline">\(x^{2}+y^{2} \equiv 0(\bmod 7)\)</span>. 因此 <span class="math inline">\(x \equiv y \equiv 0(\bmod 7)\)</span>.</p><p>两边模 <span class="math inline">\(49\)</span> 有 <span class="math inline">\(0\equiv 7\pmod{49}\)</span> 矛盾，从而无解</p><p><span class="math inline">\((2)\)</span> 方程两边模 <span class="math inline">\(5\)</span> 知 <span class="math inline">\(x^{2}-2 x y^{2}+3 \equiv 0(\bmod 5)\)</span> ，故 <span class="math inline">\(\left(x-y^{2}\right)^{2} \equiv y^{4}-3(\bmod 5)\)</span>. 注意到</p><p><span class="math inline">\(x^{2} \equiv 0,1,-1(\bmod 5),x^{4} \equiv 0,1(\bmod 5)\)</span> ，则 <span class="math inline">\(y^4\equiv 2,3,4\pmod{5}\)</span> 矛盾，从而无解</p><p><span class="math inline">\((3)\)</span> 两边模 <span class="math inline">\(41\)</span> 可知: <span class="math inline">\(y^{2} \equiv 3(\bmod 41)\)</span>. 而 <span class="math inline">\(\left(\dfrac{3}{41}\right)=\left(\dfrac{41}{3}\right)=\left(\dfrac{-1}{3}\right)=-1\)</span> ，故没有整数解.</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(x^{2}-x y+y^{2}-x-y=0\)</span> 主元后 <span class="math inline">\(x^2-(y+1)x+y^2-y=0\)</span> 其判别式</p><p><span class="math inline">\(\Delta=\sqrt{(y+1)^2-4(y^2-y)}=\sqrt{-3y^2+6y+1}\)</span> 为整数，则 <span class="math inline">\(-3y^2+6y+1=t^2\)</span></p><p><span class="math inline">\(3y^2-6y+(t^2-1)=0\)</span> 其判别式 <span class="math inline">\(\Delta =\sqrt{6^2-4\cdot 3\cdot (t^2-1)}=2\sqrt{3(4-t^2)}\)</span> 也为完全平方数</p><p>从而 <span class="math inline">\(3(4-t^2)\)</span> 为完全平方数，可以得到 <span class="math inline">\(t^2=1,4\)</span> 解得 <span class="math inline">\(y=0,1,2\)</span> 回代解得</p><p><span class="math inline">\((x,y)=(0,0),(0,1),(1,0),(1,2),(2,1),(2,2)\)</span></p><p><span class="math inline">\((5)\)</span> 方程两边模 <span class="math inline">\(8\)</span>. 注意到 <span class="math inline">\(y^{2} \equiv 0,1,4(\bmod 8) ， x^{3} \equiv 0, \pm 1, \pm 3(\bmod 8)\)</span> ，对比有 <span class="math inline">\(x \equiv 7(\bmod 8)\)</span>.</p><p><span class="math inline">\(y^{2}-2=x^{3}-8=(x-2)\left(x^{2}+2 x+4\right)=(x-2)\left((x+1)^{2}+3\right)\)</span>. 其中 <span class="math inline">\((x+1)^{2}+3 \equiv 3(\bmod 8) .\)</span></p><p>任取它的一个素因子 <span class="math inline">\(p ， p\)</span> 为奇数. <span class="math inline">\(y^{2} \equiv 2(\bmod p)\)</span>. 因此 <span class="math inline">\(1=\left(\dfrac{2}{p}\right)\)</span> ，则 <span class="math inline">\(p \equiv \pm 1(\bmod 8)\)</span>.</p><p>这与 <span class="math inline">\((x+1)^{2}+3 \equiv 3(\bmod 8)\)</span> 矛盾，所以原方程没有整数解.</p><p><span class="math inline">\((6)\)</span> <span class="math inline">\(y^{2}=x(x-1)(x+1)\)</span> ，当 <span class="math inline">\(x=0, \pm 1\)</span> 时， <span class="math inline">\(y=0\)</span>. <span class="math inline">\(|x| \geq 2\)</span> 时，若 <span class="math inline">\(x\)</span> 是偶数，<span class="math inline">\(x, x+1, x-1\)</span> 两两互素.</p><p>因此存在整数 <span class="math inline">\(a, b\)</span> 使得 <span class="math inline">\(x=a^{2}, x+1=b^{2}\)</span> ，即 <span class="math inline">\(b^{2}-a^{2}=1\)</span> ，其中 <span class="math inline">\(b&gt;a&gt;1\)</span>. 显然这是无解的.</p><p>若 <span class="math inline">\(x\)</span> 是奇数，则 <span class="math inline">\(\left(\dfrac{y}{2}\right)^{2}=x \cdot \dfrac{x+1}{2} \cdot \dfrac{x-1}{2}\)</span>. 其中 <span class="math inline">\(x, \dfrac{x-1}{2}, \dfrac{x+1}{2}\)</span> 两两互素，同理，存在整数 <span class="math inline">\(a,b\)</span> 使得</p><p><span class="math inline">\(a^2=\dfrac{x+1}{2},b^2=\dfrac{x-1}{2},a^2-b^2=1\)</span> 故原方程的解为 <span class="math inline">\((0,0),(1,0),(-1,0)\)</span>.</p><h1 id="largetextcolorblue初等数论第十次作业-_textcolorblue2022.5.8"><span class="math inline">\(\large\textcolor{blue}{初等数论第十次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.5.8}\)</span></h1><h2 id="习题5.2.1">习题5.2.1</h2><p>求所有正整数 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span>,使 <span class="math inline">\(2^{m}+3^{n}\)</span> 是完全平方.</p><hr /><p>解：由题设 <span class="math inline">\(2^m+3^n=x^2\)</span> 有 <span class="math inline">\(2,3\not\mid x\)</span> 方程两边模 <span class="math inline">\(3\)</span> 有 <span class="math inline">\((-1)^{m}\equiv x^2\equiv 1\pmod{3}\)</span> 则 <span class="math inline">\(m\equiv 0\pmod{2}\)</span></p><p><span class="math inline">\(m\geq 2,2^{m}\geq 4,2^m\equiv 0\pmod{4}\)</span>，方程两边模 <span class="math inline">\(4\)</span> 有 <span class="math inline">\(0+(-1)^{n}\equiv x^2\pmod{4}\)</span> 而 <span class="math inline">\(x^2\equiv 0,1\pmod{4}\)</span></p><p>则 <span class="math inline">\(n\equiv 0\pmod{2}\)</span>。令 <span class="math inline">\(m=2k,n=2t\)</span>，原方程化为费马方程 <span class="math inline">\((2^k)^2+(3^t)^2=x^2\)</span> 本原解满足 <span class="math display">\[2^k=2mn,3^t=m^2-n^2\]</span> 且 <span class="math inline">\(m,n\)</span> 一奇一偶，而 <span class="math inline">\(2^{k-1}=mn\)</span> 则 <span class="math inline">\(n=1,m=2^{k-1}\)</span> 代入有 <span class="math display">\[3^t=2^{2(k-1)}-1\Longrightarrow 3^t=(2^{k-1}+1)(2^{k-1}-1)\]</span> 而 <span class="math inline">\((2^{k-1}-1,2^{k-1}+1)=1\)</span>，则 <span class="math inline">\(2^{k-1}-1=1,k=2,t=1\)</span> 则仅有唯一解 <span class="math inline">\(m=4,n=2,2^4+3^2=5^2\)</span></p><h2 id="习题5.2.2">习题5.2.2</h2><p>求不定方程 <span class="math inline">\(3^{x}+4^{y}=5^{z}\)</span> 的所有正整数解.</p><hr /><p>解：方程模 <span class="math inline">\(3\)</span> 有 <span class="math inline">\(1\equiv 2^z\equiv (-1)^z\pmod{3}\)</span> 得到 <span class="math inline">\(z\equiv0\pmod{2}\)</span>。方程模 <span class="math inline">\(4\)</span> 有 <span class="math inline">\((-1)^x\equiv 1\pmod{5}\)</span></p><p>则 <span class="math inline">\(x\equiv 0\pmod{2}\)</span>，令 <span class="math inline">\(x=2r,z=2k\)</span>，原方程化为费马方程 <span class="math inline">\((3^r)^2+(2^y)^2=(5^k)^2\)</span> 本原解满足 <span class="math display">\[2^y=2mn,3^r=m^2-n^2=(m-n)(m+n)\]</span> 由 <span class="math inline">\(2^{y-1}=mn\)</span> 知 <span class="math inline">\(m=2^s,n=2^t\)</span>。有 <span class="math inline">\((m+n)-(m-n)=2n=2^{t+1},3\not\mid 2^{t+1}\)</span> 则 <span class="math inline">\(m-n=1\)</span></p><p>有 <span class="math inline">\(2^s=2^t+1\)</span>，只有 <span class="math inline">\(t=0,s=1\)</span> 唯一解，回代得到唯一解 <span class="math inline">\((x,y,z)=(2,2,2)\)</span></p><h2 id="习题5.2.4">习题5.2.4</h2><p>证明: <span class="math inline">\(x^{4}+4 y^{4}=z^{2}\)</span> 没有正整数解.</p><hr /><p>证明：假设有解 <span class="math inline">\((x,y,z)\)</span> 若 <span class="math inline">\((x,y)&gt;1\)</span> 记素数 <span class="math inline">\(p\)</span> 为 <span class="math inline">\((x,y)\)</span> 的一个约数，有 <span class="math inline">\(p^4\mid x^4+4y^4=z^2\)</span> 得到 <span class="math inline">\(p^2\mid z\)</span> 从而</p><p><span class="math inline">\((\dfrac{x}{p},\dfrac{y}{p},\dfrac{z}{p^2})\)</span> 为原方程的整数解，则有限步操作后总能使得 <span class="math inline">\((x,y)=1=(x^2,y^2)\)</span> 若 <span class="math inline">\(2\mid x\)</span> 令 <span class="math inline">\(x=2t\)</span> 有 <span class="math inline">\(2\not\mid y\)</span></p><p>则 <span class="math inline">\(16t^4+4y^4=z^2\Longrightarrow y^4+4t^4=(\dfrac{z}{2})^2\)</span> 与原方程相同，且 <span class="math inline">\(2\not\mid y\)</span> ，总可以化为 <span class="math inline">\(2\not\mid x\)</span>，有 <span class="math inline">\((x^2,2y^2)=1\)</span></p><p>则 <span class="math inline">\(x^2,2y^2,z\)</span> 为费马方程的本原解。令 <span class="math inline">\(z\)</span> 为解中最小的，由 <span class="math inline">\(2\mid 2y^2\)</span> 可知，<span class="math inline">\(m,n\)</span> 一奇一偶，<span class="math inline">\((m,n)=1,m&gt;n\)</span> <span class="math display">\[x^2=m^2-n^2,2y^2=2mn,z^2=m^2+n^2\]</span> 有 <span class="math inline">\(m^2=x^2+n^2\)</span> 因为 <span class="math inline">\((m,n)=1\)</span>，则 <span class="math inline">\((x,n)=1\)</span>，$(x,n,m) $ 也为费马方程的本原解，由 <span class="math inline">\(x\)</span> 为奇数 <span class="math display">\[x=c^2-d^2,n=2cd,m=c^2+d^2,y^2=mn=2cd(c^2+d^2)\]</span> 由 <span class="math inline">\(2 \mid mn=y^2,2\mid y\)</span>，则 <span class="math inline">\(\dfrac{cd(c^2+d^2)}{2}=(\dfrac{y}{2})^2\)</span> 为完全平方数，设 <span class="math inline">\(c,d\)</span> 中偶数、奇数为 <span class="math inline">\(s,t\)</span></p><p><span class="math inline">\(\dfrac{st(s^2+t^2)}{2}=(\dfrac{y}{2})^2\)</span> 也成立，令 <span class="math inline">\(s=2k\)</span> 有 <span class="math inline">\(kt(4k^2+t^2)=(\dfrac{y}{2})^2\)</span> 又 <span class="math inline">\((c,d)=1=(k,t)\)</span> 三者为完全平方数</p><p>则 <span class="math inline">\(k=a^2,t=b^2,4k^2+t^2=c^2\)</span> 消元有 <span class="math inline">\(b^4+4a^4=c^2\)</span> 而 <span class="math inline">\(c^2=m-d^2&lt;m=\sqrt{z^2-n^2}&lt;z&lt;z^2\)</span></p><p>与假设最小矛盾，从而原方程无解</p><h2 id="习题5.2.6">习题5.2.6</h2><p>证明: <span class="math inline">\(1\)</span> 不是同余数, 即不存在面积为 <span class="math inline">\(1 、\)</span> 三边长为有理数的直角三角形.</p><hr /><p>证明：原问题等价于满足 <span class="math inline">\(a^2+b^2=c^2,ab=2d^2\)</span> 的正整数解不存在，假设存在有若 <span class="math inline">\((a,b)=2\)</span>，则</p><p><span class="math inline">\(2\mid c,4\mid ab=2d^2,2\mid d\)</span>，从而 <span class="math inline">\((\dfrac{a}{2},\dfrac{b}{2},\dfrac{c}{2},\dfrac{d}{2})\)</span> 也为解，若 <span class="math inline">\((a,b)=p\geq 3\)</span> 则 <span class="math inline">\(p^2 \mid c^2,d^2\)</span> 同理</p><p><span class="math inline">\((\dfrac{a}{p},\dfrac{b}{p},\dfrac{c}{p},\dfrac{d}{p})\)</span> 也为解，在有限步之后，总能使得 <span class="math inline">\((a,b)=1\)</span>，满足费马方程，<span class="math inline">\(a,b\)</span> 一奇一偶，不妨设 <span class="math inline">\(a=2k\)</span></p><p>有 <span class="math inline">\(bk=d^2,(b,k)=1\)</span> 则 <span class="math inline">\(b=x^2,k=y^2\)</span> 代入 <span class="math inline">\(a^2+b^2=c^2\)</span> 有 <span class="math inline">\(4y^4+x^4=c^2\)</span>，由上题知该方程无解</p><h2 id="习题5.3.1">习题5.3.1</h2><p>证明: 形如 <span class="math inline">\(4^{a}(8 k+7)\)</span> 的正整数不能表为三个整数的平方和.</p><hr /><p>证明：由 <span class="math inline">\(x^2\equiv 0,1,4\pmod{8}\)</span> 计算 <span class="math inline">\(a^2+b^2+c^2\equiv 0,1,2,3,4,5,6\not\equiv 7\pmod{8}\)</span> 从而 <span class="math inline">\(8k+7\)</span> 的正整数</p><p>不能表示为三个整数平方和。对 <span class="math inline">\(4(8k+7)=a^2+b^2+c^2\)</span> 有 <span class="math inline">\(x^2\equiv 0,1\pmod{4}\)</span>，而三者之和模 <span class="math inline">\(0\)</span>，则</p><p><span class="math inline">\(a^2\equiv b^2\equiv c^2\pmod{4}\)</span>，有 <span class="math inline">\(a,b,c\equiv 0\pmod{2}\)</span>，则可以转化为 <span class="math inline">\(a&#39;^2+b&#39;^2+c&#39;^2=8k+7\)</span> 的情况</p><p>从而 <span class="math inline">\(4^a(8k+7)\)</span> 均与 <span class="math inline">\(8k+7\)</span> 等价，从而不能表示为三个整数的平方和</p><h2 id="习题5.3.2">习题5.3.2</h2><p><span class="math inline">\((1)\)</span> 确定哪些整数可表为两个整数的平方差.</p><p><span class="math inline">\((2)\)</span> 证明: 对任意整数 <span class="math inline">\(n\)</span>, 不定方程 <span class="math display">\[x^{2}+y^{2}-z^{2}=n\]</span> 均有无穷多组正整数解.</p><hr /><p>解：<span class="math inline">\((1)\)</span> <span class="math inline">\(z=x^2-y^2=(x+y)(x-y)\)</span>，而 <span class="math inline">\((x+y)-(x-y)=2y\)</span> 从而 <span class="math inline">\(z\equiv 0,1,3\pmod{4}\)</span></p><p>而只要 <span class="math inline">\(z\not\equiv 2\pmod{4}\)</span>，分三种情况 <span class="math inline">\(z=4k=2\cdot 2k,z=4k+1=1\cdot(4k+1),z=4k+3=1\cdot (4k+3)\)</span></p><p>三种情况都对应有 <span class="math inline">\(x,y\)</span> 解，从而当且仅当 <span class="math inline">\(z\not\equiv 2\pmod{4}\)</span> 时该整数可以表示为两个整数的平方差</p><p><span class="math inline">\((2)\)</span> 由 <span class="math inline">\(y^2-z^2=n-x^2\)</span> 且上问给出只要 <span class="math inline">\(n-x^2\not \equiv 2\pmod{4}\)</span>，就一定有解，而 <span class="math inline">\(x^2\equiv 0,1\pmod{4}\)</span></p><p>对 <span class="math inline">\(n\equiv 0,1,2,3\pmod{4}\)</span>，所有情况都有 <span class="math inline">\(x^2\equiv 0,0,1,0\pmod{4}\)</span> 使得 <span class="math inline">\(n-x^2\not \equiv 2\pmod{4}\)</span> 成立</p><p>而满足上述条件的 <span class="math inline">\(x\)</span> 有无穷多个，从而对应解 <span class="math inline">\((x,y,z)\)</span> 也有无穷多个</p><h2 id="习题5.3.3">习题5.3.3</h2><p>证明: 对任意给定的 <span class="math inline">\(n \geqslant 1\)</span>, 均存在连续 <span class="math inline">\(n\)</span> 个正整数, 其中每个都不是两个整数的平方和.</p><hr /><p>证明：取 <span class="math inline">\(4k+3\)</span> 型素数 <span class="math inline">\(n\)</span> 个，存在正整数 <span class="math inline">\(N\)</span> 使得 <span class="math display">\[N=-i+p_{i}\left(\bmod p_{i}^{2}\right) \quad(1 \leqslant i \leqslant n)\]</span> 从而 <span class="math inline">\(N+i(1\leq i\leq n)\)</span> 分解后 <span class="math inline">\(p_i\)</span> 的幂次为 <span class="math inline">\(1\)</span>，从而不能写成两个整数平方和，则 <span class="math inline">\(N+1,\cdots,N+n\)</span> 为所求</p><h1 id="largetextcolorblue初等数论第十一次作业-_textcolorblue2022.5.11"><span class="math inline">\(\large\textcolor{blue}{初等数论第十一次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.5.11}\)</span></h1><h2 id="section">1</h2><p>设 <span class="math inline">\(F\)</span> 是一个域, <span class="math inline">\(f(x), g(x) \in F[x]\)</span> 。</p><p><span class="math inline">\((1)\)</span> 证明存在多项式 <span class="math inline">\(q(x), r(x) \in F[x]\)</span> 使得 <span class="math inline">\(f(x)=g(x) q(x)+r(x)\)</span> 且 <span class="math inline">\(r(x)\)</span> 的次数严格小于 <span class="math inline">\(g(x)\)</span>;</p><p><span class="math inline">\((2)\)</span> 设 <span class="math inline">\(h(x)=(f(x), g(x))\)</span> 是首项系数为 1 的最大公因式, 则存在 <span class="math inline">\(p(x), q(x) \in F(x)\)</span> 使得 <span class="math display">\[f(x) p(x)+g(x) q(x)=h(x)\]</span> <span class="math inline">\((3)\)</span> 设 <span class="math inline">\(f(x) \in F_{p}[x]\)</span> 且 <span class="math inline">\(g(x)\)</span> 是模 <span class="math inline">\(f(x)\)</span> 的一个缩同余类。则存在 <span class="math inline">\(h(x)\)</span> 使得 <span class="math inline">\(g(x) h(x) \equiv 1\)</span> <span class="math inline">\((\bmod f(x))\)</span> 。</p><hr /><p>证明：<span class="math inline">\((1)\)</span> 设 <span class="math inline">\(f(x),g(x)\)</span> 最高幂次为 <span class="math inline">\(x^{n_1},x^{n_2}\)</span>，且系数分别为 <span class="math inline">\(a,b\)</span>，不妨设 <span class="math inline">\(n_1\geq n_2\)</span>，由非零元素存在乘法逆元</p><p>构造 <span class="math inline">\(h(x)=ab^{-1}x^{n_1-n_2}\)</span>，有 <span class="math inline">\(ax^{n_1}-bx^{n_2}\cdot ab^{-1}x^{n_1-n_2}=0\)</span>，则 <span class="math inline">\(f(x)-h(x)g(x)\)</span> 首项系数被消去。如此</p><p>新的最高幂次不超过 <span class="math inline">\(n_1-1\)</span>，执行上述操作 <span class="math inline">\(n_1-n_2+1\)</span> 之后，总能得到 <span class="math inline">\(h_{tot}(x)=\displaystyle \sum_{i=1}^{n_1-n_2+1}h_{i}(x)\)</span></p><p>使得 <span class="math inline">\(f(x)-g(x)h(x)\)</span> 的最高次数严格小于 <span class="math inline">\(g(x)\)</span></p><p><span class="math inline">\((2)\)</span> 由 <span class="math inline">\(\small(1)\)</span> 中可知，实际上给出了域上的多项式有带余除法，使用辗转相除法 <span class="math display">\[f(x)=g(x)q_1(x)+f_1(x),g(x)=f_1(x)q_2(x)+g_1(x),\cdots\]</span> 最终得到 <span class="math inline">\(f_N(x),g_{N-1}(x)=ah(x)\)</span>，从而 <span class="math inline">\(h(x)=a^{-1}f_{N}(x)\)</span>，一直回代，每次保证为线性组合</p><p>从而有限次数之后总能找到 <span class="math inline">\(f(x)q(x)+g(x)p(x)=h(x)\)</span></p><p><span class="math inline">\((3)\)</span> 由 <span class="math inline">\(\small(2)\)</span> 可以得到，当 <span class="math inline">\((f(x),g(x))=1\)</span> 时，存在 <span class="math inline">\(p(x),h(x)\)</span> 使得 <span class="math inline">\(f(x)p(x)+g(x)h(x)=1\)</span>，从而 <span class="math display">\[g(x)q(x)\equiv 1\pmod{f(x)}\]</span></p><h2 id="section-1">2</h2><p>证明 <span class="math inline">\(\left(x^{a}-1, x^{b}-1\right)=\left(x^{(a, b)}-1\right)\)</span> 。特别的, <span class="math inline">\(\left(x^{a^{m}-1}-1, x^{a^{n}-1}-1\right)=x^{a^{(m, n)}}-1\)</span> 。</p><hr /><p>证明：不妨设 <span class="math inline">\(a\geq b\)</span>，<span class="math inline">\((x^a-1,x^b-1)=(x^b-1,x^a-x^b)=(x^b-1,x^b(x^{a-b}-1))\)</span></p><p>而 <span class="math inline">\((x^b-1,x^b)=(1,x^b)=1\)</span>，则 <span class="math inline">\((x^a-1,x^b-1)=(x^{a-b}-1,x^b-1)\)</span> 相当于指数项可以相互加减</p><p>则类比辗转相除法，经过有限步辗转相除后 <span class="math inline">\((x^a-1,x^b-1)=(x^{(a,b)}-1,x^{\lambda(a,b)}-1)=x^{(a,b)}-1\)</span></p><h2 id="section-2">3</h2><p>设 <span class="math inline">\(f(x) \in F_{p}[x]\)</span> 。</p><p><span class="math inline">\((1)\)</span> 证明 <span class="math inline">\(f(x)^{p}=f\left(x^{p}\right)\)</span>;</p><p><span class="math inline">\((2)\)</span> 证明 <span class="math inline">\(f(x)\)</span> 的导函数为 <span class="math inline">\(0\)</span> 当且仅当存在 <span class="math inline">\(g(x) \in F_{p}[x]\)</span> 使得 <span class="math inline">\(f(x)=g\left(x^{p}\right)\)</span> 。</p><hr /><p><span class="math inline">\((1)\)</span> 由费马小定理 <span class="math inline">\(f(x)^p=\displaystyle (\sum_{i=0}^{n-1}a_ix^i)^{p}=\sum_{i=0}^{n-1}a_i^px^{ip}+pg(x)=\sum_{i=0}^{n-1}a_i^{p-1}a_i(x^{p})^i=\sum_{i=0}^{n-1}a_i(x^p)^{i}=f(x^p)\)</span></p><p><span class="math inline">\((2)\)</span> 由 <span class="math inline">\(f(x)=\displaystyle \sum_{i=0}^{n-1}a_ix^i,f&#39;(x)=\sum_{i=1}^{n-1}ia_ix^{i-1}=0\)</span> 从而存在数论倒数的 <span class="math inline">\(p\not\mid j\)</span>，<span class="math inline">\(ja_jx^{j-1}=0\Longrightarrow a_j=0\)</span></p><p>从而剩下 <span class="math inline">\(p\mid i\)</span>，使得 <span class="math inline">\(a_i\)</span> 不一定为 <span class="math inline">\(0\)</span>，则 <span class="math inline">\(f(x)=\displaystyle \sum_{p\mid i}a_ix^i=g(x^{p})\)</span></p><h2 id="section-3">4</h2><p>证明 <span class="math inline">\(F:=\left\{a+b i \mid a, b \in \mathbb{Z}_{5}\right\}\)</span> 不是一个域。</p><hr /><p>证明：假设 <span class="math inline">\(F\)</span> 为一个域，由域有乘法逆元，考虑 <span class="math inline">\(1+2i\)</span> 的逆，在 <span class="math inline">\(F\)</span> 中设为 <span class="math inline">\(a+bi\)</span>，显然 <span class="math inline">\(F\)</span> 的乘法单位元为 <span class="math inline">\(1\)</span>，</p><p>故 <span class="math inline">\((1+2i)(a+bi)\equiv 1\pmod{5}\)</span>，整理为 <span class="math inline">\(a\equiv 2b+1\pmod{5},2a\equiv -b\pmod{5}\)</span>，得 <span class="math inline">\(0\equiv 1\pmod{5}\)</span> ，矛盾</p><h1 id="largetextcolorblue初等数论第十二次作业-_textcolorblue2022.5.21"><span class="math inline">\(\large\textcolor{blue}{初等数论第十二次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.5.21}\)</span></h1><h2 id="柯召7.22">柯召7.22</h2><p>求出 <span class="math inline">\(F_{2}\)</span> 上的全部四次不可约多项式.</p><hr /><p>解：计算 $_{2}(4)=((1)2<sup>4+(2)2</sup>2+(4)2^1)=3  $从而共有 <span class="math inline">\(3\)</span> 个四次不可约多项式， <span class="math inline">\(F_2\)</span> 上，有</p><p>一次不可约多项式为 <span class="math inline">\(x, x+1\)</span>. 有 <span class="math inline">\(x^2\equiv x\pmod{2}\)</span> 从而当且仅当 <span class="math inline">\(f(x)\)</span> 的非零系数有偶数个时都不是不可约多项式（验证）</p><p><span class="math inline">\(F_{2}\)</span> 上的多项式 <span class="math inline">\(f(x)\)</span> 被 <span class="math inline">\(x\)</span> 整除当且仅当 <span class="math inline">\(f(0)=0\)</span> 从而排除掉上述情况有 <span class="math inline">\(\mathrm{F}_{2}\)</span> 上的不含有一次因子的四次多项式 <span class="math display">\[x^{4}+x^{3}+x^{2}+x+1, x^{4}+x^{3}+1, x^{4}+x^{2}+1, x^{4}+x+1\]</span> 而 <span class="math inline">\(x^{4}+x^{2}+1=\left(x^{2}+x+1\right)^{2}\)</span> 可约，则该多项式排除，则 <span class="math inline">\(F_{2}\)</span>​ 上的全部四次不可约多项式为 <span class="math display">\[x^{4}+x^{3}+x^{2}+x+1, x^{4}+x^{3}+1, x^{4}+x+1\]</span></p><h2 id="柯召7.23">柯召7.23</h2><p>证明：若 <span class="math inline">\(p \neq q\)</span> 是两个奇素数, 则 <span class="math inline">\(F_{p}\)</span> 上首项系数为 <span class="math inline">\(1\)</span> 的 <span class="math inline">\(q\)</span> 次不可约多项式的个数为 <span class="math inline">\(\dfrac{p^{q}-p}{q}\)</span>.</p><hr /><p>证明：由 <span class="math inline">\(\Phi_{p}(q)=\displaystyle \frac{1}{q} \sum_{l \mid q} \mu(l) p^{\frac{q}{l}}=\dfrac{1}{q}(1\cdot p^q+(-1)\cdot p)=\dfrac{p^q-p}{q}\)</span></p><h2 id="柯召7.27">柯召7.27</h2><p>证明: 若 <span class="math inline">\(\left(r, p^{n}-1\right)=1\)</span>, 则 <span class="math inline">\(F_{p^{n}}\)</span> 中任一个元 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(F_{p^n}\)</span> 中的 <span class="math inline">\(r\)</span> 次幂元，若 <span class="math inline">\(r \mid p^n-1\)</span>，则 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(F_{p^n}\)</span> 中的 <span class="math inline">\(r\)</span> 次幂元</p><p>的充分必要条件是 <span class="math inline">\(\alpha^{\frac{p^n-1}{r}}=1\)</span></p><hr /><p>证明：若 <span class="math inline">\(\left(r, p^{n}-1\right)=1\)</span> ，则 <span class="math inline">\(r\)</span> 存在数论倒数 <span class="math inline">\(r^{-1}\)</span>。 取 <span class="math inline">\(F_{p}[x]\)</span> 中的一个 <span class="math inline">\(n\)</span> 次不可约多项式 ，取模 <span class="math inline">\(f\)</span> 的原根 <span class="math inline">\(g\)</span>.</p><p>则对任意的 <span class="math inline">\(\alpha \in F_{p^{n}}\)</span> ，都存在整数 <span class="math inline">\(s\)</span> ，使得 <span class="math inline">\(\alpha \equiv g^{s}(\bmod f)\)</span>. 令 <span class="math inline">\(t=s r^{-1}\)</span> ，则 <span class="math inline">\(\left(g^{t}\right)^{r} \equiv g^{s} \equiv \alpha(\bmod f)\)</span></p><p>从而 <span class="math inline">\(\alpha\)</span> 是 <span class="math inline">\(r\)</span> 次幂元</p><p>若 <span class="math inline">\(r\mid p^n-1\)</span>，<span class="math inline">\(\Longrightarrow:\)</span> <span class="math inline">\(\alpha=\beta^r,\alpha^{\frac{p^n-1}{r}}=\beta^{p^n-1}\equiv 1\pmod{f}\)</span> <span class="math inline">\(\Longleftarrow:\)</span> 设 <span class="math inline">\(\alpha=g^s\)</span> 代入有 <span class="math display">\[\alpha^{\frac{p^n-1}{r}}=1=g^{\frac{s(p^n-1)}{r}}\equiv 1\pmod{f}\]</span> 由原根的性质可得 <span class="math inline">\(r\mid s\)</span> 从而 <span class="math inline">\(\alpha\)</span> 为 <span class="math inline">\(r\)</span> 次幂元</p><h2 id="柯召7.28">柯召7.28</h2><p>证明：设 <span class="math inline">\(\alpha_{1}, \cdots, \alpha_{p^{n}-1}\)</span> 是 <span class="math inline">\(F_{p^{n}}\)</span> 中的全体非蕶元, 则 <span class="math display">\[\alpha_{1} \cdots \alpha_{p^{n}-1}=-1 \text {. }\]</span></p><hr /><p>证明：类比威尔逊定理的证明，取 <span class="math inline">\(F_{p}[x]\)</span> 中的一个 <span class="math inline">\(n\)</span> 次不可约多项式，然后取其原根 <span class="math inline">\(g\)</span> 则 <span class="math display">\[\alpha_{1} \cdots \alpha_{p^{n}-1} \equiv g^{1+2+\cdots+\left(p^{n}-1\right)} \equiv\left(g^{\frac{p^{n}-1}{2}}\right)^{p^{n}} \equiv(-1)^{p^{n}} \equiv-1(\bmod f)\]</span> 其中 <span class="math inline">\(g^{\frac{p^n-1}{2}}\equiv -1\pmod{p^n-1}\)</span> 为原根的性质</p><blockquote><p><strong>特殊情况</strong>，考虑 <span class="math inline">\(p=2\)</span> 有 <span class="math inline">\((-1)^{p^n}\equiv 1\equiv -1\pmod{f}\)</span> 从而对所有素数成立</p></blockquote><h2 id="柯召7.32">柯召7.32</h2><p>证明：若 <span class="math inline">\(F_{p}\)</span> 上 <span class="math inline">\(n\)</span> 次不可约多项式的周期为 <span class="math inline">\(l\)</span>, 则 <span class="math inline">\(p\)</span> 模 <span class="math inline">\(l\)</span> 的次数为 <span class="math inline">\(n\)</span>.</p><hr /><p>证明：由原根的性质可知，<span class="math inline">\(l\mid p^n-1\)</span>，令 <span class="math inline">\(p^x\equiv 1\pmod{l}\)</span> 显然次数 <span class="math inline">\(r\)</span> 满足 <span class="math inline">\(r\mid n\)</span>，</p><p>于是 <span class="math inline">\(f \mid x^{p^{r}}-x\)</span> ，但 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(n\)</span> 次的，故 <span class="math inline">\(n \leq r\)</span>. 于是 <span class="math inline">\(r=n\)</span> ，即 <span class="math inline">\(p\)</span> 模 <span class="math inline">\(l\)</span> 的次数为 <span class="math inline">\(n\)</span>.</p><h1 id="largetextcolorblue初等数论第十三次作业-_textcolorblue2022.5.28"><span class="math inline">\(\large\textcolor{blue}{初等数论第十三次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.5.28}\)</span></h1><h2 id="柯召7.34">柯召7.34</h2><p>分别求出 <span class="math inline">\(F_{2}\)</span> 上多项式 <span class="math inline">\(f(x)=(x+1)\left(x^{3}+x+1\right)\left(x^{3}+x^{2}+1\right)\)</span> 和 $g(x) = (x^2+x+1)$</p><p><span class="math inline">\(\left(x^{4}+x+1\right)^{3}\)</span> 的周期.</p><hr /><p>解：由定理可知周期等于 <span class="math inline">\([l_1,\cdots,l_n]e,e=\{2^r:r\in Z,r\geq 0,2^r\geq 1(f(x)),3(g(x))\}=1,4\)</span>，求 <span class="math inline">\(l_i\)</span></p><p>由 <span class="math inline">\(x+1\mid x-1\)</span> 最小正整数为 <span class="math inline">\(1\)</span>，则对 <span class="math inline">\(f(x)\)</span> 中 <span class="math inline">\((x+1)\)</span> 的周期为 <span class="math inline">\(1\)</span>，对 <span class="math inline">\((x^3+x+1)\)</span> 和 <span class="math inline">\((x^3+x^2+1)\)</span></p><p>均为不可约多项式，且 <span class="math inline">\(2^3-1=7\)</span> 为素数，从而两者周期均为 <span class="math inline">\(7\)</span>，故 <span class="math inline">\(f(x)\)</span> 周期为 <span class="math inline">\([1,7,7]\cdot 1=7\)</span></p><p><span class="math inline">\(x^2-1=3\)</span> 为素数，且 <span class="math inline">\(x^2+x+1\)</span> 为不可约多项式，则其周期为 <span class="math inline">\(3\)</span></p><p>对 <span class="math inline">\((x^4+x+1)\)</span> 有 <span class="math inline">\(2^4-1=15\)</span> 为合数，而分别计算 $x<sup>5,x</sup>31 $ <span class="math display">\[\begin{gathered}x^5=x\cdot x^4\equiv x(-x-1)\equiv -x^2-x\equiv -x(x+1)\not \equiv 1\pmod{x^4+x+1}\\x^3\not\equiv1\pmod{x^4+x+1}\end{gathered}\]</span></p><p>故 <span class="math inline">\(15\)</span> 为 <span class="math inline">\(x^4+x+1\)</span> 的周期，<span class="math inline">\(g(x)\)</span> 周期为 <span class="math inline">\([3,15]\cdot 4=60\)</span>，故 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span> 的周期为 <span class="math inline">\(7\)</span> 和 <span class="math inline">\(60\)</span></p><h2 id="柯召7.36">柯召7.36</h2><p>求 <span class="math inline">\(F_{2}\)</span> 上多项式 <span class="math inline">\(x^{2 \cdot 3^{k}}+x^{3^{k}}+1\)</span> 的周期, 并证明它是不可约的。</p><hr /><p>解：由立方差公式 <span class="math inline">\(x^{3\cdot 3^{k}}-1=(x^{2 \cdot 3^{k}}+x^{3^{k}}+1)(x^{3^{k}}-1)\)</span> 则 <span class="math inline">\(x^{2 \cdot 3^{k}}+x^{3^{k}}+1\mid x^{3^{k+1}}-1\)</span> 令其周期为 <span class="math inline">\(r\)</span></p><p>有 <span class="math inline">\(r\mid 3^{k+1}\)</span>，而考虑 <span class="math inline">\(x^{2 \cdot 3^{k}}+x^{3^{k}}+1\mid x^r-1\)</span> 的最高次项，<span class="math inline">\(r\geq 2\cdot 3^k\)</span>，故 <span class="math inline">\(r=3^{k+1}\)</span></p><p>假设该多项式不可约，则其能被分解为若干个不可约多项式之积，由不可约多项式周期相关定理有 <span class="math display">\[3^{k+1}=[l_1,l_2,\cdots,l_n]e\]</span> 由 <span class="math inline">\(e=2^r\)</span> 则 <span class="math inline">\(e=1,\exists\ s\in[1,n],s.t.l_s=3^{k+1}\)</span> 令该不可约多项式为 <span class="math inline">\(p(x)\)</span> 令其最高幂次项为 <span class="math inline">\(n\)</span>，有 <span class="math display">\[3^{k+1}\mid 2^n-1\]</span> 两边模 <span class="math inline">\(3\)</span> 有 <span class="math inline">\((-1)^n\equiv 1\pmod{3}\)</span>，则 <span class="math inline">\(n\equiv 0\pmod{2}\)</span>，取 <span class="math inline">\(n=2t\)</span> 代入有 <span class="math inline">\(3^{k+1}\mid 4^t-1\)</span></p><p>将其展开 <span class="math inline">\(4^t-1=(1+3)^t-1\)</span> 其中 <span class="math inline">\(3\)</span> 的最小幂次为 <span class="math inline">\(k+1\)</span> 则 <span class="math inline">\(3^{k+1}\mid 3t,3^k\mid t\)</span> 则 <span class="math inline">\(n=2t\geq 2\cdot 3^k\)</span></p><p>恰为 <span class="math inline">\(f(x)\)</span> 的最高幂次，从而该多项式即为其本身，故其不可约</p><h2 id="柯召8.16">柯召8.16</h2><p>设 <span class="math inline">\(p\)</span> 是一个奇素数, <span class="math inline">\(d=(m, p-1)\)</span>, 证明: <span class="math inline">\(N\left(x^{m}=a\right)=N\left(x^{d}=a\right)\)</span>.</p><hr /><p>证明：当 <span class="math inline">\(x^d\equiv a\pmod{p}\)</span> 无解时，<span class="math inline">\(x^m\equiv a\pmod{p}\)</span> 也无解（否则 <span class="math inline">\((x^{\frac{m}{d}})^d\)</span> 为前者的解）</p><p>又当 <span class="math inline">\(x^d\equiv a\pmod{p}\)</span> 有解时，其解有 <span class="math inline">\(d\)</span> 个，设为 <span class="math inline">\(x_1,\cdots,x_d\)</span> ，又注意到 <span class="math inline">\((\dfrac{m}{d},p-1)=1\)</span> 则有</p><p><span class="math inline">\(p-1\)</span> 的完系均为 <span class="math inline">\(\dfrac{m}{d}\)</span> 次剩余，则 <span class="math inline">\(x^m\equiv a\pmod{p}\)</span> 等价于 <span class="math inline">\(x^{\frac{m}{d}}\equiv x_i\pmod{p}\)</span> ，每个方程都只有一解</p><p>（取 <span class="math inline">\(p\)</span> 的原根 <span class="math inline">\(g\)</span>，有 <span class="math inline">\(\dfrac{m}{d}\mbox{ind}_gx\equiv \mbox{ind}_gx_i\pmod{p-1}\)</span> 则只有一解）故两者解为 <span class="math inline">\(d\)</span> 个</p><h2 id="柯召8.21">柯召8.21</h2><p>证明：若 <span class="math inline">\(k \mid p-1, \chi\)</span> 是 <span class="math inline">\(F_{p}\)</span> 上一个 <span class="math inline">\(k\)</span> 阶特征, 则 <span class="math display">\[\sum_{j=0}^{k-1} \chi^{j}(-1)=\left\{\begin{array}{l}k, \quad \text { 当 }\left(\dfrac{-1}{p}\right)_{k}=1 \text { 时, } \\0 , \quad \text { 当 }\left(\dfrac{-1}{p}\right)_{k}\neq 1 \text { 时. }\end{array}\right.\]</span></p><hr /><p>证明：由定理可知，<span class="math inline">\(\displaystyle \sum_{j=0}^{k-1} \chi^{j}(-1)=N(x^k=-1)\)</span>，则当 <span class="math inline">\((\dfrac{-1}{p})_k=1\)</span> 时，显然该方程有 <span class="math inline">\(k\)</span> 个解，当 <span class="math inline">\((\dfrac{-1}{p})_k=1\)</span> 时，该方程无解，故 <span class="math inline">\(\sum_{j=0}^{k-1} \chi^{j}(-1)=\left\{\begin{array}{l} k, \quad \text { 当 }\left(\dfrac{-1}{p}\right)_{k}=1 \text { 时, } \\ 0 , \quad \text { 当 }\left(\dfrac{-1}{p}\right)_{k}\neq 1 \text { 时. } \end{array}\right.\)</span></p><h1 id="largetextcolorblue初等数论第十四次作业-_textcolorblue2022.6.2"><span class="math inline">\(\large\textcolor{blue}{初等数论第十四次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.6.2}\)</span></h1><h2 id="阶以及雅可比和">阶以及雅可比和</h2><p>设 <span class="math inline">\(\chi \neq \chi_{0}\)</span> 是 <span class="math inline">\(F_{p}\)</span> 上的一个特征。设 <span class="math inline">\(\rho(a)=\left(\dfrac{a}{p}\right)\)</span> 是唯一的 <span class="math inline">\(2\)</span> 阶特征。设 <span class="math inline">\(p \neq 2\)</span> 。</p><p><span class="math inline">\((1)\)</span> 证明 <span class="math display">\[\sum_{t \in F_{p}} \chi\left(1-t^{2}\right)=J(\chi, \rho)\]</span> <span class="math inline">\((2)\)</span> 设 <span class="math inline">\(0 \neq k \in F_{p}\)</span> 。证明 <span class="math display">\[\sum_{t \in F_{p}} \chi(t(k-t))=\frac{\chi\left(k^{2}\right)}{\chi\left(2^{2}\right)} J(\chi, \rho)\]</span> (提示：利用 <span class="math inline">\((1)\)</span> )</p><p><span class="math inline">\((3)\)</span> 证明 <span class="math inline">\(J(\chi, \chi)=\chi(2)^{-2} J(\chi, \rho)\)</span>; (提示：利用 <span class="math inline">\((2)\)</span>)</p><p><span class="math inline">\((4)\)</span> 设 <span class="math inline">\(\chi^{2} \neq \chi_{0}\)</span> 。证明 <span class="math inline">\(g_{1}(\chi)^{2}=\chi(2)^{-2} J(\chi, \rho) g_{1}\left(\chi^{2}\right)\)</span>;</p><p><span class="math inline">\((5)\)</span> 设 <span class="math inline">\(p \equiv 1(\bmod 3)\)</span> 且 <span class="math inline">\(\chi\)</span> 是一个 <span class="math inline">\(3\)</span> 阶特征。证明 <span class="math inline">\(g_1(\chi)^{3}=p \cdot \chi(2) J(\chi, \rho)\)</span>;</p><p><span class="math inline">\((6)\)</span> 设 <span class="math inline">\(p \equiv 1(\bmod 4)\)</span> 且 <span class="math inline">\(\chi\)</span> 是一个 <span class="math inline">\(4\)</span> 阶特征。证明 <span class="math inline">\(\chi^{2}=\rho\)</span> 且 <span class="math inline">\(J(\chi, \chi)=\chi(-1) J(\chi, \rho)\)</span> 。</p><p>(提示: 证明 <span class="math inline">\(\chi(-1)=(\dfrac{2}{p})\)</span>)</p><hr /><p>解：<span class="math inline">\((1)\)</span> 由雅可比定义，代入 <span class="math inline">\(\left(\dfrac{a}{p}\right)=N(x^2=a)-1\)</span> 有 <span class="math display">\[\begin{gathered}J(\chi,\rho)=\displaystyle \sum_{t\in F_p}\chi(1-t)\rho(t)=\sum_{t\in F_p}\chi(1-t)(N(x^2=t)-1)\\=\sum_{t\in F_p}\chi(1-t)N(x^2=t)-\sum_{t\in F_p}\chi(1-t)=\sum_{t\in F_p}\chi(1-t)N(x^2=t)\end{gathered}\]</span> 而 <span class="math inline">\(N(x^2=t)\)</span> 对求和有贡献的有两类，当 <span class="math inline">\(N(x^2=t)=1\)</span> 时 <span class="math inline">\(t=0\)</span>，当 <span class="math inline">\(N(x^2=t)=2\)</span> 时，<span class="math inline">\(t\)</span> 为二次剩余 <span class="math display">\[J(\chi,\rho)=\chi(1-0)\cdot 1+2\cdot \sum_{(\frac{t}{p})=1}\chi(1-t)\]</span> 而对每一个二次剩余 <span class="math inline">\(t=b^2\)</span>，且 <span class="math inline">\(\chi(1-b^2)\)</span> 中 <span class="math inline">\(\pm b\)</span> 对应同一个 <span class="math inline">\(t\)</span>，且保证所有的 <span class="math inline">\(b\)</span> 不同，构成 <span class="math inline">\(F_p\)</span> 中所有非零元素 <span class="math display">\[J(\chi,\rho)=1+2\cdot \sum_{b\in F_p,b\neq 0}\chi(1-b^2)=\sum_{t \in F_{p}} \chi\left(1-t^{2}\right)\]</span> <span class="math inline">\((2)\)</span> 由 <span class="math inline">\((2,p)=1\)</span> 以及 <span class="math inline">\((k,p)=1\)</span>，则 <span class="math inline">\(\{2t\ |\ t\in F_p\}\)</span> 和 <span class="math inline">\(\{kt\ |\ t\in F_p\}\)</span> 构成 <span class="math inline">\(F_p\)</span> 中的完系，则 <span class="math display">\[\begin{gathered}\chi(k)^2\sum_{t\in F_p}\chi(1+t)\chi (1-t)=\sum_{t\in F_p}\chi(k+kt)\chi (k-kt)=\chi(k)^2\sum_{t\in F_p}\chi(1-t^2)=\sum_{t\in F_p}\chi(k+t)\chi (k-t)\\=\sum_{t\in F_p}\chi(t)\chi (2k-t)=\sum_{t\in F_p}\chi(2t)\chi (2k-2t)=\chi(2)^2\sum_{t\in F_p}\chi(t)\chi (k-t)\end{gathered}\]</span> 代入 <span class="math inline">\(\small (1)\)</span> 中结论 <span class="math inline">\(\displaystyle \sum_{t \in F_{p}} \chi\left(1-t^{2}\right)=J(\chi, \rho)\)</span> 则得到 <span class="math inline">\(\displaystyle \sum_{t \in F_{p}} \chi(t(k-t))=\frac{\chi\left(k^{2}\right)}{\chi\left(2^{2}\right)} J(\chi, \rho)\)</span></p><p><span class="math inline">\((3)\)</span> 取 <span class="math inline">\(k=1\)</span> 有 <span class="math inline">\(\displaystyle \sum_{t \in F_{p}} \chi(t(1-t))=\frac{\chi\left(1^2\right)}{\chi\left(2^{2}\right)} J(\chi, \rho)=\sum_{t \in F_{p}}\chi(t)\chi(1-t)=J(\chi,\chi)\)</span></p><p>而 <span class="math inline">\(\chi(1)=1\)</span>，代入得 <span class="math inline">\(J(\chi, \chi)=\chi(2)^{-2} J(\chi, \rho)\)</span></p><p><span class="math inline">\((4)\)</span> 由雅可比和与高斯和之间的关系有 <span class="math inline">\(J(\chi,\chi)=\dfrac{g_1(\chi)\cdot g_1(\chi )}{g_1(\chi ^2)}=\chi(2)^{-2} J(\chi, \rho)\)</span></p><p>移项整理得到 <span class="math inline">\(g_{1}(\chi)^{2}=\chi(2)^{-2} J(\chi, \rho) g_{1}\left(\chi^{2}\right)\)</span></p><p><span class="math inline">\((5)\)</span> 在 <span class="math inline">\(\small(4)\)</span> 等式左右乘以 <span class="math inline">\(g_1(\chi)\)</span> 可以得到 <span class="math inline">\(g_{1}(\chi)^{3}=\chi(2)^{-2} J(\chi, \rho) g_{1}\left(\chi^{2}\right)g_1(\chi)\)</span>，而由于 <span class="math inline">\(\chi\)</span> 为 <span class="math inline">\(3\)</span> 阶特征</p><p>则 <span class="math inline">\(\chi(2)^3=1\)</span> 则 <span class="math inline">\(g_{1}(\chi)^{3}=\chi(2) J(\chi, \rho) g_{1}\left(\chi^{2}\right)g_1(\chi)\)</span> 由于 <span class="math display">\[\overline{g(\chi)}=\sum_{t} \overline{\chi(t)} \zeta^{-t}=\chi(-1) \sum_{t} \overline{\chi(-t)} \zeta(-t)=\chi(-1) g(\chi)\]</span> 有 <span class="math inline">\(\chi(-1)^3=1\)</span> 且 <span class="math inline">\(\chi(-1)^2=\chi(1)=1\)</span>，故 <span class="math inline">\(\chi(-1)=1\)</span>，代入有 <span class="math display">\[g\left(\chi^{2}\right) g(\chi)=g(\bar{\chi}) g(\chi)=\overline{g(\chi)} g(\chi)=|g(\chi)|^{2}=p\]</span> 则 <span class="math inline">\(g_1(\chi)^{3}=p \cdot \chi(2) J(\chi, \rho)\)</span></p><p><span class="math inline">\((6)\)</span> 由于 <span class="math inline">\(\chi\)</span> 的阶为 <span class="math inline">\(4\)</span>，则 <span class="math inline">\(\chi^2\)</span> 的阶为 <span class="math inline">\(2\)</span>，而 <span class="math inline">\(\rho\)</span> 为唯一的二阶特征，故 <span class="math inline">\(\chi ^2=\rho\)</span>，由高斯和与雅可比和之间关系 <span class="math display">\[g(\chi)^{4}=\chi(-1) p J(\chi, \chi) J\left(\chi, \chi^{2}\right)=\chi(-1) p J(\chi, \chi) J(\chi, \rho)\]</span> 又对 <span class="math inline">\(\small(4)\)</span> 中的等式两边平方得到 <span class="math display">\[g(\chi)^{4}=\chi(2)^{-4} J(\chi, \rho)^{2}\left[g\left(\chi^{2}\right)\right]^{2} \]</span> 而由 <span class="math inline">\(4\)</span> 阶特征可以得到 <span class="math inline">\(\chi\left(2^{4}\right)=\chi^{4}(2)=\chi_0(2)=1\)</span>, and <span class="math inline">\(g\left(\chi^{2}\right)=g(\rho)=g\)</span>, so <span class="math inline">\(\left[g\left(\chi^{2}\right)\right]^{2}=g^{2}\)</span> ，而有 <span class="math display">\[g_{a} g_{-a}=(\dfrac{a}{p})(\dfrac{-a}{p}) g^{2}=(\dfrac{-1}{p}) g^{2}\Longrightarrow\sum_{a} g_{a} g_{-a}=\left(\frac{-1}{p}\right)(p-1) g^{2} \]</span> 而使用另一种方法计算左边有 <span class="math display">\[g_{a} g_{-a}=\sum_{x} \sum_{y}\left(\frac{x}{p}\right)\left(\frac{y}{p}\right) \zeta^{a(x-y)}=\sum_{x} \sum_{y}\left(\frac{x}{p}\right)\left(\frac{y}{p}\right) \delta(x, y) p=(p-1) p\]</span> 两式对比有 <span class="math inline">\(g^{2}=(\dfrac{-1}{p})p\)</span> 由于 <span class="math inline">\(p\equiv 1\pmod{4}\)</span> 则 <span class="math inline">\((\dfrac{-1}{p})=1\)</span> 则 <span class="math inline">\(g^2=p\)</span>，则有 <span class="math display">\[\chi(-1) p J(\chi, \chi) J(\chi, \rho)=J(\chi, \rho)^{2} p \]</span> 由于 <span class="math inline">\(g(\chi)^{4} \neq 0\)</span> 以及 <span class="math inline">\(|g(\chi)|^{2}=p\)</span>，有 <span class="math inline">\(J(\chi, \rho) \neq 0\)</span>, 则两边约去 <span class="math inline">\(pJ(\chi,\rho)\)</span> 有 <span class="math display">\[\chi(-1) J(\chi, \chi)=J(\chi, \rho)\]</span> <span class="math inline">\([\chi(-1)]^{2}=\chi\left((-1)^{2}\right)=\chi(1)=1\)</span>, 故 <span class="math inline">\(\chi(-1)=\pm 1\)</span>, 从而 <span class="math inline">\(\chi(-1)^{-1}=\chi(-1)\)</span>, 移项得到 <span class="math display">\[J(\chi, \chi)=\chi(-1) J(\chi, \rho)\]</span></p><h1 id="largetextcolorblue初等数论第十五次作业-_textcolorblue2022.6.12"><span class="math inline">\(\large\textcolor{blue}{初等数论第十五次作业}\ \ \ \ \ \ _\textcolor{blue}{2022.6.12}\)</span></h1><h2 id="雅可比和以及加密解密">雅可比和以及加密解密</h2><ol type="1"><li><p>设 <span class="math inline">\(p\)</span> 是一个奇素数, 计算</p><p><span class="math inline">\((1)\)</span> <span class="math inline">\(N\left(x^{3}-y^{3}=1\right), p=37\)</span>;</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(N\left(9 x^{2}+8 y^{2}=a\right), p=17, a \in F_{17}^{*}\)</span> 。</p></li><li><p>使用加密密钥 <span class="math inline">\(E(x) \equiv x+3(\bmod 26)\)</span> 将信息 “mathematics” 加密.</p></li><li><p>已知加密密钥 <span class="math inline">\(E(x) \equiv x+5(\bmod 26)\)</span> 。将信息 "lttijajsnsl" 解密.</p></li><li><p>假设加密密钥 <span class="math inline">\(E(x) \equiv 3 x+1(\bmod 26)\)</span>, 求去密密钥 <span class="math inline">\(D(y)\)</span>, 并将信息 “EBOBO BEBOK" 解密。</p></li></ol><hr /><p>1、解：<span class="math inline">\((1)\)</span> 计算 <span class="math inline">\(M(x^3+(-y)^3=1)=\displaystyle \sum_{i=0}^2\sum_{j=0}^2\chi ^i(a)\chi^j(1-a)=p+J(\chi,\chi)+J(\chi^2,\chi^2)-2\chi(-1)\)</span></p><p><span class="math inline">\(=p-2+J(\chi,\chi)+J(\chi^2,\chi^2)=p-2+J(\chi,\chi)+\overline{J(\chi,\chi)}\)</span> 令 <span class="math inline">\(J(\chi,\chi)=a+b\omega,\omega=-\dfrac{1}{2}+\dfrac{\sqrt{3}}{2}i\)</span></p><p>得到 <span class="math inline">\(p-2+2a-b\)</span>，由分解定理 <span class="math inline">\(4p=(2a-b)^2+27(\dfrac{b}{3})^2=148=11^2+27\cdot 1\Longrightarrow a=7,b=3\)</span> 要求 <span class="math inline">\(2a-b\equiv 1\pmod{3}\)</span></p><p>则 <span class="math inline">\(2a-b=-11\)</span> <span class="math inline">\(N(x^3-y^3=1)=37-2+(-11)=24\)</span></p><p><span class="math inline">\((2)\)</span> 由 <span class="math inline">\(p=17\)</span> 得 <span class="math inline">\(N(9x^2+8y^2=a)=N(9(x^2-y^2)=a)\)</span> 而 <span class="math inline">\(\{3x\}\)</span> 与 <span class="math inline">\(\{x\}\)</span> 均取遍所有 <span class="math inline">\(F_{p}^*\)</span>，故化解为 <span class="math inline">\(N(x^2-y^2=a)\)</span></p><p>由 <span class="math inline">\((\dfrac{-1}{p})=(-1)^{\frac{p-1}{2}}=1\)</span> 知 <span class="math inline">\(-1\)</span> 为二次剩余，从而 <span class="math inline">\(-y^2=(a_0)^2(y)^2=(a_0y)^2\)</span> 又可化解为 <span class="math inline">\(N(x^2+y^2=a)\)</span> <span class="math display">\[\begin{gathered}N(x^2+y^2=a)=\displaystyle \sum_{i=0}^1\sum_{j=0}^1\chi ^i(t)\chi^j(a-t)=p+J(\chi,\chi_0)+J(\chi_0,\chi)+J(\chi,\chi)\\=p-\chi(-1)=p+\sum_{c\in F_p}\chi(\dfrac{c}{a-c})\end{gathered}\]</span> 而 <span class="math inline">\(\dfrac{c}{a-c}=t\Longrightarrow c=\dfrac{at}{t+1}\)</span> 只有 <span class="math inline">\(t=-1\)</span> 元素没有遍历，从而 <span class="math inline">\(\displaystyle \sum_{c\in F_p}\chi(\dfrac{c}{a-c})=0-\chi(-1)=-1\)</span></p><p>故原方程有 <span class="math inline">\(17+(-1)=16\)</span> 个解</p><p>2、使用 <span class="math inline">\(\mbox{python}\)</span> 编程计算，代码如下，加密结果为 <span class="math inline">\(\mathbf{pdwkhpdwlfv}\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">charList = <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br>word = <span class="hljs-string">&quot;mathematics&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> word:<br>    <span class="hljs-built_in">print</span>(charList[(<span class="hljs-built_in">ord</span>(i) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-number">3</span>) % <span class="hljs-number">26</span>], end = <span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>3、只需改动一行代码，解密结果为 <span class="math inline">\(\mathbf{goodevening}\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(charList[(<span class="hljs-built_in">ord</span>(i) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>) - <span class="hljs-number">5</span>) % <span class="hljs-number">26</span>], end = <span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>4、反解同余方程得 <span class="math inline">\(x\equiv 9\cdot (y-1)\equiv 9y+17\pmod{26}\)</span>，代码如下，解密结果为 <span class="math inline">\(\mathbf{BANAN\ \ ABAND}\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(charList[(<span class="hljs-number">9</span> * (<span class="hljs-built_in">ord</span>(i) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;A&quot;</span>)) + <span class="hljs-number">17</span>) % <span class="hljs-number">26</span>], end = <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>初等数论作业合集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Saltwater Room</title>
    <link href="/2022/06/10/video%20test/"/>
    <url>/2022/06/10/video%20test/</url>
    
    <content type="html"><![CDATA[<p><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"https://lr-tsinghua11.github.io/video/The Saltwater Room.mp4","pic":"https://lr-tsinghua11.github.io/img/深空之海.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>视频</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A practice for Calculus final exam</title>
    <link href="/2022/06/03/%E5%BE%AE%E7%A7%AF%E5%88%86%E6%9C%9F%E6%9C%AB%E6%A8%A1%E6%8B%9F%E8%80%83%E8%AF%95%E8%AF%95%E9%A2%98/"/>
    <url>/2022/06/03/%E5%BE%AE%E7%A7%AF%E5%88%86%E6%9C%9F%E6%9C%AB%E6%A8%A1%E6%8B%9F%E8%80%83%E8%AF%95%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>一、选择题</p><p>1、马鞍面 <span class="math inline">\(z=x y\)</span> 被圆柱面 <span class="math inline">\(x^{2}+y^{2}=1\)</span> 所截，截得的有界部分曲面的面积为 <span class="math inline">\((B)\)</span></p><ol type="A"><li><span class="math inline">\(\frac{1}{3} \pi(2 \sqrt{2}+1)\)</span></li><li><span class="math inline">\(\frac{2}{3} \pi(2 \sqrt{2}-1)\)</span></li><li><span class="math inline">\(\frac{1}{3} \pi(2 \sqrt{2}-1)\)</span></li><li><span class="math inline">\(\frac{2}{3} \pi(\sqrt{2}-1)\)</span></li></ol><p>2、设曲线 <span class="math inline">\(L\)</span> 为从点 <span class="math inline">\(A(-1,1)\)</span> 沿曲线 <span class="math inline">\(y=x^{2}\)</span> 到点 <span class="math inline">\(B(0,0)\)</span> 再沿直线 <span class="math inline">\(y=0\)</span> 到点 <span class="math inline">\(C(2,0)\)</span> 的路径，则 <span class="math inline">\(\int_{L}\left(12 x+\mathrm{e}^{y}\right) \mathrm{d} x+\left(x \mathrm{e}^{y}-\cos y\right) \mathrm{d} y=\)</span> <span class="math inline">\((A)\)</span></p><ol type="A"><li><span class="math inline">\(20+\mathrm{e}+\sin 1\)</span></li><li><span class="math inline">\(2 \mathrm{e}+\sin 1\)</span></li><li><span class="math inline">\(10+\mathrm{e}^{2}+\sin 1\)</span></li><li><span class="math inline">\(\mathrm{e}+\sin 1\)</span></li></ol><p>3、幂级数 <span class="math inline">\(\sum_{n=1}^{\infty} \frac{1}{n}(x-1)^{n}\)</span> 的收敛域为 <span class="math inline">\((B)\)</span></p><ol type="A"><li><span class="math inline">\([0,2]\)</span></li><li><span class="math inline">\([0,2)\)</span></li><li><span class="math inline">\((0,1)\)</span></li><li><span class="math inline">\([0,1]\)</span></li></ol><p>4、设 <span class="math inline">\(f\)</span> 连续, 交换累次积分的次序 <span class="math inline">\(\int_{1}^{2} \mathrm{~d} x \int_{0}^{x} f(x, y) \mathrm{d} y=\)</span> <span class="math inline">\((B)\)</span></p><ol type="A"><li><span class="math inline">\(\int_{0}^{2} \mathrm{dy} \int_{y}^{2} f(x, y) \mathrm{d} x\)</span></li><li><span class="math inline">\(\int_{0}^{1} \mathrm{~d} y \int_{1}^{2} f(x, y) \mathrm{d} x+\int_{1}^{2} \mathrm{~d} y \int_{y}^{2} f(x, y) \mathrm{d} x\)</span></li><li><span class="math inline">\(\int_{0}^{x} \mathrm{dy} \int_{1}^{2} f(x, y) \mathrm{d} x\)</span></li></ol><p>5、设 <span class="math inline">\(L\)</span> 是球面 <span class="math inline">\(x^{2}+y^{2}+z^{2}=1\)</span> 与平面 <span class="math inline">\(x+y+z=0\)</span> 的交线，则 <span class="math inline">\(\int_{L} x^{2} \mathrm{~d} l=\)</span> <span class="math inline">\((C)\)</span></p><ol type="A"><li><span class="math inline">\(2 \pi\)</span></li><li><span class="math inline">\(\pi\)</span></li><li><span class="math inline">\(\frac{2}{3} \pi\)</span></li><li><span class="math inline">\(\frac{1}{2} \pi\)</span></li></ol><p>6、级数 <span class="math inline">\(\sum_{n=1}^{\infty}(-1)^{n+1} \frac{2^{n}}{n !}\)</span> 的收敛性为 <span class="math inline">\((C)\)</span></p><ol type="A"><li>条件收敛</li><li>发散</li><li>绝对收敛</li></ol><p>7、设 <span class="math inline">\(\Omega\)</span> 为由圆柱面 <span class="math inline">\(x^{2}+y^{2}=1\)</span>, 锥面 <span class="math inline">\(z=\sqrt{x^{2}+y^{2}}\)</span> 和平面 <span class="math inline">\(z=0\)</span> 所围成的空间有界区域，则三重积分 <span class="math inline">\(\iiint_{\Omega} z \mathrm{~d} x \mathrm{~d} y \mathrm{~d} z=\)</span> <span class="math inline">\((A)\)</span></p><ol type="A"><li><span class="math inline">\(\frac{\pi}{4}\)</span></li><li><span class="math inline">\(\pi\)</span></li><li><span class="math inline">\(\frac{\pi}{2}\)</span></li><li>2</li></ol><p>二、填空题</p><p>8、设 <span class="math inline">\(2 \pi\)</span> 周期函数 <span class="math inline">\(f(x)=\left\{\begin{array}{l}4 ; x \in[-\pi, 0) \\ 0 ; x \in[0, \pi)\end{array}\right.\)</span> 的形式 Fourier 级数的和函数为 <span class="math inline">\(S(x)\)</span> ，则 <span class="math inline">\(S(0)=\stackrel{\Large 2}{\_\_\_\_\_\_}\)</span></p><p>9、若 <span class="math inline">\((x+3 y) \mathrm{d} x+(k x+y) \mathrm{d} y=0\)</span> 为全微分方程，则常数 <span class="math inline">\(k=\stackrel{\Large 3}{\_\_\_\_\_\_}\)</span></p><p>10、柱面 <span class="math inline">\(x^{2}+y^{2}=2 x\)</span> 夹在锥面 <span class="math inline">\(z=\sqrt{x^{2}+y^{2}}\)</span> 和平面 <span class="math inline">\(z=0\)</span> 之间部分的面积为 <span class="math inline">\(\stackrel{\Large 8}{\_\_\_\_\_\_}\)</span></p><p>11、设 <span class="math inline">\(S\)</span> 为单位球面 <span class="math inline">\((x-1)^{2}+(y-2)^{2}+(z-3)^{2}=1\)</span> ，则 <span class="math inline">\(\dfrac{1}{\pi} \displaystyle \iint_{S}(x+y+z) \mathrm{d} S=\stackrel{\Large 24}{\_\_\_\_\_\_}\)</span></p><p>12、设 <span class="math inline">\(\overrightarrow{\mathbf{F}}(x, y, z)=(y z, z x, x y)\)</span> ，则 <span class="math inline">\(\|\operatorname{rot} \overrightarrow{\mathbf{F}}(x, y, z)\|=\stackrel{\Large 0}{\_\_\_\_\_\_}\)</span></p><p>13、封闭曲线 <span class="math inline">\(\left(x^{2}+y^{2}\right)^{2}=2\left(x^{2}-y^{2}\right)(x \geq 0)\)</span> 所围区域的面积为 <span class="math inline">\(\stackrel{\Large 1}{\_\_\_\_\_\_}\)</span></p><p>14、设 <span class="math inline">\(L^{+}\)</span>为逆时针旋转的椭圆 <span class="math inline">\(x^{2}+4 y^{2}=1\)</span> ，则 <span class="math inline">\(\oint_{L^{+}} \frac{x^{2} \mathrm{~d} x+y^{3} \mathrm{~d} y}{x^{2}+4 y^{2}}=\stackrel{\Large 0}{\_\_\_\_\_\_}\)</span></p><p>15、设 <span class="math inline">\(L: x^{2}+y^{2}=1\)</span> ，则 <span class="math inline">\(\frac{1}{\pi} \int_{L}(x+y)^{2} \mathrm{~d} l=\stackrel{\Large 2}{\_\_\_\_\_\_}\)</span></p><p>16、设曲面 <span class="math inline">\(\mathrm{S}^{+}: z=1\left(x^{2}+y^{2} \leq 1\right)\)</span> ，方向向上。则 <span class="math inline">\(\frac{1}{\pi} \iint_{\mathrm{S}^{+}} x \mathrm{~d} y \wedge \mathrm{d} z+y \mathrm{~d} z \wedge \mathrm{d} x+z \mathrm{~d} x \wedge \mathrm{d} y=\stackrel{\Large 1}{\_\_\_\_\_\_}\)</span></p><p>17、设 <span class="math inline">\(f(x)\)</span> 是以 2 为周期的周期函数， <span class="math inline">\(f(x)=x ， x \in[0,1]\)</span> 。若 <span class="math inline">\(f(x)\)</span> 的形式Fourier级数为 <span class="math inline">\(\sum_{n=1}^{\infty} b_{n} \sin n \pi x\)</span> ，则 <span class="math inline">\(5 \pi b_{5}=\stackrel{\Large 2}{\_\_\_\_\_\_}\)</span></p><p>18、设 <span class="math inline">\(f(x, y)=x^{2} y^{2}\)</span> ，则在点 <span class="math inline">\((1,1)\)</span> 处， <span class="math inline">\(\operatorname{div}(\operatorname{grad} f)=\stackrel{\Large 4}{\_\_\_\_\_\_}\)</span></p><p>19、记 <span class="math inline">\(L^{+}\)</span>为逆时针旋转的有向封闭曲线 <span class="math inline">\(|x|+|y|=1\)</span> ，则 <span class="math inline">\(\frac{1}{\pi} \oint_{L^{+}} \frac{x \mathrm{~d} y-y \mathrm{~d} x}{x^{2}+y^{2}}=\stackrel{\Large 2}{\_\_\_\_\_\_}\)</span></p><p>20、设 <span class="math inline">\(L^{+}\)</span>为从 <span class="math inline">\((0,0)\)</span> 点到 <span class="math inline">\((1,2)\)</span> 点的有向线段，则 <span class="math inline">\(\int_{L^{+}} x y^{2} \mathrm{~d} x+x^{2} y \mathrm{~d} y=\stackrel{\Large 2}{\_\_\_\_\_\_}\)</span></p><p>三、主观题</p><p>1、设 <span class="math inline">\(\Omega\)</span> 为由 <span class="math inline">\(z=1-\left(x^{2}+y^{2}\right)\)</span> 和 <span class="math inline">\(x^{2}+y^{2}+z^{2}=1\)</span> 围成的空间有界区域，求 <span class="math inline">\(\iiint_{\Omega} z \mathrm{~d} x \mathrm{~d} y \mathrm{~d} z\)</span> <span class="math inline">\(\stackrel{\ \dfrac{\pi}{12}}{\_\_\_\_\_\_}\)</span></p><p>2、证明函数项级数 <span class="math inline">\(\sum_{k=1}^{\infty} k^{2} \mathrm{e}^{-k x}\)</span> 的和函数 <span class="math inline">\(S(x)\)</span> 在其收敛域内连续可微。</p>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
      <category>微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微积分期末模拟考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>memristor in Weiyang Congyou</title>
    <link href="/2022/06/01/CongYou/"/>
    <url>/2022/06/01/CongYou/</url>
    
    <content type="html"><![CDATA[<p><img src="https://pic.imgdb.cn/item/624a6435239250f7c5911903.jpg" style="zoom: 20%;" /></p><p>​ 信息所 <strong>李春平教授</strong></p><h1 id="专业分享-sharing-major">专业分享 (sharing major)</h1><p>之前在德国留学，从清华软件学院成立以来工作 <span class="math inline">\(20\)</span> 年，AI，机器学习，数据挖掘。</p><p>当过 <span class="math inline">\(04年-08年,12年-18年\)</span> 班主任，招聘实习生</p><p>信息所关注信息技术，发展迅速，在各个行业应用广泛， <span class="math display">\[\large \begin{cases}数据处理:收集、管理、检索数据(高性能)\\数据分析:了解存储数据之间的分布、关联、信息\end{cases}\]</span></p><p><span class="math display">\[\large 数据分析\begin{cases}数据挖掘:预测(经济)、医疗(身体状况信息)\\数据分类:(类似图书管理系统)机器自动分类庞大数据\\数据关联:(智能用户画像)推荐系统,异常检测\end{cases}\]</span></p><p>背后技术：<strong>机器学习</strong>、统计学习（学习模型，能反映各个类之间的特征），预测（类似拟合曲线）</p><p>监督、指导过程，当前演化为无指导化（不需要原始数据集，聚类，<span class="math inline">\(\mbox{Class}\)</span> ）</p><p>应用：互联网（给定关键词检索，相似的内容自动分好组）</p><blockquote><p><strong>实验室工作</strong>，结构化的时序，文本，网络结构三类数据</p><ul><li><p>时序数据：例如（手机）传感器判断场景、监测健康信息(华为、西门子研究院、医疗团队)</p></li><li><p>文本数据：自然语言处理（ <span class="math inline">\(\mbox{NLP}\)</span> ）（目前存在瓶颈，语义分析较浅，主要运用统计分析的方法统计频率），话题识别，文本相似性便于分类，正负情感分析）</p></li><li><p>网络结构数据：和图相似（超链接相连），利用节点数量寻找最关键信息，模块化思想引入多个类进行分析，程序容易有局限性，判断节点是否出现失效</p><p>未来数据的融合程度更高。</p></li></ul></blockquote><h1 id="交流提问-question-answer">交流提问 (question &amp; answer)</h1><p>顾：<strong>人工智能浪潮是否还能持续？多层神经网络是否不能被严格证明？</strong></p><p>人工智能三起三落，神经网络在30-40年前就出现了。AI 的问题：能耗性、存在一定不可解释性（但是可用性高）</p><p>多层神经网络节点多，参数多，需要大量的参数，会引发“过拟合”（模型过于依赖所给样例）</p><p>顾：我也了解到深度学习（贵软无雷系都在作相关工作），<strong>邓仰东老师的工业预测，刘世霞的可解释性，龙明盛的深度学习，软院各老师工作之间是否有什么关联？</strong></p><p>刘世霞，之前关注图像处理，后面也聚焦文本</p><p>邓仰东，嵌入式设备，针对工业环节，高铁监控数据</p><p>关于未央书院培养，物理学习确实有些偏难</p><p>顾：<strong>老师您对本博贯通计划了解吗？</strong></p><p>这是一种可以学习更多个性化课程的方式</p><p>网络、软件从计算机系大类中独立出来</p><p>林：<strong>请问老师您刚才说的程序性正确性无法保证具体来说是什么？</strong></p><p>逻辑性系统，程序性本身不能完全证明，程序犯错率 <span class="math inline">\(\dfrac{5,6}{100000}\)</span></p><p>顾：<strong>我最近正在了解物联网，利用焦平面傅里叶变换，模电计算很快，请问老师对这个课题有什么了解吗？</strong></p><p>实验室方向欢迎大家来，本科生、研究生一起组会。只要感兴趣，有精力，就可以来了解学习。</p><h2 id="算力需要提升">算力需要提升</h2><p>原始架构在传递方面有一定局限，<span class="math inline">\(1000\mbox{GB/s}\)</span>，但是最终数据流不到 <span class="math inline">\(\mbox{1GB/s}\)</span> <span class="math display">\[\begin{array}{|c|c|c|c|c|}\hline &amp; \text { 计算器件 } &amp; \text { 计算范式 } &amp; \text { 算子 } &amp; \text { 架构 } \\\hline \text { 冯诺依曼计算系统 } &amp; \text { 场效应晶体管 } &amp; \text { 布尔逻辑数字计算 } &amp; \text { 与门, 非门 } &amp; \text { 存算分离 } \\\hline \text { 存算一体计算系统 } &amp; \text { 忆阻器 } &amp; \text { 物理定律模拟计算 } &amp; \text { 乘法, 加法 } &amp; \text { 存算一体 } \\\hline\end{array}\]</span></p><h2 id="基于忆阻器的存算一体技术">基于忆阻器的存算一体技术</h2><p><img src="https://pic.imgdb.cn/item/62971fb30947543129a912f9.jpg" /></p><p><img src="https://pic.imgdb.cn/item/6297216f0947543129ab5a96.jpg" /></p><p>模拟计算机会导致许多误差（在物理层面的），虽然其在矩阵乘法效率上有很大的优势，但是有一定局限性。</p><p><img src="https://pic.imgdb.cn/item/62b2c76d094754312913c8a9.jpg" /></p><p><img src="https://pic.imgdb.cn/item/629723f80947543129ae816a.jpg" /></p><ul><li>将带来从底层器件到编译器等层面的改变, 实 现新计算机系统, 但不改变现有编程语言。 &gt; 新计算系统能效将提高 <span class="math inline">\(10^{2}-10^{3}\)</span> 倍以上, 达到 1POPs/W。 &gt; 单芯片算力可以得到有效提升, 达到 500TOPs 或者 1POPS 。</li></ul><p><img src="https://pic.imgdb.cn/item/629725640947543129b06dff.jpg" /></p><p>大脑对少于一定值的信号会忽略，但对大于一定值的信号会放大，类脑计算能在一些复杂问题中发挥作用（入）</p><p><img src="https://pic.imgdb.cn/item/629725eb0947543129b11dc8.jpg" /></p><p><img src="https://pic.imgdb.cn/item/6297267d0947543129b1e400.jpg" /></p><p>大脑神经元 <span class="math inline">\(10^{11}\)</span> 量级，突触为 <span class="math inline">\(10^{15}\)</span> 量级，要实现仿生型的芯片，还有很多关键技术需要突破</p><h2 id="小结">小结</h2><ul><li>后摩尔时代传统架构AI芯片面临严峻的算力和能效瓶颈；</li><li>存算一体是突破传统架构中存储墙、功耗墙的好办法；</li><li>基于存算一体(模拟计算)的 <span class="math inline">\(\mathbf{NPU}\)</span> 任重道远:新器件、新电路、新架构、新算法、新工具链；</li><li>更远的未来,需要超越模拟计算,开发"类脑芯片"?</li></ul><p>光计算使用光的干涉来模拟 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span>，还缺乏功能演示，没有到 <span class="math inline">\(\mathbf{array}\)</span> 的环节</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>未央从游坊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未央微电子方向从游坊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Functional plotter</title>
    <link href="/2022/05/25/Program/Functional%20plotter/"/>
    <url>/2022/05/25/Program/Functional%20plotter/</url>
    
    <content type="html"><![CDATA[<center>面向对象</center><center>空教室，录音放。先继承，再封装。</center><center>写模板，搞工厂。郑成伟，凌精望。</center><center>谢谢你，非常棒！精品书，快推广！</center><h1 id="函数绘图器">函数绘图器</h1><h2 id="效果呈现">效果呈现</h2><h3 id="用户入界面">用户入界面</h3><p>函数绘图器的用户输入 <span class="math inline">\(\mbox{ui}\)</span> 界面如下，其中点击 <code>θ</code> 按钮之后，函数表达式文本字符串会增加 <span class="math inline">\(\theta\)</span> 字符串，用户在该界面中输入表达式、精度、自变量 <span class="math inline">\(x\)</span> 取值范围等信息，输入结束之后，绘图器会自动识别函数表达式类型，结合步长以及定义域生成对应的图像。</p><p><img src="https://pic.imgdb.cn/item/628c5b40094754312947880c.jpg" style="zoom:70%;" /></p><h3 id="有理函数">有理函数</h3><p>本函数绘图器首先实现只与加减乘除相关的基本函数，如<strong>多项式函数、带括号的多项式函数、有理分式函数</strong>。三者统一表达式为 <span class="math inline">\(f(x)=\dfrac{P(x)}{Q(x)}\)</span> ，其中 <span class="math inline">\(P(x)\)</span> 和 <span class="math inline">\(Q(x)\)</span> 均为多项式且 <span class="math inline">\(Q(x)\neq0\)</span>，绘制一些函数图像如下图所示：</p><p><img src="https://pic.imgdb.cn/item/628bac030947543129840abd.jpg" style="zoom:45%;" /> <span class="math display">\[\large 多项式函数:\ y=2x^3-x^2-3x+2,x\in[-1.5,1.5]\]</span> <img src="https://pic.imgdb.cn/item/628bac670947543129853239.jpg" style="zoom:60%;" /> <span class="math display">\[\large 含括号多项式函数:\ y=(x+1)\cdot (x-1)\cdot (x-2),x\in[-1.5,2.5]\]</span></p><p><img src="https://pic.imgdb.cn/item/628bb7ce0947543129a22f14.jpg" style="zoom:30%;" /> <span class="math display">\[\large 有理分式函数:\ y=\dfrac{x^2+1}{x^4+1},x\in[-2,2]\]</span></p><h3 id="其余初等函数">其余初等函数</h3><p>同时，该函数绘图器实现了<strong>三角函数、指数函数、对数函数</strong>的绘制</p><p><img src="https://pic.imgdb.cn/item/628c5c40094754312948df9a.jpg" style="zoom:30%;" /> <span class="math display">\[\large 三角混合函数:\ y=\sin x +\cos x,x\in[-5,5]\]</span> <img src="https://pic.imgdb.cn/item/628bb30c094754312995dbfc.jpg" style="zoom:40%;" /> <span class="math display">\[\large 指数函数:\ y=e^x,x\in[-2,1.5]\]</span> <img src="https://pic.imgdb.cn/item/628bb5ff09475431299db82e.jpg" style="zoom:50%;" /> <span class="math display">\[\large 对数函数:\ y=\ln x,x\in[0.05,2]\]</span></p><h3 id="极坐标函数">极坐标函数</h3><p>当点击 <span class="math inline">\(\theta\)</span> 按钮时，绘图器会自动在表达式后面增加 <span class="math inline">\(\theta\)</span> 字符串，同时定义域会自动修改为 <span class="math inline">\([0,2\pi]\)</span>（可修改），以绘制极坐标函数：</p><p><img src="https://pic.imgdb.cn/item/628c3d4f094754312922da9b.jpg" style="zoom:40%;" /> <span class="math display">\[\large 阿基米德螺旋线:\ \rho=\theta,\theta\in[0,\dfrac{3}{2}\pi]\]</span> <img src="https://pic.imgdb.cn/item/628bb8790947543129a33300.jpg" style="zoom:40%;" /> <span class="math display">\[\large 星形线:\ \rho=1-\sin \theta,\theta\in[0,2\pi]\]</span> <img src="https://pic.imgdb.cn/item/628c3c4d094754312921f7f2.jpg" style="zoom:40%;" /> <span class="math display">\[\large 极坐标函数(有理分式):\ \rho=\dfrac{\theta-1}{\theta+1},\theta\in[0,2\pi]\]</span></p><h3 id="混合函数">混合函数</h3><p>上述函数可以组合成更一般的初等函数，一些<strong>比较优雅</strong>的函数如下图所示</p><p><img src="https://pic.imgdb.cn/item/628c3b2f094754312920a828.jpg" style="zoom:40%;" /> <span class="math display">\[\large 三角函数与多项式混合:\ y=(x+1)\cdot (\sin x+1),x\in[-2,2]\]</span> <img src="https://pic.imgdb.cn/item/628c6a8909475431295d6cc6.jpg" style="zoom:50%;" /> <span class="math display">\[\large 三角函数与指数混合:\ y=\cos x\cdot e^x,\theta\in[0,2\pi]\]</span> <img src="https://pic.imgdb.cn/item/628c98b20947543129a67d4b.jpg" style="zoom:60%;" /> <span class="math display">\[\large 指数函数和多项式混合:\ y=(x^2-1)e^x,x\in[-1,1]\]</span></p><h3 id="极限修复函数">极限修复函数</h3><p>除了一些定义域上连续可微的函数，本函数绘图器实现极限修复功能，可以绘制<strong>存在第一类间断点以及第二类间断点的函数</strong>，例如：</p><p><img src="https://pic.imgdb.cn/item/628c519609475431293bb1c0.jpg" style="zoom:40%;" /> <span class="math display">\[\large 与e相关的函数:\ y=x\ln(1+\dfrac{1}{x}),x\in[0,2]\]</span> <img src="https://pic.imgdb.cn/item/628c5829094754312943dcc9.jpg" style="zoom:50%;" /> <span class="math display">\[\large 一次函数:\ y=\dfrac{2x^2}{x},x\in[-2,2]\]</span> <img src="https://pic.imgdb.cn/item/628c4d0e094754312935d3af.jpg" style="zoom:40%;" /> <span class="math display">\[\large 正弦极限函数:\ y=\dfrac{\sin x}{x},x\in[-5,5]\]</span></p><h2 id="框架构建">框架构建</h2><p>该函数绘图器大作业使用 <span class="math inline">\(\mbox{QT}\)</span> 编写，共编写 <span class="math inline">\(18\)</span> 个文件（ <span class="math inline">\(8\)</span> 个头文件，<span class="math inline">\(8\)</span> 个 <span class="math inline">\(\mbox{C++}\)</span> 文件，<span class="math inline">\(2\)</span> 个 <span class="math inline">\(\mbox{ui}\)</span> 文件）</p><p>其中 <span class="math inline">\(\mbox{Utils.h}\)</span> 头文件中定义一些数学常数（如 <span class="math inline">\(\pi,e\)</span> ），以及一些<strong>内联函数</strong>，形成一种<strong>函数工具包</strong>便于调用，其余除生成实例对象的 <span class="math inline">\(\mbox{main.cpp}\)</span> 之外均分为头文件和源文件 <span class="math inline">\((\mbox{.h/cpp})\)</span> ，且每对文件只针对一个类，各种类之间尽量<strong>解耦</strong>以及<strong>模块化</strong>，各文件之间的层级关系以及功能如下图所示：</p><pre><code class="mermaid" >flowchart TD    A([main.cpp]) --实例对象--> B([mainwindow.h/cpp])    C((mainwindow.ui)) --用户输入--> B    B -->|后端图像| D([latexImg.h/cpp])    B --->|前端展示| E([dialog.h/cpp])    B --后端数据--> F([Expression.h/cpp])    F --直角坐标系--> G([recExp.h/cpp])    F --极坐标系--> H([polarExp.h/cpp])    G --表达式以及异常处理--> I[(vector< double > x,y)]    H --表达式以及异常处理--> I    D --转换latex格式--> J[downloader.h/cpp]J --URL网络请求--> K[(QPixmap img)]K --图像背景更换--> L{graph}I --线性重排以及调整--> LE --> M((dialog.ui))M --高精度计时器-->LN[Utils.h] --内联函数-->B</code></pre><p>对于绘制函数图像这一需求，设计上先分为<strong>前端和后端</strong>，后端处理分为数据双列表的计算以及 <span class="math inline">\(\LaTeX\)</span> 图像的获取，前端将后端得到的内容进行重排以及处理，最终展示得到相应的含 <span class="math inline">\(\LaTeX\)</span> 表达式的图像</p><h2 id="实现细节">实现细节</h2><h3 id="mboxutils.h-工具函数"><span class="math inline">\(\mbox{Utils.h}\)</span> 工具函数</h3><p>该头文件实现一些工具函数，有字符串处理、背景颜色更换、获取 <span class="math inline">\(\mbox{vector}\)</span> 对象中的最大值最小值、使用 <span class="math inline">\(\mbox{C++}\)</span> 文件流的操作转换 <span class="math inline">\(\mbox{double}\)</span> 类型数据和 <span class="math inline">\(\mbox{string}\)</span> 类型数据几种函数。例如其中更改背景颜色的工具函数中使用 <span class="math inline">\(\mbox{QColor}\)</span> 类创建白色和灰色实例对象，将从网络上获取到的 <span class="math inline">\(\LaTeX\)</span> 图像中的白色背景转换为灰色，以适应函数图像的背景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//更改背景颜色</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> QPixmap <span class="hljs-title">changeBackGroundColor</span><span class="hljs-params">(QPixmap img)</span></span>&#123;<br>    <span class="hljs-function">QColor <span class="hljs-title">white</span><span class="hljs-params">(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)</span></span>;<br>    <span class="hljs-function">QColor <span class="hljs-title">grey</span><span class="hljs-params">(<span class="hljs-number">240</span>, <span class="hljs-number">240</span>, <span class="hljs-number">240</span>)</span></span>;<br>    QImage image = img.<span class="hljs-built_in">toImage</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;w &lt; image.<span class="hljs-built_in">width</span>();w++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> h = <span class="hljs-number">0</span>; h &lt; image.<span class="hljs-built_in">height</span>();h++)&#123;<br>            QRgb rgb = image.<span class="hljs-built_in">pixel</span>(w, h);<br>            <span class="hljs-keyword">if</span> (rgb == white.<span class="hljs-built_in">rgb</span>())<br>                image.<span class="hljs-built_in">setPixel</span>(w, h, grey.<span class="hljs-built_in">rgba</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> QPixmap::<span class="hljs-built_in">fromImage</span>(image);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数可以将以白色为背景的图片转换为以灰色为背景的图片：</p><p><img src="https://pic.imgdb.cn/item/628b8d0509475431292d1d3a.jpg" style="zoom:20%;" /></p><h3 id="内联函数">内联函数</h3><p><span class="math inline">\(\mbox{Utils.g}\)</span> 文件中均使用内联函数，<span class="math inline">\(\mbox{wiki}\)</span> 上对 <code>inline function</code> 的定义如下：</p><blockquote><p>It serves as a compiler directive that suggests (but does not require) that the <strong>compiler</strong> substitute the body of the function inline by performing <strong>inline expansion</strong>, i.e. by inserting the function code at the address of each function call, thereby saving the overhead of a function call.</p></blockquote><p>可见，内联函数通过直接在调用点展开的方式节约函数调用的开销，这对于一些工具函数是合理的，毕竟这些工具函数不需要专门的类加以封装，对于所有类中的方法，均可以直接进行调用展开即可。</p><p>在 <span class="math inline">\(\mbox{C++}\)</span> 中也可以使用 <span class="math inline">\(\mbox{lambda}\)</span> 匿名函数实现函数的插入。 <span class="math inline">\(\mbox{lambda}\)</span> 表达式是 <span class="math inline">\(\mbox{C++}\)</span> 发展史上的一个重大事件，也是 <span class="math inline">\(\mbox{C++}\)</span> 支持函数式编程的重要一环。</p><p><strong><span class="math inline">\(\mbox{C++}\)</span> 既融合了面向对象编程的约束，也融合了函数式编程的自由，一张一弛，乃编程之道</strong>。<span class="math inline">\(\mbox{lambda}\)</span> 表达式在数学上可以证明为图灵完备的，其开创了 <span class="math inline">\(\mbox{C++}\)</span> 的一个崭新编程范式。</p><p>具体来说，<span class="math inline">\(\mbox{lambda}\)</span> 表达式可以看做是一个临时使用的、嵌入在几乎任何地方的函数，简单示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> maxVec = [](vector&lt;<span class="hljs-type">double</span>&gt; x)&#123; <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(x.<span class="hljs-built_in">begin</span>(), x.<span class="hljs-built_in">end</span>()); &#125;;<br>    <span class="hljs-comment">// maxVec 为 lambda 表达式，代表一个函数</span><br>    vector&lt;<span class="hljs-type">double</span>&gt; a&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">maxVec</span>(a) &lt;&lt; endl;<span class="hljs-comment">// 使用起来相当于一个函数，可重复调用多个 Vector </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在编写代码过程中，对于一些不需要专门声明的函数，可以使用上述 <span class="math inline">\(\mbox{lambda}\)</span> 表达式，<span class="math inline">\(\mbox{lambda}\)</span> 表达式还可以使将函数内部的局部变量进行捕获，防止函数作用完成之后原始数据丢失的情况，由于该特性没有在代码编写中使用，这里不再展开。</p><h3 id="后端数据处理">后端数据处理</h3><p>采用正则表达式的方法对表达式中的对各种运算进行逐一搜索递归计算，下面给出所有正则表达式运算优先级代码，在初等函数的分类下，共 <span class="math inline">\(17\)</span> 个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::regex Expression::priority[<span class="hljs-number">17</span>]&#123;<br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(.*)\\+(.*)&quot;</span>),              <span class="hljs-comment">//0，加</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(.*)\\-(.*)&quot;</span>),              <span class="hljs-comment">//1，减</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(.*)\\*(.*)&quot;</span>),              <span class="hljs-comment">//2，乘</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(.*)/(.*)&quot;</span>),                <span class="hljs-comment">//3，除</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(.*)\\^(.*)&quot;</span>),              <span class="hljs-comment">//4，次方</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;sin(.*)&quot;</span>),                  <span class="hljs-comment">//5，正弦</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;cos(.*)&quot;</span>),                  <span class="hljs-comment">//6，余弦</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;tan(.*)&quot;</span>),                  <span class="hljs-comment">//7，正切</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;arcsin(.*)&quot;</span>),               <span class="hljs-comment">//8，反正弦</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;arccos(.*)&quot;</span>),               <span class="hljs-comment">//9，反余弦</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;arctan(.*)&quot;</span>),               <span class="hljs-comment">//10，反正切</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;log\\((.*),(.*)\\)&quot;</span>),       <span class="hljs-comment">//11，以 10 为底对数</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;ln(.*)&quot;</span>),                   <span class="hljs-comment">//12，以 e 为底对数</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;(^(-?\\d+)(\\.\\d+)?$)&quot;</span>),   <span class="hljs-comment">//13，单个常数（包括任何小数）</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;x&quot;</span>),                        <span class="hljs-comment">//14，自变量符号 x</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;e&quot;</span>),                        <span class="hljs-comment">//15，自然底数 e</span><br>    std::<span class="hljs-built_in">regex</span>(<span class="hljs-string">&quot;π&quot;</span>)                         <span class="hljs-comment">//16，圆周率 π</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>运算级较低的符号应该放在最后计算，由于递归的特点，其应该在前面进行检测，在运算时，只需要依次遍历每个正则表达式，若符合要求，则将表达式拆成几个部分进行递归计算，其流程图（仅有 <span class="math inline">\(2\)</span> 次递归）如下：</p><pre><code class="mermaid" >flowchart TDA[A operator B] --> B[A]A[A operator B] --- C(operator)A[A operator B] --> D[B]B <--> O[a1]B <--> P[operator]B <--> Q[a2]B --data--> CD --data--> CD <--> R[b1]D <--> S[operator]D <--> T[b2]C -->Z[result]</code></pre><p>对于输入表达式有误进行异常处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//合法、括号不匹配、分子不为0且分母为0、分子分母均为0（可能存在极限）、非括号运算符错误、常数错误（小数点出错）、函数无定义</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">judge</span>&#123;isLegal, mismatch, divisorZero, perhapsLim, operatorInlegal, constantInlegal, undefined&#125;;<br>    std::map&lt;<span class="hljs-type">double</span>, judge&gt; judges;<br></code></pre></td></tr></table></figure><p>采用枚举各种错误的方式，对于括号不匹配，分母为 <span class="math inline">\(0\)</span> 等一些异常处理进行相应的判断。使用标准库中的 <span class="math inline">\(\mathbf{map}\)</span> 数据结构，将对应自变量 <span class="math inline">\(x\)</span> 与相关判断构成映射关系，方便之后统一处理，例如对于 <code>/</code> 的处理如下，其中由于计算机浮点数误差，采用比较 <span class="math inline">\(\mbox{tolerance}\)</span> 误差的方法进行判定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-comment">//正则表达式以 / 为界切分为两部分，调用 str() 函数构造两个新的 Expression 实例对象</span><br><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_search</span>(<span class="hljs-keyword">this</span>-&gt;exp, m, priority[<span class="hljs-number">3</span>]))&#123;<br>       Expression e1&#123; m[<span class="hljs-number">1</span>].<span class="hljs-built_in">str</span>(), x &#125;;<br>       Expression e2&#123; m[<span class="hljs-number">2</span>].<span class="hljs-built_in">str</span>(), x &#125;;<br>       <span class="hljs-comment">//分子&quot;不为0&quot;，分母&quot;为0&quot;</span><br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(e2) &lt; tol &amp;&amp; <span class="hljs-built_in">fabs</span>(e1) &gt; tol)<br>           judges[x] = judge::divisorZero;<br>       <span class="hljs-comment">//分子&quot;为0&quot;，分母也&quot;为0&quot;，有可能存在极限</span><br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(e2) &lt; tol &amp;&amp; <span class="hljs-built_in">fabs</span>(e1) &lt; tol)<br>           judges[x] = judge::perhapsLim;<br>       cout &lt;&lt; errorStrings[judges[x]] &lt;&lt; endl;<br>       <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>(judges[x]) == <span class="hljs-number">0</span>)? e1 / e2 : <span class="hljs-number">0</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>最后在处理 <code>vector&lt;double&gt; x,y</code> 时若出现极限可能存在的情况，考虑其两侧的函数值，如果两者差异过大，则该处极限不存在，如果两者差异不大，则该处极限可以用两侧的点取平均得到近似解，写成数学表达式有 <span class="math display">\[\begin{gathered}|\lim_{x\to x_0^+}f(x)-\lim_{x\to x_0^-}f(x)|&lt;\mbox{tolerance} , \lim_{x\to x_0}f(x)\ \  \mbox{exists}\\|\lim_{x\to x_0^+}f(x)-\lim_{x\to x_0^-}f(x)|\geq \mbox{tolerance} , \lim_{x\to x_0}f(x)\ \  \mbox{doesn&#39;t exist}\end{gathered}\]</span></p><p>相关处理函数如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">int</span>(x.<span class="hljs-built_in">size</span>()); i++)&#123;<br>    judges[x[i]] = judge::isLegal;<br>    y.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getValue</span>(x[i]));<br>    <span class="hljs-comment">//如果这个点存在极限，判定两侧的差值是否较大，如果不大则使用平均值</span><br>    <span class="hljs-keyword">if</span> (judges[x[i]] == judge::perhapsLim &amp;&amp; <span class="hljs-number">0</span> &lt; i &amp;&amp; i + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">int</span>(y.<span class="hljs-built_in">size</span>()) )&#123;<br>        judges[x[i + <span class="hljs-number">1</span>]] = judge::isLegal;<br>        y.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getValue</span>(y[i + <span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(y[i + <span class="hljs-number">1</span>] - y[i - <span class="hljs-number">1</span>]) &lt;= <span class="hljs-number">100</span> * tol)&#123;<br>            y[i] = (y[i + <span class="hljs-number">1</span>] + y[i - <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;<br>            judges[x[i]] = judge::isLegal;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            judges[x[i]] = judge::divisorZero;<br>            cout &lt;&lt; x[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y[i + <span class="hljs-number">1</span>] &lt;&lt; endl;<br>        &#125;<br>        i += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理之后得到的 <span class="math inline">\(\mbox{x,y}\)</span> 两列表还需要单独针对极坐标系进行计算，相应计算公式如下： <span class="math display">\[\begin{cases}x=\rho \cos \theta\\y=\rho \sin \theta\end{cases}\]</span> 针对两个继承的类，使用<strong>函数重载</strong>对两种情况进行处理，在 <span class="math inline">\(\mbox{mainwindow.h/cpp}\)</span> 中通过查找是否存在 <code>"θ"</code> 字符串判定需要定义的类，该类中的运算方法都继承自 <code>class Expression</code> ，<strong>复用</strong>相同的使用正则表达式计算对应的函数值。</p><h3 id="迭代器">迭代器</h3><p>在处理一些冗余点时，使用 <code>iterator</code> 迭代器以及 <span class="math inline">\(\mbox{C++}\)</span> 新特性对 <span class="math inline">\(\mbox{vector}\)</span> 中的元素进行迭代， <span class="math inline">\(\mbox{wiki}\)</span> 中对 <span class="math inline">\(\mbox{iterator}\)</span> 的解释如下：</p><blockquote><p>In computer programming, an iterator is an object that enables a programmer to traverse a container, particularly lists.</p></blockquote><p><span class="math inline">\(\mbox{C++}\)</span> 语言在其标准库中广泛使用了迭代器，并描述了几类选代器，它们所允许的操作不同。这些包括前向选代器、双向选代器和随机访问选代器，在 <span class="math inline">\(\mbox{C++}\)</span> 语言中还支持自定义迭代器，更加方便构建适用的类，例如机器学习中对数据预处理就可以使用迭代器的方式进行处理（ 依照 <span class="math inline">\(\mbox{epoch,batch}\)</span> 的大小分批次处理数据），这样可以在调用接口处使用 <span class="math inline">\(\mbox{auto}\)</span> 语句更加简洁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataLoader</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//乱序编码位置</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; _rand_order;<br>    <span class="hljs-comment">//每个 batch 的最大长度，总组数</span><br>    <span class="hljs-type">int</span> batch_size = <span class="hljs-number">0</span>, endIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//所有句子编码（顺序排列）</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; _data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//三维数组</span><br>    vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; ans;<br>    <span class="hljs-comment">// 迭代器，取出 ans 对应下标结果</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Iterator</span><br>    &#123;<br>        <span class="hljs-comment">//标签</span><br>        <span class="hljs-keyword">using</span> iterator_category = std::forward_iterator_tag;<br>        <span class="hljs-keyword">using</span> difference_type   = std::<span class="hljs-type">ptrdiff_t</span>;<br>        <span class="hljs-keyword">using</span> value_type        = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;;<br>        <span class="hljs-keyword">using</span> reference         = value_type&amp;;<span class="hljs-comment">// 迭代器所指向的变量的引用类型</span><br>        <span class="hljs-keyword">using</span> pointer           = value_type*;<span class="hljs-comment">// 迭代器所指向的变量的指针类型</span><br>    <span class="hljs-keyword">private</span>:<br>        pointer m_ptr;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Iterator</span>(pointer ptr) : <span class="hljs-built_in">m_ptr</span>(ptr) &#123;&#125;<br>        reference <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *m_ptr; &#125;<br>        pointer <span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> m_ptr; &#125;<br>        <span class="hljs-comment">//前缀 ++</span><br>        Iterator&amp; <span class="hljs-keyword">operator</span>++() &#123; m_ptr++; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;   <span class="hljs-comment">// ++i</span><br>        <span class="hljs-comment">//后缀 ++</span><br>        Iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123; Iterator tmp = *<span class="hljs-keyword">this</span>; ++(*<span class="hljs-keyword">this</span>); <span class="hljs-keyword">return</span> tmp; &#125;<br>    &#125;;<br>    <span class="hljs-comment">//迭代器开始</span><br>    <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(&amp;ans[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// 返回迭代器</span><br>    &#125;<br>    <span class="hljs-comment">//迭代器结束</span><br>    <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Iterator</span>(&amp;ans[endIndex]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>auto batch : D</code> 等同于 <code>iteractor it = D.begin(); it &lt; D.end();it++, batch = *it</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> batch : D)&#123;<br>    string str = <span class="hljs-built_in">matrix_unicode</span>(batch);<br>    cout&lt;&lt; str &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可见，将迭代器和 <span class="math inline">\(\mbox{auto}\)</span> 关键字可以简化代码的编写，对于本次函数绘图器而言，若出现一些需要去除的点（已经极限修复的点不算），则将 <span class="math inline">\(\mbox{vetcor&lt;double&gt; x,y}\)</span> 中对应的 <span class="math inline">\((x,y)\)</span> 均删除，实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = x.<span class="hljs-built_in">begin</span>(), j = y.<span class="hljs-built_in">begin</span>(); i != x.<span class="hljs-built_in">end</span>() &amp;&amp; j != y.<span class="hljs-built_in">end</span>(); i++, j++)&#123;<br>    <span class="hljs-comment">//如果这个点为特殊点，将其删除</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span>(judges[*i]) != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// temp.erase返回迭代器，将不合法的元素全部删除</span><br>        i = x.<span class="hljs-built_in">erase</span>(i);<br>        j = y.<span class="hljs-built_in">erase</span>(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用两个迭代器同向遍历，遇到出现问题的点就自动对应删除，达到删除不合理点的目的，例如 <span class="math inline">\(f(x)=\dfrac{1}{x}\)</span> 中 <span class="math inline">\(x=0\)</span> 的点，在处理时便自动删除该间断点。</p><h3 id="后端图像处理">后端图像处理</h3><p>在编写函数绘图器的过程中，曾经使用过与 <span class="math inline">\(\mbox{Qt 4.0}\)</span> 版本兼容的排版库 <span class="math inline">\(\mbox{miktex}\)</span>，但由于当前 <span class="math inline">\(\mbox{Qt}\)</span> 版本为 <span class="math inline">\(6.2.4\)</span> 无法和该排版库兼容，另一方面，<span class="math inline">\(\mbox{miktex}\)</span> 在数学公式渲染方面有一定缺陷，需要更换思路。</p><p>进而想到 <span class="math inline">\(\mbox{Qt}\)</span> 有相应的网络包，可以通过给定的 <span class="math inline">\(\mbox{URL}\)</span> 网址获取对应的图片，而 <span class="math inline">\(\mbox{latex.codecogs.com}\)</span> 官网提供可以直接获取 <span class="math inline">\(\LaTeX\)</span> 排版之后的图片，经过清晰化调整之后在以下网址 <span class="math display">\[\mbox{https://latex.codecogs.com/png.latex?\%5Cdpi\%7B300\%7D\%20\%5Cbg\_white\%20\%5Chuge\%20}\]</span> 后面添加正确的 <span class="math inline">\(\LaTeX\)</span> 公式（如 <span class="math inline">\(\mbox{y=\\dfrac\{\\sin x\}\{x}\small\wedge\normalsize \mbox{2+1\}}\)</span>），便可以获取对应图片，相应的 <span class="math inline">\(y=\dfrac{\sin x}{x^2+1}\)</span> 在该<a href="https://latex.codecogs.com/png.latex?%5Cdpi%7B300%7D%20%5Cbg_white%20%5Chuge%20y=\dfrac%7B\sin%20x%7D%7Bx%5E2+1%7D">网址</a>中便可得到以下高清图片：</p><p><img src="https://pic.imgdb.cn/item/628ce54c09475431292c425d.jpg" style="zoom:50%;" /></p><p>将一般表达式转换到 <span class="math inline">\(\LaTeX\)</span> 表达式单独列封装成一个类 <span class="math inline">\(\mbox{latexImg.h/cpp}\)</span>，针对各种表达式进行替换，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;pair&lt;string, string&gt;&gt; replaceLatex = &#123;&#123;<span class="hljs-string">&quot;θ&quot;</span>,<span class="hljs-string">&quot;\\theta&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;π&quot;</span>, <span class="hljs-string">&quot;\\pi&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;（&quot;</span>, <span class="hljs-string">&quot;(&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;）&quot;</span>, <span class="hljs-string">&quot;)&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;)*(&quot;</span>, <span class="hljs-string">&quot;) \\cdot (&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;)(&quot;</span>, <span class="hljs-string">&quot;) \\cdot (&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;PI&quot;</span>, <span class="hljs-string">&quot; \\pi &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;Pi&quot;</span>, <span class="hljs-string">&quot; \\pi &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;pi&quot;</span>, <span class="hljs-string">&quot; \\pi &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;x*(&quot;</span>,<span class="hljs-string">&quot;x \\cdot (&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;x(&quot;</span>,<span class="hljs-string">&quot;x \\cdot (&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;)*x&quot;</span>, <span class="hljs-string">&quot;) \\cdot x&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;)x&quot;</span>,<span class="hljs-string">&quot;) \\cdot x&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;sin&quot;</span>, <span class="hljs-string">&quot; \\Sin &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;cos&quot;</span>, <span class="hljs-string">&quot; \\Cos &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot; \\Tan &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;ln&quot;</span>, <span class="hljs-string">&quot; \\Ln &quot;</span>&#125;, &#123;<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot; \\cdot &quot;</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pr : solveRepeations)<br>    latexStr = <span class="hljs-built_in">replace_all</span>(latexStr, pr.first, pr.second);<br></code></pre></td></tr></table></figure><p>使用 <span class="math inline">\(\mbox{pair}\)</span> 数据结构以及 <span class="math inline">\(\mbox{auto}\)</span> 的使用，对成对的字符串进行替换，再编写 <code>removeRedundant()</code> 函数专门处理和分式相关的字符串，例如将 <span class="math inline">\(\mbox{1/x}\)</span> 转换为 <span class="math inline">\(\mbox{\\dfrac\{1\}\{x\}}\)</span> 依此类推</p><p>有关网络请求获取图片的代码如下，编写在 <span class="math inline">\(\mbox{mainwindow.cpp}\)</span> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::getImg</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//在函数里面定义一个类的实例对象，需要在前面加上关键词 class</span><br>    <span class="hljs-comment">//使用 latexImg 对象获取对应表达式的 latex 图片</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">latexImg</span> latex&#123;<span class="hljs-keyword">this</span>-&gt;exp.<span class="hljs-built_in">toStdString</span>(), isRec&#125;;<br>    string latexURL = latex.<span class="hljs-built_in">getURL</span>();<br>    <span class="hljs-comment">//构造 QNetworkAccessManage 实例模拟获取网页的过程</span><br>    <span class="hljs-function">QUrl <span class="hljs-title">url</span><span class="hljs-params">(QString::fromStdString(latexURL))</span></span>;<br>    QNetworkAccessManager manager;<br>    QEventLoop loop;<br>    QNetworkReply *reply = manager.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">QNetworkRequest</span>(url));<br>    <span class="hljs-comment">//请求结束并下载完成后，退出子事件循环</span><br>    QObject::<span class="hljs-built_in">connect</span>(reply, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">finished</span>()), &amp;loop, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">quit</span>()));<br>    <span class="hljs-comment">//开启子事件循环</span><br>    loop.<span class="hljs-built_in">exec</span>();<br>    QByteArray jpegData = reply-&gt;<span class="hljs-built_in">readAll</span>();<br>    <span class="hljs-comment">//将获取图片存储在 mainwindow 中</span><br>    latexImg.<span class="hljs-built_in">loadFromData</span>(jpegData);<br>&#125;<br></code></pre></td></tr></table></figure><p>在调试过程中发现，对于类中的方法，如果函数里面定义一个类的实例对象，需要在前面加上关键词 <code>class</code>，否则编译不通过</p><h2 id="前端展示">前端展示</h2><p>对于主窗口，使用 <span class="math inline">\(\mbox{Qt}\)</span> 中的设计师界面添加相应的按钮以及修改相应的初始值，设计相应的前端框架界面</p><p><img src="https://pic.imgdb.cn/item/628cf1f4094754312940eff6.jpg" /></p><p>对于从后端拿到的<strong>数据</strong>，分别进行等比例缩放以及在合适的位置处增加坐标轴和标度，从数学的角度来说，该步骤是将数据所在的线性空间<strong>线性且合适地映射</strong>到画布所在的线性空间。注意绘图原点在左上角，<span class="math inline">\(x\)</span> 方向向右，<span class="math inline">\(y\)</span> 方向向下，绘制的坐标轴处的箭头需要一定的偏置，本绘图器采用 <span class="math inline">\(45\degree\)</span> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-comment">// x 放大倍数</span><br>   <span class="hljs-type">int</span> zoomOutX = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() * <span class="hljs-number">0.9</span> / width;<br>   <span class="hljs-comment">// y 放大倍数</span><br>   <span class="hljs-type">int</span> zoomOutY = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.9</span> / height;<br>   <span class="hljs-comment">//放大倍数，取较小者</span><br>   <span class="hljs-type">int</span> zoomOut = zoomOutX &lt; zoomOutY ? zoomOutX : zoomOutY;<br><span class="hljs-comment">//原点 x</span><br>   <span class="hljs-type">double</span> originX = offsetX * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() * <span class="hljs-number">0.05</span>;<br>   <span class="hljs-comment">//原点 y</span><br>   <span class="hljs-type">double</span> originY = offsetY * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.05</span>;<br>   minX = (minX + offsetX) * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() * <span class="hljs-number">0.05</span>;<br>   maxX = (maxX + offsetX) * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() * <span class="hljs-number">0.05</span>;<br>   minY = (minY + offsetY) * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.05</span>;<br>   maxY = (maxY + offsetY) * zoomOut + <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.05</span>;<br>   <span class="hljs-comment">// x 轴</span><br>   <span class="hljs-function">QLine <span class="hljs-title">xLine</span><span class="hljs-params">(minX, originY, maxX, originY)</span></span>;<br>   qPainter.<span class="hljs-built_in">drawLine</span>(xLine);<br>   <span class="hljs-comment">// y 轴</span><br>   <span class="hljs-function">QLine <span class="hljs-title">yLine</span><span class="hljs-params">(originX, minY, originX, maxY)</span></span>;<br>qPainter.<span class="hljs-built_in">drawLine</span>(yLine);<br>   <span class="hljs-comment">//绘制原点、x轴、y轴处的字符</span><br>   qPainter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">QPointF</span>(originX + <span class="hljs-number">2</span>, originY - <span class="hljs-number">2</span>), <span class="hljs-string">&quot;O&quot;</span>);<br>   qPainter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">QPointF</span>(maxX, originY - <span class="hljs-number">7</span>), <span class="hljs-string">&quot;x&quot;</span>);<br>   qPainter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">QPointF</span>(originX + <span class="hljs-number">7</span>, minY), <span class="hljs-string">&quot;y&quot;</span>);<br>   <span class="hljs-comment">//绘制箭头，45°方向绘制箭头</span><br>   QLineF *arrows = <span class="hljs-keyword">new</span> QLineF[<span class="hljs-number">4</span>]&#123;&#123;maxX, originY, maxX - <span class="hljs-number">5</span>, originY - <span class="hljs-number">5</span>&#125;,<br>                                  &#123;maxX, originY, maxX - <span class="hljs-number">5</span>, originY + <span class="hljs-number">5</span>&#125;,<br>                                  &#123;originX, minY, originX - <span class="hljs-number">5</span>, minY + <span class="hljs-number">5</span>&#125;,<br>                                  &#123;originX, minY, originX + <span class="hljs-number">5</span>, minY + <span class="hljs-number">5</span>&#125;&#125;;<br><br></code></pre></td></tr></table></figure><p>而绘制刻度时，原点需要作为一个刻度，<span class="math inline">\(y\)</span> 轴需要正负号分别计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;originY + i * hSpacer &lt;= maxScreenY;i++)&#123;<br>       <span class="hljs-type">int</span> screenY = originY + i * hSpacer;<br>       qPainter.<span class="hljs-built_in">drawLine</span>(originX, screenY, originX + <span class="hljs-number">3</span>, screenY);<br>       <span class="hljs-type">double</span> realY = (screenY - <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.05</span>) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(zoomOut) - offsetY;<br>       qPainter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">QPoint</span>(originX + <span class="hljs-number">13</span>, screenY + <span class="hljs-number">5</span>), QString::<span class="hljs-built_in">number</span>(-realY, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">2</span>));<br>   &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;originY - i * hSpacer &gt;= minScreenY;i++)&#123;<br>       <span class="hljs-type">int</span> screenY = originY - i * hSpacer;<br>       qPainter.<span class="hljs-built_in">drawLine</span>(originX, screenY, originX + <span class="hljs-number">3</span>, screenY);<br>       <span class="hljs-type">double</span> realY = (screenY - <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.05</span>) / <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(zoomOut) - offsetY;<br>       qPainter.<span class="hljs-built_in">drawText</span>(<span class="hljs-built_in">QPoint</span>(originX + <span class="hljs-number">13</span>, screenY + <span class="hljs-number">5</span>), QString::<span class="hljs-built_in">number</span>(-realY, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">2</span>));<br>   &#125;<br></code></pre></td></tr></table></figure><p>同理，对于从后端拿到的<strong>图像</strong>，进行背景颜色的替换再通过计算当前画大小得到相应的右上角位置，并最后设置画笔为蓝色，调用 <span class="math inline">\(\mbox{Qt}\)</span> 中的 <code>qPainter.drawPolyline(points, size)</code> 函数平滑连接各点，得到相应的图像</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-comment">//获取当前画布宽度和高度</span><br><span class="hljs-type">double</span> imgWidth = originImg.<span class="hljs-built_in">width</span>();<br>   <span class="hljs-type">double</span> imgHeight = originImg.<span class="hljs-built_in">height</span>();<br><span class="hljs-comment">//比较得到图片的高度</span><br>   <span class="hljs-type">int</span> sizeImg = <span class="hljs-built_in">MIN</span>(<span class="hljs-number">60</span>, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() / <span class="hljs-number">1.2</span> / imgWidth * imgHeight);<br><span class="hljs-comment">//将图片放置在合适的位置</span><br>   qPainter.<span class="hljs-built_in">drawPixmap</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>() - sizeImg * <span class="hljs-number">1.2</span> * imgWidth / imgHeight, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>() * <span class="hljs-number">0.1</span>, sizeImg * imgWidth / imgHeight, sizeImg, <span class="hljs-built_in">changeBackGroundColor</span>(originImg));<br>   qPainter.<span class="hljs-built_in">setPen</span>(<span class="hljs-built_in">QColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>));<br>   qPainter.<span class="hljs-built_in">drawPolyline</span>(points, size);<br></code></pre></td></tr></table></figure><h3 id="高精度计时">高精度计时</h3><p>关于这部分，可以访问本人博客有关 <span class="math inline">\(\mbox{OOP}\)</span> 第二次小作业报告中的探讨，网址如下<a href="https://lr-tsinghua11.github.io/2022/03/06/Program/OOP%20Homework%202/">面向对象编程第二次作业</a></p><p>大致为调用相关 <span class="math inline">\(\mbox{API}\)</span> ，通过所在电脑的频率和计数器高精度计算相关时间，并将时间显示在图像标题处</p><h2 id="单元测试">单元测试</h2><h3 id="表达式函数">表达式函数</h3><p>由于 <span class="math inline">\(\mbox{Qt}\)</span> 相关的 <span class="math inline">\(\mbox{ui}\)</span> 界面在编写过程中已经写好，对于该表达式函数，使用 <span class="math inline">\(\mbox{Visual studio}\)</span> 单独定义该类并进行测试，通过的测试样例如下（其中大致可以分为几个部分）：</p><table><thead><tr class="header"><th>单元测试分类</th><th>实例</th></tr></thead><tbody><tr class="odd"><td>乘法含负号</td><td><code>Expression e("2*(-2)");</code></td></tr><tr class="even"><td>除法含负号</td><td><code>Expression e("-1/1");</code></td></tr><tr class="odd"><td>加减（含括号）</td><td><code>Expression e("(-1+1)*(-1-1)");</code></td></tr><tr class="even"><td>加乘（含括号）</td><td><code>Expression e("(1+2)*(2+3)");</code></td></tr><tr class="odd"><td>加减乘（含括号）</td><td><code>Expression e("(1+1)*(1-1)");</code></td></tr><tr class="even"><td>加乘（含括号和负号）</td><td><code>Expression e&#123; "-(-(2*4-1*3))",1&#125;;</code></td></tr><tr class="odd"><td>加减和幂次</td><td><code>Expression e("-1^3+3*1");</code></td></tr><tr class="even"><td>加减除幂次</td><td><code>Expression e("(x^2-1)/(x+1)");</code></td></tr><tr class="odd"><td>三角函数（含负号）</td><td><code>Expression e("sin(-1)");</code> <code>Expression e("tan(-1000)");</code></td></tr></tbody></table><p>调取之后输出相应的结果并口算进行验证，结果符合预测，验证代码如下，在表达式分段处加入 <code>cout &lt;&lt; Exp</code> 等语句调试上述正则表达式相关过程，进行 <span class="math inline">\(\mbox{Debug}\)</span>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;The result is &quot;</span> &lt;&lt; e.<span class="hljs-built_in">getValue</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Judge is &quot;</span> &lt;&lt; e.judges[<span class="hljs-built_in">double</span>(<span class="hljs-number">0</span>)] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><span class="math inline">\(\mbox{Visual Studio}\)</span> 中单元测试代码截屏如下：</p><p><img src="https://pic.imgdb.cn/item/628cf6b7094754312948beb1.jpg" style="zoom:40%;" /></p><h3 id="处理-latex-公式">处理 <span class="math inline">\(\LaTeX\)</span> 公式</h3><p>在中后期编写处理 <span class="math inline">\(\LaTeX\)</span> 公式进行单元测试，采用 <span class="math inline">\(\mbox{wsl/Linux}\)</span> 子系统控制台终端进行测试，摆脱大型 <span class="math inline">\(\mbox{IDE}\)</span> 的束缚，让代码输入输出全部都在 <span class="math inline">\(\mbox{powershell}\)</span> 中进行，能够达到快速 <span class="math inline">\(\mbox{Debug}\)</span> 的效果，截图如下：</p><p><img src="https://pic.imgdb.cn/item/628cf9e809475431294dfcd6.jpg" style="zoom:60%;" /></p><p>其中可以在控制台中使用重定向 <code>&gt;</code> 运算符将输入输出结果保存到相应的 <span class="math inline">\(\mbox{txt}\)</span> 文件中，测试通过的样例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-number">1</span>/x \dfrac&#123;<span class="hljs-number">1</span>&#125;&#123;x&#125;<br><span class="hljs-number">1</span>/x+<span class="hljs-number">2</span>/x \dfrac&#123;<span class="hljs-number">1</span>&#125;&#123;x&#125;+\dfrac&#123;<span class="hljs-number">2</span>&#125;&#123;x&#125;<br>(<span class="hljs-number">1</span>+x)/x \dfrac&#123;<span class="hljs-number">1</span>+x&#125;&#123;x&#125;<br><span class="hljs-number">1</span>/(x+<span class="hljs-number">1</span>) \dfrac&#123;<span class="hljs-number">1</span>&#125;&#123;x+<span class="hljs-number">1</span>&#125;<br>(x+<span class="hljs-number">2</span>)/(x+<span class="hljs-number">1</span>) \dfrac&#123;x+<span class="hljs-number">2</span>&#125;&#123;x+<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>对于多重分式需要括号匹配，该公式转换会出现一些问题。但是，在函数绘制中很少出现这种情形，如 <span class="math inline">\(\dfrac{1+\dfrac{1}{x}}{x}=\dfrac{x+1}{x^2}\)</span> 总可以通过手工化简的方式简化为只需要一个分号的形式，不需要考虑多重分式的情况。</p><p>从而该单元测试函数的测试至此为止，<strong>否则会极大影响开发进度</strong>。</p><h2 id="总结与反思">总结与反思</h2><ul><li><p>该函数绘图器中正则表达式遍历查找的算法时间消耗比较大，对一般的函数基本消耗时间 <span class="math inline">\(\in[1s,2s]\)</span> ，由于数据结构相关课程没有学习，猜测一些树的结构能够加快运算速度</p></li><li><p>本次函数绘图器开发周期至少整整 <span class="math inline">\(7\)</span> 天，从最开始的手足无措，到后面一点点列出需求文档不断进行实现和填充，在需求和实现之间追求高效率地开发，之前编写的函数绘图器需求文档截图如下：</p><p><img src="https://pic.imgdb.cn/item/628cffa70947543129579805.jpg" style="zoom:50%;" /></p></li><li><p>从上图中可以发现有些功能仍然没有实现，由于时间原因只能先搁置一段时间。但这种 <span class="math inline">\(\mbox{to-do-list}\)</span> 的方式可以很大幅度提高大作业代码编写的效率</p></li><li><p>单元测试在一个功能模块完成后便可以进行，针对不同的情况逐一进行测验，遇到相应的问题马上进行调整和修复，否则各种网状结构连接一起运行时，不容易定位 <span class="math inline">\(\mbox{bug}\)</span></p></li><li><p>一些难以解决的问题可以考虑另辟蹊径（如使用发送网络请求的方式获取 <span class="math inline">\(\LaTeX\)</span> 图片）</p></li><li><p><span class="math inline">\(\mbox{C++}\)</span> 新特性的使用可以省去了很多繁琐的语法表达式，加快代码的编写效率，虽然和 <span class="math inline">\(\mbox{pythonic}\)</span> 的 <span class="math inline">\(\mbox{python}\)</span> 语言有一定差距，但毕竟前者更接触底层，效率较高（当然对一些特定问题也未必），两者各有千秋</p></li><li><p><span class="math inline">\(\mbox{Qt}\)</span> 的熟悉以及使用虽然让我踩过不少坑，不过，对报错信息的理解以及在各种网络资源的帮助之下，逐渐排开各种“雷”</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>面向对象编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象编程作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring in THU</title>
    <link href="/2022/05/12/Spring%20is%20gone/"/>
    <url>/2022/05/12/Spring%20is%20gone/</url>
    
    <content type="html"><![CDATA[<p><img src="https://pic.imgdb.cn/item/627cfc6b0947543129ba5921.jpg" /></p><p><img src="https://pic.imgdb.cn/item/627cfbb90947543129b78080.jpg" /></p><p><img src="https://pic.imgdb.cn/item/627cfbd80947543129b7f79f.jpg" /></p><p><img src="https://pic.imgdb.cn/item/627cfbe80947543129b83b9e.jpg" /></p><p><img src="https://pic.imgdb.cn/item/627cfbf60947543129b879d4.jpg" /></p><p><img src="https://pic.imgdb.cn/item/627cfc040947543129b8bde2.jpg" /></p><p><img src="https://pic.imgdb.cn/item/627cfc190947543129b91ad4.jpg" /></p><p><img src="https://pic.imgdb.cn/item/627cfc2b0947543129b95c7a.jpg" /></p><p><img src="https://pic.imgdb.cn/item/627cfc450947543129b9c0ad.jpg" /></p><p><img src="https://pic.imgdb.cn/item/627cfc5a0947543129ba190f.jpg" /></p>]]></content>
    
    
    <categories>
      
      <category>随想</category>
      
      <category>里程碑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客建成三周随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advanced Algebra HW8</title>
    <link href="/2022/05/09/Math/Advanced%20Linear%20Algebra/HW8/"/>
    <url>/2022/05/09/Math/Advanced%20Linear%20Algebra/HW8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\Large \mathbf{If\ your\ life\ is\ tense,\ it\ could\ be\ a\ tensor. }\)</span></p></blockquote><h1 id="largetextcolorbluemboxadvanced-algebra-small-mathbbhwmathrm8-_textcolorblue2022.5.9"><span class="math inline">\(\large\textcolor{blue}{\mbox{Advanced Algebra } \small \mathbb{HW}\mathrm{8}}\ \ \ \ \ \ _\textcolor{blue}{2022.5.9}\)</span></h1><h2 id="small-mboxelementary-layer-operations-for-tensors">1.8.1<span class="math inline">\(\ \small \mbox{Elementary layer operations for tensors}\)</span></h2><p>Note that, for "2D" matrices we have row and column operations, and the two kinds of operations corresponds to the two dimensions of the array.</p><p>For simplicity, let <span class="math inline">\(M\)</span> be a <span class="math inline">\(2 \times 2 \times 2\)</span> "3D matrix". Then we have "row layer operations", "column layer operations", "horizontal layer operations". The three kinds corresponds to the three dimensions of the array. We interpret this as a multilinear map <span class="math inline">\(M: \mathbb{R}^{2} \times \mathbb{R}^{2} \times \mathbb{R}^{2} \rightarrow \mathbb{R}\)</span>. Let <span class="math inline">\(\left(\left(\mathbb{R}^{2}\right)^{*}\right)^{\otimes 3}\)</span> be the space of all multilinear maps from <span class="math inline">\(\mathbb{R}^{2} \times \mathbb{R}^{2} \times \mathbb{R}^{2}\)</span> to <span class="math inline">\(\mathbb{R}\)</span>.</p><ol type="1"><li>Given <span class="math inline">\(\alpha, \beta, \gamma \in\left(\mathbb{R}^{2}\right)^{*}\)</span>, what is the <span class="math inline">\((i, j, k)\)</span>-entry of the "3D matrix" <span class="math inline">\(\alpha \otimes \beta \otimes \gamma\)</span> in terms of the coordinates of <span class="math inline">\(\alpha, \beta, \gamma\)</span> ? Here <span class="math inline">\(\alpha \otimes \beta \otimes \gamma\)</span> is the multilinear map sending <span class="math inline">\((\boldsymbol{u}, \boldsymbol{v}, \boldsymbol{w})\)</span> to the real number <span class="math inline">\(\alpha(\boldsymbol{u}) \beta(\boldsymbol{v}) \gamma(\boldsymbol{w})\)</span>.</li><li>Let <span class="math inline">\(E\)</span> be an elementary matrix. Then we can send <span class="math inline">\(\alpha \otimes \beta \otimes \gamma\)</span> to <span class="math inline">\((\alpha E) \otimes \beta \otimes \gamma\)</span>. Why can this be extended to a linear map <span class="math inline">\(M_{E}:\left(\left(\mathbb{R}^{2}\right)^{*}\right)^{\otimes 3} \rightarrow\left(\left(\mathbb{R}^{2}\right)^{*}\right)^{\otimes 3}\)</span> ? (This gives a formula for the "elementary layer operations" on "3D matrices", where the three kinds of layer operations corresponds to applying <span class="math inline">\(E\)</span> to the three arguments respectively.)</li><li>Show that elementary layer operations preserve rank. Here we say <span class="math inline">\(M\)</span> has rank <span class="math inline">\(r\)</span> if <span class="math inline">\(r\)</span> is the smallest possible integer such that <span class="math inline">\(M\)</span> can be written as the linear combination of <span class="math inline">\(r\)</span> "rank one" maps, i.e., maps of the kind <span class="math inline">\(\alpha \otimes \beta \otimes \gamma\)</span> for some <span class="math inline">\(\alpha, \beta, \gamma \in\left(\mathbb{R}^{2}\right)^{*}\)</span>.</li><li>Show that, if some "2D" layer matrix of a "3D matrix" has rank r, then the <span class="math inline">\(3 D\)</span> matrix has rank at least <span class="math inline">\(r\)</span>.</li><li>Let <span class="math inline">\(M\)</span> be made of two layers, <span class="math inline">\(\left[\begin{array}{ll}1 &amp; 0 \\ 0 &amp; 1\end{array}\right]\)</span> and <span class="math inline">\(\left[\begin{array}{ll}0 &amp; 1 \\ 1 &amp; 0\end{array}\right]\)</span>. Find its rank.</li><li>(Read only) Despite some practical interests, finding the tensor rank in general is NOT easy. In fact, it is NP-complete just for 3-tensors over finite field. Furthermore, a tensor with all real entries might have different real rank and complex rank.</li></ol><hr /><p><span class="math inline">\((1)\)</span> According to the symmetry of dot product <span class="math inline">\(\langle\alpha,u\rangle=\langle u,\alpha\rangle\)</span> we have equation <span class="math inline">\(\alpha^Tu=u^T\alpha\)</span> So</p><p><span class="math inline">\(\alpha^{T} u \beta^{T} v \gamma^{T} \omega=u^{T} \alpha \beta^{T} v \gamma^{T} \omega=u^{T}\left[\alpha \beta^{T} v \gamma_{1} \quad \partial \beta^{T} v \gamma_{2}\right] \omega\)</span> Compare to <span class="math inline">\([u^TA_1v\quad u^TA_2v]\omega\)</span> hence</p><p><span class="math inline">\(A_{1}=\gamma_{1}\left(\begin{array}{ll}\alpha_{1} \beta_{1} &amp; \alpha_{1} \beta_{2} \\ \alpha_{2} \beta_{1} &amp; \alpha_{2} \beta_{2}\end{array}\right)=\gamma_1\alpha\beta^T,A_{2}=\gamma_{2}\left(\begin{array}{ll}\alpha_{1} \beta_{1} &amp; \alpha_{1} \beta_{2} \\ \alpha_{2} \beta_{1} &amp; \alpha_{2} \beta_{2}\end{array}\right)=\gamma_2\alpha\beta^T\)</span> . So <span class="math inline">\(A_{ijk}=\gamma_i\alpha_j\beta_k\)</span></p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(M_E\)</span> sends tensor <span class="math inline">\(M=[[A_1,A_2]]=[[\gamma_1\alpha \beta^T,\gamma_2\alpha \beta^T]]\)</span> to <span class="math inline">\(M&#39;=[[\gamma_1\alpha E \beta^T,\gamma_2\alpha E\beta^T]]\)</span></p><p>For <span class="math inline">\(\alpha _1,\alpha_2\)</span> in <span class="math inline">\((\mathbb{R}^2)^*\)</span> as one part in <span class="math inline">\(((\mathbb{R}^2)^*)^{\otimes3}\)</span> <span class="math display">\[M_{k\alpha_1+\mu\alpha_2}=[[\gamma_1(k\alpha_1+\mu\alpha_2) \beta^T,\gamma_2(k\alpha_1+\mu\alpha_2) \beta^T]]=kM_{\alpha _1}+\mu M_{\alpha _2}\in ((\mathbb{R}^2)^*)^{\otimes3}\]</span> So for <span class="math inline">\(\alpha ,\beta\)</span> is linear. and for <span class="math inline">\(\gamma_1,\gamma_2\)</span> in <span class="math inline">\((\mathbb{R}^2)^*\)</span> as one part in <span class="math inline">\(((\mathbb{R}^2)^*)^{\otimes3}\)</span>, set <span class="math inline">\(\gamma_{11,12}\)</span> as the component of <span class="math inline">\(\gamma_1\)</span></p><p><span class="math inline">\(\gamma_{21,22}\)</span> as the component of <span class="math inline">\(\gamma_2\)</span>, So <span class="math display">\[M_{k\gamma_1+\mu\gamma_2}=[[(k\gamma_{11}+\mu\gamma_{21})\alpha\beta^T,(k\gamma_{12}+\mu\gamma_{22})\alpha \beta^T]]=kM_{\gamma _1}+\mu M_{\gamma _2}\in ((\mathbb{R}^2)^*)^{\otimes3}\]</span> So <span class="math inline">\(M_E\)</span> is a linear map, three operations at <span class="math inline">\(\alpha,\beta,\gamma\)</span></p><p><span class="math inline">\((3)\)</span> Suppose <span class="math inline">\(M=\displaystyle \sum_{i=1}^rM_{base(i)}\)</span> if we operate elementary layer operations for <span class="math inline">\(M\)</span>, the right hand side</p><p>is also in "rank one" maps, so <span class="math inline">\(r&#39;\leq r\)</span>. And if <span class="math inline">\(r&#39;&lt;r\)</span>, i.e., <span class="math inline">\(M&#39;=\displaystyle \sum_{i=1}^{r&#39;}M_{base(i)}\)</span> As elementary have its inverse</p><p>operate the inverse of elementary operation, and we have contradiction, so <span class="math inline">\(r&#39;=r\)</span></p><p><span class="math inline">\((4)\)</span> According to <span class="math inline">\(\mbox{SVD}\)</span>, the minimum number of decomposing a matrix into rank-<span class="math inline">\(1\)</span> matrixes equals to rank</p><p>So if <span class="math inline">\(2D\)</span> matrix needs at least <span class="math inline">\(r\)</span> rank-<span class="math inline">\(1\)</span> matrixes to make up, since every rank-<span class="math inline">\(1\)</span> maps in <span class="math inline">\(\alpha \otimes \beta \otimes \gamma\)</span></p><p>contains two rank-<span class="math inline">\(1\)</span> matrix, so the <span class="math inline">\(3D\)</span> matrix also needs at least <span class="math inline">\(r\)</span> rank-<span class="math inline">\(1\)</span> tensors to make up</p><p><span class="math inline">\((5)\)</span> For <span class="math inline">\(A_1=\left[\begin{array}{ll}1 &amp; 0 \\ 0 &amp; 1\end{array}\right]\)</span> its rank is <span class="math inline">\(2\)</span>, so <span class="math inline">\(r(M)\geq 2\)</span>. Besides, construct two rank-<span class="math inline">\(1\)</span> tensors <span class="math display">\[M_1=[[\dfrac{1}{2}\begin{bmatrix}1 &amp; 1 \\ 1 &amp; 1\end{bmatrix},\dfrac{1}{2}\begin{bmatrix}1 &amp; 1 \\ 1 &amp; 1\end{bmatrix}]],M_2=[[\dfrac{1}{2}\begin{bmatrix}1 &amp; -1 \\ -1 &amp; 1\end{bmatrix},-\dfrac{1}{2}\begin{bmatrix}1 &amp; -1 \\ -1 &amp; 1\end{bmatrix}]]\]</span> And <span class="math inline">\(M=M_1+M_2\)</span>, so its rank is <span class="math inline">\(2\)</span></p><p><img src="https://pic.imgdb.cn/item/6278cb2909475431290238c1.jpg" /></p><h2 id="small-mboxijk-rank-3-tensor">1.8.2<span class="math inline">\(\ \small \mbox{i+j+k rank-3 tensor}\)</span></h2><p>Let <span class="math inline">\(M\)</span> be a <span class="math inline">\(3 \times 3 \times 3\)</span> "3D matrix" whose <span class="math inline">\((i, j, k)\)</span>-entry is <span class="math inline">\(i+j+k\)</span>. We interpret this as a multilinear map <span class="math inline">\(M: \mathbb{R}^{3} \times \mathbb{R}^{3} \times \mathbb{R}^{3} \rightarrow \mathbb{R}\)</span>.</p><ol type="1"><li>Let <span class="math inline">\(\boldsymbol{v}=\left[\begin{array}{l}x \\ y \\ z\end{array}\right]\)</span>, then <span class="math inline">\(M(\boldsymbol{v}, \boldsymbol{v}, \boldsymbol{v})\)</span> is a polynomial in <span class="math inline">\(x, y, z\)</span>. What is this polynomial?</li><li>Let <span class="math inline">\(\sigma:\{1,2,3\} \rightarrow\{1,2,3\}\)</span> be any bijection. Show that <span class="math inline">\(M\left(\boldsymbol{v}_{1}, \boldsymbol{v}_{2}, \boldsymbol{v}_{3}\right)=M\left(\boldsymbol{v}_{\sigma(1)}, \boldsymbol{v}_{\sigma(2)}, \boldsymbol{v}_{\sigma(3)}\right)\)</span>. (Hint: brute force works. But alternatively, try find the <span class="math inline">\((i, j, k)\)</span> entry of the multilinear map <span class="math inline">\(M^{\sigma}\)</span>, a map that sends <span class="math inline">\(\left(\boldsymbol{v}_{1}, \boldsymbol{v}_{2}, \boldsymbol{v}_{3}\right)\)</span> to <span class="math inline">\(M\left(\boldsymbol{v}_{\sigma(1)}, \boldsymbol{v}_{\sigma(2)}, \boldsymbol{v}_{\sigma(3)}\right)\)</span>.)</li><li>Show that the rank <span class="math inline">\(r\)</span> of <span class="math inline">\(M\)</span> is at least 2 and at most 3. (It is actually exactly three.)</li><li>(Read only) Any study of polynomial of degree <span class="math inline">\(d\)</span> on <span class="math inline">\(n\)</span> variables is equivalent to the study of some symmetric <span class="math inline">\(d\)</span> tensor on <span class="math inline">\(\mathbb{R}^{n}\)</span>.</li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(M=[[\begin{bmatrix}3 &amp; 4 &amp; 5 \\ 4 &amp; 5 &amp; 6\\5&amp; 6&amp;7\end{bmatrix},\begin{bmatrix}4 &amp; 5 &amp; 6 \\ 5 &amp; 6 &amp; 7\\6&amp; 7&amp;8\end{bmatrix},\begin{bmatrix}5 &amp; 6 &amp; 7 \\ 6 &amp; 7 &amp; 8\\7&amp; 8&amp;9\end{bmatrix}]]=[[A_1,A_2,A_3]]\)</span> And <span class="math inline">\(M(\boldsymbol v,\boldsymbol v,\boldsymbol v)\)</span> where <span class="math inline">\(\boldsymbol{v}=\begin{pmatrix}x\\y\\z\end{pmatrix}\)</span></p><p><span class="math inline">\(=[\boldsymbol v^TA_1\boldsymbol v\quad \boldsymbol v^TA_2\boldsymbol v\quad \boldsymbol v^TA_3\boldsymbol v]\boldsymbol v=[\boldsymbol v^T\begin{bmatrix}3 &amp; 4 &amp; 5 \\ 4 &amp; 5 &amp; 6\\5&amp; 6&amp;7\end{bmatrix}\boldsymbol v\quad \boldsymbol v^T\begin{bmatrix}4 &amp; 5 &amp; 6 \\ 5 &amp; 6 &amp; 7\\6&amp; 7&amp;8\end{bmatrix}\boldsymbol v\quad \boldsymbol v^T\begin{bmatrix}5 &amp; 6 &amp; 7 \\ 6 &amp; 7 &amp; 8\\7&amp; 8&amp;9\end{bmatrix}\boldsymbol v]\boldsymbol v\)</span></p><p>Calculate it by <span class="math inline">\(\mbox{Mathematica}\)</span>, the result is <span class="math inline">\(p(x,y,z)=3 (x+y+z)^2 (x+2 y+3 z)\)</span></p><p><img src="https://pic.imgdb.cn/item/6278d61109475431291e44d0.jpg" /></p><p><span class="math inline">\((2)\)</span> let a linear map from <span class="math inline">\(\mathbb{R}^{3} \times \mathbb{R}^{3} \times \mathbb{R}^{3}\)</span> to <span class="math inline">\(\mathbb{R}\)</span> sends <span class="math inline">\(\left(\boldsymbol{v}_{1}, \boldsymbol{v}_{2}, \boldsymbol{v}_{3}\right)\)</span> to <span class="math inline">\(M\left(\boldsymbol{v}_{\sigma(1)}, \boldsymbol{v}_{\sigma(2)}, \boldsymbol{v}_{\sigma(3)}\right)\)</span></p><p>Obviously, it's multi-linear since for <span class="math inline">\(\boldsymbol{v}_i\)</span> the evaluation result is linear no matter which position <span class="math inline">\(\boldsymbol{v}_i\)</span> is.</p><p>And this map have a tensor such <span class="math inline">\(M&#39;=[[A_1&#39;,A_2&#39;,A_3&#39;]]\)</span>. Specialise <span class="math inline">\(\boldsymbol{v_i}\)</span> to get value of <span class="math inline">\(A_{1}&#39;,A_{2}&#39;,A_{3}&#39;\)</span></p><p>Set <span class="math inline">\(\boldsymbol{b}_1=\begin{pmatrix}1\\0\\0\end{pmatrix},\boldsymbol{b}_2=\begin{pmatrix}0\\1\\0\end{pmatrix},\boldsymbol{b}_3=\begin{pmatrix}0\\0\\1\end{pmatrix}\)</span> let <span class="math inline">\((\boldsymbol{v_1},\boldsymbol{v_2},\boldsymbol{v_3})=(\boldsymbol{b_i},\boldsymbol{b_j},\boldsymbol{b_k})\)</span> where <span class="math inline">\(1\leq i,j,k\leq 3\)</span></p><p>and they can be the same. Put one of condition into the map so <span class="math display">\[A_{k(ij)}&#39;=A_{\sigma^{-1}(i)(\sigma^{-1}(j)\sigma^{-1}(k))}=\sigma^{-1}(i)+\sigma^{-1}(j)+\sigma^{-1}(k)=i+j+k\]</span> So for <span class="math inline">\(k=1,2,3\)</span> <span class="math inline">\(A_{k}&#39;=A_k\)</span>, which implies that <span class="math inline">\(M&#39;=M\)</span>, so the equation is proved.</p><blockquote><p><strong>A brute try</strong> (failed):</p><p>It is obvious that swaping <span class="math inline">\(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\)</span> at most twice can make <span class="math inline">\(\boldsymbol{v}_1,\boldsymbol{v}_2,\boldsymbol{v}_3\)</span> $$ <span class="math inline">\(\boldsymbol{v}_{\sigma(1)}, \boldsymbol{v}_{\sigma(2)}, \boldsymbol{v}_{\sigma(3)}\)</span></p><p>If swap <span class="math inline">\(\boldsymbol{v}_{1},\boldsymbol{v}_{2}\)</span>, the value <span class="math inline">\(\boldsymbol v_1^TA_i\boldsymbol v_2=\boldsymbol v_2^TA_i\boldsymbol v_1,i=1,2,3\)</span>, since <span class="math inline">\(A_i=A_i^T\)</span> so the result stays the same.</p><p>And if we swap <span class="math inline">\(\boldsymbol{v}_{2},\boldsymbol{v}_{3}\)</span>, <span class="math inline">\([\boldsymbol v_1^TA_1\boldsymbol v_2\quad \boldsymbol v_1^TA_2\boldsymbol v_2\quad \boldsymbol v_1^TA_3\boldsymbol v_2]\boldsymbol v_3=\boldsymbol v_1^TA_1\boldsymbol v_2v_{3x}+\boldsymbol v_1^TA_2\boldsymbol v_2v_{3y}+\boldsymbol v_1^TA_3\boldsymbol v_2v_{3z}\)</span></p></blockquote><p><span class="math inline">\((3)\)</span> According to <span class="math inline">\(1.8.1(4)\)</span>, since <span class="math inline">\(\mbox{rank}(A_i)=2\)</span>, so <span class="math inline">\(r\geq 2\)</span>. Then just construct a reasonable combination</p><p>I guess <span class="math inline">\(\alpha=\begin{pmatrix}1\\1\\-1\end{pmatrix},\beta=\begin{pmatrix}1\\-1\\1\end{pmatrix},\gamma=\begin{pmatrix}-1\\1\\1\end{pmatrix}\)</span> so the rank-<span class="math inline">\(1\)</span> matrix like <span class="math display">\[\begin{bmatrix}a&amp;b&amp;c\\a&amp;b&amp;c\\-a&amp;-b&amp;-c\end{bmatrix},\begin{bmatrix}d&amp;e&amp;f\\-d&amp;-e&amp;-f\\d&amp;e&amp;f\end{bmatrix},\begin{bmatrix}-g&amp;-h&amp;-i\\g&amp;h&amp;i\\g&amp;h&amp;i\end{bmatrix},\]</span> And the linear combinations of these three matrixes are <span class="math inline">\(\begin{bmatrix}3 &amp; 4 &amp; 5 \\ 4 &amp; 5 &amp; 6\\5&amp; 6&amp;7\end{bmatrix},\begin{bmatrix}4 &amp; 5 &amp; 6 \\ 5 &amp; 6 &amp; 7\\6&amp; 7&amp;8\end{bmatrix},\begin{bmatrix}5 &amp; 6 &amp; 7 \\ 6 &amp; 7 &amp; 8\\7&amp; 8&amp;9\end{bmatrix}\)</span></p><p>which transfers to three nine - dimensional equations, out of my hand ability, the coefficient matrix is <span class="math display">\[A=\left(\begin{array}{ccccccccc} 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\  0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; -1 \\  0 &amp; 1 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ -1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\\end{array}\right),A\vec{x}=\vec{b}_{i}=\begin{pmatrix}3\\4\\5\\4\\5\\6\\5\\6\\7\end{pmatrix},\begin{pmatrix}4\\5\\6\\5\\6\\7\\6\\7\\8\end{pmatrix},\begin{pmatrix}5\\6\\7\\6\\7\\8\\7\\8\\9\end{pmatrix}\]</span> And the accurate solution is <span class="math display">\[\begin{gathered}\begin{bmatrix}3 &amp; 4 &amp; 5 \\ 4 &amp; 5 &amp; 6\\5&amp; 6&amp;7\end{bmatrix}=\begin{bmatrix}3.5&amp;4.5&amp;5.5\\3.5&amp;4.5&amp;5.5\\-3.5&amp;-4.5&amp;-5.5\end{bmatrix}+\begin{bmatrix}4&amp;5&amp;6\\-4&amp;-5&amp;-6\\4&amp;5&amp;6\end{bmatrix}+\begin{bmatrix}-4.5&amp;-5.5&amp;-6.5\\4.5&amp;5.5&amp;6.5\\4.5&amp;5.5&amp;6.5\end{bmatrix}\\\begin{bmatrix}4 &amp; 5 &amp; 6 \\ 5 &amp; 6 &amp; 7\\6&amp; 7&amp;8\end{bmatrix}=\begin{bmatrix}4.5&amp;5.5&amp;6.5\\4.5&amp;5.5&amp;6.5\\-4.5&amp;-5.5&amp;-6.5\end{bmatrix}+\begin{bmatrix}5&amp;6&amp;7\\-5&amp;-6&amp;-7\\5&amp;6&amp;7\end{bmatrix}+\begin{bmatrix}-5.5&amp;-6.5&amp;-7.5\\5.5&amp;6.5&amp;7.5\\5.5&amp;6.5&amp;7.5\end{bmatrix}\\\begin{bmatrix}5 &amp; 6 &amp; 7 \\ 6 &amp; 7 &amp; 8\\7&amp; 8&amp;9\end{bmatrix}=\begin{bmatrix}5.5&amp;6.5&amp;7.5\\5.5&amp;6.5&amp;7.5\\-5.5&amp;-6.5&amp;-7.5\end{bmatrix}+\begin{bmatrix}6&amp;7&amp;8\\-6&amp;-7&amp;-8\\6&amp;7&amp;8\end{bmatrix}+\begin{bmatrix}-6.5&amp;-7.5&amp;-8.5\\6.5&amp;7.5&amp;8.5\\6.5&amp;7.5&amp;8.5\end{bmatrix}\\\end{gathered}\]</span> So it can be decomposed into three rank-<span class="math inline">\(1\)</span> tensors. So <span class="math inline">\(r\leq 3\)</span></p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>高等代数选讲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高代作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Foundation for machine learning</title>
    <link href="/2022/05/08/Machine%20Learning/Foundation%20for%20machine%20learning/"/>
    <url>/2022/05/08/Machine%20Learning/Foundation%20for%20machine%20learning/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习绪论">机器学习绪论</h1><p>机器学习的三起两落：</p><p>第一次兴起，<span class="math inline">\(1958\ \mbox{Perception}\)</span> ，<span class="math inline">\(1969\)</span> <span class="math inline">\(\mbox{AI winter}\)</span></p><p>第二次兴起，<span class="math inline">\(1986\ \mbox{BP}\)</span>，在 <span class="math inline">\(\mbox{SVM}\)</span> （隔壁统计学家）下跌落</p><p>第三次兴起，<span class="math inline">\(2006\ \mbox{DBN}\)</span>，<span class="math inline">\(2012\ \mbox{CNN}\)</span></p><p>最近预测下落两大原因：</p><p><span class="math inline">\(①\)</span> 自动驾驶在决策方面解决不了行人的无规律问题</p><p><span class="math inline">\(②\)</span> 存在使用 <span class="math inline">\(\mbox{idea}\)</span> 骗取资本的诟病，使得资本注入减少</p><p>传统机器学习：人工设计特征</p><p>传统机器学习和深度学习：<strong>专家系统</strong>（人为指定一系列规则）$$ <strong>经典机器学习</strong>： <span class="math inline">\(\mbox{PCA}\)</span> 进行分类</p><p>$$ <strong>浅层机器学习</strong> $$ <strong>深度机器学习</strong>（浅层的特征，每加一层更加抽象，得到抽象特征后做一个 <span class="math inline">\(\mbox{mapping}\)</span> ）</p><p>特征到标签的映射（二分类：<span class="math inline">\(\mbox{softmark relation}\)</span> 、 <span class="math inline">\(\mbox{logistic}\)</span> 、决策树、<span class="math inline">\(\mbox{SVM}\)</span>）</p><p>深度学习的数学描述：<span class="math inline">\(f^1(f^2(f^3\cdots f^n(x)))\)</span></p><ul><li><p>前机器学习时代：花很多时间观察图像，<strong>绞尽脑汁</strong>选择或者设计特征，使用分类器进行训练和测试，结果不好的话就重新回到绞尽脑汁选择或设计特征步骤</p></li><li><p>深度学习时代：花一定时间，挑选几个深度模型，选几个模型超参数，交给机器<strong>绞尽脑汁</strong>优化模型总的数千万/数权重参数</p></li><li><p>后深度学习时代：花少量时间标注，让机器更<strong>绞尽脑汁</strong>学习模型</p></li></ul><h1 id="机器学习基础">机器学习基础</h1><h2 id="三大要素">三大要素</h2><p>机器学习：在计算机上从数据中产生“模型"的算法，称为学习算法</p><p>例如，给定一系列芒果的性质以及其好坏，求另一种芒果性质的好坏</p><p>三个基本要素：<strong>模型</strong>、<strong>学习准则</strong>、<strong>优化算法</strong></p><ul><li><p><strong>模型</strong>：线性方法 : <span class="math inline">\(f(\boldsymbol{x} ; \theta)=\boldsymbol{w}^{\top} \boldsymbol{x}+b\)</span>，广义非线性方法 : <span class="math inline">\(f(\boldsymbol{x} ; \theta)=\boldsymbol{w}^{\top} \phi(\boldsymbol{x})+b\)</span></p><p><span class="math inline">\(\checkmark\)</span> 如果 <span class="math inline">\(\phi(x)\)</span> 为可学习的非线性基函数， <span class="math inline">\(f(x, \theta)\)</span> 就等价于神经网络。</p></li><li><p><strong>学习准则</strong>：期望风险（期望误差 <span class="math inline">\(\mbox{Expected Risk}\)</span> ，衡量模型的好坏），损失函数定义如下 <span class="math display">\[\mathcal{R}(\theta)=\mathbb{E}_{(\boldsymbol{x}, y) \sim p_{r}(\boldsymbol{x}, y)}\mathcal{L}(y, f(\boldsymbol{x} ; \theta))\]</span> 表征所有样本的差异，能量化模型预测和真实标签之间的差异，（期望风险最小化准则）</p><p><span class="math inline">\(0-1\)</span> 损失函数，正确为 <span class="math inline">\(1\)</span>，错误为 <span class="math inline">\(0\)</span>，平方损失函数：<span class="math inline">\(\mathcal{L}(y, f(\boldsymbol{x} ; \theta))=(y-f(x, \theta))^{2}\)</span></p><p>存在泛化错误 <span class="math inline">\(g_{\mathcal{D}}(f)=\mathcal{R}(f)-\mathcal{R}_{\mathcal{D}}^{e m p}(f)\)</span>，真实数据分布未知，期望风险不可以计算</p><p>利用大数定律，使用经验风险最小化，转化为最优化问题，使下列函数最小，在 <span class="math inline">\(N\to \infty\)</span> 时两者相同 <span class="math display">\[\mathcal{R}_{\mathcal{D}}^{e m p}(\theta)=\frac{1}{N} \sum_{n=1}^{N} \mathcal{L}(y, f(\boldsymbol x ; \theta))\]</span></p></li></ul><p><img src="https://pic.imgdb.cn/item/6277c4f9094754312923ec21.jpg" style="zoom:80%;" /></p><p>​</p><ul><li><strong>优化算法</strong>：梯度下降，迭代法，其中 <span class="math inline">\(\alpha\)</span> 定义为<strong>学习率</strong> <span class="math display">\[\begin{aligned} \theta_{t+1} &amp;=\theta_{t}-\alpha \frac{\partial \mathcal{R}_{\mathcal{D}}(\theta)}{\partial \theta} \\ &amp;=\theta_{t}-\alpha \frac{1}{N} \sum_{n=1}^{N} \frac{\partial \mathcal{L}\left(y^{(n)}, f\left(x^{(n)} ; \theta\right)\right)}{\partial \theta} \end{aligned}\]</span> <img src="https://pic.imgdb.cn/item/6277c3f809475431291f8974.jpg" /></li></ul><p>​ <span class="math inline">\(\alpha\)</span> 必须选择恰当（如上图所示）</p><h2 id="数学基础">数学基础</h2><p>正则化，一类通过限制模型复杂度，避免过拟合，提高泛化能力的犯法</p><p><span class="math inline">\(l_1\)</span> 和 <span class="math inline">\(l_2\)</span> 正则化，正方形、椭圆 <span class="math display">\[\begin{array}{llll}\hline &amp; \text { 监督学习 } &amp; \text { 无监督学习 } &amp; \text { 强化学习 } \\\hline \text { 训练样本 } &amp; \text { 训练集 } &amp; \text { 训练集 } &amp; \text { 智能体和环境交互的 } \\&amp; \left\{\left(\mathbf{x}^{(n)}, y^{(n)}\right)\right\}_{n=1}^{N} &amp; \left\{\mathbf{x}^{n}\right\}_{n=1}^{N} &amp; \text { 轨迹 } \tau \text { 和累积奖励 } G_{\tau} \\&amp; &amp; &amp; \\\text { 优化目标 } &amp; y=f(\mathbf{x}) \text { 或 } p(y \mid \mathbf{x}) &amp; p(\mathbf{x}) \text { 或带隐变量 } &amp; \text { 期望总回报 } \mathbb{E}_{\tau}\left[G_{\tau}\right] \\&amp; &amp; \mathbf{z} \text { 的 } p(\mathbf{x} \mid \mathbf{z}) &amp; \\\text { 学习准则 } &amp; \text { 期望风险最小化 } &amp; \text { 最大似然估计 } &amp; \text { 策略评估 } \\&amp; \text { 最大似然估计 } &amp; \text { 最小重构错误 } &amp; \text { 策略改进 } \\\hline\end{array}\]</span> 向量的范数：</p><p><span class="math inline">\(\ell_{1}\)</span> 范数为向量的各个元素的绝对值之和. <span class="math inline">\(\displaystyle \|\boldsymbol{v}\|_{1}=\sum_{n=1}^{N}\left|v_{n}\right|\)</span></p><p><span class="math inline">\(\ell_2\)</span> 范数为向量的各个元素的方和根 <span class="math inline">\(\displaystyle \|\boldsymbol{v}\|_{2}=\sqrt{\sum_{n=1}^{N} v_{n}^{2}}=\sqrt{\boldsymbol{v}^{\top} \boldsymbol{v}}\)</span></p><p><span class="math inline">\(\ell_{\infty}\)</span> 范数 <span class="math inline">\(\ell_{\infty}\)</span> 范数为向量的各个元素的最大绝对值 <span class="math inline">\(\|\boldsymbol{v}\|_{\infty}=\max \left\{v_{1}, v_{2}, \cdots, v_{N}\right\} .\)</span></p><p>矩阵的范数：</p><p><span class="math inline">\(\ell_{p}\)</span> 范数定义为 <span class="math inline">\(\displaystyle \|\boldsymbol{A}\|_{p}=\left(\sum_{m=1}^{M} \sum_{n=1}^{N}\left|a_{m n}\right|^{p}\right)^{1 / p} .\)</span></p><p><span class="math inline">\(F\)</span> 范数是向量的 <span class="math inline">\(l_{2}\)</span> 范数的推广 <span class="math inline">\(\displaystyle \|\boldsymbol{W}\|_{F}=\sqrt{\sum_{m=1}^{M} \sum_{n=1}^{N}\left(w_{m n}\right)^{2}}\)</span></p><h2 id="模型">模型</h2><ul><li><p>线性模型</p><ul><li><p>线性模型 ( Linear Model) 是机器学习中应用最广泛的模型，指通过样本特 征的线性组合来进行预测的模型</p></li><li><p>分类问题 : 输出目标 <span class="math inline">\(y\)</span> 是一些离散的标签（具体是哪一类）</p><p><span class="math inline">\(&gt;\)</span> 而特征的线性组合本身是连续值，即 <span class="math inline">\(f(x ; \boldsymbol{w})\)</span> 的值域为实数 <span class="math inline">\(&gt;\)</span> 需要引入一个非线性的决策函数 <span class="math inline">\(g(\cdot)\)</span> ，使输出符合预期离散值的目标</p></li></ul></li></ul><p>​ 分类决策问题，使用符号函数</p><ul><li><span class="math inline">\(\mbox{Logistic}\)</span> 回归，把分类决策问题压缩压缩到 <span class="math inline">\([0,1]\)</span> 区间内</li></ul><p><span class="math display">\[\sigma(x)=\dfrac{1}{1+e^{-x}}\]</span></p><p>​ 先用线性函数组合特征: <span class="math inline">\(f=\boldsymbol{\omega}^{\mathrm{T}} \boldsymbol{x}\)</span>，利用 <span class="math inline">\(g(\cdot)=\sigma(\boldsymbol{x})\)</span> 作非线性决策： <span class="math display">\[\begin{aligned}p(y=1 \mid \boldsymbol{x}) &amp;=\sigma\left(\boldsymbol{w}^{\top} \boldsymbol{x}\right) &amp; p(y=0 \mid \boldsymbol{x}) &amp;=1-p(y=1 \mid \boldsymbol{x}) \\&amp; \triangleq \frac{1}{1+\exp \left(-\boldsymbol{w}^{\top} \boldsymbol{x}\right)} &amp; &amp;=\frac{\exp \left(-\boldsymbol{w}^{\top} \boldsymbol{x}\right)}{1+\exp \left(-\boldsymbol{w}^{\top} \boldsymbol{x}\right)}\end{aligned}\]</span> ​ <span class="math inline">\(Logistic\)</span> 回归可以看作预测值为<strong>标签的对数几率</strong>的线性回归模型。因此， Logistic 回归也称为对数几率回归 <span class="math display">\[\boldsymbol{w}^{\top} \boldsymbol{x}=\log \frac{p(\bar{y}=1 \mid \boldsymbol{x})}{1-p(y=1 \mid \boldsymbol{x})} \quad \text { 样本为正负例的后验概率的比值 }\]</span> ​ 衡量两个条件概率的差距，引入熵的概念，<strong>自信息</strong> <span class="math inline">\(I(x)=-\ln (p(x))\)</span>，<strong>自信息的期望</strong> <span class="math display">\[\begin{aligned}H(X) &amp;=\mathbb{E}_{X}[I(x)]=\mathbb{E}_{X}[-\log p(x)]=-\sum_{x \in X} p(x) \log p(x)\end{aligned}\]</span> ​ 对分布 <span class="math inline">\(p(x)\)</span> 的信息进行编码时，<strong>熵</strong>为自信息的期望为该信息编码所需要的最小长度</p><p>​ 例如，如果选择题 <span class="math inline">\(ABCD\)</span> 四个答案的概率为 <span class="math inline">\(\dfrac{1}{4}\)</span> 计算自信息的期望 <span class="math inline">\(-4\cdot \dfrac{1}{4}\log(\dfrac{1}{4})=-2\log(2)\)</span></p><p>​ 计算机编码时就规定 <span class="math inline">\(\log=\log_2\)</span></p><p>​ <strong>交叉熵</strong>按照概率分布 <span class="math inline">\(q\)</span> 的最优编码对真实分布为 <span class="math inline">\(p\)</span> 的信息进行编码的长度 <span class="math display">\[\begin{aligned}H(p, q) =\mathbb{E}_{p}[-\log q(x)]=-\sum_{x} p(x) \log q(x)\end{aligned}\]</span> ​ 基于交叉熵损失函数可以得到损失函数公式（<strong>准则</strong>），如果两个分布越靠近，交叉熵就会越小 <span class="math display">\[\mathcal{R}(\mathbf{w})=-\frac{1}{N} \sum_{n=1}^{N}\left(y^{(n)} \log \hat{y}^{(n)}+\left(1-y^{(n)}\right) \log \left(1-\hat{y}^{(n)}\right)\right)\]</span> ​ 优化算法，求导有公式</p><p>​ 对一维数据拟合时该回归更好</p><p><img src="https://pic.imgdb.cn/item/6277cf15094754312952e57d.jpg" /></p><ul><li><span class="math inline">\(Softmax\)</span> 回归，多类或多项 <span class="math inline">\(Logistic\)</span> 回归，是上者的推广，其三要素如下</li></ul><p>​ 模型 <span class="math display">\[p(y=c \mid \boldsymbol{x})=\operatorname{softmax}\left(\boldsymbol{w}_{c}^{\top} \boldsymbol{x}\right)=\frac{\exp \left(\boldsymbol{w}_{c}^{\top} \boldsymbol{x}\right)}{\sum_{c^{\prime}=1}^{C} \exp \left(\boldsymbol{w}_{c^{\prime}}^{\top} \boldsymbol{x}\right)},\]</span> ​ 学习: 交叉熵损失 <span class="math inline">\(\quad \mathcal{R}(\boldsymbol{W})=-\frac{1}{N} \sum_{n=1}^{N} \sum_{c=1}^{c} \boldsymbol{y}_{c}^{(n)} \log \hat{\boldsymbol{y}}_{c}^{(n)}\)</span> <span class="math display">\[=-\frac{1}{N} \sum_{n=1}^{N}\left(\boldsymbol{y}^{(n)}\right)^{\top} \log \hat{\boldsymbol{y}}^{(n)},\]</span> ​ 优化算法 ：梯度下降 <span class="math display">\[\frac{\partial \mathcal{R}(\boldsymbol{W})}{\partial \boldsymbol{W}}=-\frac{1}{N} \sum_{n=1}^{N} \boldsymbol{x}^{(n)}\left(\boldsymbol{y}^{(n)}-\hat{\boldsymbol{y}}^{(n)}\right)^{\top}\]</span></p><ul><li>感知机（最简单的神经网络，一个神经元）</li></ul><p>​ 模型： <span class="math display">\[g(\mathbf{x}, \mathbf{w})=\left\{\begin{array}{lll}+1 &amp; \text { 当 } &amp; \mathbf{w}^{\mathrm{T}} \mathbf{x}&gt;0, \\ -1 &amp; \text { 当 } &amp; \mathbf{w}^{\mathrm{T}} \mathbf{x}&lt;0 .\end{array}\right.\]</span> ​ 学习准则 : <span class="math display">\[\mathcal{L}(\mathbf{w} ; \mathbf{x}, y)=\max \left(0,-y \mathbf{w}^{\mathrm{T}} \mathbf{x}\right)\]</span> ​ 优化算法：随机梯度下降 <span class="math display">\[\frac{\partial \mathcal{L}(\mathbf{w} ; \mathbf{x}, y)}{\partial \mathbf{w}}= \begin{cases}0 &amp; \text { 当 } y \mathbf{w}^{\mathrm{T}} \mathbf{x}&gt;0, \\ -y \mathbf{x} &amp; \text { 当 } y \mathbf{w}^{\mathrm{T}} \mathbf{x}&lt;0 .\end{cases}\]</span></p><p><span class="math display">\[\begin{equation}\begin{array}{llll}\text { 线性模型 } &amp; \text { 激活函数 } &amp; \text { 损失函数 } &amp; \text { 优化方法 } \\\hline \text { 线性回归 } &amp; - &amp; \left(y-\boldsymbol{w}^{\top} \boldsymbol{x}\right)^{2} &amp; \text { 最小二乘、梯度下降 } \\\text { Logistic 回归 } &amp; \sigma\left(\boldsymbol{w}^{\top} \boldsymbol{x}\right) &amp; \boldsymbol{y} \log \sigma\left(\boldsymbol{w}^{\top} \boldsymbol{x}\right) &amp; \text { 梯度下降 } \\\text { Softmax回归 } &amp; \operatorname{softmax}\left(\boldsymbol{W}^{\top} \boldsymbol{x}\right) &amp; \boldsymbol{y} \log \operatorname{softmax}\left(\boldsymbol{W}^{\top} \boldsymbol{x}\right) &amp; \text { 梯度下降 } \\\text { 感知器 } &amp; \operatorname{sgn}\left(\boldsymbol{w}^{\top} \boldsymbol{x}\right) &amp; \max \left(0,-y \boldsymbol{w}^{\top} \boldsymbol{x}\right) &amp; \text { 随机梯度下降 }\end{array}\end{equation}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web 前端入门</title>
    <link href="/2022/05/08/Program/Web%20primary/"/>
    <url>/2022/05/08/Program/Web%20primary/</url>
    
    <content type="html"><![CDATA[<p>结合 <a href="https://frontend-dev-scissorseven.app.secoder.net/">zcy软工半成品</a>，学习一些 <span class="math inline">\(\mbox{web}\)</span> 的一些前置知识</p><hr /><p><span class="math inline">\(\mbox{web}\)</span> 前端<strong>三驾马车</strong>：</p><p><span class="math inline">\(\mbox{HTML}\)</span>（网页最终渲染格式），<span class="math inline">\(\mbox{JS}\)</span>（处理网页逻辑、交互），<span class="math inline">\(\mbox{CSS}\)</span>（网页样式）</p><p>一些前端框架将上述语言进行封装，如 <span class="math inline">\(\mbox{react}\)</span> 框架</p><p>在一个网页中可以按下 <span class="math inline">\(\mbox{Ctrl }+\ \mbox{s}\)</span> 可以保存为静态网页，在浏览器中按下 <span class="math inline">\(\mbox{F}_{12}\)</span> 后各种界面的应用</p><p><img src="https://pic.imgdb.cn/item/6277860f09475431293c57ef.jpg" style="zoom:80%;" /></p><p><strong>元素</strong>：最左上角按钮为抓取元素，便于爬虫位置的提取。按钮右侧显示手机端界面</p><p><strong>控制台</strong>：输出源代码中各种 <code>console.log()</code> 中的内容，便于开发者调试，也可以使用该控制台进行编程</p><p><strong>源代码</strong>：查看当前网页的 <span class="math inline">\(\mbox{js}\)</span> 源码</p><p><strong>网络</strong>：查看各项请求名称类型以及操作延时</p><hr /><ul><li>和 <span class="math inline">\(\mbox{js}\)</span> 打交道会和<strong>异步</strong>做斗争</li><li><span class="math inline">\(\mbox{react}\)</span> 前端框架中 <span class="math inline">\(\mbox{hook}\)</span> 在时间线上有效解决一些渲染不足的问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web 入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unlock pdf by shell commands</title>
    <link href="/2022/05/04/Program/Basic%20shell%20commands/"/>
    <url>/2022/05/04/Program/Basic%20shell%20commands/</url>
    
    <content type="html"><![CDATA[<h1 id="解锁-mboxpdf-密码并替换原始文件">解锁 <span class="math inline">\(\mbox{pdf}\)</span> 密码并替换原始文件</h1><p>每次解锁 <span class="math inline">\(\mbox{pdf}\)</span> 中的密码比较麻烦，当然有免费的在线网页资源 <a href="https://smallpdf.com/cn/unlock-pdf">smallpdf</a> 不过每次需要上传文件，而且有一定的安全风险。使用 <span class="math inline">\(\mbox{wsl}\)</span> 安装 <span class="math inline">\(\mbox{qpdf}\)</span> 加上脚本编辑可以实现解锁 <span class="math inline">\(\mbox{pdf}\)</span> （在不知道密码的情况下，有暴力解锁的 <span class="math inline">\(\mbox{linux}\)</span> 安装包，不过现在 <span class="math inline">\(\mbox{pdf}\)</span> 升级了，貌似不能被暴力破解了……）</p><p>在 <span class="math inline">\(\mbox{linux/wsl}\)</span> 环境下，安装 <span class="math inline">\(\mbox{qpdf}\)</span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install qpdf<br></code></pre></td></tr></table></figure><p>输入密码后便自动安装好了。之后，在当前目录下创建一个 <span class="math inline">\(\mbox{unlockPDF}\)</span> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch unlockPDF<br></code></pre></td></tr></table></figure><p>使用 <span class="math inline">\(\mbox{nano}\)</span> 进行编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano unlockPDF<br></code></pre></td></tr></table></figure><p>在编辑界面中写入如下代码，其中 <span class="math inline">\(\#\)</span> 开头的为注释</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">第一行代表在哪个 shell 命令下执行，可以修改为 python 成为 python 脚本</span><br><span class="hljs-meta"># </span><span class="language-bash">可以使用命令行 <span class="hljs-built_in">which</span> bash 找到当前控制台命令行所在位置（本质上命令也是一些文件）</span><br><span class="hljs-meta">#</span><span class="language-bash">!/usr/bin/bash</span><br><span class="hljs-meta"># </span><span class="language-bash">要求文件名中不能有空格，否则处理时会把文件名分割，其中一个成为命令使得程序运行失败</span><br><span class="hljs-meta"># </span><span class="language-bash">pdf名称，存储输入的第一个参数</span><br>pdfName=$1<br><span class="hljs-meta"># </span><span class="language-bash">密码，存储输入的第二个参数</span><br>password=$2<br><span class="hljs-meta"># </span><span class="language-bash">解锁 pdf 命令，安装 qpdf (sudo apt-get install qpdf) 便可以使用</span><br>qpdf -password=$password --decrypt $pdfName output.pdf<br><span class="hljs-meta"># </span><span class="language-bash">$? 为 0 代表上条命令执行成功</span><br>if [ $? -eq 0 ]; then<br>    # 删除原文件<br>    rm -rf $pdfName<br>    # 将得到的 output.pdf 名称修改为原来 pdf 的名称，达到替换的效果<br>    mv output.pdf $pdfName<br>    # 输出成功结果<br>    echo &quot;解锁成功，原文件被替换&quot;<br>else<br>    # 输出失败结果<br>    echo &quot;密码错误，或未安装qpdf&quot;<br>fi<br></code></pre></td></tr></table></figure><p>可以看到 <span class="math inline">\(\mbox{shell}\)</span> 中的参数传递方式、<span class="math inline">\(\mbox{if}\)</span> 语句的输入、<span class="math inline">\(=\)</span> 的格式规范（不要在 <span class="math inline">\(=\)</span> 两侧加空格，<strong>加空格就代表分割命令</strong>，文件名也不能有空格）等与其他语言有些不同，需要加以熟悉，不过各语言之间的底层逻辑是相通的，只是各有千秋。</p><p>编写好之后，由于 <span class="math inline">\(\mbox{wsl}\)</span> 与 <span class="math inline">\(\mbox{windows}\)</span> 的分隔机制，不能把写好的脚本直接放在 <span class="math inline">\(\mbox{wsl}\)</span> 控制台中，就直接放在文件夹中，专门用来处理文件，执行时输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">secure.pdf 为需要解锁的 pdf 文件，password 为解锁密码</span><br>./unlockPDF secure.pdf password<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux 命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 命令行技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Physics of report</title>
    <link href="/2022/05/03/Physics%20Report/"/>
    <url>/2022/05/03/Physics%20Report/</url>
    
    <content type="html"><![CDATA[<p><a href="https://lr-tsinghua11.github.io/pdf/阻尼振动和受迫振动.pdf">阻尼振动和受迫振动实验报告</a></p><p><a href="https://lr-tsinghua11.github.io/pdf/弦振动实验.pdf">弦振动实验报告</a></p><p><a href="https://lr-tsinghua11.github.io/pdf/电磁感应.pdf">电磁感应实验报告</a></p>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
      <category>实验报告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物理实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advanced Algebra HW7</title>
    <link href="/2022/05/03/Math/Advanced%20Linear%20Algebra/HW7/"/>
    <url>/2022/05/03/Math/Advanced%20Linear%20Algebra/HW7/</url>
    
    <content type="html"><![CDATA[<h1 id="largetextcolorbluemboxadvanced-algebra-small-mathbbhwmathrm7-_textcolorblue2022.5.3"><span class="math inline">\(\large\textcolor{blue}{\mbox{Advanced Algebra } \small \mathbb{HW}\mathrm{7}}\ \ \ \ \ \ _\textcolor{blue}{2022.5.3}\)</span></h1><h2 id="small-mboxbra-map-and-riesz-map">1.7.1<span class="math inline">\(\ \small \mbox{bra map and Riesz map}\)</span></h2><p>On the space <span class="math inline">\(\mathbb{R}^{n}\)</span>, we fix a symmetric positive-definite matrix <span class="math inline">\(A\)</span>, and define <span class="math inline">\((\boldsymbol{v}, \boldsymbol{w})=\boldsymbol{v}^{\mathrm{T}}A\boldsymbol{w}\)</span></p><ol type="1"><li>Show that this is an inner product.</li><li>The Riesz map (inverse of the bra map) from <span class="math inline">\(V^{*}\)</span> to <span class="math inline">\(V\)</span> would send a row vector <span class="math inline">\(\boldsymbol{v}^{\mathrm{T}}\)</span> to what?</li><li>The bra map from <span class="math inline">\(V\)</span> to <span class="math inline">\(V^{*}\)</span> would send a vector <span class="math inline">\(\boldsymbol{v}\)</span> to what?</li><li>The dual of the Riesz map from <span class="math inline">\(V^{*}\)</span> to <span class="math inline">\(V\)</span> would send a row vector <span class="math inline">\(\boldsymbol{v}^{\mathrm{T}}\)</span> to what?</li></ol><hr /><p><span class="math inline">\((1)\)</span> Easy to prove.</p><p><span class="math inline">\((2)\)</span> The bra map means <span class="math inline">\(\forall \ \langle \boldsymbol{v}|\in \mathcal{B},s.t.\langle \boldsymbol{v}|:\boldsymbol{\omega\longmapsto}\langle\boldsymbol{v},\boldsymbol{\omega}\rangle=\boldsymbol{v}^{\mathrm{T}}A\boldsymbol{w}\)</span> So the inverse of <span class="math inline">\(\langle \boldsymbol{v}|\)</span> is make <span class="math inline">\(\boldsymbol{v}^{\mathrm{T}}A\)</span></p><p>to <span class="math inline">\(\boldsymbol {v}\)</span>, which is from <span class="math inline">\(V^{*}\)</span> to <span class="math inline">\(V\)</span>. Set <span class="math inline">\(\boldsymbol{u}=\boldsymbol {v}^{T}A\)</span>, so <span class="math inline">\(\boldsymbol{v}^{T}=\boldsymbol{u}A^{-1}\)</span> then transpose it we can get <span class="math inline">\(\boldsymbol{v}=(A^{-1})^{T}\boldsymbol{u^{T}}\)</span></p><p>So if the input is <span class="math inline">\(\boldsymbol{v}^{T}\in V^{*}\)</span>, the output is <span class="math inline">\((A^{-1})^{T}(\boldsymbol v^{T})^{T}=(A^{-1})^{T}\boldsymbol{v}\in V\)</span></p><p><span class="math inline">\((3)\)</span> Obviously, it sends <span class="math inline">\(\boldsymbol{v}\)</span> to <span class="math inline">\(\boldsymbol{v}^{T}A\)</span></p><p><span class="math inline">\((4)\)</span> I guess the result is the same with <span class="math inline">\(\small(2)\)</span>, which sends <span class="math inline">\(\boldsymbol {v}^{T}\)</span> to <span class="math inline">\((A^{-1})^{T}\boldsymbol{v}\)</span></p><h2 id="small-mboxwhat-is-a-derivative">1.7.2<span class="math inline">\(\ \small \mbox{What is a derivative}\)</span></h2><p>The discussions in this problem holds for all manifolds <span class="math inline">\(M\)</span>. But for simplicities sake, suppose <span class="math inline">\(M=\mathbb{R}^{3}\)</span> for this problem.</p><p>Let <span class="math inline">\(V\)</span> be the space of all analytic functions from <span class="math inline">\(M\)</span> to <span class="math inline">\(\mathbb{R}\)</span>. Here analytic means <span class="math inline">\(f(x, y, z)\)</span> is a infinite polynomial series (its Taylor expansion) with variables <span class="math inline">\(x, y, z\)</span>. Approximately <span class="math inline">\(f(x, y, z)=a_{0}+a_{1} x+a_{2} y+\)</span> <span class="math inline">\(a_{3} z+a_{4} x^{2}+a_{5} x y+a_{6} x z+a_{7} y^{2}+\ldots\)</span>, and things should converge always.</p><p>Then a dual vector <span class="math inline">\(v \in V^{*}\)</span> is said to be a "derivation at <span class="math inline">\(\boldsymbol{p} \in M^{\prime \prime}\)</span> if it satisfy the following Leibniz rule (or product rule): <span class="math display">\[v(f g)=f(\boldsymbol{p}) v(g)+g(\boldsymbol{p}) v(f) .\]</span> (Note the similarity with your traditional product rule <span class="math inline">\((f g)^{\prime}(x)=f(x) g^{\prime}(x)+g(x) f^{\prime}(x)\)</span>.) Prove the following:</p><ol type="1"><li>Constant functions in <span class="math inline">\(V\)</span> must be sent to zero by all derivations at any point.</li><li>Let <span class="math inline">\(x, y, z \in V\)</span> be the coordinate function. Suppose <span class="math inline">\(\boldsymbol{p}=\left[\begin{array}{l}p_{1} \\ p_{2} \\ p_{3}\end{array}\right]\)</span>, then for any derivation <span class="math inline">\(v\)</span> at <span class="math inline">\(\boldsymbol{p}\)</span>, then we have <span class="math inline">\(v\left(\left(x-p_{1}\right) f\right)=f(\boldsymbol{p}) v(x), v\left(\left(y-p_{2}\right) f\right)=f(\boldsymbol{p}) v(y)\)</span> and <span class="math inline">\(v\left(\left(z-p_{3}\right) f\right)=f(\boldsymbol{p}) v(z)\)</span>.</li><li>Let <span class="math inline">\(x, y, z \in V\)</span> be the coordinate function. Suppose <span class="math inline">\(\boldsymbol{p}=\left[\begin{array}{l}p_{1} \\ p_{2} \\ p_{3}\end{array}\right]\)</span>, then for any derivation <span class="math inline">\(v\)</span> at <span class="math inline">\(\boldsymbol{p}\)</span>, then we have <span class="math inline">\(v\left(\left(x-p_{1}\right)^{a}\left(y-p_{2}\right)^{b}\left(z-p_{3}\right)^{c}\right)=0\)</span> for any non-negative integers <span class="math inline">\(a, b, c\)</span> such that <span class="math inline">\(a+b+c&gt;1\)</span>.</li><li>Let <span class="math inline">\(x, y, z \in V\)</span> be the coordinate function. Suppose <span class="math inline">\(\boldsymbol{p}=\left[\begin{array}{l}p_{1} \\ p_{2} \\ p_{3}\end{array}\right]\)</span>, then for any derivation <span class="math inline">\(v\)</span> at <span class="math inline">\(\boldsymbol{p}, v(f)=\)</span> <span class="math inline">\(\dfrac{\partial f}{\partial x}(\boldsymbol{p}) v(x)+\dfrac{\partial f}{\partial y}(\boldsymbol{p}) v(y)+\dfrac{\partial f}{\partial z}(\boldsymbol{p}) v(z)\)</span>. (Hint: use the Taylor expansion of <span class="math inline">\(f\)</span> at <span class="math inline">\(\left.\boldsymbol{p} .\right)\)</span></li><li>Any derivation <span class="math inline">\(v\)</span> at <span class="math inline">\(\boldsymbol{p}\)</span> must be exactly the directional derivative operator <span class="math inline">\(\nabla_{\boldsymbol{v}}\)</span> where <span class="math inline">\(\boldsymbol{v}=\left[\begin{array}{l}v(x) \\ v(y) \\ v(z)\end{array}\right]\)</span>. (Remark: So, algebraically speaking, tangent vectors are exactly derivations, i.e., things that satisfy the Leibniz rule.)</li></ol><hr /><p><span class="math inline">\((1)\)</span> Set <span class="math inline">\(f(\vec{p})\equiv a\)</span>, because <span class="math inline">\(v(f g)=f(\boldsymbol{p}) v(g)+g(\boldsymbol{p}) v(f)\)</span> and <span class="math inline">\(v\in V^{*}\)</span> is linear, <span class="math inline">\(v(fg)=av(g)+g(\boldsymbol{p})v(f)\)</span></p><p>Set <span class="math inline">\(g=f\)</span>, so <span class="math inline">\(v(ff)=2av(f)=v(af)=av(f)\)</span> If <span class="math inline">\(a=0\)</span>, <span class="math inline">\(v(g)=v(0)=v(gg)=0+0=0\)</span> If <span class="math inline">\(a\neq 0\)</span></p><p><span class="math inline">\(av(f)=0\)</span>, and <span class="math inline">\(v(f)=0\)</span> So constant functions in <span class="math inline">\(V\)</span> are all sent to <span class="math inline">\(0\)</span></p><p><span class="math inline">\((2)\)</span> Calculate <span class="math inline">\(v((x-p_1)f)=f(\boldsymbol {p})v(x-p_1)+(x-p_1)(\boldsymbol{p})v(f)\)</span> And <span class="math inline">\(x(\boldsymbol{p})=p_1,p_1(\boldsymbol{p})=p_1\)</span></p><p>So <span class="math inline">\((x-p_1)(\boldsymbol{p})=0\)</span> For constant <span class="math inline">\(\boldsymbol{p}\)</span>, <span class="math inline">\(v(\boldsymbol{p}=0)\)</span> So <span class="math inline">\(v((x-p_1)f)=f(\boldsymbol{p})(v(x)-v(p_1))=f(\boldsymbol{p})v(x)\)</span></p><p><span class="math inline">\((3)\)</span> As <span class="math inline">\(a,b,c\)</span> are all integers, if <span class="math inline">\(a,b,c&lt;1\)</span>, the sum of them is <span class="math inline">\(a+b+c\leq 0\)</span>, contradiction</p><p>So at least one intergers is <span class="math inline">\(\geq 1\)</span>, without loss of generalization, assume <span class="math inline">\(a\geq 1\)</span></p><p><span class="math inline">\(v\left(\left(x-p_{1}\right)^{a}\left(y-p_{2}\right)^{b}\left(z-p_{3}\right)^{c}\right)=v(x-p_1)((x-p_1)^{a-1}(y-p_2)^b(z-p_3)^c)(\boldsymbol{p})\)</span></p><p>And if <span class="math inline">\(a&gt; 1\)</span>, <span class="math inline">\((x-p_1)^{a-1}(\boldsymbol{p})=(x-p_1)^{a-2}(x-p_1)(\boldsymbol{p})=0\)</span> if <span class="math inline">\(a=1\)</span>, then <span class="math inline">\(b+c&gt;0\)</span></p><p>at least one integer in <span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span> <span class="math inline">\(\geq 1\)</span>, without of generalization, assume <span class="math inline">\(b\geq 1\)</span>. Then</p><p><span class="math inline">\((y-p_2)^{b}(\boldsymbol{p})=(y-p_2)^{b-1}(y-p_2)(\boldsymbol{p})=0\)</span> So <span class="math inline">\(v\left(\left(x-p_{1}\right)^{a}\left(y-p_{2}\right)^{b}\left(z-p_{3}\right)^{c}\right)=0\)</span></p><p><span class="math inline">\((4)\)</span> Use Taylor expansion for <span class="math inline">\(f\)</span>, we have <span class="math display">\[f(x, y, z)=f\left(p_{1}, p_{2}, p_{3}\right)+\frac{\partial f}{\partial x}(\boldsymbol{p})\left(x-p_{1}\right)+\frac{\partial f}{\partial y}(\boldsymbol{p})\left(y-p_{2}\right)+\frac{\partial f}{\partial z}(\boldsymbol{p})\left(z-p_{3}\right)+o(|\boldsymbol{r}-\boldsymbol{p}|)\]</span> According to <span class="math inline">\((3)\)</span>, the remainder <span class="math inline">\(o(|\boldsymbol{r}-\boldsymbol{p}|)=\left(x-p_{1}\right)^{a}\left(y-p_{2}\right)^{b}\left(z-p_{3}\right)^{c},a+b+c&gt;1\)</span></p><p>So <span class="math inline">\(v(o(|\boldsymbol{r}-\boldsymbol{p}|))=0\)</span> For constant number <span class="math inline">\(v\)</span> sends to <span class="math inline">\(0\)</span>. Take <span class="math inline">\(v\)</span> function to the Taylor expansion <span class="math display">\[v(f)=\dfrac{\partial f}{\partial x}(\boldsymbol{p}) v(x)+\dfrac{\partial f}{\partial y}(\boldsymbol{p}) v(y)+\dfrac{\partial f}{\partial z}(\boldsymbol{p}) v(z)\]</span> Which shows the complete differential at <span class="math inline">\(\boldsymbol{p}\)</span></p><p><span class="math inline">\((5)\)</span> Just calculate the directional derivative <span class="math inline">\(\nabla_{\boldsymbol{v}}\)</span> where <span class="math inline">\(\boldsymbol{v}=\left[\begin{array}{l}v(x) \\ v(y) \\ v(z)\end{array}\right]\)</span> <span class="math display">\[\begin{aligned}\nabla_{v} f &amp;=\lim _{t \rightarrow 0^{+}} \frac{f(\boldsymbol{p}+t \boldsymbol{v})-f(\boldsymbol{p})}{t} \\&amp;=\lim _{t \rightarrow 0^{+}} \dfrac{f(\boldsymbol{p})+\dfrac{\partial f}{\partial x}(\boldsymbol{p}) v(x) t+\dfrac{\partial f}{\partial y}(\boldsymbol{p}) v(y) t+\dfrac{\partial f}{\partial z}(\boldsymbol{p}) v(z) t+o(\|\boldsymbol{v}\| t)-f(\boldsymbol{p})}{t} \\&amp;=\frac{\partial f}{\partial x}(\boldsymbol{p}) v(x)+\frac{\partial f}{\partial y}(\boldsymbol{p}) v(y)+\frac{\partial f}{\partial z}(\boldsymbol{p}) v(z) \\&amp;=v(f)\end{aligned}\]</span> So derivative in calculus is just a vector in the dual space of <span class="math inline">\(R^{n}\)</span> which suits Leibniz rule</p><h2 id="small-mboxwhat-is-a-vector-field">1.7.3<span class="math inline">\(\ \small \mbox{What is a vector field}\)</span></h2><p>The discussions in this problem holds for all manifolds <span class="math inline">\(M\)</span>. But for simplicities sake, suppose <span class="math inline">\(M=\mathbb{R}^{3}\)</span> for this problem. Let <span class="math inline">\(V\)</span> be the space of all analytic functions from <span class="math inline">\(M\)</span> to <span class="math inline">\(\mathbb{R}\)</span> as usual. We say <span class="math inline">\(X: V \rightarrow V\)</span> is a vector field on <span class="math inline">\(X\)</span> if <span class="math inline">\(X(f g)=f X(g)+g X(f)\)</span>, i.e., the Leibniz rule again! Prove the following:</p><ol type="1"><li><p>Show that <span class="math inline">\(X_{\boldsymbol{p}}: V \rightarrow \mathbb{R}\)</span> such that <span class="math inline">\(X_{\boldsymbol{p}}(f)=(X(f))(\boldsymbol{p})\)</span> is a derivation at <span class="math inline">\(\boldsymbol{p}\)</span>. (Hence <span class="math inline">\(X\)</span> is indeed a vector field, since it is the same as picking a tangent vector at each point.)</p></li><li><p>Note that each <span class="math inline">\(f\)</span> on <span class="math inline">\(M\)</span> induces a covector field <span class="math inline">\(\mathrm{d} f\)</span>. Then at each point <span class="math inline">\(\boldsymbol p\)</span>, the cotangent vector <span class="math inline">\(\mathrm{d} f\)</span> and the tangent vector <span class="math inline">\(X\)</span> would evaluate to some number. So <span class="math inline">\(\mathrm{d} f(X)\)</span> is a function <span class="math inline">\(M \rightarrow \mathbb{R}\)</span>. Show that <span class="math inline">\(\mathrm{d} f(X)=X(f)\)</span>, i.e., the two are the same. (Hint: just use definitions and calculate directly.)</p></li><li><p>If <span class="math inline">\(X, Y: V \rightarrow V\)</span> are vector fields, then note that <span class="math inline">\(X \circ Y: V \rightarrow V\)</span> might not be a vector field. (Leibniz rule might fail.) However, show that <span class="math inline">\(X \circ Y-Y \circ X\)</span> is always a vector field.</p></li><li><p>On a related note, show that if <span class="math inline">\(A, B\)</span> are skew-symmetric matrices, then <span class="math inline">\(A B-B A\)</span> is still skewsymmetric. (Skew-symmetric matrices actually corresponds to certain vector fields on the manifold of orthogonal matrices. So this is no coincidence.)</p></li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(X_{\boldsymbol{p}}(fg)=(X(fg))(\boldsymbol{p})=(fX(g)+gX(f))(\boldsymbol{p})=f(\boldsymbol{p})X(g)(\boldsymbol{p})+g(\boldsymbol{p})X(f)(\boldsymbol{p})\)</span></p><p><span class="math inline">\(=f(\boldsymbol{p})X_{\boldsymbol{p}}(g)+g(\boldsymbol{p})X_{\boldsymbol{p}}(f)\)</span> So it suits the definition of derivative at <span class="math inline">\(\boldsymbol{p}\)</span></p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(X_{\boldsymbol{p}}:V\rightarrow R\)</span> So <span class="math inline">\(X_{\boldsymbol{p}}\in V^{*}\)</span> <span class="math inline">\(X_{p}=\left[\begin{array}{c} X_{\boldsymbol{p}}(X) &amp; X_{p}(Y) &amp; X_{p}(Z) \end{array}\right]\)</span></p><p><span class="math inline">\(df(X)(\boldsymbol{p})=df_{\boldsymbol{p} }(X_{\boldsymbol{p}})\)</span> where <span class="math inline">\(df=\left[\begin{array}{c} \dfrac{\partial f}{\partial x}(\boldsymbol{p})\\ \dfrac{\partial f}{\partial y}(\boldsymbol{p})\\ \dfrac{\partial f}{\partial z}(\boldsymbol{p})\\ \end{array}\right]\)</span> combine them together then we have</p><p>From <span class="math inline">\(\small (1.4)\)</span> <span class="math inline">\((X(f))(\boldsymbol{p})=X_{p}(f)=\dfrac{\partial f}{\partial x}(\boldsymbol{p}) X_{\boldsymbol{p}}(X)+\dfrac{\partial f}{\partial y}(\boldsymbol{p}) X_{\boldsymbol{p}}(Y)+\dfrac{\partial f}{\partial z}(\boldsymbol{p}) X_{\boldsymbol{p}}(Z)\)</span></p><p><span class="math inline">\(=\left[\begin{array}{c} X_{\boldsymbol{p}}(X) &amp; X_{p}(Y) &amp; X_{p}(Z) \end{array}\right]\left[\begin{array}{c} \dfrac{\partial f}{\partial x}(\boldsymbol{p})\\ \dfrac{\partial f}{\partial y}(\boldsymbol{p})\\ \dfrac{\partial f}{\partial z}(\boldsymbol{p})\\ \end{array}\right]=df(X)\)</span></p><p><span class="math inline">\((3)\)</span> Just unfold the fomula <span class="math display">\[\begin{gathered}(X\circ Y-Y\circ X)(fg)=X\circ Y(fg)-Y\circ X(fg)=X\circ (fY(g)+gY(f))-Y\circ (fX(g)+gX(f))\\=\small f (X\circ Y)g+X(f)Y(g)+g (X\circ Y)f+X(g)Y(f)-(f (Y\circ X)g+Y(f)X(g)+g (Y\circ X)f+Y(g)X(f))\\=f(X\circ Y-Y\circ X)g+g(X\circ Y-Y\circ X)f\end{gathered}\]</span> So <span class="math inline">\(X\circ Y-Y \circ X\)</span> suits the Leibniz rule, which is a vector field.</p><p><span class="math inline">\((4)\)</span> Calculate directly we can prove <span class="math inline">\((AB-BA)^{T}=-(AB-BA)\)</span> <span class="math display">\[\begin{aligned}(A B-B A)^{T} =(A B)^{T}-(B A)^{T}=(B^{T} A^{T}-A^{T} B^{T}) \\=(-B)(-A)-(-A)(-B) =BA-AB=-(A B-B A)\end{aligned}\]</span> For all the positive orthogonal matrices <span class="math inline">\(\mathcal{Q}\)</span> <span class="math inline">\(\forall \ Q\in \mathcal{Q},\det(Q)=1\)</span>. At one matrix, its tangent vector</p><p><span class="math inline">\((Q+A)^{T}(Q+A)=I=(Q^{T}+A^{T})(Q+A)=I\Longrightarrow A=-A^{T},||A||\to 0\)</span></p><p>are all Skew-symmetric matrices. According to <span class="math inline">\(\small (3)\)</span>, <span class="math inline">\(AB-BA\)</span> is also a Skew-symmetric matrix</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>高等代数选讲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高代作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thoughts on the tenth week of blog building</title>
    <link href="/2022/05/01/Thoughts%20on%20the%20tenth%20week%20of%20blog%20building/"/>
    <url>/2022/05/01/Thoughts%20on%20the%20tenth%20week%20of%20blog%20building/</url>
    
    <content type="html"><![CDATA[<h2 id="第八周">第八周</h2><ul><li><p>之前几周遇上期中周，然后 <span class="math inline">\(SRT\)</span> 那边<del>压榨劳动力</del>，每天到工位去赶进度，主要是希望挑战杯答辩顺利吧，<span class="math inline">\(\mbox{grw}\)</span> 答辩能力确实很强，再加上这个项目的自带 <span class="math inline">\(\mbox{buff}\)</span> 属性，混了个二等奖。</p></li><li><p>微积分考试前几天，感谢室友帮我留了门，无论怎样，寝室还是个比较温暖的地方。</p></li><li><p>在软院赶进度时觉得大屏显示器确实用着比较舒服，就斥<del>巨</del>资买了一个显示器，感觉用着确实不错，分屏写代码写作业看视频之类的体验都很不错。不过在 <span class="math inline">\(\mbox{zcy}\)</span> 的<del>鼓吹</del>建议下，之后经济方面宽松后还是去买一个 <span class="math inline">\(\mbox{mac}\)</span> 本，<span class="math inline">\(\mbox{windows}\)</span> 垃中之垃……</p><p><img src="https://pic.imgdb.cn/item/626ea398239250f7c544a9d4.jpg" style="zoom:15%;" /></p></li><li><p>在几天黑白颠倒之后，微积分周六考，反正发下来就觉得大事不妙，证明题比较困难，不过能拿一些分还是拿了一些分，半期分数不算高也不算低，还算凑合吧</p></li></ul><h2 id="第九周">第九周</h2><ul><li>挑战杯过后，复习大化，可以带一张 <span class="math inline">\(\mbox{cheat paper}\)</span>, 结果根本没用，而且平均分 <span class="math inline">\(89\)</span>，期末难度怕不是要起飞。真搞不懂，我这个专业为啥大学化学还是必修，生物也是，据说就是高中生物基本就是再学一遍，学点其他什么的不好……</li><li>周末投入到科展的筹备当中，端茶送水，跑腿，看大佬们的课外科技作品。身为工作人员，自己却到处参观。有幸和 <span class="math inline">\(\mbox{zcy}\)</span> 在生物蛋白质分子 <span class="math inline">\(\mbox{VR}\)</span> 眼镜处获得“拍立得''</li></ul><p><img src="https://pic.imgdb.cn/item/626ea6e5239250f7c54ec6f8.jpg" style="zoom:50%;" /></p><p><img src="https://pic.imgdb.cn/item/626ea7bc239250f7c550fe94.jpg" style="zoom:15%;" /></p><ul><li><p>忙碌了一周，周天下午回来睡觉，梦见一些奇怪的东西，话说解析梦境这种事情在我有生之年能实现吗？</p><p><img src="https://pic.imgdb.cn/item/626ead9c239250f7c560f92e.jpg" style="zoom:33%;" /></p></li></ul><h2 id="第十周">第十周</h2><ul><li><p>感觉这周也没干个什么，写写作业，准备这周的基物期中考试</p></li><li><p>周四要游泳测试，星期一和星期三晚上去陈明游泳馆分别游了一个小时，上次游泳都是去年暑假的事了，有点不熟悉蛙泳了，反正游过去就行，先保证毕业……</p></li><li><p>周四一天物理期中 + 游泳测试，中午吃完饭就马山到游泳馆，游后到东主楼见识工程能力最强的男人教我们开源软件和<strong>网络优化器</strong>（手动狗头）</p></li><li><p>漫长的五一假期开始，这周每隔一天就要测一次核酸，之前说五一假期出去耍的计划泡汤了……</p></li><li><p>五一第一天下午跟 <span class="math inline">\(\mbox{zcy}\)</span> 饭局，<strong>没得书读了</strong>真是我明年要考虑的事情！？看来一些科研相关的计划可以推进起来了，<span class="math inline">\(\mbox{GPA}\)</span> 还是高中思维，也要涉足研究领域啊</p><p><img src="https://pic.imgdb.cn/item/626eaaaa239250f7c5598a8f.jpg" style="zoom:33%;" /></p></li><li><p>傍晚又去听了 <span class="math inline">\(\mbox{zcy}\)</span> 新 <span class="math inline">\(\mbox{SRT}\)</span> 的事情，可以学习一些技术的东西，白嫖一个服务器，可以观战他们人工智能图形学的比赛，冲！</p></li><li><p>白嫖服务器过程中从高老板中获得名字，没想到 <span class="math inline">\(\mbox{LR}\)</span> 还可以是 <span class="math inline">\(\mbox{Learning Rate}\)</span> 的缩写，看来未来还是要走上炼丹的道路了。不过还有 <span class="math inline">\(\mbox{LMD(lambda},\lambda )\)</span> 、以及更离谱的 <span class="math inline">\(\mbox{STL,WSL}\)</span> 这种命中和计算机注定的简写……</p></li><li><p>晚上跟 <span class="math inline">\(\mbox{zcy}\)</span> 搞 <span class="math inline">\(\mbox{HCI}\)</span>，挺有趣的，帮他们实现了一个 <span class="math inline">\(\mbox{featrue}\)</span></p></li><li><p>虽然学校不能出去，但是学校里面的活动还是比较多，紫荆操场座无虚席</p></li><li><p>五一第一天，早上起来不久跟班上集体生日会，打狼人杀，打完回来睡觉，摆大烂</p></li><li><p>五一第二天，想卷，结果摆</p></li><li><p>五一第三天，千万不能摆了，多干事！基物成绩出了，开摆，晚上气膜馆、紫操、情人坡到处转转</p></li><li><p>五一第四天，清华学堂，淦，把 <span class="math inline">\(\mbox{OOP}\)</span> 大作业框架搭好了，之后在框架的基础上开发</p></li><li><p>五一第五天，上午班级的主题团日，职业规划，现在还是比较迷茫，不清楚自己之后的从业方向是什么，没有清晰的认识，一直在用清北名师开玩笑……中午吃完饭后回来睡午觉，睡到下午四点半，差点忘记做核酸，晚上跟 kbq 打了会儿乒乓，新手乒乓主要还是找球感吧。八点半回来学了会儿脚本，准备明天清华学堂，淦！</p></li><li><p>五一从 <span class="math inline">\(4\)</span> 月 <span class="math inline">\(30\)</span> 日开始，<span class="math inline">\(5\)</span> 月 <span class="math inline">\(5\)</span> 日结束，假期余额马上就要欠费了，哎，五一假期有点摆烂</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>随想</category>
      
      <category>里程碑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客建成六周随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matplotlib-For-Lab-of-Physics</title>
    <link href="/2022/04/30/Program/Matplotlib-For-Lab-of-Physics/"/>
    <url>/2022/04/30/Program/Matplotlib-For-Lab-of-Physics/</url>
    
    <content type="html"><![CDATA[<p>之前写的绘制最小二乘法代码太垃了，现在使用面向对象的技术对截距为 <span class="math inline">\(0\)</span> 和不为 <span class="math inline">\(0\)</span> 封装为两个类，并共同继承拥有一个父类 <span class="math inline">\(\mbox{regression}\)</span> 在命令行执行时输入相应参数，对应两种不同拟合方式，以后有时间可以增加多项式拟合相关的类。</p><p>源码以及对应详尽注释如下：（绘制拟合直线和计算相应误差并输出为 <span class="math inline">\(\LaTeX\)</span> 格式 ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt,log,pi<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> IPython <span class="hljs-keyword">import</span> embed<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> TINV <span class="hljs-keyword">import</span> TINV<br><span class="hljs-comment"># 存储xy坐标名称</span><br><br>xNames = [<span class="hljs-string">&quot;谐频次数$\mathcal&#123;n&#125;$(个)&quot;</span>, <span class="hljs-string">&quot;弦长倒数$\ \mathcal&#123;L&#125;^&#123;-1&#125;(\mathcal&#123;m&#125;$$^&#123;-1&#125;$)&quot;</span>, <br>            <span class="hljs-string">&quot;拉力对数$\ln\mathcal&#123;T&#125;&#125;$&quot;</span>, <span class="hljs-string">&quot;线密度对数$\ \lnρ$&quot;</span>, <span class="hljs-string">&quot;振动次数 n&quot;</span>, <span class="hljs-string">&quot;振幅平方$A^2(rad^2$)&quot;</span>]<br><br>yNames = [<span class="hljs-string">&quot;共振频率$\mathcal&#123;f&#125;\ \mathcal&#123;(Hz)&#125;$&quot;</span>, <span class="hljs-string">&quot;共振频率$\mathcal&#123;f&#125;\ \mathcal&#123;(Hz)&#125;$&quot;</span>, <br>            <span class="hljs-string">&quot;基频对数$\ln\mathcal&#123;f&#125;&#125;$&quot;</span>, <span class="hljs-string">&quot;基频对数$\ln\mathcal&#123;f&#125;&#125;$&quot;</span>, <span class="hljs-string">&quot;振幅($\mathrm&#123;rad&#125;$)的对数 $\mathrm&#123;ln&#125;\  θ$&quot;</span>, <span class="hljs-string">&quot;周期$T(s)$&quot;</span>]<br><br><span class="hljs-comment"># 当前选择的名称，默认为列表最后一个</span><br>xName = xNames[-<span class="hljs-number">1</span>]<br>yName = yNames[-<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 传入截距是否为0的参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getInput</span>():<br><br>    parser = argparse.ArgumentParser(description = <span class="hljs-string">&#x27;Version: v1.0. Draw the regression line for the Physics Report,&#x27;</span> <br>                        <span class="hljs-string">&#x27;coefficient 0 means the intercept is 0, &#x27;</span><br>                        <span class="hljs-string">&#x27;1 means the intercept is not 1, &#x27;</span><br>                        <span class="hljs-string">&#x27;01 means the intercept is 0 and save the figure, &#x27;</span><br>                        <span class="hljs-string">&#x27;11 means the intercept is not 0 and save the figure.&#x27;</span><br>                        <span class="hljs-string">&#x27;\nFor example, python LinearRegression.py 0&#x27;</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;crossOrigin&#x27;</span>, <span class="hljs-built_in">help</span> = <span class="hljs-string">&#x27;Whether the intercept of the line is 0 or 1. &#x27;</span> <br>                                        <span class="hljs-string">&#x27;Besides, if want to save the figure, just add 1. &#x27;</span>)<br>    args = parser.parse_args()<br>    <span class="hljs-keyword">return</span> args.crossOrigin<br><br><span class="hljs-comment"># 截距为0和不为0的父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">regression</span>:<br><br>    <span class="hljs-comment"># 初始化相关数据</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x<br>        self.y = y<br>        self.length = <span class="hljs-built_in">len</span>(x)<br>        self.k = <span class="hljs-number">0.0</span><br>        self.b = <span class="hljs-number">0.0</span><br>        self.R_2 = <span class="hljs-number">0.0</span><br>        self.Sk = <span class="hljs-number">0.0</span><br>        self.Uk = <span class="hljs-number">0.0</span><br>        self.Sb = <span class="hljs-number">0.0</span><br>        self.Ub = <span class="hljs-number">0.0</span><br>    <br>    <span class="hljs-comment"># 将计算结果表达为latex格式</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">expression</span>(<span class="hljs-params">self</span>):<br>        lineExpression = <span class="hljs-string">&quot;$\hat&#123;y&#125;=&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(self.k, <span class="hljs-number">6</span>)) + <span class="hljs-string">&quot;x&quot;</span><br>        R2Expression = <span class="hljs-string">&#x27;$r^2=&#x27;</span> + <span class="hljs-built_in">str</span>(self.R_2) + <span class="hljs-string">&quot;$&quot;</span><br>        <span class="hljs-keyword">if</span> self.b == <span class="hljs-number">0.0</span>:<br>            b = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">elif</span> self.b &gt; <span class="hljs-number">0</span>:<br>            b = <span class="hljs-string">&quot;+&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(self.b, <span class="hljs-number">6</span>))<br>        <span class="hljs-keyword">else</span>:<br>            b = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">round</span>(self.b, <span class="hljs-number">6</span>))<br>        lineExpression += (b + <span class="hljs-string">&quot;$&quot;</span>)<br>        <span class="hljs-keyword">return</span> lineExpression, R2Expression<br><br>    <span class="hljs-comment"># 绘制直线以及离散点</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drawLineAndPoints</span>(<span class="hljs-params">self</span>):<br>        xdraw = np.linspace(<span class="hljs-built_in">min</span>(self.x), <span class="hljs-built_in">max</span>(self.x), <span class="hljs-number">50</span>)<br>        ydraw = self.k * xdraw + self.b<br>        plt.plot(xdraw, ydraw, <span class="hljs-string">&#x27;-&#x27;</span> , color = <span class="hljs-string">&#x27;b&#x27;</span>, linewidth = <span class="hljs-number">0.5</span>)<br>        plt.plot(self.x, self.y, <span class="hljs-string">&#x27;ro&#x27;</span>)<br><br>    <span class="hljs-comment"># 将拟合直线表达式和相关系数自动标定在合适位置</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoExpressions</span>(<span class="hljs-params">self</span>):<br>        addLimx = (<span class="hljs-built_in">max</span>(self.x) - <span class="hljs-built_in">min</span>(self.x)) / <span class="hljs-number">10</span><br>        addLimy = (<span class="hljs-built_in">max</span>(self.y) - <span class="hljs-built_in">min</span>(self.y)) / <span class="hljs-number">10</span><br>        plt.xlim(<span class="hljs-built_in">min</span>(self.x) - addLimx, <span class="hljs-built_in">max</span>(self.x) + addLimx)<br>        plt.ylim(<span class="hljs-built_in">min</span>(self.y) - addLimy, <span class="hljs-built_in">max</span>(self.y) + addLimy)<br><br>        deltaY = <span class="hljs-built_in">max</span>(self.y ) - <span class="hljs-built_in">min</span>(self.y) + <span class="hljs-number">2</span> * addLimy<br>        deltaX = <span class="hljs-built_in">max</span>(self.x) - <span class="hljs-built_in">min</span>(self.x) + <span class="hljs-number">2</span> * addLimx<br>        middleX = (<span class="hljs-built_in">max</span>(self.x) + <span class="hljs-built_in">min</span>(self.x)) / <span class="hljs-number">2</span><br>        middleY = (<span class="hljs-built_in">max</span>(self.y) + <span class="hljs-built_in">min</span>(self.y)) / <span class="hljs-number">2</span><br><br>        <span class="hljs-keyword">if</span> self.k &lt; <span class="hljs-number">0</span>:<br>            lineY1 = middleY + deltaY * <span class="hljs-number">0.24</span><br>            lineY2 = middleY + deltaY * <span class="hljs-number">0.16</span><br>            lineX1 = middleX - deltaX * <span class="hljs-number">0.088</span><br>            lineX2 = middleX - deltaX * <span class="hljs-number">0.088</span><br>        <span class="hljs-keyword">else</span>:<br>            lineY1 = middleY - deltaY * <span class="hljs-number">0.16</span><br>            lineY2 = middleY - deltaY * <span class="hljs-number">0.24</span><br>            lineX1 = middleX - deltaX * <span class="hljs-number">0.088</span><br>            lineX2 = middleX - deltaX * <span class="hljs-number">0.088</span><br><br>        lineExpression, R2Expression = self.expression()<br>        plt.text(lineX1, lineY1, lineExpression, fontsize = <span class="hljs-number">12</span>)<br>        plt.text(lineX2, lineY2, R2Expression, fontsize = <span class="hljs-number">12</span>)<br><br>    <span class="hljs-comment"># 添加xy轴标签</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addLabels</span>(<span class="hljs-params">self</span>):<br>        plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = <span class="hljs-string">&#x27;Kaiti&#x27;</span> <span class="hljs-comment"># 文字使用楷体</span><br>        plt.xlabel(xName, fontsize = <span class="hljs-number">12</span>)<br>        plt.ylabel(yName, fontsize = <span class="hljs-number">12</span>)<br><br>    <span class="hljs-comment"># 绘制图形</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drawGraph</span>(<span class="hljs-params">self</span>):<br>        plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 正常显示负数</span><br>        plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] =<span class="hljs-string">&#x27;Times New Roman&#x27;</span>  <span class="hljs-comment"># 数字使用罗马字体</span><br>        self.drawLineAndPoints()<br>        self.addTwoExpressions()<br>        self.addLabels()<br>        self.addLabels()<br><br>    <span class="hljs-comment"># 输出数据</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dataOutput</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\quad \quad \quad 线性拟合斜率$k=&quot;</span>, <span class="hljs-built_in">round</span>(self.k, <span class="hljs-number">10</span>), end = <span class="hljs-string">&quot;$&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\quad \quad 调用Excel中TINV函数&quot;</span>, <span class="hljs-string">&quot;$t_&#123;0.95,&quot;</span>, <span class="hljs-built_in">str</span>(self.length - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;&#125;=&quot;</span>, <span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(TINV[self.length - <span class="hljs-number">1</span>]), <span class="hljs-number">10</span>), <span class="hljs-string">&quot;$\par&quot;</span>) <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\quad \quad \quad 斜率标准偏差$s_k=&quot;</span>, <span class="hljs-built_in">round</span>(self.Sk, <span class="hljs-number">10</span>), end = <span class="hljs-string">&quot;$&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\quad \quad 斜率不确定度为$U_k=&quot;</span>, <span class="hljs-built_in">round</span>(self.Uk, <span class="hljs-number">10</span>), <span class="hljs-string">&quot;$\par&quot;</span>)<br><br>        <span class="hljs-keyword">if</span>(self.Sb != <span class="hljs-number">0.0</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\quad \quad \quad 线性拟合截距$b=&quot;</span>, <span class="hljs-built_in">round</span>(self.b, <span class="hljs-number">10</span>), end = <span class="hljs-string">&quot;$&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\quad \quad 线性回归相关系数&quot;</span>, <span class="hljs-string">&quot;$R^2=&quot;</span>, <span class="hljs-built_in">round</span>(self.R_2, <span class="hljs-number">10</span>), <span class="hljs-string">&quot;$\par&quot;</span>) <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\quad \quad \quad 截距标准偏差$s_b=&quot;</span>, <span class="hljs-built_in">round</span>(self.Sb, <span class="hljs-number">10</span>), end = <span class="hljs-string">&quot;$&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\quad \quad 截距不确定度为$U_b=&quot;</span>, <span class="hljs-built_in">round</span>(self.Ub,<span class="hljs-number">10</span>), <span class="hljs-string">&quot;$\par&quot;</span>)<br><br>    <span class="hljs-comment"># 预览但不保存图片</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">output</span>(<span class="hljs-params">self</span>):<br>        self.dataOutput()<br>        self.drawGraph()<br>        plt.show()<br><br>    <span class="hljs-comment"># 保存且预览图片</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">self, saveName</span>):<br>        self.dataOutput()<br>        self.drawGraph()<br>        plt.savefig(saveName)<br>        plt.show()<br><br><span class="hljs-comment"># 继承父类，不强制截距为0</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">notCrossOrigin</span>(<span class="hljs-title class_ inherited__">regression</span>):<br><br>    <span class="hljs-comment"># 计算父类中的所有数据</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        regression.__init__(self, x, y)<br>        self.k, self.b = self.regressK_b()<br>        self.R_2 = self.getR_2()<br>        self.Sk = sqrt((<span class="hljs-number">1</span> / self.R_2 - <span class="hljs-number">1</span>) / (self.length - <span class="hljs-number">2</span>)) * self.k<br>        self.Uk = self.Sk * TINV[self.length - <span class="hljs-number">1</span>]<br>        self.Sb = sqrt((<span class="hljs-number">1</span> - self.R_2) / (self.length - <span class="hljs-number">2</span>)) * self.b<br>        self.Ub = self.Sb * TINV[self.length - <span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 计算线性回归斜率和截距</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">regressK_b</span>(<span class="hljs-params">self</span>):<br>        coef = np.polyfit(self.x, self.y, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> coef[<span class="hljs-number">0</span>], coef[<span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-comment"># 计算线性回归相关系数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getR_2</span>(<span class="hljs-params">self</span>):<br>        coeffs = np.polyfit(self.x, self.y, <span class="hljs-number">1</span>)<br>        p = np.poly1d(coeffs)<br>        yhat = p(self.x)<br>        ybar = np.<span class="hljs-built_in">sum</span>(self.y) / <span class="hljs-built_in">len</span>(self.y)<br>        ssreg = np.<span class="hljs-built_in">sum</span>((yhat - ybar) ** <span class="hljs-number">2</span>)<br>        sstot = np.<span class="hljs-built_in">sum</span>((self.y - ybar) ** <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> ssreg / sstot<br><br><span class="hljs-comment"># 继承父类，强制截距为0</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">crossOrigin</span>(<span class="hljs-title class_ inherited__">regression</span>):<br><br>    <span class="hljs-comment"># 计算父类中的所有数据</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        regression.__init__(self, x, y)<br>        self.k = np.dot(x, y) / np.dot(x, x)<br>        self.R_2, self.Sk= self.getR_2AndS_k()<br>        self.Uk = self.Sk * TINV[self.length - <span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-comment"># 计算线性回归相关系数和斜率标准偏差</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getR_2AndS_k</span>(<span class="hljs-params">self</span>):<br>        yhat = [self.k * self.x[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.length)]<br>        deltay = [self.y[i] - yhat[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.length)]<br>        ybar = np.<span class="hljs-built_in">sum</span>(self.y) / self.length<br>        newReg = np.dot(deltay, deltay)<br>        sstot = np.dot(self.y - ybar, yhat - ybar)<br>        sy = sqrt(newReg / (<span class="hljs-built_in">len</span>(self.y) - <span class="hljs-number">1</span>))<br>        xrms = sqrt(np.dot(self.x, self.x))<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> - newReg / sstot), sy / xrms<br><br><span class="hljs-comment"># 主函数定义开始</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    <span class="hljs-comment"># 原始数据，如果需要处理，添加循环语句进行计算</span><br>    x = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>)<br>    y = [<span class="hljs-number">31.2</span>,<span class="hljs-number">62.9</span>,<span class="hljs-number">95.5</span>,<span class="hljs-number">128.4</span>,<span class="hljs-number">161.0</span>,<span class="hljs-number">194.3</span>]<br><br>    <span class="hljs-comment"># 获取类型参数</span><br>    cross = getInput()<br><br>    <span class="hljs-comment"># 对不同参数进行回归</span><br>    <span class="hljs-keyword">if</span> cross == <span class="hljs-string">&quot;0&quot;</span>:<br>        crossOrigin(x, y).output()<br>    <span class="hljs-keyword">elif</span> cross == <span class="hljs-string">&quot;1&quot;</span>:<br>        notCrossOrigin(x, y).output()<br><br>    <span class="hljs-keyword">elif</span> cross == <span class="hljs-string">&quot;01&quot;</span>:<br>        crossOrigin(x, y).save(<span class="hljs-string">&quot;crossOrigin.png&quot;</span>)<br>    <span class="hljs-keyword">elif</span> cross == <span class="hljs-string">&quot;11&quot;</span>:<br>        notCrossOrigin(x, y).save(<span class="hljs-string">&quot;notCrossOrigin.png&quot;</span>)<br></code></pre></td></tr></table></figure><p>绘制可微的 <span class="math inline">\(Bezeir\)</span> 曲线源代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> scipy.special <span class="hljs-keyword">import</span> comb<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt,pi,exp<br><br><span class="hljs-comment"># 全局变量，每次绘图前修改曲线颜色，xlabel,ylabel代表横纵坐标</span><br>colorLineWhole = <span class="hljs-string">&quot;blue&quot;</span><br>xLabel = [<span class="hljs-string">&quot;Forced frequency $\omega_&#123;f&#125; (\mathrm&#123;s&#125;^&#123;-1&#125;)$&quot;</span>]<br>yLabel = [<span class="hljs-string">&quot;Amplitude θ (°)&quot;</span>,<span class="hljs-string">&quot;Phase Difference φ&quot;</span>,<span class="hljs-string">&quot;Amplitude θ (°)&quot;</span>]<br><br><span class="hljs-comment"># 使用 python 中面向对象特性，编写贝塞尔曲线类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BezierCurve</span>:<br><br>    <span class="hljs-comment"># 初始化点坐标和控制点个数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, list_of_points: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>]]</span>):<br>        self.list_of_points = list_of_points<br>        self.degree = <span class="hljs-built_in">len</span>(list_of_points) - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># Bezier 曲线基函数对应多项式系数数组 B_&#123;i,n&#125;(t) = C_&#123;n&#125;^&#123;i&#125; * (1 - t)^&#123;n - i&#125; * t^&#123;i&#125;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">basis_function</span>(<span class="hljs-params">self, t: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">float</span>]:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> &lt;= t &lt;= <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Time t must be between 0 and 1.&quot;</span><br>        output_values: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">float</span>] = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.list_of_points)):<br>            output_values.append(comb(self.degree, i) * ((<span class="hljs-number">1</span> - t) ** (self.degree - i)) * (t**i))<br>        <span class="hljs-keyword">return</span> output_values<br><br>    <span class="hljs-comment"># 计算 Bezier 曲线函数在 t∈[0,1] 处的值</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bezier_curve_function</span>(<span class="hljs-params">self, t: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>]:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> &lt;= t &lt;= <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Time t must be between 0 and 1.&quot;</span><br>        basis_function = self.basis_function(t)<br>        x = <span class="hljs-number">0.0</span><br>        y = <span class="hljs-number">0.0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.list_of_points)):<br>            x += basis_function[i] * self.list_of_points[i][<span class="hljs-number">0</span>]<br>            y += basis_function[i] * self.list_of_points[i][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> (x, y)<br><br>    <span class="hljs-comment"># 绘制给定 n 个控制点下的 Bezier 曲线</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_curve</span>(<span class="hljs-params">self, step_size: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.001</span></span>):<br>        to_plot_x: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">float</span>] = []<br>        to_plot_y: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">float</span>] = []<br>        t = <span class="hljs-number">0.0</span><br>        <span class="hljs-keyword">while</span> t &lt;= <span class="hljs-number">1</span>:<br>            value = self.bezier_curve_function(t)<br>            to_plot_x.append(value[<span class="hljs-number">0</span>])<br>            to_plot_y.append(value[<span class="hljs-number">1</span>])<br>            t += step_size<br>        x = [i[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.list_of_points]<br>        y = [i[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.list_of_points]<br>        plt.plot(to_plot_x, to_plot_y, color = colorLineWhole, linewidth = <span class="hljs-number">0.88</span>)<br><br><span class="hljs-comment">#  x 排序从大到小，并保证数据对应</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sortXY</span>(<span class="hljs-params">x, y</span>):<br>    data = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        data.append([x[i],y[i]])<br>    data.sort(key = <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])<br>    x = [i[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data]<br>    y = [i[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data]<br>    <span class="hljs-keyword">return</span> x, y<br><br><span class="hljs-comment"># 计算两个点的欧式距离</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">p1,p2</span>):<br>    <span class="hljs-keyword">return</span> sqrt((p1[<span class="hljs-number">0</span>] - p2[<span class="hljs-number">0</span>]) * (p1[<span class="hljs-number">0</span>] - p2[<span class="hljs-number">0</span>]) + (p1[<span class="hljs-number">1</span>] - p2[<span class="hljs-number">1</span>]) * (p1[<span class="hljs-number">1</span>] - p2[<span class="hljs-number">1</span>]))<br><br><span class="hljs-comment"># 计算四个点对应两条直线的交点</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">intersectPoints</span>(<span class="hljs-params">p1, p2, p3, p4</span>):<br>    k1 = (p2[<span class="hljs-number">1</span>] - p1[<span class="hljs-number">1</span>]) / (p2[<span class="hljs-number">0</span>] - p1[<span class="hljs-number">0</span>])<br>    b1 = p1[<span class="hljs-number">1</span>] - k1 * p1[<span class="hljs-number">0</span>]<br>    k2 = (p4[<span class="hljs-number">1</span>] - p3[<span class="hljs-number">1</span>]) / (p4[<span class="hljs-number">0</span>] - p3[<span class="hljs-number">0</span>])<br>    b2 = p3[<span class="hljs-number">1</span>] - k2 * p3[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> [(b1 - b2) / (k2 - k1), (k2 * b1 - k1 * b2) / (k2 - k1)]<br><br><span class="hljs-comment"># 计算由上述所生成三个点所构成三角形的内心</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">angularBisector</span>(<span class="hljs-params">p1,p2,p3,p4</span>):<br>    interP = intersectPoints(p1,p2,p3,p4)<br>    a = distance(p2, p3)<br>    b = distance(p3, interP)<br>    c = distance(p2, interP)<br><span class="hljs-keyword">return</span> [(a * interP[<span class="hljs-number">0</span>] + b * p2[<span class="hljs-number">0</span>] + c * p3[<span class="hljs-number">0</span>]) / (a + b + c),<br>             (a * interP[<span class="hljs-number">1</span>] + b * p2[<span class="hljs-number">1</span>] + c * p3[<span class="hljs-number">1</span>]) / (a + b + c) ]<br><br><span class="hljs-comment"># 计算给定离散点生成的 Bezier 曲线</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pointdBezierGraph</span>(<span class="hljs-params">x,y,colorPoint</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        plt.scatter(x[i], y[i], color = colorPoint, marker = <span class="hljs-string">&quot;+&quot;</span>, s = <span class="hljs-number">24</span>, linewidth = <span class="hljs-number">0.88</span>)<br>    averageX = (x[-<span class="hljs-number">1</span>] - x[<span class="hljs-number">0</span>]) / <span class="hljs-built_in">len</span>(x)<br>    x.insert(<span class="hljs-number">0</span>, x[<span class="hljs-number">0</span>] - averageX)<br>    x.append(x[-<span class="hljs-number">1</span>] + averageX)<br>    y.insert(<span class="hljs-number">0</span>, y[<span class="hljs-number">0</span>])<br>    y.append(y[-<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x) - <span class="hljs-number">3</span>):<br>        p1 = [x[i], y[i]]<br>        p2 = [x[i + <span class="hljs-number">1</span>], y[i + <span class="hljs-number">1</span>]]<br>        p3 = [x[i + <span class="hljs-number">2</span>], y[i + <span class="hljs-number">2</span>]]<br>        p4 = [x[i + <span class="hljs-number">3</span>], y[i + <span class="hljs-number">3</span>]]<br>        I = angularBisector(p1, p2, p3, p4)<br>        BezierCurve([p2, I, p3]).plot_curve()<br><br><span class="hljs-comment"># 自动处理数据，传入两个列表，线条颜色，标记点颜色， 绘制 Bezier 曲线</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drawBezier</span>(<span class="hljs-params">x,y,colorLine,colorPoint</span>):<br>    x,y = sortXY(x,y)<br>    <span class="hljs-keyword">global</span> colorLineWhole<br>    colorLineWhole = colorLine<br>    pointdBezierGraph(x,y,colorPoint)<br><br><span class="hljs-comment"># 主函数定义开始</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    x = [<span class="hljs-number">1.575</span>,<span class="hljs-number">1.553</span>,<span class="hljs-number">1.531</span>,<span class="hljs-number">1.516</span>,<span class="hljs-number">1.501</span>,<span class="hljs-number">1.487</span>,<span class="hljs-number">1.479</span>,<span class="hljs-number">1.472</span>,<span class="hljs-number">1.465</span>,<span class="hljs-number">1.451</span>,<span class="hljs-number">1.443</span>,<span class="hljs-number">1.427</span>,<span class="hljs-number">1.413</span>,<span class="hljs-number">1.391</span>,<span class="hljs-number">1.369</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        x[i] = <span class="hljs-number">2</span> * pi / x[i]<br><br>    y = [<span class="hljs-number">15</span>,<span class="hljs-number">25</span>,<span class="hljs-number">35</span>,<span class="hljs-number">44</span>,<span class="hljs-number">58</span>,<span class="hljs-number">76</span>,<span class="hljs-number">87</span>,<span class="hljs-number">99</span>,<span class="hljs-number">112</span>,<span class="hljs-number">130</span>,<span class="hljs-number">138</span>,<span class="hljs-number">147</span>,<span class="hljs-number">152</span>,<span class="hljs-number">156</span>,<span class="hljs-number">160</span>]<br>    drawBezier(x,y,<span class="hljs-string">&quot;green&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>)<br><br>    plt.xlabel(xLabel[<span class="hljs-number">1</span>])<br>    plt.ylabel(yLabel[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment"># plt.savefig(&quot;图片.png&quot;,dpi = 2000)</span><br>    plt.show()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>可视化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python 可视化基物实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advanced Algebra HW6</title>
    <link href="/2022/04/29/Math/Advanced%20Linear%20Algebra/HW6/"/>
    <url>/2022/04/29/Math/Advanced%20Linear%20Algebra/HW6/</url>
    
    <content type="html"><![CDATA[<h1 id="largetextcolorbluemboxadvanced-algebra-small-mathbbhwmathrm6-_textcolorblue2022.4.29"><span class="math inline">\(\large\textcolor{blue}{\mbox{Advanced Algebra } \small \mathbb{HW}\mathrm{6}}\ \ \ \ \ \ _\textcolor{blue}{2022.4.29}\)</span></h1><h2 id="small-mboxvandermode-matrix">1.6.1<span class="math inline">\(\ \small \mbox{Vandermode matrix}\)</span></h2><p>Let <span class="math inline">\(V\)</span> be the space of real polynomials of degree less than <span class="math inline">\(n\)</span>. So <span class="math inline">\(\operatorname{dim} V=n\)</span>. Then for each <span class="math inline">\(a \in \mathbb{R}\)</span>, the evaluation <span class="math inline">\(\mathrm{ev}_{a}\)</span> is a dual vector.</p><p>For any real numbers <span class="math inline">\(a_{1}, \ldots, a_{n} \in \mathbb{R}\)</span>, consider the map <span class="math inline">\(L: V \rightarrow \mathbb{R}^{n}\)</span> such that <span class="math inline">\(L(p)=\left[\begin{array}{c}p\left(a_{1}\right) \\ \vdots \\ p\left(a_{n}\right)\end{array}\right]\)</span>.</p><ol type="1"><li>Write out the matrix for <span class="math inline">\(L\)</span> under the basis <span class="math inline">\(1, x, \ldots, x^{n-1}\)</span> for <span class="math inline">\(V\)</span> and the standard basis for <span class="math inline">\(\mathbb{R}^{n}\)</span>. (Do you know the name for this matrix?)</li><li>Prove that <span class="math inline">\(L\)</span> is invertible if and only if <span class="math inline">\(a_{1}, \ldots, a_{n}\)</span> are distinct. (If you can name the matrix <span class="math inline">\(L\)</span>, then you may use its determinant formula without proof.)</li><li>Show that <span class="math inline">\(\mathrm{ev}_{a_{1}}, \ldots, \mathrm{ev}_{a_{n}}\)</span> form a basis for <span class="math inline">\(V^{*}\)</span> if and only if all <span class="math inline">\(a_{1}, \ldots, a_{n}\)</span> are distinct.</li><li>Set <span class="math inline">\(n=3\)</span>. Find polynomials <span class="math inline">\(p_{1}, p_{2}, p_{3}\)</span> such that <span class="math inline">\(p_{i}(j)=\delta_{i j}\)</span> for <span class="math inline">\(i, j \in\{-1,0,1\}\)</span>.</li><li>Set <span class="math inline">\(n=4\)</span>, and consider <span class="math inline">\(\mathrm{ev}_{-2}, \mathrm{ev}_{-1}, \mathrm{ev}_{0}, \mathrm{ev}_{1}, \mathrm{ev}_{2} \in V^{*}\)</span>. Since <span class="math inline">\(\operatorname{dim} V^{*}=4\)</span>, these must be linearly dependent. Find a non-trivial linear combination of these which is zero.</li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(L=\left[\begin{array}{cccc} 1 &amp; a_{1} &amp; \cdots &amp; a_{1}^{n-1} \\ 1 &amp; a_{2} &amp; \cdots &amp; a_{2}^{n-1} \\ \vdots &amp; &amp; &amp; \vdots \\ 1 &amp; a_{n} &amp; \cdots &amp; a_{n}^{n-1} \end{array}\right]\)</span><strong>Vandermode matrix</strong></p><p>Calculate its inverse and we can get standard basis using Lagrange interpolation. <span class="math display">\[\left(\begin{array}{cccc}1 &amp; a_{1} &amp; \cdots &amp; a_{1}^{n-1} \\1 &amp; a_{2} &amp; \cdots &amp; a_{2}^{n-1} \\\vdots &amp; &amp; &amp; \vdots \\1 &amp; a_{n} &amp; \cdots &amp; a_{n}^{n-1}\end{array}\right)\left(\begin{array}{c}x_{0} \\ x_{1} \\ x_{2} \\ \vdots \\ x_{n-1}\end{array}\right)=\left(\begin{array}{c}y_{0} \\ y_{1} \\ y_{2} \\ \vdots \\ y_{n-1}\end{array}\right)\\\left(\begin{array}{cccc}1 &amp; a_{1} &amp; \cdots &amp; a_{1}^{n-1} \\1 &amp; a_{2} &amp; \cdots &amp; a_{2}^{n-1} \\\vdots &amp; &amp; &amp; \vdots \\1 &amp; a_{n} &amp; \cdots &amp; a_{n}^{n-1}\end{array}\right)^{-1}\left(\begin{array}{c}y_{0} \\ y_{1} \\ y_{2} \\ \vdots \\ y_{n-1}\end{array}\right)=\left(\begin{array}{c}x_{0} \\ x_{1} \\ x_{2} \\ \vdots \\ x_{n-1}\end{array}\right)\]</span> Construct polynomial <span class="math inline">\(f(a)=\displaystyle \sum_{i}y_i \prod_{j \neq i} \frac{a-a_{j}}{a_{i}-a_{j}}\)</span> So <span class="math inline">\(f(a_i)=x_i\)</span></p><p>So <span class="math inline">\(\left(V^{-1}\right)_{i j}\)</span> is the coefficient of <span class="math inline">\(\displaystyle \prod_{k \neq i} \frac{a-a_{k}}{a_{i}-a_{k}}\)</span> at <span class="math inline">\(x^{j-1}\)</span> , which is <span class="math inline">\(\displaystyle\left(V^{-1}\right)_{i j}=\left[x^{j-1}\right] \prod_{k \neq i} \frac{a-a_{k}}{a_{i}-a_{k}}\)</span> <span class="math display">\[\left(V^{-1}\right)_{i j}=(-1)^{j+1} \frac{\displaystyle \sum_{0 \leq p_{1}&lt;\cdots&lt;p_{n-\zeta} ; p_{1}, p_{2}, \cdots p_{n-j} \neq i} x_{p_{1}} x_{p_{2}} \cdots x_{p_{n-j}}}{\displaystyle \prod_{0 \leq k&lt;n ; k \neq i}\left(x_{k}-x_{i}\right)}\]</span> The column of the <span class="math inline">\((V^{-1})\)</span> is the standard basis of <span class="math inline">\(V\)</span></p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(\det L=\displaystyle \prod_{1\leq i\leq j\leq n }(a_i-a_j)\neq 0\Longleftrightarrow a_i\neq a_j\)</span></p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(e v_{a_{1}}, \cdots, ev_{a_n}\)</span> form a basis for <span class="math inline">\(V^{*} \Longleftrightarrow e v_{a_{1}}, e v_{a_{2}}, \cdots, ev_{a_n}\)</span>, evan are linearly indepenctent.</p><p>The matrix <span class="math inline">\(\left(\begin{array}{c}e v_{a_{1}} \\ e v_{a_{2}} \\ \vdots \\ e v_{a_{n}}\end{array}\right)\)</span> is invertible, which means <span class="math inline">\(L\)</span> is invertible. According to <span class="math inline">\(\small(2)\)</span>, <span class="math inline">\(a_i\)</span> are distinct.</p><p><span class="math inline">\((4)\)</span> Pick original basis <span class="math inline">\(\{1,x,x^2\}\)</span> So <span class="math inline">\(\alpha_{1}=(1,-1,1) \quad \alpha_{2}=(1,0,0) \quad \alpha_{3}=(1,1,1)\)</span> <span class="math display">\[A=\left(\begin{array}{l}\alpha_{1} \\ \alpha_{2} \\ \alpha_{3}\end{array}\right)=\left(\begin{array}{ccc}1 &amp; -1 &amp; 1 \\ 1 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1\end{array}\right) \quad A^{-1}=\left(\begin{array}{ccc}0 &amp; 1 &amp; 0 \\ -\frac{1}{2} &amp; 0 &amp; \frac{1}{2} \\ \frac{1}{2} &amp; -1 &amp; \frac{1}{2}\end{array}\right)\]</span> So <span class="math inline">\(p_{1}=-\dfrac{1}{2} x+\dfrac{1}{2} x^{2} \quad p_{2}=1-x^{2} \quad p_{3}=\dfrac{1}{2} x+\dfrac{1}{2} x^{2}\)</span></p><p><span class="math inline">\((5)\)</span> Set <span class="math inline">\(p(x)=ax^3+bx^2+cx+d\)</span> and <span class="math display">\[m e v_{-2}+n e v_{-1}+p e v_{0}+q e v_{1}+r e v_{2}=0\]</span> <span class="math display">\[\begin{gathered}e v_{-2}=-8 a+4 b-2 c+d \quad e v_{-1}=-a+b-c+d \quad e v_{0}=d\\ \quad e v_{1}=a+b+c+d \quad e v_{2}=8 a+4 b+2 c+d\\\left(\begin{array}{ccccc}-8 &amp; -1 &amp; 0 &amp; 1 &amp; 8 \\ 4 &amp; 1 &amp; 0 &amp; 1 &amp; 4 \\ -2 &amp; -1 &amp; 0 &amp; 1 &amp; 2 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp;1\end{array}\right)\left(\begin{array}{l}m \\ n \\ p \\ q \\ r\end{array}\right)=\boldsymbol 0\end{gathered}\]</span> Solve that <span class="math inline">\(e v_{-2}-4 e v_{-1}+6 e v_{0}-4 e v_{1}+e v_{2}=0\)</span></p><h2 id="small-mboxdual-vector-in-polynomials">1.6.2<span class="math inline">\(\ \small \mbox{dual vector in polynomials}\)</span></h2><p>Let <span class="math inline">\(V\)</span> be the space of real polynomials of degree less than <span class="math inline">\(3\)</span>. Which of the following is a dual vector? Prove it or show why not.</p><ol type="1"><li><span class="math inline">\(p \mapsto \operatorname{ev}_{5}((x+1) p(x))\)</span>.</li><li><span class="math inline">\(p \mapsto \lim _{x \rightarrow \infty} \dfrac{p(x)}{x}\)</span>.</li><li><span class="math inline">\(p \mapsto \lim _{x \rightarrow \infty} \dfrac{p(x)}{x^{2}}\)</span>.</li><li><span class="math inline">\(p \mapsto p(3) p^{\prime}(4)\)</span>.</li><li><span class="math inline">\(p \mapsto \operatorname{deg}(p)\)</span>, the degree of the polynomial <span class="math inline">\(p\)</span>.</li></ol><hr /><p><span class="math inline">\((1)\)</span> Yes. <span class="math inline">\(①\  e_{s}((x+1) p(x))=6 p(5)\)</span>. that is the map from <span class="math inline">\(V\)</span> to <span class="math inline">\(\mathbb{R}\)</span>. <span class="math inline">\(②\)</span> For <span class="math inline">\(\forall\  p, q \in V\)</span> and</p><p><span class="math inline">\(\forall m, n \in \mathbb{R}, L(m p+n q)=6 m p(5)+6 n p(5)=m L(p)+n L(q)\)</span>, so its bilinear.</p><p><span class="math inline">\((2)\)</span> No. Sometimes the limit doeen't exist when <span class="math inline">\(\mbox{deg}(p)\geq 2\)</span></p><p><span class="math inline">\((3)\)</span> Yes. This vector is just a 'taking the coefficient of <span class="math inline">\(x^2\)</span>', which is bilinear.</p><p><span class="math inline">\((4)\)</span> No. For instance, <span class="math inline">\(p(x)=x^{2}+2, q(x)=-2 x, \quad L(p)=11 \times 8=88 \quad L(q)=12\)</span></p><p><span class="math inline">\(L(p+q)=5 \times 6=30 . \quad L(p+q) \neq L(p)+L(q)\)</span>. So it's not a dual vector.</p><p><span class="math inline">\((5)\)</span> No. For instance, <span class="math inline">\(p(x)=x^{2}+x, q(x)=-x^{2}+1, L(p)=\operatorname{deg}(p)=2, L(q)=\operatorname{deg}(q)=2\)</span></p><p><span class="math inline">\(L(p+q)=\operatorname{deg}(x+1)=1 . L(p)+L(q) \neq L(p+q)\)</span>. So it's not a clual vector</p><h2 id="small-mboxdirectional-derivative">1.6.3<span class="math inline">\(\ \small \mbox{directional derivative}\)</span></h2><p>Fix a differentiable function <span class="math inline">\(f: \mathbb{R}^{2} \rightarrow \mathbb{R}\)</span>, and fix a point <span class="math inline">\(\boldsymbol{p} \in \mathbb{R}^{2}\)</span>. For any vector <span class="math inline">\(\boldsymbol{v} \in \mathbb{R}^{2}\)</span>, then the directional derivative of <span class="math inline">\(f\)</span> at <span class="math inline">\(\boldsymbol{p}\)</span> in the direction of <span class="math inline">\(\boldsymbol{v}\)</span> is defined as <span class="math inline">\(\nabla_{\boldsymbol{v}} f:=\lim _{t \rightarrow 0} \dfrac{f(\boldsymbol{p}+t \boldsymbol{v})-f(\boldsymbol{p})}{t} . S \mathrm{Show}\)</span> that the map <span class="math inline">\(\nabla f: \boldsymbol{v} \mapsto \nabla_{\boldsymbol{v}}(f)\)</span> is a dual vector in <span class="math inline">\(\left(\mathbb{R}^{2}\right)^{*}\)</span>, i.e., a row vector. Also, what are its "coordinates" under the standard dual basis? (Remark: In calculus, we write <span class="math inline">\(\nabla f\)</span> as a column vector for historical reasons. By all means, from a mathematical perspective, the correct way to write <span class="math inline">\(\nabla f\)</span> is to write it as a row vector, as illlustrated in this problem. (But don't annoy your calculus teachers though.... In your calculus class, you use whatever notation your calculus teacher told you.) (Extra Remark: If we use row vector, then the evaluation of <span class="math inline">\(\nabla f\)</span> at <span class="math inline">\(\boldsymbol{v}\)</span> is purely linear, and no inner product structure is needed, which is sweet. But if we HAVE TO write <span class="math inline">\(\nabla f\)</span> as a column vector (for historical reason), then we would have to do a dot product between <span class="math inline">\(\nabla f\)</span> and <span class="math inline">\(\boldsymbol{v}\)</span>, which now requires an inner product structure. That is an unnecessary dependence on an extra structure that actually should have no influence.)</p><hr /><p>Set <span class="math inline">\(\vec{v}=\begin{pmatrix}a\\b\end{pmatrix}\)</span>, since the function <span class="math inline">\(f\)</span> is differentiable, <span class="math inline">\(\nabla_{\vec{v}} f=\dfrac{\partial f(\vec{v})}{\partial x} \cdot \dfrac{a}{\sqrt{a^{2}+b^{2}}}+\dfrac{\partial f(\vec{v})}{\partial y} \dfrac{b}{\sqrt{a^{2}+b}}\)</span></p><p>So the map <span class="math inline">\(\nabla f\)</span> is a map from <span class="math inline">\(\left(\mathbb{R}^{2}\right)^{*}\)</span> to <span class="math inline">\(\mathbb{R}\)</span>.And for <span class="math inline">\(\forall\)</span> diffential functions <span class="math inline">\(f, g, \forall m, n \in \mathbb{R}\)</span>, we have: <span class="math display">\[\begin{aligned}\nabla_{\vec{v}}(m f+n g) &amp;=\frac{\partial[m f(\vec{v})+n g(\vec{v})]}{\partial x} \cdot \frac{a}{\sqrt{a^{2}+b^{2}}}+\frac{\partial[m f(\vec{v})+n g(\vec{v})]}{\partial y} \cdot \frac{b}{\sqrt{a^{2}+b^{2}}} \\&amp;=m \nabla_{\vec{v}} f+n \nabla_{\vec{v}} g\end{aligned}\]</span> So the map <span class="math inline">\(\nabla f\)</span> is bilinear, i.e, is a dual vector in <span class="math inline">\(\left(\mathbb{R}^{2}\right)^{*}\)</span>.</p><p>Since <span class="math inline">\(x\)</span>-axis and <span class="math inline">\(y\)</span>-axis are perpendicular, the standard dual basis is <span class="math inline">\(\dfrac{\partial f}{\partial x}\)</span> and <span class="math inline">\(\dfrac{\partial f}{\partial y} .\)</span> And the coordinates are <span class="math inline">\(\dfrac{\vec{v} \cdot \hat{x}}{\|\vec{v}\|}\)</span> and <span class="math inline">\(\dfrac{\vec{v} \cdot \hat{y}}{\|\vec{v}\|}\)</span></p><h2 id="section">1.6.4$ $</h2><p>Consider a linear map <span class="math inline">\(L: V \rightarrow W\)</span> and its dual map <span class="math inline">\(L^{*}: W^{*} \rightarrow V^{*}\)</span>. Prove the following.</p><ol type="1"><li><span class="math inline">\(\operatorname{Ker}\left(L^{*}\right)\)</span> is exactly the collection of dual vectors in <span class="math inline">\(W^{*}\)</span> that kills <span class="math inline">\(\operatorname{Ran}(L)\)</span>.</li><li><span class="math inline">\(\operatorname{Ran}\left(L^{*}\right)\)</span> is exactly the collection of dual vectors in <span class="math inline">\(V^{*}\)</span> that kills <span class="math inline">\(\operatorname{Ker}(L)\)</span>.</li></ol><hr /><p><span class="math inline">\((1)\)</span> First, all the elements in <span class="math inline">\(\ker(L^*)\in W^{*}\)</span>, so just prove <span class="math inline">\(\forall \ \vec{v}\in \ker(L^*),\vec{\omega}\in \mbox{Ran}(L),\vec{v}^{T}\cdot \vec{\omega}=0\)</span></p><p><span class="math inline">\(L^{*}\vec{v}=0,L^{*}\vec{v}\cdot\vec{x}=0=\vec{v}^{T}(L\vec{x})\)</span>, set <span class="math inline">\(L\vec{x}=\vec{\omega}\)</span> So <span class="math inline">\(\vec{v}^{T}\cdot \vec{\omega}=\langle \vec{v},\vec{\omega}\rangle=0\)</span></p><p><span class="math inline">\((2)\)</span> First, all the elements in <span class="math inline">\(\mbox{Ran}(L^{*})\in V^{*}\)</span> ,so just prove <span class="math inline">\(\forall \ \vec{v}\in \mbox{Ran}(L^*),\vec{\omega}\in \mbox{Ker}(L),\vec{v}^{T}\cdot \vec{\omega}=0\)</span></p><p><span class="math inline">\(L\vec{\omega}=0,L\vec{\omega}\cdot\vec{x}=0=\vec{\omega}^{T}(L^{*}\vec{x})\)</span>, set <span class="math inline">\(L^{*}\vec{x}=\vec{v}\)</span>, So <span class="math inline">\(\vec{\omega}^{T}\cdot \vec{v}=\langle \vec{\omega},\vec{v}\rangle=0\)</span></p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>高等代数选讲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高代作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advanced Algebra Midterm</title>
    <link href="/2022/04/24/Math/Advanced%20Linear%20Algebra/Advanced%20Algebra%20Midterm/"/>
    <url>/2022/04/24/Math/Advanced%20Linear%20Algebra/Advanced%20Algebra%20Midterm/</url>
    
    <content type="html"><![CDATA[<h1 id="largetextcolorbluemboxadvanced-algebra-small-mathbfmidterm-_textcolorblue2022.4.21"><span class="math inline">\(\large\textcolor{blue}{\mbox{Advanced Algebra } \small \mathbf{Midterm}}\ \ \ \ \ \ _\textcolor{blue}{2022.4.21}\)</span></h1><h2 id="problem-1-small-mboxquaternions">Problem 1<span class="math inline">\(\ \small \mbox{Quaternions}\)</span></h2><p>The quaternions are widely applied in computation graphics and computer games, and can also be used to simplify calculations that involves angular stuff or rotations. They are defiend as <span class="math inline">\(a+b i+c j+d k\)</span>, where <span class="math inline">\(a, b, c, d \in \mathbb{R}\)</span> and <span class="math inline">\(i^{2}=j^{2}=k^{2}=i j k=-1\)</span>. (In particular, the multiplication is defined <span class="math display">\[a s(a+b i+c j+d k)\left(a^{\prime}+b^{\prime} i+c^{\prime} j+d^{\prime} k\right)=\left(a a^{\prime}-b b^{\prime}-c c^{\prime}-d d^{\prime}\right)+\\\left(a b^{\prime}+b a^{\prime}+c d^{\prime}-d c^{\prime}\right) i+\left(a c^{\prime}+c a^{\prime}+d^{\prime} b-\right.\left.b d^{\prime}\right) j+\left(a d^{\prime}+d a^{\prime}+b c^{\prime}-c b^{\prime}\right) k\]</span> You don't really need to know this formula for this problem though.)</p><p><span class="math inline">\((1)\)</span> Recall that we can formulate complex numbers as matrices. Similarly, let us try this for quaternions. Consider matrices of the form <span class="math display">\[a\left[\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right]+b\left[\begin{array}{cccc}0 &amp; -1 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -1 \\ 0 &amp; 0 &amp; 1 &amp; 0\end{array}\right]+c\left[\begin{array}{cccc}0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 &amp; 0\end{array}\right]+d\left[\begin{array}{cccc}0 &amp; 0 &amp; 0 &amp; -1 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0\end{array}\right]\]</span> where <span class="math inline">\(a, b, c, d \in \mathbb{R}\)</span>. Show that this gives a model of the quaternions as well, i.e., they satisfy <span class="math inline">\(i^{2}=j^{2}=k^{2}=i j k=-1\)</span>.</p><p><span class="math inline">\((2)\)</span> You may interpret <span class="math inline">\(\left[\begin{array}{l}a \\ b \\ c \\ d\end{array}\right] \in \mathbb{R}^{4}\)</span> as the quaternion <span class="math inline">\(a+b i+c j+d k\)</span>. Then for any quaternion <span class="math inline">\(q\)</span>, multiplying <span class="math inline">\(q\)</span> to <span class="math inline">\(a+b i+c j+d k\)</span> from the left gives a linear map <span class="math inline">\(\mathbb{R}^{4} \rightarrow \mathbb{R}^{4}:(a+b i+c j+d k) \mapsto q(a+b i+c j+d k)\)</span>. If <span class="math inline">\(q=r+x i+y j+z k\)</span>, what is the matrix <span class="math inline">\(L_{q}\)</span> for this linear map? What is the matrix <span class="math inline">\(R_{q}\)</span> for the linear map if we multiply <span class="math inline">\(q\)</span> from the right? Do we have <span class="math inline">\(L_{q} R_{q}=R_{q} L_{q}\)</span> ?</p><p><span class="math inline">\((3)\)</span> The conjugate of a quaternion <span class="math inline">\(q=a+b i+c j+d k\)</span> is <span class="math inline">\(\bar{q}=a-b i-c j-d k\)</span>. Show that for a unit quaternion <span class="math inline">\(q\)</span> (i.e., <span class="math inline">\(q \bar{q}=1\)</span> ), the matrix <span class="math inline">\(L_{q} R_{\bar{q}}\)</span> has block form <span class="math inline">\(\left[\begin{array}{cc}1 &amp; 0 \\ 0 &amp; Q\end{array}\right]\)</span> where <span class="math inline">\(Q\)</span> is an orthogonal matrix. (Hint: The block form is easy. To see that <span class="math inline">\(Q\)</span> is orthogonal, an easy way is to show that <span class="math inline">\(\left(L_{q} R_{\bar{q}}\right)^{T}\left(L_{q} R_{\bar{q}}\right)=I\)</span> by understanding the meaning of the matrices involved.) (In particular, if you interpret a <span class="math inline">\(3 D\)</span> vector <span class="math inline">\((x, y, z)\)</span> as the quaternion <span class="math inline">\(v=0+x i+y j+z k \mathrm{~ , ~ t h e n ~ t h e ~ q u a t e r n i o n ~ m u l t i p l i c a t i o n ~ q v}\)</span> to some rotation of <span class="math inline">\(v\)</span>. This quaternion interpretation is currently one of the best way to compute 3D rotations in real life. Many of your games with <span class="math inline">\(3 D\)</span> graphics depend on this.)</p><hr /><p><span class="math inline">\((1)\)</span> Just calculate it.</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(L_{q}=\begin{pmatrix}r&amp;-x&amp;-y&amp;-z\\x&amp;r&amp;-z&amp;y\\y&amp;z&amp;r&amp;-x\\z&amp;-y&amp;x&amp;r\end{pmatrix},R_{q}=\begin{pmatrix}r&amp;-x&amp;-y&amp;-z\\x&amp;r&amp;z&amp;-y\\y&amp;-z&amp;r&amp;x\\z&amp;y&amp;-x&amp;r\end{pmatrix}\)</span></p><p><span class="math inline">\(R_qL_q=\begin{pmatrix}-x^2-y^2-z^2+r^2&amp;-2rx&amp;-2ry&amp;-2rz\\2rx&amp;-x^2+r^2+y^2+z^2&amp;-2xy&amp;-2xz\\2yr&amp;-2yx&amp;-y^2+z^2+r^2+x^2&amp;-2zy\\2zr&amp;2zx&amp;-2zy&amp;-z^2+r^2+x^2+y^2\end{pmatrix}\)</span></p><p><span class="math inline">\(L_qR_q=\begin{pmatrix}-x^2-y^2-z^2+r^2&amp;-2rx&amp;-2ry&amp;-2rz\\2rx&amp;-x^2+r^2+y^2+z^2&amp;-2xy&amp;-2xz\\2yr&amp;-2yx&amp;-y^2+z^2+r^2+x^2&amp;-2zy\\2zr&amp;2zx&amp;-2zy&amp;-z^2+r^2+x^2+y^2\end{pmatrix}\)</span></p><p>So <span class="math inline">\(L_qR_q=R_qL_q\)</span>, and it's obvious when looking at its linear map, which is both right for <span class="math inline">\(L_qR_q\)</span> and <span class="math inline">\(R_qL_q\)</span> : <span class="math inline">\(\mathbb{R}^{4} \rightarrow \mathbb{R}^{4}:(a+b i+c j+d k) \mapsto q(a+b i+c j+d k)q\)</span></p><p><span class="math inline">\((3)\)</span> Calculate that <span class="math inline">\(q\bar{q}=1\Longleftrightarrow a^2+b^2+c^2+d^2=1\)</span> <span class="math display">\[\begin{gathered}L_qR_{\bar{q}}=\begin{pmatrix}a&amp;-b&amp;-c&amp;-d\\b&amp;a&amp;-d&amp;c\\c&amp;d&amp;a&amp;-b\\d&amp;-c&amp;b&amp;a\end{pmatrix}\begin{pmatrix}a&amp;b&amp;c&amp;d\\-b&amp;a&amp;-d&amp;c\\-c&amp;d&amp;a&amp;-b\\-d&amp;-c&amp;b&amp;a\end{pmatrix}\\=\begin{pmatrix}1&amp;0&amp;0&amp;0\\0&amp;a^2+b^2-c^2-d^2&amp;2(bc-ad)&amp;2(ac+bd)\\0&amp;2(ad+bc)&amp;a^2+c^2-b^2-d^2&amp;2(cd-ab)\\0&amp;2(bd-ac)&amp;2(ab-cd)&amp;a^2+d^2-b^2-c^2\end{pmatrix}\end{gathered}\]</span> The direct way to judge whether the matrix above is orthogonal is hard. So consider multiply <span class="math display">\[\left(L_{q} R_{\bar{q}}\right)^{T}\left(L_{q} R_{\bar{q}}\right)=R_{\bar{q}}^TL_q^TL_qR_{\bar{q}}\]</span> And calculate <span class="math inline">\(L_q^TL_q=I_4,R_{\bar{q}}^TR_{\bar{q}}=I_4\)</span> So this matrix has block form <span class="math inline">\(\begin{pmatrix}I&amp;O\\O&amp;Q\end{pmatrix}\)</span></p><h2 id="problem-2-small-mboxdrazin-inverse-and-differential-equation">Problem 2<span class="math inline">\(\ \small \mbox{Drazin Inverse and Differential Equation}\)</span></h2><p>Given an unknown vector-valued function <span class="math inline">\(\boldsymbol{v}(t)\)</span>, we know how to solve <span class="math inline">\(\boldsymbol{v}^{\prime}=A \boldsymbol{v}\)</span> for a constant matrix <span class="math inline">\(A\)</span>. But what if we have <span class="math inline">\(A \boldsymbol{v}^{\prime}+B \boldsymbol{v}=\mathbf{0}\)</span> for constant matrices? If <span class="math inline">\(A\)</span> is invertible, we can reorganize this into <span class="math inline">\(\boldsymbol{v}^{\prime}=-A^{-1} B \boldsymbol{v}\)</span> and solve it easily. But what if <span class="math inline">\(A\)</span> is not invertible?</p><p>Here we introduce the Drazin inverse of a matrix. Recall that for any matrix A, according to the ultimate decomposition, <span class="math inline">\(A=X\left[\begin{array}{cc}A_{R} &amp; \\ &amp; A_{N}\end{array}\right] X^{-1}\)</span> where <span class="math inline">\(A_{R}\)</span> is invertible and <span class="math inline">\(A_{N}\)</span> is nilpotent. Then we define <span class="math inline">\(A^{(\mathrm{D})}=X\left[\begin{array}{ll}A_{R}^{-1} &amp; \\ &amp; 0\end{array}\right] X^{-1}\)</span> as the Drazin inverse of <span class="math inline">\(A\)</span></p><p><span class="math inline">\((1)\)</span> Show that if <span class="math inline">\(\left[\begin{array}{ll}R &amp; \\ &amp; N\end{array}\right]=X\left[\begin{array}{cc}R^{\prime} &amp; \\ &amp; N^{\prime}\end{array}\right] X^{-1}\)</span> where <span class="math inline">\(R, R^{\prime}\)</span> are invertible and <span class="math inline">\(N, N^{\prime}\)</span> are nilpotent, then <span class="math inline">\(\left[\begin{array}{cc}R^{-1} &amp; \\ &amp; 0\end{array}\right]=X\left[\begin{array}{cc}\left(R^{\prime}\right)^{-1} &amp; \\ &amp; 0\end{array}\right] X^{-1}\)</span>. (This shows that the Drazin inverse of <span class="math inline">\(A\)</span> is unique and does not depends on the choice of invertible-nilpotent decomposition <span class="math inline">\(A=X\left[\begin{array}{lll}A_{R} &amp; &amp; \\ &amp; A_{N}\end{array}\right] X^{-1}\)</span>.)</p><p><span class="math inline">\((2)\)</span> Show that <span class="math inline">\(A A^{(\mathrm{D})}=A^{(\mathrm{D})} A, A^{(\mathrm{D})} A A^{(\mathrm{D})}=A^{(\mathrm{D})}\)</span>, and <span class="math inline">\(A^{(\mathrm{D})} A^{k+1}=A^{k}\)</span> where <span class="math inline">\(k\)</span> is the smallest integer such that <span class="math inline">\(\operatorname{Ker}\left(A^{k}\right)=\operatorname{Ker}\left(A^{k+1}\right)\)</span></p><p><span class="math inline">\((3)\)</span> Calculate <span class="math inline">\(\left(\boldsymbol{a} \boldsymbol{b}^{*}\right)^{(\mathrm{D})}\)</span> for non-zero vectors <span class="math inline">\(\boldsymbol{a}, \boldsymbol{b} \in \mathbb{C}^{n}\)</span>. (Hint: Harder if you use brute force calculation with the definition. Easier if you can guess it out right, and prove that you have the right guess.)</p><p><span class="math inline">\((4)\)</span> For fixed <span class="math inline">\(A\)</span>, show that we can find a polynomial <span class="math inline">\(p(x)\)</span> such that <span class="math inline">\(A^{(\mathrm{D})}=p(A)\)</span>. (Again, note that for different <span class="math inline">\(A\)</span> this polynomial may be different.) (Hint: Suppose <span class="math inline">\(A_{R}^{-1}=q\left(A_{R}\right)\)</span> for a polynomial <span class="math inline">\(q(x)\)</span>.)</p><p><span class="math inline">\((5)\)</span> If <span class="math inline">\(A B=B A\)</span>, show that <span class="math inline">\(\mathrm{e}^{-A^{(\mathrm{D})} B t} A A^{(\mathrm{D})} \boldsymbol{v}_{0}\)</span> is a solution to <span class="math inline">\(A \boldsymbol{v}^{\prime}+B \boldsymbol{v}=\mathbf{0}\)</span> for any constant vector <span class="math inline">\(\boldsymbol{v}_{0}\)</span>. (This is one of the results in a paper by Campbell, Meyer and Rose in <span class="math inline">\(1967\)</span>.)</p><hr /><p><span class="math inline">\((1)\)</span> Set <span class="math inline">\(X=\begin{bmatrix}A&amp; B\\C&amp;D\end{bmatrix}\)</span> so the equation can be simplified <span class="math display">\[\left[\begin{array}{ll}R &amp; \\ &amp; N\end{array}\right]=X\left[\begin{array}{cc}R^{\prime} &amp; \\ &amp; N^{\prime}\end{array}\right] X^{-1}\rightarrow \begin{bmatrix}R&amp;\\&amp;N\end{bmatrix}\begin{bmatrix}A&amp; B\\C&amp;D\end{bmatrix}=\begin{bmatrix}A&amp; B\\C&amp;D\end{bmatrix}\begin{bmatrix}R&amp;\\&amp;N\end{bmatrix}\]</span> For each block we have <span class="math inline">\(RA=AR&#39;,RB=BN&#39;,ND=DN&#39;\)</span>. Use induction to prove</p><p><span class="math inline">\(R^nB=BN&#39;^{n}\)</span>, if <span class="math inline">\(n=k-1\)</span> <span class="math inline">\(R^{k-1}B=BN&#39;^{k-1}\)</span> is right, then <span class="math inline">\(R^{k}B=RBN^{k-1}=BN&#39;^{k}\)</span></p><p>And <span class="math inline">\(N\)</span> is a nilpotent matrix, so after limited steps, it transfers to <span class="math inline">\(R^{n}B=O\)</span> and <span class="math inline">\(R\)</span> is invertible</p><p>So <span class="math inline">\(B=O\)</span>, it's the same with <span class="math inline">\(C=O\)</span>, and <span class="math inline">\(X=\begin{bmatrix}A&amp;\\&amp;D\end{bmatrix}\)</span> since <span class="math inline">\(RA=AR&#39;\)</span>, <span class="math inline">\(R^{-1}A=A(R&#39;)^{-1}\)</span> <span class="math display">\[\begin{bmatrix}R^{-1}&amp; O\\O&amp;O\end{bmatrix}\begin{bmatrix}A&amp; O\\O&amp;D\end{bmatrix}=\begin{bmatrix}R^{-1}A&amp; O\\O&amp;O\end{bmatrix}=\begin{bmatrix}A(R&#39;)^{-1}&amp; O\\O&amp;O\end{bmatrix}=\begin{bmatrix}A&amp; O\\O&amp;D\end{bmatrix}\begin{bmatrix}(R&#39;)^{-1}&amp; O\\O&amp;O\end{bmatrix}\]</span> So <span class="math inline">\(\left[\begin{array}{cc}R^{-1} &amp; \\ &amp; 0\end{array}\right]=X\left[\begin{array}{cc}\left(R^{\prime}\right)^{-1} &amp; \\ &amp; 0\end{array}\right] X^{-1}\)</span>, so the Drazin inverse is sole.</p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(AA^{(D)}=X\left[\begin{array}{cc}A_{R} &amp; \\ &amp; A_{N}\end{array}\right] X^{-1}X\left[\begin{array}{ll}A_{R}^{-1} &amp; \\ &amp; 0\end{array}\right] X^{-1}=X\begin{bmatrix}I&amp;O\\O&amp;O\end{bmatrix}X^{-1}\)</span></p><p><span class="math inline">\(A^{(D)}A=X\left[\begin{array}{ll}A_{R}^{-1} &amp; \\ &amp; 0\end{array}\right] X^{-1}X\left[\begin{array}{cc}A_{R} &amp; \\ &amp; A_{N}\end{array}\right] X^{-1}=X\begin{bmatrix}I&amp;O\\O&amp;O\end{bmatrix}X^{-1}=AA^{(D)}\)</span></p><p><span class="math inline">\(A^{(D)}AA^{(D)}=X\begin{bmatrix}I&amp;O\\O&amp;O\end{bmatrix}X^{-1}X\left[\begin{array}{ll}A_{R}^{-1} &amp; \\ &amp; 0\end{array}\right] X^{-1}=X\left[\begin{array}{ll}A_{R}^{-1} &amp; \\ &amp; 0\end{array}\right] X^{-1}=A^{(D)}\)</span></p><p>By induction, <span class="math inline">\(A^{(D)}A^{k+1}=X\left[\begin{array}{ll}A_{R}^{-1} &amp; \\ &amp; O\end{array}\right] X^{-1}X\left[\begin{array}{cc}A_{R}^{k+1} &amp; \\ &amp; A_{N}^{k+1}\end{array}\right] X^{-1}=X\begin{bmatrix}A_R^{k}&amp;\\&amp;O\end{bmatrix}X^{-1}\)</span></p><p>And <span class="math inline">\(A^{k}=X\left[\begin{array}{cc}A_{R}^k &amp; \\ &amp; A_{N}^k\end{array}\right] X^{-1}\)</span> if <span class="math inline">\(\ker{(A^{k})}=\ker{(A^{k+1})}\)</span> so <span class="math inline">\(\ker{(A_N^k)}=\ker{(A_{N}^{k+1})}\)</span></p><p>let <span class="math inline">\(m\)</span> is the smallest number that satisfied <span class="math inline">\(A_N^m=O\)</span>, so <span class="math inline">\(k\leq m\)</span>, if <span class="math inline">\(k&lt;m\)</span>, that is to say</p><p><span class="math inline">\(A_N^{k+1}\vec{x}=\vec{0}\Longrightarrow A_N^{k}\vec{x}=\vec{0}\)</span> and <span class="math inline">\(\ker{(A_{N}^{k})}=\ker{(A_{N}^{k+1})}=\cdots \ker{(A_{N}^{m})}=\mathbb{R}^{n}\)</span></p><p>So <span class="math inline">\(A_N^{k}=O\)</span> , <span class="math inline">\(A^{(\mathrm{D})} A^{k+1}=A^{k}\)</span></p><p><span class="math inline">\((3)\)</span> Can't solve this question</p><p><span class="math inline">\((4)\)</span> For <span class="math inline">\(A_R\neq O\)</span>, let its minimal polynomial <span class="math inline">\(p(A_R)=p_1(A_R)+a I=O\)</span> because <span class="math inline">\(A_R\)</span></p><p>is invertible, and its eigenpolynomial's constant term is not <span class="math inline">\(0\)</span>, so <span class="math inline">\(a\neq 0\)</span>, <span class="math inline">\(p_2(A_R)A_R=-aI\)</span></p><p>Define <span class="math inline">\(q(A_R)=-\dfrac{p_2(A_{R})}{a}\)</span> so $$ polynomial <span class="math inline">\(q(x)\)</span> such that <span class="math inline">\(A_R^{-1}=q(A_R)\)</span>. Also define</p><p><span class="math inline">\(k\)</span> is the smallest integer such that <span class="math inline">\(\operatorname{Ker}\left(A^{k}\right)=\operatorname{Ker}\left(A^{k+1}\right)\)</span> According to <span class="math inline">\(\small(2)\)</span>, we have</p><p><span class="math inline">\(A_N^k=O,A^k=X\begin{bmatrix}A_R^k&amp;O\\O&amp;O\end{bmatrix}X^{-1}\)</span>, and multiply by <span class="math inline">\((q(A))^{k+1}=X\begin{pmatrix}(A_{R}^{-1})^{k+1}&amp;O\\O&amp;q(A_N)\end{pmatrix}X^{-1}\)</span></p><p><span class="math inline">\(A^{k}q(A)^{k+1}=X\begin{bmatrix}A_R^k&amp;O\\O&amp;O\end{bmatrix}X^{-1}X\begin{pmatrix}(A_{R}^{-1})^{k+1}&amp;O\\O&amp;q(A_N)\end{pmatrix}X^{-1}=X\begin{bmatrix}A_R^{-1}&amp;O\\O&amp;O\end{bmatrix}X^{-1}=A^{(D)}\)</span></p><p><span class="math inline">\((5)\)</span> First, <span class="math inline">\(A^{(D)}\)</span> and <span class="math inline">\(B\)</span> is community. let <span class="math inline">\(B^{\prime}=X^{-1}BX\)</span> so that <span class="math display">\[\begin{pmatrix}A_{R}&amp;O\\O&amp;A_N\end{pmatrix}B^{\prime}=B^{\prime}\begin{pmatrix}A_{R}&amp;O\\O&amp;A_N\end{pmatrix}\]</span> like question <span class="math inline">\(\small(1)\)</span> we can know that <span class="math inline">\(B^{\prime}=\begin{pmatrix}B_1&amp;O\\O&amp;B_4\end{pmatrix}\)</span> <span class="math inline">\(B_1\)</span> and <span class="math inline">\(A_R\)</span> is community</p><p>so it's obvious that <span class="math inline">\(\begin{pmatrix}A_{R}^{-1}&amp;O\\O&amp;O\end{pmatrix}B^{\prime}=B^{\prime}\begin{pmatrix}A_{R}^{-1}&amp;O\\O&amp;O\end{pmatrix}\)</span> so <span class="math inline">\(A^{(D)}\)</span> and <span class="math inline">\(B\)</span> is community.</p><p>Secondly, because <span class="math inline">\(AB=BA,AA^{(D)}=A^{(D)}A\)</span> we can prove that <span class="math inline">\((A^{(D)}Bt)^{i}A=A(A^{(D)}Bt)^{i}\)</span></p><p>if <span class="math inline">\(i=k\)</span> right <span class="math inline">\((A^{(D)}Bt)^{k+1}A=A^{(D)}Bt(A^{(D)}Bt)^{k}A=A^{(D)}BtA(A^{(D)}Bt)^{k}=A(A^{(D)}Bt)^{k+1}\)</span></p><p><span class="math inline">\(i=0\)</span> is right, By induction <span class="math inline">\((A^{(D)}Bt)^{i}A=A(A^{(D)}Bt)^{i}\)</span> is right. It is the same to</p><p><span class="math inline">\((A^{(D)}Bt)^{i}A^{(D)}=A^{(D)}(A^{(D)}Bt)^{i}\)</span>, calculate the solution below <span class="math display">\[\begin{gathered}A \boldsymbol{v}^{\prime}=-AA^{(D)}Be^{-A^{(D)}Bt}AA^{(D)}\boldsymbol{v}_{0}=-AA^{(D)}B\sum_{i=1}^{+\infty}\dfrac{1}{i!}(A^{(D)}Bt)^{i}AA^{(D)}\boldsymbol{v}_{0}\\=-AA^{(D)}BA\sum_{i=0}^{+\infty}\dfrac{1}{i!}(A^{(D)}Bt)^{i}A^{(D)}\boldsymbol{v}_{0}=-AA^{(D)}ABA^{(D)}\sum_{i=0}^{+\infty}\dfrac{1}{i!}(A^{(D)}Bt)^{i}\boldsymbol{v}_{0}\\=-BA\boxed{A^{(D)}AA^{(D)}}\sum_{i=0}^{+\infty}\dfrac{1}{i!}(A^{(D)}Bt)^{i}\boldsymbol{v}_{0}=-BA\boxed{A^{(D)}}\sum_{i=0}^{+\infty}\dfrac{1}{i!}(A^{(D)}Bt)^{i}\boldsymbol{v}_{0}\\=-BA\sum_{i=0}^{+\infty}\dfrac{1}{i!}(A^{(D)}Bt)^{i}A^{(D)}\boldsymbol{v}_{0}=-B\sum_{i=0}^{+\infty}\dfrac{1}{i!}(A^{(D)}Bt)^{i}AA^{(D)}\boldsymbol{v}_{0}=-B\boldsymbol {v}\end{gathered}\]</span> So <span class="math inline">\(\mathrm{e}^{-A^{(\mathrm{D})} B t} A A^{(\mathrm{D})} \boldsymbol{v}_{0}\)</span> is a solution to <span class="math inline">\(A \boldsymbol{v}^{\prime}+B \boldsymbol{v}=\mathbf{0}\)</span></p><h2 id="problem-3-small-mboxsherman-morrison-woodburry-formula">Problem 3<span class="math inline">\(\ \small \mbox{Sherman-Morrison-Woodburry Formula}\)</span></h2><p>The famous Sherman-Morrison-Woodburry formula states that, for any <span class="math inline">\(m \times m\)</span> invertible matrix <span class="math inline">\(X, n \times n\)</span> invertible matrix <span class="math inline">\(Y, m \times n\)</span> matrix <span class="math inline">\(A\)</span> and <span class="math inline">\(n \times m\)</span> matrix <span class="math inline">\(B\)</span>, we have <span class="math inline">\((X-A Y B)^{-1}=X^{-1}+X^{-1} A\left(Y^{-1}-B X^{-1} A\right)^{-1} B X^{-1}\)</span>. This can be proven using block eliminations on <span class="math inline">\(\left[\begin{array}{cc}X &amp; -A \\ B &amp; Y\end{array}\right]\)</span>. Well, I always find that proof annoying. So let us not do that, and try to find some alternative proofs. To simplify, you can easily see that it is enough to establish the special case <span class="math inline">\(\left(I_{m}-A B\right)^{-1}=I_{m}+A\left(I_{n}-B A\right)^{-1} B .\)</span></p><p>Consider the function <span class="math inline">\(f(x)=(1-x)^{-1}\)</span>. This function has a Taylor expansion <span class="math inline">\(f(x)=1+x+x^{2}+\ldots\)</span> for all <span class="math inline">\(|x|&lt;1\)</span> over the complex numbers. (This is also the sum of the geometric series, which you should have learned about in high school.)</p><p><span class="math inline">\((1)\)</span> For any <span class="math inline">\(m \times n\)</span> matrix <span class="math inline">\(A\)</span> and <span class="math inline">\(n \times m\)</span> matrix <span class="math inline">\(B\)</span>, suppose <span class="math inline">\(I_{m}-A B\)</span> is invertible and all eigenvalues of <span class="math inline">\(AB\)</span> have absolute value less than 1. Write <span class="math inline">\(\left(I_{m}-A B\right)^{-1}\)</span> as the sum of a series of matrices.</p><p><span class="math inline">\((2)\)</span> Using above idea, deduce the formula <span class="math inline">\(\left(I_{m}-A B\right)^{-1}=I_{m}+A\left(I_{n}-B A\right)^{-1} B\)</span>, when <span class="math inline">\(I_{m}+A B\)</span> and <span class="math inline">\(I_{n}-B A\)</span> are invertible and all eigenvalues of <span class="math inline">\(A B\)</span> and <span class="math inline">\(B A\)</span> have absolute value less than <span class="math inline">\(1 .\)</span> (Btw, note that <span class="math inline">\(A B\)</span> and <span class="math inline">\(B A\)</span> always have the same non-zero eigenvalues. You don't need this fact though.)</p><p><span class="math inline">\((3)\)</span> Oops, unfortunately, the method above does not always work. It has many annoying requirements on eigenvalues. Let us now forget about Taylor expansion. In general, prove that <span class="math inline">\(A p(B A)=p(A B) A\)</span> for all polynomials <span class="math inline">\(p(x)\)</span>. (Hint: <span class="math inline">\(\operatorname{try} p(x)=x\)</span> first.)</p><p><span class="math inline">\((4)\)</span> Show that for any function <span class="math inline">\(f(x)\)</span> and any two square matrix <span class="math inline">\(X, Y\)</span>, we can find a polynomial <span class="math inline">\(p(x)\)</span> such that <span class="math inline">\(p(X)=f(X)\)</span> and <span class="math inline">\(p(Y)=f(Y)\)</span> simultaneously. (Hint: block matrix.)</p><p><span class="math inline">\((5)\)</span> Show that <span class="math inline">\(A f(B A)=f(A B) A\)</span> as long as <span class="math inline">\(f(A B)\)</span> and <span class="math inline">\(f(B A)\)</span> are defined.</p><p><span class="math inline">\((6)\)</span> Verify that <span class="math inline">\(f(A B)=I_{m}+A f(B A) B\)</span>, using the identity above.</p><hr /><p><span class="math inline">\((1)\)</span> let <span class="math inline">\(S=I_m+AB+(AB)^2+\cdots\)</span> the absolute value of <span class="math inline">\(AB\)</span> is less than <span class="math inline">\(1\)</span>, so it converges</p><p>And <span class="math inline">\((I_m-AB)S=(I_m+AB+(AB)^2+\cdots)-(AB+(AB)^2+\cdots)=I_m\)</span> then</p><p><span class="math inline">\(S=(I_m-AB)^{-1}=I_m+AB+(AB)^2+\cdots=\displaystyle \sum_{i=0}^{+\infty}(AB)^{i}\)</span></p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(RHS=I_m+\displaystyle A\sum_{i=0}^{+\infty}(BA)^{i}B=I_m+\sum_{i=0}^{+\infty}A(BA)^{i}B \stackrel{?}{=}\sum_{i=0}^{+\infty}(AB)^{i}=LHS\)</span></p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(p(x)=\displaystyle \sum_{i=0}^{n}a_ix^{i}\)</span>, it can be linearly decomposed into 'single' polynomial. Consider <span class="math inline">\(x^{n}\)</span></p><p>If <span class="math inline">\(n=k\)</span> is right, so <span class="math inline">\(A(BA)^{k+1}=A(BA)^{k}(BA)=(AB)^{k}ABA=(AB)^{k+1}A\)</span> <span class="math inline">\(n=k+1\)</span> is right, and <span class="math inline">\(n=0\)</span> is right. By induction, <span class="math inline">\(A p(B A)=p(A B) A\)</span> for each <span class="math inline">\(x^{n}\)</span> Add them together</p><p>So <span class="math inline">\(A p(B A)=p(A B) A\)</span></p><p><span class="math inline">\((4)\)</span> Construct a block matrix <span class="math inline">\(M=\begin{pmatrix}X&amp;O\\O&amp;Y\end{pmatrix}\)</span> for any fixed matrix <span class="math inline">\(M\)</span>, we can find a certain polynomial <span class="math inline">\(p(x)\)</span>, such that <span class="math inline">\(p(M)=f(M)\)</span> use the Taylor Series divide its minimal polynomial</p><p><span class="math inline">\(p(\begin{pmatrix}X&amp;O\\O&amp;Y\end{pmatrix})=f(\begin{pmatrix}X&amp;O\\O&amp;Y\end{pmatrix})\)</span> so <span class="math inline">\(p(X)=f(X),p(Y)=f(Y)\)</span></p><p><span class="math inline">\((5)\)</span> if fix <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, according to the last question, we can find a polynomial <span class="math inline">\(p(x)\)</span> to replace the function <span class="math inline">\(f\)</span>. Also, according to the <span class="math inline">\(\small (3)\)</span> question, if <span class="math inline">\(f(A B)\)</span> and <span class="math inline">\(f(B A)\)</span> are defined, then <span class="math display">\[A f(B A)=f(A B) A\]</span> <span class="math inline">\((6)\)</span> let <span class="math inline">\(f(AB)=\displaystyle \sum_{i=0}^{+\infty}(AB)^{i}\)</span> so use the equation above <span class="math display">\[\begin{gathered}RHS=I_m+\displaystyle \sum_{i=0}^{+\infty}A(BA)^{i}B=I_m+Af(BA)B=I_m+f(AB)AB=\\I_m+\sum_{i=0}^{+\infty}(AB)^{i+1}=\sum_{i=0}^{+\infty}(AB)^{i}=LHS\end{gathered}\]</span> So we prove the equality <span class="math inline">\(\left(I_{m}-A B\right)^{-1}=I_{m}+A\left(I_{n}-B A\right)^{-1} B\)</span></p><h2 id="problem-4-small-mboxequations-of-matrixes">Problem 4<span class="math inline">\(\ \small \mbox{Equations of matrixes}\)</span></h2><p>Let <span class="math inline">\(N\)</span> be the <span class="math inline">\(n \times n\)</span> nilpotent Jordan block.</p><p><span class="math inline">\((1)\)</span> Show that the solutions to the Sylvester's equation <span class="math inline">\(N X-X N=0\)</span> are exactly the polynomials of <span class="math inline">\(N\)</span>.</p><p><span class="math inline">\((2)\)</span> Suppose <span class="math inline">\(Y=\mathrm{e}^{N}\)</span>. Show that <span class="math inline">\(Y, Y-I,(Y-I)^{2}, \ldots,(Y-I)^{n-1}\)</span> are linearly independent in the space of matrixes, and they span the space of matrices made of polynomials of <span class="math inline">\(N\)</span>. (Consequently, <span class="math inline">\(N\)</span> is a polynomial of <span class="math inline">\(Y\)</span>.)</p><p><span class="math inline">\((3)\)</span> Find all solutions <span class="math inline">\(X\)</span> to the matrix equation <span class="math inline">\(\mathrm{e}^{X}=\mathrm{e}^{N}\)</span>. (Make sure to consider COMPLEX matrixes <span class="math inline">\(X\)</span>.)</p><p><span class="math inline">\((4)\)</span> Find real matrixes <span class="math inline">\(A, B\)</span> such that <span class="math inline">\(A B \neq B A\)</span> but <span class="math inline">\(\mathrm{e}^{A}=\mathrm{e}^{B}\)</span>. (Hint: for complex <span class="math inline">\(1 \times 1\)</span> matrices, try to find <span class="math inline">\(x \neq y \in \mathbb{C}\)</span> such that <span class="math inline">\(\mathrm{e}^{x}=\mathrm{e}^{y}\)</span>.)</p><p><span class="math inline">\((5)\)</span> Prove that there is no solution <span class="math inline">\(X\)</span> to the equation <span class="math inline">\(\sin (X)=\left[\begin{array}{cc}1 &amp; 1996 \\ 0 &amp; 1\end{array}\right]\)</span>. (This is a Putnam competition problem. I'm sure you know the year of the competition....)</p><hr /><p>(1)$ let $ <span class="math inline">\(N=\left[\begin{array}{lllll}0 &amp; &amp; &amp; &amp; \\ 1 &amp; 0 &amp; &amp; 0 &amp; \\ &amp; \ddots &amp; \ddots &amp; &amp; \\ 0 &amp; &amp; \ddots &amp; \ddots &amp; \\ &amp; &amp; &amp; 1 &amp; 0\end{array}\right],X=\left[\begin{array}{cccc}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1 n} \\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2 n} \\ \vdots &amp; \vdots &amp; &amp; \vdots \\ a_{n 1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n}\end{array}\right]\)</span></p><p><span class="math inline">\(NX=\left[\begin{array}{cccc}0&amp;0&amp;\cdots&amp;0\\a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1 n} \\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2 n} \\ \vdots &amp; \vdots &amp; &amp; \vdots \\ a_{(n-1) 1} &amp; a_{(n-1) 2} &amp; \cdots &amp; a_{(n-1) n}\end{array}\right],XN=\left[\begin{array}{cccc}a_{12} &amp; a_{13} &amp; \cdots &amp; a_{1 (n-1)}&amp;0 \\ a_{22} &amp; a_{23} &amp; \cdots &amp; a_{2 (n-1)}&amp;0 \\ \vdots &amp; \vdots &amp; &amp; \vdots \\ a_{n 2} &amp; a_{n 3} &amp; \cdots &amp; a_{n(n-1) }&amp;0\end{array}\right],\)</span></p><p>some elements of each row are 'killed' step by step. like <span class="math inline">\(\{a_{12},a_{13}\cdots,a_{1n}\}\)</span></p><p>neat <span class="math inline">\(\{a_{23},a_{24},\cdots ,a_{2n}\},\{a_{34},a_{35},\cdots,a_{3n}\},\cdots,\{a_{(n-1)n}\}\)</span> and <span class="math inline">\(a_{ij}=a_{(i+k)(j+k)}\)</span></p><p>So <span class="math inline">\(X=\left[\begin{array}{cccc}a_{11} &amp; 0 &amp; \cdots &amp; 0 \\ a_{21} &amp; a_{11} &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; &amp; \vdots \\ a_{n 1} &amp; \cdots &amp;a_{21}&amp; a_{11}\end{array}\right]=a_{11}I+a_{21}N+a_{31}N^{2}+\cdots +a_{n1}N^{n-1}=p(N)\)</span></p><p><span class="math inline">\((2)\)</span> Use Taylor Series to <span class="math inline">\(Y=e^{N}=\displaystyle \sum_{i=0}^{+\infty}\dfrac{N^{i}}{i!}=\sum_{i=0}^{n-1}\dfrac{N^{i}}{i!}=I+\sum_{i=1}^{n-1}\dfrac{N^{i}}{i!}\)</span></p><p><span class="math inline">\((Y-I)^{k}=\displaystyle (\sum_{i=1}^{n-1}\dfrac{N^{i}}{i!})^{k}\)</span> the minimum of <span class="math inline">\(N\)</span> is <span class="math inline">\(k\)</span>. So for <span class="math inline">\(\{Y, Y-I,(Y-I)^{2}, \ldots,(Y-I)^{n-1}\}\)</span></p><p>the minimum of <span class="math inline">\(N\)</span> is exactly $0,1,2,,n-1 $ and each <span class="math inline">\(N^{k}\)</span> is obviously independent</p><p>So, they are linearly independent, the dimension of the polynomial of <span class="math inline">\(N\)</span> is <span class="math inline">\(n\)</span>, which is equal to the number of the base, so they span the whole space <span class="math inline">\(V\)</span>. Also, <span class="math inline">\(N\in V\)</span> and <span class="math inline">\(N\)</span> can be written by the combination of the base. Each base is just the polynomial of <span class="math inline">\(Y\)</span>. So, <span class="math inline">\(N=p(e^{N})\)</span></p><p><span class="math inline">\((3)\)</span> Use Jordan factorization, every complex matrix <span class="math inline">\(A\)</span> can be divided into <span class="math display">\[A=XJX^{-1}\]</span> Obviously, one solution is <span class="math inline">\(x=N\)</span>, finding complex matrixes <span class="math inline">\(A_{I}\)</span> such that <span class="math inline">\(e^{A_{I}}=I\)</span> matters.</p><p>And <span class="math inline">\(e^{A_{I}}=Xe^{J_{I}}X^{-1}=I\Longrightarrow e^{J_{I}}=I\)</span> And if <span class="math inline">\(J_{k}=\begin{bmatrix}\lambda&amp;1&amp;0&amp;\cdots&amp;0\\0&amp;\lambda&amp;1&amp;\cdots&amp;0\\0&amp;0&amp;\lambda&amp;\cdots&amp;0\\\vdots&amp;\vdots&amp;\vdots &amp;\ddots&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;\lambda\end{bmatrix}\)</span> exists in <span class="math inline">\(J_{I}\)</span></p><p>which will produce <span class="math inline">\(\dfrac{d^{n}e^{x}}{dx^{n}}\Large|\normalsize _{x=\lambda}\neq 0\)</span> as non-diagonal elements, causing contradiction.</p><p>So <span class="math inline">\(J_{I}\)</span> is a diagonal matrix <span class="math inline">\(J_{I}=\mbox{diag}(z_1,z_2\cdots,z_{n})\)</span> So <span class="math inline">\(e^{z_i}=1\Longrightarrow z_{i}=2k\pi ,k\in \mathbb{Z}\)</span></p><p>Some base soluitions to <span class="math inline">\(e^{X}=e^{N}\)</span> are <span class="math inline">\(X=N+2\pi\cdot\mbox{diag}(k_1,k_2,\cdots,k_{n}),k_{i}\in \mathbb{Z}\)</span></p><p>And if want to add <span class="math inline">\(X\)</span> and <span class="math inline">\(X^{-1}\)</span>, because <span class="math inline">\(e^{A+B}=e^{A}e^{B}\)</span> needs <span class="math inline">\(AB=BA\)</span></p><p><span class="math inline">\(N(XDX^{-1})=(XDX^{-1})N\Longrightarrow (X^{-1}NX)D=D(X^{-1}NX)\)</span> if and only if <span class="math inline">\(d_{i}=d_{j}\)</span></p><p><span class="math inline">\(N+X\mbox{diag}(2\pi k,2\pi k,\cdots 2\pi k)X^{-1},k\in \mathbb{Z}\)</span> Can be added to the solutions</p><p>So one part of the solutions are (can't prove these matrixes contain all the solutions) <span class="math display">\[\{N+2\pi\mbox{diag}(k_1,k_2,\cdots,k_{n}),k_{i}\in \mathbb{Z}\}\cup \{N+2\pi X\mbox{diag}(k,k,\cdots k)X^{-1},k\in \mathbb{Z},\det X\neq 0\}\]</span> <span class="math inline">\((4)\)</span> Because of the rotation <span class="math inline">\(e^{x+yi}=e^{x+(y+2k\pi)i}\)</span> So we can easily know that <span class="math display">\[\Large e^{\large \begin{pmatrix}0&amp;-2k\pi\\2k\pi&amp;0\end{pmatrix}}\normalsize =I_2,k\in \mathbb{Z}\]</span> But the 'standard complex' matrix <span class="math inline">\(aI+bJ=\begin{pmatrix}a&amp;-b\\b&amp;a\end{pmatrix}\)</span> is community. So let's try other matrixes meaning for rotations, which gives the <span class="math inline">\(I\)</span> itself. And the answer is <strong>Quaternions</strong></p><p>Because of its non-commnuity. Like <span class="math inline">\((b_1i+c_1j)(b_2i+c_2j)=-b_1b_2-c_1c_2+(b_1c_2-c_1b_2)k\)</span></p><p><span class="math inline">\(\neq (b_2i+c_2j)(b_1i+c_1j)=-b_1b_2-c_1c_2+(b_2c_1-c_2b_1)k\)</span> when <span class="math inline">\(b_1c_2\neq b_2c_1\)</span> and <span class="math inline">\(e^{2\pi i,j}=I_4\)</span> <span class="math display">\[\begin{gathered}A=2\pi i=\begin{pmatrix}0&amp;-2\pi&amp;0&amp;0\\2\pi &amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;-2\pi\\0&amp;0&amp;2\pi&amp;0\end{pmatrix},B=2\pi j=\begin{pmatrix}0&amp;0&amp;-2\pi&amp;0\\0&amp;0&amp;0&amp;2\pi\\2\pi&amp;0&amp;0&amp;0\\0&amp;-2\pi&amp;0&amp;0\end{pmatrix}\\AB=4\pi^2\begin{pmatrix}0&amp;0&amp;0&amp;-1\\0&amp;0&amp;-1&amp;0\\0&amp;1&amp;0&amp;0\\1&amp;0&amp;0&amp;0\end{pmatrix}\neq BA=4\pi^2\begin{pmatrix}0&amp;0&amp;0&amp;1\\0&amp;0&amp;1&amp;0\\0&amp;-1&amp;0&amp;0\\-1&amp;0&amp;0&amp;0\end{pmatrix}\\\mbox{But}\ \ \ e^{A}=e^{B}=\begin{pmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\end{pmatrix}=I_4\end{gathered}\]</span></p><p><span class="math inline">\((5)\)</span> Since <span class="math inline">\(f(x)=\sin x,g(x)=\cos x\)</span> are all matrix functions, and <span class="math inline">\(f(x)^2+g(x)^2=1\)</span> is right</p><p>So <span class="math inline">\(\sin^2X+\cos ^2X=I\)</span> substitute <span class="math inline">\(\sin X=\left[\begin{array}{cc}1 &amp; 1996 \\ 0 &amp; 1\end{array}\right]\)</span> we can get <span class="math inline">\(\cos^2 X=\left[\begin{array}{cc}0 &amp; -3992 \\ 0 &amp; 0\end{array}\right]\)</span></p><p>That is to say <span class="math inline">\(Y=\cos X\)</span> is nilpotent <span class="math inline">\(Y^{4}=O\)</span>. However, the matrix is $2 $. <span class="math inline">\(Y^{2}\)</span> must be <span class="math inline">\(O\)</span> ,</p><p>which causes contradiction.</p><h2 id="problem-5-small-mboxnewtons-method">Problem 5<span class="math inline">\(\ \small \mbox{Newton&#39;s Method}\)</span></h2><p>As we have seen in class, <span class="math inline">\(\operatorname{sign}(X)\)</span> is useful to solve certain Sylvester's equations. Here we aim to find a way an approximation to <span class="math inline">\(\operatorname{sign}(X)\)</span>. Given a matrix <span class="math inline">\(A\)</span> with no purely imaginary eigenvalue, set <span class="math inline">\(X_{0}=A\)</span>, and set <span class="math inline">\(X_{n+1}=\dfrac{1}{2}\left(X_{n}+X_{n}^{-1}\right)\)</span>. (As a side note, a complex number <span class="math inline">\(z\)</span> is purely imaginary if its real part is zero. In particular, 0 is a purely imaginary number as well. So, if a matrix has no purely imaginary eigenvalue, then it is invertible.)</p><p><span class="math inline">\((1)\)</span> Show that if <span class="math inline">\(X_{n}\)</span> has no purely imaginary eigenvalue, then <span class="math inline">\(X_{n+1}\)</span> has no purely imaginary eigenvalue. (So our inductive definition makes sense.)</p><p><span class="math inline">\((2)\)</span> If <span class="math inline">\(A\)</span> is <span class="math inline">\(1 \times 1\)</span>, and it is not purely imaginary, show that <span class="math inline">\(X_{n}\)</span> indeed coverge to sign <span class="math inline">\((A)\)</span>. (This question has little to do with linear algebra...) (Hint: <span class="math inline">\(\dfrac{f(x)-1}{f(x)+1}=\left(\dfrac{x-1}{x+1}\right)^{2}\)</span> where <span class="math inline">\(f(x)=\dfrac{1}{2}\left(x+\dfrac{1}{x}\right)\)</span>.</p><p><span class="math inline">\((3)\)</span> If <span class="math inline">\(A\)</span> is diagonalizable and has no purely imaginary eigenvalue, show that <span class="math inline">\(X_{n}\)</span> indeed coverge to sign <span class="math inline">\((A)\)</span>. (Not part of this problem. But diagonalizable matrices are dense, so you can imagine that this is true in general.)</p><p><span class="math inline">\((4)\)</span> Suppose <span class="math inline">\(A\)</span> is an <span class="math inline">\(n \times n\)</span> Jordan block with eigenvalue <span class="math inline">\(1\)</span>. Show that <span class="math inline">\(X_{n-1}=I\)</span>.</p><hr /><p><span class="math inline">\((1)\)</span> Use Jordan block <span class="math inline">\(X_{n}=XJX^{-1}\)</span> <span class="math display">\[J=\begin{pmatrix}J_{1}\\&amp;\ddots\\&amp;&amp;J_{n}\end{pmatrix},J_{i}=\begin{bmatrix}\lambda_i&amp;1&amp;0&amp;\cdots&amp;0\\0&amp;\lambda_i&amp;1&amp;\cdots&amp;0\\0&amp;0&amp;\lambda_i&amp;\ddots&amp;0\\\vdots&amp;\vdots&amp;\vdots &amp;\ddots&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;\lambda_i\end{bmatrix}\]</span> And <span class="math inline">\(\mathbf{Re}(\lambda_{i})\neq 0\)</span> So <span class="math inline">\(X_n^{-1}=XJ^{-1}X^{-1}=X\begin{bmatrix}\lambda_i^{-1}&amp;a_1&amp;a_2&amp;\cdots&amp;a_{n-1}\\0&amp;\lambda_i^{-1}&amp;a_1&amp;\cdots&amp;a_{n-2}\\0&amp;0&amp;\lambda_i^{-1}&amp;\cdots&amp;a_{n-3}\\\vdots&amp;\vdots&amp;\vdots &amp;\ddots&amp;a_1\\0&amp;0&amp;0&amp;\cdots&amp;\lambda_i^{-1}\end{bmatrix}X^{-1}\)</span></p><p>and <span class="math inline">\(\dfrac{X_n+X_n^{-1}}{2}=\dfrac{1}{2}X\begin{bmatrix}\lambda_i+\lambda_i^{-1}&amp;1+a_1&amp;a_2&amp;\cdots&amp;a_{n-1}\\0&amp;\lambda_i+\lambda_i^{-1}&amp;1+a_1&amp;\cdots&amp;a_{n-2}\\0&amp;0&amp;\lambda_i+\lambda_i^{-1}&amp;\cdots&amp;a_{n-3}\\\vdots&amp;\vdots&amp;\vdots &amp;\ddots&amp;1+a_1\\0&amp;0&amp;0&amp;\cdots&amp;\lambda_i+\lambda_i^{-1}\end{bmatrix}X^{-1}\)</span></p><p>So the eigenvalue of <span class="math inline">\(X_{n+1}\)</span> is <span class="math inline">\(\lambda_i+\lambda_{i}^{-1}=(x_i+y_i)+\dfrac{1}{x_i+y_i}\)</span> its real part is <span class="math display">\[x_i+\dfrac{x_i}{x_i^2+y_i^2}=x_i(1+\dfrac{1}{x_i^2+y_i^2})\neq 0\]</span> So <span class="math inline">\(X_{n+1}\)</span> has no purely imaginary eigenvalue</p><p><span class="math inline">\((2)\)</span> set <span class="math inline">\(f(x)=\dfrac{1}{2}(x+\dfrac{1}{x})\)</span> We have recursion formula <span class="math inline">\(\dfrac{f(x)-1}{f(x)+1}=\left(\dfrac{x-1}{x+1}\right)^{2}\)</span></p><p><span class="math inline">\(A = x+yi\)</span> if <span class="math inline">\(\mathbf{Re}(A)=x&gt;0\)</span> So set <span class="math inline">\(a_n=\dfrac{X_{n}-1}{X_{n}+1}\)</span> it will be <span class="math inline">\(a_n=a_{n-1}^{2}\)</span></p><p>By induction we can easily get <span class="math inline">\(a_n=a_1^{2^{n-1}}=(\dfrac{x-1+yi}{x+1+yi})^{2^{n}}\)</span> and the length of <span class="math inline">\(\dfrac{x-1+yi}{x+1+yi}\)</span></p><p>is <span class="math inline">\(\sqrt{\dfrac{(x-1)^{2}+y^2}{(x+1)^2+y^2}}=\sqrt{1-\dfrac{4x}{(x+1)^2+y^2}}&lt;1\)</span> so let $n+$ <span class="math inline">\(\lim\limits_{n\to +\infty}a_n=0\)</span> <span class="math inline">\(X_{+\infty}\to 1\)</span></p><p>And if <span class="math inline">\(x&lt;0\)</span>, find a new path <span class="math inline">\(b_n=\dfrac{X_n+1}{X_n-1}\)</span>, also satisfy <span class="math inline">\(b_{n+1}=b_{n}^2\)</span> And the length</p><p><span class="math inline">\(|\dfrac{x+1+yi}{x-1+yi}|=\sqrt{1+\dfrac{4x}{(x-1)^{2}+y^2}}&lt;1\)</span> so let <span class="math inline">\(n\to +\infty\)</span> <span class="math inline">\(\lim\limits_{n\to +\infty}a_n=0,X_{+\infty }\to -1\)</span></p><p>In conclusion, <span class="math inline">\(\lim\limits_{n\to +\infty}X_n=\begin{cases}1&amp;\mathbf{Re}(A)&gt;0\\-1&amp;\mathbf{Re}(A)&lt;0\end{cases}=\mbox{sign(A)}\)</span></p><p><span class="math inline">\((3)\)</span> Actually, for every Jordan block <span class="math inline">\(J_{i}=\begin{bmatrix}\lambda_i&amp;1&amp;0&amp;\cdots&amp;0\\0&amp;\lambda_i&amp;1&amp;\cdots&amp;0\\0&amp;0&amp;\lambda_i&amp;\ddots&amp;0\\\vdots&amp;\vdots&amp;\vdots &amp;\ddots&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;\lambda_i\end{bmatrix}\)</span> the diagonal elements</p><p>stay the sequence transformation. <span class="math inline">\(\lambda_{i(n+1)}=\dfrac{1}{2}(\lambda_{in}+\lambda_{in}^{-1})\)</span> According to the <span class="math inline">\(\small (2)\)</span> question</p><p><span class="math inline">\(\lim\limits_{n\to +\infty}\lambda_{in}=\mbox{sign}(\lambda_{i})\)</span> So the diagonal elements of <span class="math inline">\(\lim\limits_{n\to +\infty}X_{n}\)</span> are <span class="math inline">\(\mbox{sign}(\lambda_i)\)</span> Just consider <span class="math inline">\(\lambda_i&gt;0\)</span></p><p>Then <span class="math inline">\(\mbox{sign}(\lambda_i)=1\)</span> So <span class="math inline">\(\lim\limits_{n\to +\infty}X_n=I+\displaystyle \sum_{i=1}^{n-1}b_i(J-\lambda I)^{i}\)</span> Take the limit for the original equation <span class="math inline">\(X_{n+1}=\dfrac{1}{2}\left(X_{n}+X_{n}^{-1}\right)\Longrightarrow I+\displaystyle \sum_{i=1}^{n-1}b_i(J-\lambda I)^{i}=\dfrac{1}{2}(I+\displaystyle \sum_{i=1}^{n-1}b_i(J-\lambda I)^{i}+(I+\displaystyle \sum_{i=1}^{n-1}b_i(J-\lambda I)^{i})^{-1})\)</span></p><p>So <span class="math inline">\((I+\displaystyle \sum_{i=1}^{n-1}b_i(J-\lambda I)^{i})^{2}=I\)</span> then <span class="math inline">\(\displaystyle \sum_{i=1}^{n-1}(b_i^2(J-\lambda I)^{2i}+2b_i(J-\lambda I)^{i})=O\)</span></p><p>We have proved that <span class="math inline">\(J,J-I,(J-I)^2,\cdots,(J-I)^{n-1}\)</span> are linearly independent</p><p>So <span class="math inline">\(b_1=b_3=\cdots=b_{2j+1}=0\)</span> and <span class="math inline">\(b_1^2+2b_2=0\Longrightarrow b_2=0,\cdots,b_{j}^{2}+2b_{2j}=0\)</span></p><p>For every even <span class="math inline">\(b_{\small\mbox{even}}=2^{n}\cdot c\)</span> where <span class="math inline">\(c\in \mbox{odd}\)</span> So <span class="math inline">\(b_{\small\mbox{even}}\)</span> will ultimately went to <span class="math inline">\(0\)</span>. So</p><p><span class="math inline">\(\lim\limits_{n\to +\infty}X_{n}=I=\mbox{sign}(A)\)</span> when <span class="math inline">\(\lambda_i&lt;0\)</span> that is the same.</p><p>Every matrix can be transformed into Jordan block and every Jordan block is right</p><p>So the algorithm of <span class="math inline">\(X_{n+1}=\dfrac{1}{2}(X_n+X_{n}^{-1})\)</span> can give <span class="math inline">\(\mbox{sign}(A)\)</span> if <span class="math inline">\(A\)</span> has no purely eigenvalues</p><p>And also, solving the equation <span class="math inline">\(AX+XB=C\)</span> by calculating <span class="math inline">\(\mbox{sign}\begin{pmatrix}A&amp;-C\\O&amp;B\end{pmatrix}\)</span> can be done</p><p><span class="math inline">\((4)\)</span> <span class="math inline">\(A=I+J,J=\begin{bmatrix}0&amp;1&amp;0&amp;\cdots&amp;0\\0&amp;0&amp;1&amp;\cdots&amp;0\\0&amp;0&amp;0&amp;\ddots&amp;0\\\vdots&amp;\vdots&amp;\vdots &amp;\ddots&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0\end{bmatrix}\)</span> use Taylor series and note that <span class="math inline">\(J^{n}=O\)</span></p><p><span class="math inline">\(X_0=I+J,X_1=\dfrac{1}{2}(I+J+(I+J)^{-1})=\dfrac{1}{2}(I+J+(I-J+J^2+\cdots+(-1)^{n-1}J^{n-1}))\)</span></p><p><span class="math inline">\(=I+\dfrac{1}{2}J^2+\cdots\)</span> every step at least 'kill's the 'smallest one'. If after <span class="math inline">\(k\)</span> steps the result is <span class="math inline">\(X_{k}=I+a_{k+1}J^{k+1}+\cdots+a_{n-1}J^{n-1}\)</span>, then <span class="math inline">\(X_{k+1}=\dfrac{1}{2}(X_k+X_k^{-1})\)</span></p><p><span class="math inline">\(=\dfrac{1}{2}((I+a_{k+1}J^{k+1}+\cdots+a_{n-1}J^{n-1})+(I+a_{k+1}J^{k+1}+\cdots+a_{n-1}J^{n-1})^{-1})\)</span></p><p>the coefficient of <span class="math inline">\(J^{k+1}\)</span> is eliminated. By induction, <span class="math inline">\(X_{n-1}=I+a_nJ^{n}+\cdots=I\)</span></p><h2 id="problem-6-small-mboxreal-möbius-transformations">Problem 6<span class="math inline">\(\ \small \mbox{Real Möbius transformations}\)</span></h2><p>A Möbius transformation is a function <span class="math inline">\(f: x \mapsto \dfrac{a x+b}{c x+d}\)</span>. For example, scaling <span class="math inline">\(x \mapsto 2 x\)</span>, addition <span class="math inline">\(x \mapsto x+1\)</span>, inversion <span class="math inline">\(x \mapsto \dfrac{1}{x}\)</span> are all Mobius transformations. We may further define <span class="math inline">\(f(\infty)=\dfrac{a}{c}\)</span> and <span class="math inline">\(f\left(-\dfrac{d}{c}\right)=\infty\)</span>, as you can tell by taking limits. So Möbius transformations are actiong on the space <span class="math inline">\(\mathbb{R} \cup\{\infty\}\)</span>. In some sense, you are imagining the real line where <span class="math inline">\(\infty\)</span> and <span class="math inline">\(-\infty\)</span> are treated as the same thing (i.e., they are glued together), and you see that <span class="math inline">\(\mathbb{R} \cup\{\infty\}\)</span> is in fact a big circle. (You can skip these materials in this parenthesis. They are irrelavant but maybe of interest: geometrically, consider the circle <span class="math inline">\(C\)</span> on the xy-plane with center <span class="math inline">\((0,1 / 2)\)</span> and radius <span class="math inline">\(1 / 2\)</span>. Then imagine that the point <span class="math inline">\((0,1)\)</span> on the circle has a ray gun attached. For each point of the circle, the ray gun can shoot that point, and then go through it and intersect with the <span class="math inline">\(x\)</span>-axis somewhere. This would give a 1-to-1 correspondence betwee the real line <span class="math inline">\(\mathbb{R}\)</span> and <span class="math inline">\(C-\{(0,1)\}\)</span>. Now think of <span class="math inline">\(\infty\)</span> as the point <span class="math inline">\((0,1)\)</span>, and you have thus build a 1-to-1 correspondence bwteen <span class="math inline">\(\mathbb{R} \cup\{\infty\}\)</span> and the circle <span class="math inline">\(C\)</span>. The Möbius transformations act on <span class="math inline">\(\mathbb{R} \cup\{\infty\}\)</span>, so under this correspondence you can imagine them as acting on the circle <span class="math inline">\(C\)</span>. They usually stretch some portions of <span class="math inline">\(C\)</span> while shrinking some other portions. This corresponds to looking at this circle from various perspectives. For example, if you look at the circle from the left, then since the left portion of the circle is closer to your eyes, it appears to be larger, while the right portion of the circle appears to be smaller as it is further away from your eyes. For a more concrete example, consider <span class="math inline">\(x \mapsto 2 x\)</span>. This means you are moving your perspective to be closer to <span class="math inline">\((0,0)\)</span> on the circle, so that points near <span class="math inline">\((0,0)\)</span> are more spread out. Everyone is now repelled away from the origin and attracted towards the infinity point <span class="math inline">\((0,1)\)</span>.)</p><p><img src="https://pic.imgdb.cn/item/62610514239250f7c5e6c98c.jpg" style="zoom:50%;" /></p><p>For any 2 by 2 invertible real matrix <span class="math inline">\(A=\left[\begin{array}{ll}a &amp; b \\ c &amp; d\end{array}\right]\)</span>, we can build a corresponding Möbius transformation <span class="math inline">\(f_{A}: \mathbb{R} \cup\{\infty\} \rightarrow \mathbb{R} \cup\{\infty\}\)</span> such that <span class="math inline">\(f_{A}(x)=\dfrac{a x+b}{c x+d}\)</span>. Obviously all Möbius transformation arises in this way.</p><p><span class="math inline">\((1)\)</span> Show that <span class="math inline">\(f_{A} \circ f_{B}=f_{A B}\)</span> for any <span class="math inline">\(A, B\)</span>. In particular, if we simply write <span class="math inline">\(A\)</span> to represent the function <span class="math inline">\(f_{A}\)</span>, then the composition of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is the same as the matrix multiplication of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. (You may also check <span class="math inline">\(f_{A^{-1}}\)</span> is the inverse function of <span class="math inline">\(f_{A}\)</span> and so on. This is not required though.)</p><p><span class="math inline">\((2)\)</span> Show that for any <span class="math inline">\(k \in \mathbb{R}-\{0\}, f_{A}=f_{k A}\)</span>. And conversely, if <span class="math inline">\(f_{A}=f_{B}\)</span>, then <span class="math inline">\(A=k B\)</span> for some complex constant <span class="math inline">\(k\)</span>. (So WLOG, to study a Möbius transformation <span class="math inline">\(f_{A}\)</span>, you can always scale A appropriately and assume that <span class="math inline">\(\operatorname{det}(A)=1\)</span>.)</p><p><span class="math inline">\((3)\)</span> Interpret a vector <span class="math inline">\(\left[\begin{array}{l}x \\ y\end{array}\right]\)</span> as a ratio <span class="math inline">\(\dfrac{x}{y}\)</span>. Then show that, under this interpretation, <span class="math inline">\(A\left[\begin{array}{l}x \\ y\end{array}\right]\)</span> is interpreted exactly as the ratio <span class="math inline">\(f_{A}\left(\dfrac{x}{y}\right)\)</span>. (As a result, some literature write <span class="math inline">\(A\)</span> and <span class="math inline">\(f_{A}\)</span> interchangably and <span class="math inline">\(\left[\begin{array}{l}x \\ y\end{array}\right]\)</span> and <span class="math inline">\(\dfrac{x}{y}\)</span> interchangably.)</p><p><span class="math inline">\((4)\)</span> Show that there are only four kinds of Möbius transformations. There is a kind where <span class="math inline">\(f_{A}\)</span> has two fixed points in <span class="math inline">\(\mathbb{R} \cup\{\infty\}\)</span> (a typical example is <span class="math inline">\(x \mapsto 2 x\)</span> where 0 and <span class="math inline">\(\infty\)</span> are the fixed points), a kind where <span class="math inline">\(f_{A}\)</span> has only one fixed point in <span class="math inline">\(\mathbb{R} \cup\{\infty\}\)</span> (a typical example is <span class="math inline">\(x \mapsto x+1\)</span> where <span class="math inline">\(\infty\)</span> is the only fixed point), and a kind without any fixed point in <span class="math inline">\(\mathbb{R} \cup\{\infty\}\)</span> (a typical example is <span class="math inline">\(x \mapsto-\dfrac{1}{x}\)</span> ). Finally, there is a kind where everyone is fixed, i.e., the identity function <span class="math inline">\(x \mapsto x\)</span>.</p><hr /><p><span class="math inline">\((1)\)</span> set <span class="math inline">\(A=\begin{pmatrix}a_1&amp;a_2\\a_3&amp;a_4\end{pmatrix},B=\begin{pmatrix}b_1&amp;b_2\\b_3&amp;b_4\end{pmatrix}\)</span> <span class="math inline">\(f_A\circ f_B(x)=f_A(\dfrac{b_1x+b_2}{b_3x+b_4})=\dfrac{a_1\dfrac{b_1x+b_2}{b_3x+b_4}+a_2}{a_3\dfrac{b_1x+b_2}{b_3x+b_4}+a_4}\)</span></p><p><span class="math inline">\(=\dfrac{(a_1b_1+a_2b_3)x+(a_1b_2+a_2b_4)}{(a_3b_1+a_4b_3)x+(a_3b_2+a_4b_4)}=f_{AB}(x)=f_{\begin{pmatrix}a_1b_1+a_2b_3&amp;a_1b_2+a_3b_4\\a_3b_1+a_4b_3&amp;a_3b_2+a_4b_4\end{pmatrix}}(x)\)</span></p><p>Check <span class="math inline">\(A^{-1}=\dfrac{1}{a_1a_4-a_2a_3}\begin{pmatrix}a_4&amp;-a_2\\-a_3&amp;a_1\end{pmatrix}\)</span> so <span class="math inline">\(f_{A^{-1}}(x)=\dfrac{a_4x-a_2}{-a_3x+a_1}\)</span> <span class="math inline">\((a_1a_4\neq a_2a_3)\)</span></p><p><span class="math inline">\(x\stackrel{f_{A}}{\longmapsto}\dfrac{a_1x+a_2}{a_3x+a_4}\stackrel{f_{A^{-1}}}{\longmapsto} \dfrac{a_4\dfrac{a_1x+a_2}{a_3x+a_4}-a_2}{-a_3\dfrac{a_1x+a_2}{a_3x+a_4}+a_1}=\dfrac{(a_1a_4-a_2a_3)x}{a_1a_4-a_2a_3}=x\)</span> <span class="math inline">\(f_{A^{-1}}\)</span> is the inverse of <span class="math inline">\(f_{A}\)</span></p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(A=\begin{pmatrix}a_1&amp;a_2\\a_3&amp;a_4\end{pmatrix},f_{kA}(x)=\dfrac{ka_1x+ka_2}{ka_3x+ka_4}=\dfrac{a_1x+a_2}{a_3x+a_4}=f_{A}(x)\)</span> if <span class="math inline">\(k\neq 0\)</span></p><p>If <span class="math inline">\(B=\begin{pmatrix}b_1&amp;b_2\\b_3&amp;b_4\end{pmatrix},f_{A}=f_{B}\)</span> we can get <span class="math inline">\(\dfrac{a_1x+a_2}{a_3x+a_4}=\dfrac{b_1x+b_2}{b_3x+b_4}\)</span> <span class="math inline">\(\Longrightarrow a_1b_3=a_3b_1,a_2b_4=b_2a_4\)</span></p><p>Construct <span class="math inline">\(k=\dfrac{a_1b_4-a_2b_3}{b_1b_4-b_2b_3}+i\dfrac{a_1b_2-a_2b_1}{b_1b_4-b_2b_3}=\begin{pmatrix}\dfrac{a_1b_4-a_2b_3}{b_1b_4-b_2b_3}&amp;\dfrac{a_2b_1-a_1b_2}{b_1b_4-b_2b_3}\\\dfrac{a_1b_2-a_2b_1}{b_1b_4-b_2b_3}&amp;\dfrac{a_1b_4-a_2b_3}{b_1b_4-b_2b_3}\end{pmatrix}\)</span></p><p>After too many calculations, <span class="math inline">\(A=kB=\begin{pmatrix}\dfrac{a_1b_4-a_2b_3}{b_1b_4-b_2b_3}&amp;\dfrac{a_2b_1-a_1b_2}{b_1b_4-b_2b_3}\\\dfrac{a_1b_2-a_2b_1}{b_1b_4-b_2b_3}&amp;\dfrac{a_1b_4-a_2b_3}{b_1b_4-b_2b_3}\end{pmatrix}B\)</span> is right.</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(A\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}a_1&amp;a_2\\a_3&amp;a_4\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}a_1x+a_2y\\a_3x+a_4y\end{bmatrix}\)</span> which can be interpred as <span class="math inline">\(\dfrac{a_1x+a_2y}{a_3x+a_4y}\)</span></p><p>and <span class="math inline">\(f_{A}(\dfrac{x}{y})=\dfrac{a_1\dfrac{x}{y}+a_2}{a_3\dfrac{x}{y}+a_4}=\dfrac{a_1x+a_2y}{a_3x+a_4y}\)</span> they are the same</p><p><span class="math inline">\((4)\)</span> For all the <span class="math inline">\(2\times 2\)</span> matrixes <span class="math inline">\(A\)</span>, use Jordan block, <span class="math inline">\(A=XJX^{-1}\)</span> All types of the <span class="math inline">\(J\)</span> are <span class="math inline">\(4\)</span> <span class="math display">\[\det(J)=1\Longrightarrow J=\begin{pmatrix}1&amp;0\\0&amp;1\end{pmatrix},\begin{pmatrix}\lambda_1&amp;0\\0&amp;\lambda_2\end{pmatrix},\begin{pmatrix}z&amp;0\\0&amp;\bar{z}\end{pmatrix},\begin{pmatrix}1&amp;1\\0&amp;1\end{pmatrix}\ \ \mbox{where} \ \lambda_1\lambda_2=|z|=1\]</span> Fixed points are <span class="math inline">\(\R,\{0,\infty\},\{\phi\},\{\infty\}\)</span> Because their eigenvectors must be real <span class="math inline">\(A\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}x\\y\end{bmatrix}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>高等代数选讲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高代作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>An intriguing contest in Spring</title>
    <link href="/2022/04/10/Math%20Contest/"/>
    <url>/2022/04/10/Math%20Contest/</url>
    
    <content type="html"><![CDATA[<p>期中考试前一周周六，参加求真书院（丘成桐班）举办的新生数理基础大赛，分为数学组和非数学组，当然选的是非数学组。考试途中监考员觉得我们做得有点慢，还给我们加了时长，从 <span class="math inline">\(3\)</span> 小时增加到 <span class="math inline">\(3.5\)</span> 小时。</p><p>很久没有集中精力考过这么长的试了，那本答题纸被我填满了（没有正反面都写），考到最后手都没力气了（手动捂脸）。考完整个人都虚脱了，吃了紫荆二楼的涮羊肉后待在寝室睡了一小时觉，睡完觉起来啥都不想干，直接躺平整个晚上。</p><p>考题总体来说比较符合口味，很像之前物理竞赛中的<strong>亚赛</strong>风格，从最简单、底层的证明开始推导，像楼房一样一层层累高。说实话，这才比较具有趣味性和科研性，那种一来就大眼瞪小眼（例如：求证 <span class="math inline">\(x^n+y^n=z^n,n\geq 3\)</span> 无平凡整数解，当然这是开玩笑，反正就这个意思）的题反而体验感不好。</p><p>四道题，每题 <span class="math inline">\(25\)</span> 分，<span class="math inline">\(A\)</span> 题 <span class="math inline">\(Stirling\)</span> 公式，<span class="math inline">\(B\)</span> 题包络线，<span class="math inline">\(C\)</span> 题两个题选一个，一个菲涅尔积分，一个随机游走，<span class="math inline">\(D\)</span> 题正交投影。<span class="math inline">\(C\)</span> 题我选的菲涅尔积分，也就是我做了 <span class="math inline">\(3\)</span> 道微积分，<span class="math inline">\(1\)</span> 道线代，平均每个题 <span class="math inline">\(7-8\)</span> 个小问。</p><p>据说前三题是同一个人出的，当时做的时候很容易在中间地方卡壳，但最后冥思苦想后都通关了，尤其是第一题做到一半感觉差点都要放弃了……最后一个线代题有点云里雾里，考试也说了后面问可以使用前面问的结论，由此<del>骗了不少分</del>（手动狗头）。</p><p>最终得分 <span class="math inline">\(\mathbf{25+23+23+18=89}\)</span>，混了个非数学组第二名（一等奖第一名），有几个数值计算题可能脑袋已经超负荷了，没有检查合理性，第三题算星形线面积时多乘了个 <span class="math inline">\(4\)</span>，线代题奇异值忘记开根号了，有些小遗憾。不过 wl 大师拿第一名特等奖也是实至名归了（<span class="math inline">\(\mathbf{92}\)</span> 分），等繁忙的期中考试后把题目（或许有时间的话解答）贴在后面。</p><p>新生数理基础大赛之旅还真不错，难得思考问题这么集中持久，感觉平常写代码 <span class="math inline">\(\mbox{copy}\)</span> 惯了，脑子没有之前高中竞赛那么灵活了，遇到j问题全靠搜索引擎。之后有机会还是多参加类似的比赛，也算是无聊大学生活中的愉悦体验吧。</p><p>麻了，微积分半期考试还没考过这个竞赛……</p><p><a href="https://lr-tsinghua11.github.io/pdf/NoneProfessionalMathmeticsContest.pdf">非数学组答案 pdf 版本</a></p>]]></content>
    
    
    <categories>
      
      <category>竞赛</category>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理基础大赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calculus A2 notes for exercise classes 2</title>
    <link href="/2022/04/08/Math/Calculus/Calculus%20A2%20notes%20for%20exercise%20class%202/"/>
    <url>/2022/04/08/Math/Calculus/Calculus%20A2%20notes%20for%20exercise%20class%202/</url>
    
    <content type="html"><![CDATA[<h1 id="第三次习题课">第三次习题课</h1><p><strong>齐次函数</strong>: 如果函数 <span class="math inline">\(f(x, y)\)</span> 满足对任意正数 <span class="math inline">\(t, f(t x, t y)=\)</span> <span class="math inline">\(t^{n} f(x, y)\)</span>, 则称 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(n\)</span> 次齐次函数。</p><p>有结论 设 <span class="math inline">\(f \in \mathscr{C}^{1}\)</span> 。则 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(n\)</span> 次齐次函数 <span class="math inline">\(\Longleftrightarrow x \dfrac{\partial f}{\partial x}(x, y)+y \dfrac{\partial f}{\partial y}(x, y)=n f(x, y)\)</span> 。</p><p>可以构造函数 <span class="math inline">\(g(x,y)=t^{-n}f(x,y)\)</span> 对 <span class="math inline">\(t\)</span> 求偏导可证明</p><p>对于多元函数求偏导，使用结论 <span class="math inline">\(\dfrac{\partial y}{\partial x_{i}}=-\dfrac{F_{x_{i}}(\mathbf{x}, y)}{F_{y}(\mathbf{x}, y)}=-\dfrac{\dfrac{\partial F}{\partial x_{i}}}{\dfrac{\partial F}{\partial y}}\)</span></p><p>多个方程组确定的隐函数方程，求偏导时两边对待定值求偏导解线性方程组，如：</p><p>在 <span class="math inline">\(\left\{\begin{array}{l}x^{2}+y^{2}=-z^{2}+1, \\ x^{2}+2 y^{2}=z^{2}+1\end{array}\right.\)</span> 两边对 <span class="math inline">\(z\)</span> 求导数, <span class="math inline">\(\left\{\begin{array}{l}2 x \frac{\mathrm{d} x}{\mathrm{~d} z}+2 y \frac{\mathrm{d} y}{\mathrm{~d} z}=-2 z, \\ 2 x \frac{\mathrm{d} x}{\mathrm{~d} z}+4 y \frac{\mathrm{d} y}{\mathrm{~d} z}=2 z .\end{array}\right.\)</span></p><p>参数曲面 <span class="math inline">\(S:\left\{\begin{array}{l}x=x(u, v) \\ y=y(u, v) \\ z=z(u, v)\end{array} \quad(u, v) \in D_{u v} \subset \mathbb{R}^{2},\right.\)</span>, <span class="math inline">\(P_{0}\left(x_{0}, y_{0}, z_{0}\right)=\left(x\left(u_{0}, v_{0}\right), y\left(u_{0}, v_{0}\right), z\left(u_{0}, v_{0}\right)\right)\)</span> 处的切平面为 <span class="math display">\[\left\{\begin{array}{l}x=x_{0}+\dfrac{\partial x}{\partial u}\left(u_{0}, v_{0}\right) t+\dfrac{\partial x}{\partial v}\left(u_{0}, v_{0}\right) s, \\ y=y_{0}+\dfrac{\partial y}{\partial u}\left(u_{0}, v_{0}\right) t+\dfrac{\partial y}{\partial v}\left(u_{0}, v_{0}\right) s, \quad t, s \in \mathbb{R} \\ z=z_{0}+\dfrac{\partial z}{\partial u}\left(u_{0}, v_{0}\right) t+\dfrac{\partial z}{\partial v}\left(u_{0}, v_{0}\right) s,\end{array}\right.\]</span> 固定 <span class="math inline">\(u,v\)</span> 中的其中一个变量，计算两种切线，切平面为这两种切线的线性组合，也可以写作 <span class="math display">\[\left|\begin{array}{ccc}x-x_{0} &amp; y-y_{0} &amp; z-z_{0} \\ \dfrac{\partial x}{\partial u} &amp; \dfrac{\partial y}{\partial u} &amp; \dfrac{\partial z}{\partial u} \\ \dfrac{\partial x}{\partial v} &amp; \dfrac{\partial y}{\partial v} &amp; \dfrac{\partial z}{\partial v}\end{array}\right|=0\]</span> 曲面 <span class="math inline">\(S\)</span> 由方程 <span class="math inline">\(a x+b y+c z=G\left(x^{2}+y^{2}+z^{2}\right)\)</span> 确定, 试证明: 曲面 <span class="math inline">\(S\)</span> 上 任一点的法线与某定直线相交。 证明. 曲面上任意一点 <span class="math inline">\(P\left(x_{0}, y_{0}, z_{0}\right)\)</span> 的法线（<strong>参数方程</strong>） <span class="math display">\[L:\left\{\begin{array}{l}x=x_{0}+t\left(G^{\prime}\left(r^{2}\right)\left(2 x_{0}\right)-a\right)=x_{0}\left(1+2 t G^{\prime}\left(r^{2}\right)\right)-a t, \\y=y_{0}+t\left(G^{\prime}\left(r^{2}\right)\left(2 y_{0}\right)-b\right)=y_{0}\left(1+2 t G^{\prime}\left(r^{2}\right)\right)-b t, \\z=z_{0}+t\left(G^{\prime}\left(r^{2}\right)\left(2 z_{0}\right)-c\right)=z_{0}\left(1+2 t G^{\prime}\left(r^{2}\right)\right)-c t .\end{array}\right.\]</span> 取 <span class="math inline">\(t=-\dfrac{1}{2 G^{\prime}\left(r^{2}\right)}\)</span>, 则 <span class="math inline">\((x, y, z)=(-a t,-b t,-c t)\)</span> 。所有法线 <span class="math inline">\(L\)</span> 都与直线 <span class="math inline">\(\dfrac{x}{a}=\)</span> <span class="math inline">\(\dfrac{y}{b}=\dfrac{z}{c}\)</span> 相交。</p><h1 id="第四次习题课">第四次习题课</h1><p>暴力计算由隐函数确定的二阶偏导数，例如对 <span class="math inline">\(2x^2+2y^2+z^2+8xz-z+8=0\)</span> 试图求解在驻点处的 <span class="math inline">\(\mbox{Hesse }\)</span> 矩阵</p><p>上述方程对 <span class="math inline">\(x\)</span> 求偏导，<span class="math inline">\(4x+2z\dfrac{\partial z}{\partial x}+8z+8x\dfrac{\partial z}{\partial x}-\dfrac{\partial z}{\partial x}=0\)</span></p><p>继续对 <span class="math inline">\(x\)</span> 求偏导，<span class="math inline">\(4+2(\dfrac{\partial z}{\partial x})^2+2z\dfrac{\partial^2 z}{\partial x^2}+8\dfrac{\partial z}{\partial x}+8\dfrac{\partial z}{\partial x}+8x\dfrac{\partial^2 z}{\partial x^2}-\dfrac{\partial^2 z}{\partial x^2}=0\)</span> 可解得 <span class="math inline">\(\dfrac{\partial z}{\partial x}\)</span></p><p>可以解得 <span class="math inline">\(\dfrac{\partial^2 z}{\partial x^2}=-\dfrac{4+2(\dfrac{\partial z}{\partial x})^2+16\dfrac{\partial z}{\partial x}}{2x+8z-1}\)</span> 代入 <span class="math inline">\(\dfrac{\partial z}{\partial x}\)</span> 的表达式则可解得 <span class="math inline">\(\dfrac{\partial^2 z}{\partial x^2}\)</span></p><p>一道使用 <span class="math inline">\(\mathbf{Hesse}\)</span> <strong>矩阵和特征值性质</strong>的证明题：设 <span class="math inline">\(u(x, y)\)</span> 在 <span class="math inline">\(x^{2}+y^{2} \leq 1\)</span> 上连续, 在 <span class="math inline">\(x^{2}+y^{2}&lt;1\)</span> 内有二阶连续偏导数, 并且满足 <span class="math display">\[\begin{cases}\dfrac{\partial^{2} u}{\partial x^{2}}+\dfrac{\partial^{2} u}{\partial y^{2}}=u, &amp; x^{2}+y^{2}&lt;1 \\ u(x, y) \geq 0 &amp; x^{2}+y^{2}=1\end{cases}\]</span> 证明: 当 <span class="math inline">\(x^{2}+y^{2} \leq 1\)</span> 时, <span class="math inline">\(u(x, y) \geq 0\)</span> 。</p><p>反证法，假设 <span class="math inline">\(\exists \ x_0,y_0,x_0^2+y_0^2&lt;1\)</span> 时 <span class="math inline">\(u(x_0,y_0)&lt;0\)</span> ，设 <span class="math inline">\((a,b)\)</span> 是 <span class="math inline">\(u(x,y)\)</span></p><p>的最小值点，该点的 <span class="math inline">\(\mbox{Hesse}\)</span> 矩阵为半正定 <span class="math inline">\(\mathbf{H}=\begin{bmatrix}\dfrac{\partial^2 u}{\partial x^2}&amp;\dfrac{\partial ^2u}{\partial x\partial y}\\\dfrac{\partial ^2u}{\partial x\partial y}&amp;\dfrac{\partial^2 u}{\partial y^2}\end{bmatrix}\)</span>，由特征值性质 <span class="math inline">\(\lambda_1+\lambda_2=\mbox{tr}(\mathbf{H})\geq 0\)</span> 但 <span class="math inline">\(\nabla u=u\leq u(x_0,y_0)&lt;0\)</span> 矛盾</p><p>假设 <span class="math inline">\(f(x, y)\)</span> 有连续的偏导数, 在全平面除原点之外处处满足等式 <span class="math display">\[x \frac{\partial f}{\partial x}+y \frac{\partial f}{\partial y}&gt;0 .\]</span> 求证原点是 <span class="math inline">\(f(x, y)\)</span> 的唯一极小值点. 并且满足 <span class="math display">\[\lim _{x \rightarrow 0, y \rightarrow 0} \frac{f(x, y)-f(0,0)}{\sqrt{x^{2}+y^{2}}}=0 .\]</span> 就是证明在 <span class="math inline">\((0,0)\)</span> 处对 <span class="math inline">\(x,y\)</span> 的偏导数都是 <span class="math inline">\(0\)</span></p><p>期中考试前一周周六，参加求真书院（丘成桐班）举办的新生数理基础大赛，分为数学组和非数学组，当然选的是非数学组。考试途中监考员觉得我们做得有点慢，还给我们加了时长，从 <span class="math inline">\(3\)</span> 小时增加到 <span class="math inline">\(3.5\)</span> 小时。</p><p>很久没有集中精力考过这么长的试了，那本答题纸被我填满了（没有正反面都写），考到最后手都没力气了（手动捂脸）。考完整个人都虚脱了，吃了紫荆二楼的涮羊肉后待在寝室睡了一小时觉，睡完觉起来啥都不想干，直接躺平整个晚上。</p><p>考题总体来说比较符合口味，很像之前物理竞赛中的<strong>亚赛</strong>风格，从最简单、底层的证明开始推导，像楼房一样一层层累高。说实话，这才比较具有趣味性和科研性，那种一来就大眼瞪小眼（例如：求证 <span class="math inline">\(x^n+y^n=z^n,n\geq 3\)</span> 无平凡整数解，当然这是开玩笑，反正就这个意思）的题反而体验感不好。</p><p>四道题，每题 <span class="math inline">\(25\)</span> 分，<span class="math inline">\(A\)</span> 题 <span class="math inline">\(Stirling\)</span> 公式，<span class="math inline">\(B\)</span> 题包络线，<span class="math inline">\(C\)</span> 题两个题选一个，一个菲涅尔积分，一个随机游走，<span class="math inline">\(D\)</span> 题正交投影。<span class="math inline">\(C\)</span> 题我选的菲涅尔积分，也就是我做了 <span class="math inline">\(3\)</span> 道微积分，<span class="math inline">\(1\)</span> 道线代，平均每个题 <span class="math inline">\(7-8\)</span> 个小问。</p><p>据说前三题是同一个人出的，当时做的时候很容易在中间地方卡壳，但最后冥思苦想后都通关了，尤其是第一题做到一半感觉差点都要放弃了……最后一个线代题有点云里雾里，考试也说了后面问可以使用前面问的结论，由此<del>骗了不少分</del>（手动狗头）。</p><p>最终得分 <span class="math inline">\(\mathbf{25+23+23+18=89}\)</span>，混了个非数学组第二名（一等奖第一名），有几个数值计算题可能脑袋已经超负荷了，没有检查合理性，第三题算星形线面积时多乘了个 <span class="math inline">\(4\)</span>，线代题奇异值忘记开根号了，有些小遗憾。不过 wl 大师拿第一名特等奖也是实至名归了（<span class="math inline">\(\mathbf{92}\)</span> 分），等繁忙的期中考试后把题目（或许有时间的话解答）贴在后面。</p><p>新生数理基础大赛之旅还真不错，难得思考问题这么集中持久，感觉平常写代码 <span class="math inline">\(\mbox{copy}\)</span> 惯了，脑子没有之前高中竞赛那么灵活了，遇到问题全靠搜索引擎。之后有机会还是多参加类似的比赛，也算是无聊大学生活中的愉悦体验~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>多元微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多元微积分习题课笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thoughts on the sixth week of blog building</title>
    <link href="/2022/04/03/Thoughts%20on%20the%20sixth%20week%20of%20blog%20building%20%20/"/>
    <url>/2022/04/03/Thoughts%20on%20the%20sixth%20week%20of%20blog%20building%20%20/</url>
    
    <content type="html"><![CDATA[<h2 id="第六周">第六周</h2><p>简单说说这几周以来的感受嘛，基本上一个学期到这个时候，事务繁杂，简直忙都忙不过来，觉都睡不好，还没去年高考这个时候舒服（X），毕竟那个时候想刷就刷，不想刷（尤其是诊断性考试后几天）就拉倒。哎，这几周忙完报告，各种讲座，科协事情，半期考试之后就好多了。之前开学的时候想学好多东西，结果到这个时候 flag 全倒了（QAQ）</p><ul><li>实验报告作图自动化</li><li>半期考试稳重就行，其他不管</li><li>第五届人工智能大赛认真参加</li><li>OOP大作业决定用一些 QT 吧，顺便学一些 zcy 他们图形学相关的知识</li><li>史纲期末报告冲！</li></ul>]]></content>
    
    
    <categories>
      
      <category>随想</category>
      
      <category>里程碑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客建成六周随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A story of farming</title>
    <link href="/2022/03/27/Farming/"/>
    <url>/2022/03/27/Farming/</url>
    
    <content type="html"><![CDATA[<p>地点在北京市房山区庐西园，感觉书院还是有钱，包了两个大棚拿给未央书院和日新书院种地。</p><p>早上起来天气是真的好，太阳照着很暖和， <span class="math inline">\(3\)</span> 月初北京还倔强地下雪，现在总算是被春天逮到起了</p><p>基地入口和大棚外面的空旷田园，嗯，春天的气息</p><p><img src="https://pic.imgdb.cn/item/6249c599239250f7c5c8850e.jpg" style="zoom:33%;" /></p><p><img src="https://pic.imgdb.cn/item/6249c47f239250f7c5c5c882.jpg" style="zoom:33%;" /></p><p>有个小牧场，看到许多动物，鸡，狗，孔雀，鸵鸟，兔（白毛但眼睛周围的毛是黑色的是啥品种？），羊……</p><p><img src="https://pic.imgdb.cn/item/6249c624239250f7c5c9d26e.jpg" style="zoom:33%;" /></p><p>然后便化身<strong>喂（未）养（央）人</strong>：</p><p><img src="https://pic.imgdb.cn/item/6249c6a1239250f7c5cafac9.jpg" style="zoom:33%;" /></p><p>想不到吧，这里最吸引我们的还是<strong>童趣乐园</strong>，辅导员们和我们在这儿磨蹭了很久……</p><p><img src="https://pic.imgdb.cn/item/6249c75c239250f7c5cca41a.jpg" style="zoom:33%;" /></p><p><img src="https://pic.imgdb.cn/item/6249c7fd239250f7c5ce15cc.jpg" style="zoom:33%;" /></p><p>中午吃了一些干粮，还没耍够，一点钟准备种地，农场挂牌</p><p><img src="https://pic.imgdb.cn/item/6249c539239250f7c5c7a6e0.jpg" style="zoom:33%;" /></p><p>进去直接热炸了，汗水一层一层地从皮肤中冒出来，大中午种地确实难受，结果进去第一件事情就是均匀铲平这些牛粪，别看着轻松，没铲下去甩一下还真不知道这阻力有多大</p><p><img src="https://pic.imgdb.cn/item/6249c8a9239250f7c5cfa035.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <categories>
      
      <category>随想</category>
      
      <category>种田记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>初春种田记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calculus A2 notes for exercise classes</title>
    <link href="/2022/03/25/Math/Calculus/Calculus%20A2%20notes%20for%20exercise%20class%201/"/>
    <url>/2022/03/25/Math/Calculus/Calculus%20A2%20notes%20for%20exercise%20class%201/</url>
    
    <content type="html"><![CDATA[<h2 id="第一次习题课">第一次习题课</h2><ul><li><p>善用放缩 <span class="math inline">\(\dfrac{xy}{x^2+y^2}\leq \dfrac{1}{2}\)</span></p></li><li><p>函数 <span class="math inline">\(f(x, y)\)</span> 在点 <span class="math inline">\(\left(x_{0}, y_{0}\right)\)</span> 的某去心邻域内有定义, 若：</p><ol type="a"><li><p>存在 <span class="math inline">\(x_{0}\)</span> 的去心邻域 <span class="math inline">\(U=\left\{x|0&lt;| x-x_{0} \mid&lt;r\right\}\)</span>, 使得 <span class="math inline">\(\forall x \in U\)</span>, <span class="math inline">\(\displaystyle \lim _{y \rightarrow y_{0}} f(x, y)=g(x)\)</span> 存在;</p></li><li><p><span class="math inline">\(\displaystyle \lim _{x \rightarrow x_{0}} f(x, y)=h(y)\)</span> 关于 <span class="math inline">\(y_{0}\)</span> 的某个去心邻域 <span class="math inline">\(\left\{y|0&lt;| y-y_{0} \mid&lt;\eta\right\}\)</span> 上一 致,</p></li></ol><p>则极限 <span class="math inline">\(\displaystyle \lim _{x \rightarrow x_{0}} g(x)\)</span> 和 <span class="math inline">\(\displaystyle \lim _{y \rightarrow y_{0}} h(y)\)</span> 都存在, 并且相等, 即 <span class="math inline">\(\displaystyle \lim _{x \rightarrow x_{0}} \displaystyle \lim _{y \rightarrow y_{0}} f(x, y)=\)</span> <span class="math inline">\(\displaystyle \lim _{y \rightarrow y_{0}} \displaystyle \lim _{x \rightarrow x_{0}} f(x, y)\)</span> 。</p><p><strong>即在一个方向上加入一致连续的条件就可以让累次极限和二重极限存在</strong></p><p>满足一致连续的一个充分条件，存在常数 <span class="math inline">\(M&gt;0\)</span> 使得在 <span class="math inline">\(\left(x_{0}, y_{0}\right)\)</span> 的一个去心邻域中, 都有</p></li></ul><p><span class="math display">\[\left|\frac{\partial f}{\partial x}(x, y)\right|&lt;M .\]</span></p><ul><li><p><span class="math inline">\(\dfrac{x+y}{x^2-xy+y^2}=\dfrac{x+y}{\dfrac{3}{4}(x-y)^2+\dfrac{1}{4}(x+y)^2}\leq \dfrac{4}{x+y}\)</span></p></li><li><p><span class="math inline">\(\dfrac{x^2y^n}{x^3+y^3},n\geq 1\)</span>，取 <span class="math inline">\(y=x\)</span> 和 <span class="math inline">\(y=x^n-x\)</span> 可知在 <span class="math inline">\((0,0)\)</span> 处二重极限不存在（对多元多项式, 无穷小比阶不能仅看多项式的次数）</p></li></ul><h2 id="第二次习题课">第二次习题课</h2><ul><li><p><span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\((x_0,y_0)\)</span> 处可微的充要条件 <span class="math display">\[\exists\ A,B\in R,s.t.f(x,y)=A(x-x_0)+B(y-y_0)+o(\sqrt{(x-x_0)^2+(y-y_0)^2})\]</span> 对具体的问题先计算 <span class="math inline">\(A=\lim\limits_{x\to x_0}\dfrac{f(x,y_0)-f(0,y_0)}{x-x_0},B=\lim\limits_{y\to y_0}\dfrac{f(x_0,y)-f(x_0,y_0)}{y-y_0}\)</span></p><p>然后再计算 <span class="math inline">\(\lim\limits_{(x,y)\to (x_0,y_0)}\dfrac{f(x,y)-A(x-x_0)-B(y-y_0)}{\sqrt{(x-x_0)^2+(y-y_0)^2}}\)</span> 是否等于 <span class="math inline">\(0\)</span></p></li><li><p>设 <span class="math inline">\(z(x, y)\)</span> 定义在矩形区域 <span class="math inline">\(D=\{(x, y) \mid 0 \leq x \leq a, 0 \leq y \leq b\}\)</span> 上的 <span class="math inline">\(\mathscr{C}^{1}\)</span> 函数。证明:</p><ol type="1"><li><span class="math inline">\(z(x, y)=f(y) \Longleftrightarrow \forall(x, y) \in D, \dfrac{\partial z}{\partial x}=0\)</span>;</li><li><span class="math inline">\(z(x, y)=f(x)+g(y) \Longleftrightarrow \forall(x, y) \in D, \dfrac{\partial^{2} z}{\partial x \partial y}=0\)</span></li></ol><p><span class="math inline">\((1)\)</span> 使用微分中值定理，<span class="math inline">\(z(x,y)=z(x_0,y)+\dfrac{\partial z}{\partial x}(\xi,y)(x-x_0)=z(x_0,y)=f(y)\)</span></p><p><span class="math inline">\((2)\)</span> 令 <span class="math inline">\(u(x,y)=\dfrac{\partial z}{\partial y},\dfrac{\partial u}{\partial x}=0\)</span>，由 <span class="math inline">\(\small (1)\)</span> 有 <span class="math inline">\(u(x,y)=\dfrac{\partial z }{\partial y}=h(y)\)</span>，有 <span class="math inline">\(h(y)\)</span> 原函数令为 <span class="math inline">\(g(y)\)</span>，令 <span class="math inline">\(v(x,y)=z(x,y)-g(y)\)</span> 从而得证</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>多元微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多元微积分习题课笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advanced Algebra HW2</title>
    <link href="/2022/03/24/Math/Advanced%20Linear%20Algebra/HW3/"/>
    <url>/2022/03/24/Math/Advanced%20Linear%20Algebra/HW3/</url>
    
    <content type="html"><![CDATA[<h1 id="largetextcolorbluemboxadvanced-algebra-small-mathbbhwmathrm3-_textcolorblue2022.3.24"><span class="math inline">\(\large\textcolor{blue}{\mbox{Advanced Algebra } \small \mathbb{HW}\mathrm{3}}\ \ \ \ \ \ _\textcolor{blue}{2022.3.24}\)</span></h1><h2 id="small-mboxjordan-normal-form">1.3.1<span class="math inline">\(\ \small \mbox{jordan normal form}\)</span></h2><p>Find a basis in the following vector space so that the linear map involved will be in Jordan normal form. Also find the Jordan normal form.</p><ol type="1"><li><span class="math inline">\(V=\mathbb{C}^{2}\)</span> is a real vector space, and <span class="math inline">\(A: V \rightarrow V\)</span> that sends <span class="math inline">\(\left[\begin{array}{l}x \\ y\end{array}\right]\)</span> to <span class="math inline">\(\left[\begin{array}{c}\bar{x}-\Re(y) \\ (1+i) \Im(x)-y\end{array}\right]\)</span> is a real linear map. (Here <span class="math inline">\(\bar{x}\)</span> means the complex conjugate of a complex number <span class="math inline">\(x\)</span>, and <span class="math inline">\(\Re(x), \Im(x)\)</span> means the real part and the imaginary part of a complex number <span class="math inline">\(x .)\)</span></li><li><span class="math inline">\(V=P_{4}\)</span>, the real vector space space of all real polynomials of degree at most 4. And <span class="math inline">\(A: V \rightarrow V\)</span> is a linear map such that <span class="math inline">\(A(p(x))=p^{\prime}(x)+p(0)+p^{\prime}(0) x^{2}\)</span> for each polynomial <span class="math inline">\(p \in P_{4}\)</span>.</li><li><span class="math inline">\(A=\left[\begin{array}{llll} &amp; &amp; &amp; a_{1} \\ &amp; &amp; a_{2} &amp; \\ &amp; a_{3} &amp; &amp; \\ a_{4} &amp; &amp; &amp; \end{array}\right]\)</span>. Be careful here. Maybe we have many possibilities for its Jordan normal form depending on the values of <span class="math inline">\(a_{1}, a_{2}, a_{3}, a_{4}\)</span>.</li></ol><hr /><p><span class="math inline">\((1)\)</span> <span class="math inline">\(A_1=\begin{pmatrix}1&amp;0&amp;-1&amp;0\\0&amp;-1&amp;0&amp;0\\0&amp;1&amp;-1&amp;0\\0&amp;1&amp;0&amp;-1\end{pmatrix}=\begin{pmatrix}1&amp;2&amp;1&amp;0\\0&amp;0&amp;4&amp;0\\0&amp;4&amp;0&amp;0\\0&amp;4&amp;0&amp;1\end{pmatrix}\begin{pmatrix}1&amp;0&amp;0&amp;0\\0&amp;-1&amp;1&amp;0\\0&amp;0&amp;-1&amp;0\\0&amp;0&amp;0&amp;-1\end{pmatrix}\begin{pmatrix}1&amp;2&amp;1&amp;0\\0&amp;0&amp;4&amp;0\\0&amp;4&amp;0&amp;0\\0&amp;4&amp;0&amp;1\end{pmatrix}^{-1}\)</span></p><p><span class="math inline">\((2)\)</span> <span class="math inline">\(A:a_0+a_1x+a_2x^2+a_3x^3+a_4x^4\longmapsto(a_0+a_1)+2a_2x+(a_1+2a_3)x^2+4a_4x^3\)</span> <span class="math display">\[\begin{gathered}\begin{pmatrix}1&amp;1&amp;0&amp;0&amp;0\\0&amp;0&amp;2&amp;0&amp;0\\0&amp;1&amp;0&amp;3&amp;0\\0&amp;0&amp;0&amp;0&amp;4\\0&amp;0&amp;0&amp;0&amp;0\end{pmatrix}=J\begin{pmatrix}1&amp;0&amp;0&amp;0&amp;0\\0&amp;\sqrt{2}&amp;0&amp;0&amp;0\\0&amp;0&amp;-\sqrt{2}&amp;0&amp;0\\0&amp;0&amp;0&amp;0&amp;1\\0&amp;0&amp;0&amp;0&amp;0\end{pmatrix}J^{-1}\\J=\begin{pmatrix}1&amp;\sqrt{2}+1&amp;1-\sqrt{2}&amp;12&amp;12\\0&amp;1&amp;1&amp;-12&amp;0\\0&amp;\dfrac{\sqrt{2}}{2}&amp;-\dfrac{\sqrt{2}}{2}&amp;0&amp;-6\\0&amp;0&amp;0&amp;4&amp;0\\0&amp;0&amp;0&amp;0&amp;1\end{pmatrix}\end{gathered}\]</span> <span class="math inline">\((3)\)</span> <span class="math display">\[J=\begin{pmatrix}J_{1,4}&amp;O\\O&amp;J_{2,3}\end{pmatrix},\mbox{where }J_{i,j}=\begin{cases}\begin{pmatrix}\sqrt{a_ia_j}&amp;0\\0&amp;-\sqrt{a_ia_j}\end{pmatrix}&amp;a_i\neq 0,a_j\neq 0\\\begin{pmatrix}0&amp;0\\0&amp;0\end{pmatrix}&amp;a_i= 0,a_j\neq 0\mbox{ or }a_i\neq 0,a_j=0 \\\begin{pmatrix}0&amp;1\\0&amp;0\end{pmatrix}&amp;a_i=a_j=0\\\end{cases}\]</span></p><h2 id="small-mboxpartitions-of-interger">1.3.2<span class="math inline">\(\ \small \mbox{partitions of interger}\)</span></h2><p>A partition of integer <span class="math inline">\(n\)</span> is a way to write <span class="math inline">\(n\)</span> as a sum of other positive integers, say <span class="math inline">\(5=2+2+1\)</span>. If you always order the summands from large to small, you end up with a dot diagram, where each column represent an integer: <span class="math inline">\(\left[\begin{array}{ll}\cdot &amp; \cdot \\ \cdot &amp; \cdot \\ \cdot\end{array}\right]\)</span>. Similarly, <span class="math inline">\(7=4+2+1\)</span> should be represented as <span class="math inline">\(\left[\begin{array}{lll} \cdot &amp; \cdot &amp; \cdot \\ \cdot &amp; \cdot &amp; \\ \cdot &amp; &amp; \\ \cdot &amp; &amp; \end{array}\right]\)</span></p><ol type="1"><li><p>If the Jordan normal form of an <span class="math inline">\(n \times n\)</span> nilpotent matrix <span class="math inline">\(A\)</span> is diag <span class="math inline">\(\left(J_{a_{1}}, J_{a_{2}}, \ldots, J_{a_{k}}\right)\)</span>, then we have a partition of integer <span class="math inline">\(n=a_{1}+\ldots+a_{k}\)</span>. However, we also have a partition of integer <span class="math inline">\(n=\small [\operatorname{dim} \operatorname{Ker}(A)]+\left[\operatorname{dim} \operatorname{Ker}\left(A^{2}\right)-\operatorname{dim} \operatorname{Ker}(A)\right]+\left[\operatorname{dim} \operatorname{Ker}\left(A^{3}\right)-\operatorname{dim} \operatorname{Ker}\left(A^{2}\right)\right]+\ldots\)</span> where we treat the content of each bracket as a positive integer. Can you find a relation between the two dot diagrams?</p></li><li><p>A partition of integer <span class="math inline">\(n=a_{1}+\ldots+a_{k}\)</span> is called self-conjugate if, for the matrix <span class="math inline">\(A=\operatorname{diag}\left(J_{a_{1}}, J_{a_{2}}, \ldots, J_{a_{k}}\right)\)</span>, the two dot diagrams you obtained above are the same. Show that, for a fixed integer n, the number of self-conjugate partition of <span class="math inline">\(n\)</span> is equal to the number of partition of <span class="math inline">\(n\)</span> into distinct odd positive integers. (Hint: For a self-conjugate dot diagram, count the total number of dots that are either in the first column or in the first row or in both. Is this always odd?)</p></li><li><p>Suppose a 4 by 4 matrix <span class="math inline">\(A\)</span> is nilpotent and upper trianguler, and all <span class="math inline">\((i, j)\)</span> entries for <span class="math inline">\(i&lt;j\)</span> are chosen randomly and uniformly in the interval <span class="math inline">\([-1,1]\)</span>. What are the probabilities that its Jordan canonical form corresponds to the partitions <span class="math inline">\(4=4,4=3+1,4=2+2,4=2+1+1,4=1+1+1+1\)</span> ?</p></li></ol><hr /><p><span class="math inline">\((1)\)</span> I can find that the sequence of each bracket' number is not incremental, which is just like the dot graph. Put <span class="math inline">\(\small [\operatorname{dim} \operatorname{Ker}(A)],\left[\operatorname{dim} \operatorname{Ker}\left(A^{2}\right)-\operatorname{dim} \operatorname{Ker}(A)\right],\left[\operatorname{dim} \operatorname{Ker}\left(A^{3}\right)-\operatorname{dim} \operatorname{Ker}\left(A^{2}\right)\right],\ldots\)</span> like the dot graph. According to the 'killing chain', the number of each row's dots of the dot graph is just <span class="math inline">\(a_1,a_2,a_3,\ldots\)</span></p><p><span class="math inline">\((2)\)</span> The self-conjugate of the partition is just like a flying wing. Like this <span class="math inline">\(\left[\begin{array}{lll} \cdot &amp; \cdot &amp; \cdot &amp; \cdot&amp;\cdot &amp;\cdot \\ \cdot &amp; \cdot &amp; \cdot &amp; \cdot&amp;\cdot \\ \cdot &amp;\cdot &amp;\cdot &amp; \\\cdot &amp;\cdot &amp;\\ \cdot &amp;\cdot &amp;\\\cdot \end{array}\right]\)</span></p><p>If rudely call this as a matrix <span class="math inline">\(A\)</span>, because of the condition, we have <span class="math inline">\(A=A^{T}\)</span>.</p><p>Consider the outermost corner, the total number of the dots is <span class="math inline">\(n+n-1=2n-1\in \mbox{odd}\)</span></p><p>And deprive each corner, the newest outermost corner also satisfies the odd condition.</p><p>So every self-conjugate can be correspondence to odd-partition. And for each odd-partition, we can construct the matrix one corner by one corner.</p><p>In conclusion, the two numbers are the same.</p><p><span class="math inline">\((3)\)</span> <span class="math inline">\(A\)</span> is nilpotent and its dimension is <span class="math inline">\(4\)</span>, so <span class="math inline">\(A^{4}=O\)</span>. Consider the diagonal elements.</p><p><span class="math inline">\(A^4(i,i)=(A(i,i))^4=0\)</span>, so <span class="math inline">\(A\)</span> is like <span class="math inline">\(A=\begin{pmatrix}0&amp;\mbox{ran}&amp;\mbox{ran}&amp;\mbox{ran}\\0&amp;0&amp;\mbox{ran}&amp;\mbox{ran}\\0&amp;0&amp;0&amp;\mbox{ran}\\0&amp;0&amp;0&amp;0\end{pmatrix}\)</span>. It is obvious that all the</p><p>eigenvalues are <span class="math inline">\(0\)</span>. Consider <span class="math inline">\(\mbox{Ker}(A),\mbox{Ker}(A^2),\mbox{Ker}(A^3),\mbox{Ke}(A^4)\)</span>, dimension of each is nearly</p><p><span class="math inline">\(1,2,3,4\)</span> , since each <span class="math inline">\(\mbox{ran}\)</span> is randomly chosen from <span class="math inline">\([-1,1]\)</span>. The probability <span class="math inline">\(4=1+1+1+1\)</span></p><p>is <span class="math inline">\(1\)</span>, others are <span class="math inline">\(0\)</span>.</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>高等代数选讲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高代作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP-homework-5</title>
    <link href="/2022/03/23/Program/OOP%20homework%205/"/>
    <url>/2022/03/23/Program/OOP%20homework%205/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程第五次作业">面向对象编程第五次作业</h1><p><strong>Object-Oriented Programming <span class="math inline">\(\bullet\)</span> Homework <span class="math inline">\(\mathbf{5}\)</span></strong></p><p>本文从模型、验证两个方面构建复数类的软件库（包含加减乘除、前置（后置）加（减）以及乘方九种运算符号），使用<span class="math inline">\(\mbox{doctest}\)</span>工具进行自动化测试，共验证<span class="math inline">\(1273\)</span>个测试点，使用手动验证和自动化验证完备地给出不同情况下复数的运算</p><p><strong>关键词:</strong> 复数;运算符;对拍器;完备性</p><h2 id="模型">模型</h2><h3 id="基本运算">基本运算</h3><p>对复数的加法减法，即为对应实部虚部的相加，乘法除法的运算如下： <span class="math display">\[(a+bi)(c+di)=ac-bd+(bc+ad)i,\ \dfrac{a+bi}{c+di}=\dfrac{ac+bd+(bc-ad)i}{c^2+d^2}\]</span> 相应的代码实现比较简单</p><h3 id="前后置加减">前（后）置加（减）</h3><p>对于前置加和后置加，应用运算操作符的静态多态性（函数重载，两者通过<span class="math inline">\(int\)</span>的标识差别），对前置和后置的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">complex&amp; <span class="hljs-keyword">operator</span>++();      <span class="hljs-comment">//前置加</span><br>complex <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>);    <span class="hljs-comment">//后置加</span><br>complex&amp; <span class="hljs-keyword">operator</span>--();      <span class="hljs-comment">//前置减</span><br>complex <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>);    <span class="hljs-comment">//后置减</span><br></code></pre></td></tr></table></figure><p>由前置运算符要求先做加加（或者减减）运算，再赋值，后置运算符要求先赋值，后做加加（或者减减）运算，前者直接返回运算后的<span class="math inline">\((*this)\)</span>指针，后者返回提前"备份"好的<span class="math inline">\(old\)</span>，相应函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">complex&amp; complex::<span class="hljs-keyword">operator</span>++() &#123;<br>        m_real++;<br>        <span class="hljs-built_in">show</span>(<span class="hljs-string">&quot;（前++）= &quot;</span>);<br>        <span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br>complex complex::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        complex old = *<span class="hljs-keyword">this</span>;<br>        m_real++;<br>        <span class="hljs-built_in">show</span>(<span class="hljs-string">&quot;（后++）= &quot;</span>);<br>        <span class="hljs-keyword">return</span> old;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复数的幂">复数的幂</h3><p>对于复数<span class="math inline">\(z\)</span>，<span class="math inline">\(z^0=1\)</span>，其<span class="math inline">\(a\)</span>次正整数幂为<span class="math inline">\(\large z^{a}=\underbrace{z \cdot z \cdots \cdot z}_{\small \mbox{a个z}}\)</span>，负整数幂次对应为相应正整数幂次的倒数，对应幂次函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">complex complex::<span class="hljs-keyword">operator</span>^(<span class="hljs-type">int</span> a) &#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>) &#123;<br>        complex <span class="hljs-built_in">temp</span>(m_real, m_imaginary);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a - <span class="hljs-number">1</span>; i++) &#123;<br>                temp = temp * (*<span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        complex <span class="hljs-built_in">temp</span>(m_real, m_imaginary);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; -a - <span class="hljs-number">1</span>; i++) &#123;<br>                temp = temp * (*<span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) / temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="验证">验证</h2><h3 id="样例测试">样例测试</h3><p>构造不同的复数对象，分为有复平面四个象限的点，"纯实数"，"纯虚数"六种类型，例如对加法、减法、前（后）置加（减）使用手动构造的样例，截图如下（使用Ubuntu的Linux系统编辑和debug代码）：</p><p><img src="https://pic.imgdb.cn/item/623d688327f86abb2a9e35ce.jpg" style="zoom:50%;" /></p><h3 id="自动化测试对拍器">自动化测试（对拍器）</h3><p>上述测试比较机械化，针对复数的乘法和除法而言，使用极坐标进行检验，在极坐标下的乘法和除法计算如下： <span class="math display">\[z_1=r_1e^{i\theta_1},z_2=r_2e^{i\theta_2},z_1\cdot z_2=r_1r_2\cdot e^{i(\theta_1 +\theta_2)},\dfrac{z_1}{z_2}=\dfrac{r_1}{r_2}\cdot e^{i(\theta_1 -\theta_2)}\]</span> 在<span class="math inline">\(&lt;cmath&gt;\)</span>中有可以计算反三角函数以及根式，由于需要遍历每个象限，使用四重for循环逐一整点验证，对应自动化测试代码如下：</p><p><img src="https://pic.imgdb.cn/item/623d689d27f86abb2a9eedfe.jpg" style="zoom:50%;" /></p><p>而对除法运算需要着重验证分母为<span class="math inline">\(0\)</span>的异常处理情况，对应for循环跳过相应情况，提前验证分母为0的情况，对应输出<span class="math inline">\(\mbox{Zero cannot be divisor!}\)</span></p><p>对幂次运算也可使用极坐标进行计算 <span class="math inline">\(z^{a}=(re^{i\theta})^{a}=(r^{a})\cdot e^{ia\theta}\)</span></p><p>同理使用上述方法进行验证的时候，发现<span class="math inline">\((z^{1.2})^{2.4}=z^{2.88}\)</span>次方不能过相应测试，使用linux下gdb测试工具（见：<a href="https://lr-tsinghua11.github.io/2022/03/18/Program/gdb%20to%20debug/" class="uri">https://lr-tsinghua11.github.io/2022/03/18/Program/gdb%20to%20debug/</a>，为本人博客）</p><p>最后发现错误是因为复数的分数幂不是唯一的，例如<span class="math inline">\(\sqrt{i}=\pm \dfrac{1+i}{\sqrt{2}}\)</span>，或者说复变函数<span class="math inline">\(f(z)=z^{\frac{1}{n}},n\geq 2\in \mathbb{Z}\)</span>不是单值的，则修改了测试代码，使幂次都是整数，最后均通过测试，截图如下：</p><p><img src="https://pic.imgdb.cn/item/623d68c527f86abb2aa000b4.jpg" style="zoom:50%;" /></p><h2 id="完备性">完备性</h2><p>加减乘除等简单运算使用手动输入不同象限的测试样例，对乘法、除法以及乘方运算以极坐标的方式形成"对拍器"，同时使用for循环对复平面上各种情况的点都进行了计算和验证，由于浮点数误差，实验结果<span class="math inline">\(\leq 10^{-12}\)</span>范围均通过。</p><p>在边界条件上，除法讨论了分母为<span class="math inline">\(0\)</span>的情况，乘方排除了分数幂次的情况，在类型划分和边界判定上均进行完备的测试。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>面向对象编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象编程作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux to convert files</title>
    <link href="/2022/03/20/Program/Linux%20to%20convert%20files/"/>
    <url>/2022/03/20/Program/Linux%20to%20convert%20files/</url>
    
    <content type="html"><![CDATA[<h1 id="转换文档的-mboxlinux-命令行">转换文档的 <span class="math inline">\(\mbox{Linux}\)</span> 命令行</h1><p>（ wsl 环境下输入下行代码会自动提示安装对应包，由于在命令行中运行，十分简便）</p><p><strong>转换 <span class="math inline">\(\mbox{tex}\)</span> 文件为 <span class="math inline">\(\mbox{md}\)</span> 文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">//需要安装 pandoc<br>pandoc -s OOP_Homework.tex -o OOp_Homework.md<br></code></pre></td></tr></table></figure><p>使用 <span class="math inline">\(\text {linux}\)</span> 环境下<strong>合成多个 <span class="math inline">\(pdf\)</span></strong>（主要用于合成多个爬虫 <span class="math inline">\(pdf\)</span> 文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">//需要安装 pdftk<br>pdftk $(<span class="hljs-built_in">ls</span> *.pdf) <span class="hljs-built_in">cat</span> output 教材.pdf<br></code></pre></td></tr></table></figure><p>将<strong>多张原始图片合成为 <span class="math inline">\(pdf\)</span></strong>（主要用于合成手写作业）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs b">//需要安装 ImageMagick<br>convert *.jpg 作业.pdf<br></code></pre></td></tr></table></figure><p>如果出现安全问题（如下）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">attempt to perform an operation not allowed by the security policy `PDF<span class="hljs-string">&#x27; @ error/constitute.c/IsCoderAuthorized/408.</span><br></code></pre></td></tr></table></figure><p>需要使用权限修改 <span class="math inline">\(policy.xml\)</span> 文件，使用以下命令行进入此文件中，回车后会进入编辑模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/ImageMagick-6/policy.xml<br></code></pre></td></tr></table></figure><p>其中，<span class="math inline">\(nano\)</span> 是字符终端的文本编辑器，可以对文件进行修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">…………//大概在文件结尾部分<br>   <span class="hljs-tag">&lt;<span class="hljs-name">policy</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&quot;coder&quot;</span> <span class="hljs-attr">rights</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;EPS&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">policy</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&quot;coder&quot;</span> <span class="hljs-attr">rights</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;PDF&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">policy</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&quot;coder&quot;</span> <span class="hljs-attr">rights</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;XPS&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>修改 <span class="math inline">\(\mbox{PDF}\)</span> 对应权限 <code>rights="none"</code> $$ <code>rights="read|write"</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">policy</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&quot;coder&quot;</span> <span class="hljs-attr">rights</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;EPS&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">policy</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&quot;coder&quot;</span> <span class="hljs-attr">rights</span>=<span class="hljs-string">&quot;read|write&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;PDF&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">policy</span> <span class="hljs-attr">domain</span>=<span class="hljs-string">&quot;coder&quot;</span> <span class="hljs-attr">rights</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;XPS&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><span class="math inline">\(Ctrl+X\)</span> 退出并输入 <span class="math inline">\(Y\)</span> 保存就可以使用了</p><p>转换 <span class="math inline">\(img\)</span> 为 <span class="math inline">\(latex\)</span> ，开源代码 https://github.com/kingyiusuen/image-to-latex.git</p><p>按照所给的包创建一个新的 <span class="math inline">\(conda\)</span> 环境，便于配置相同环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建新的python3.6环境</span><br>conda create --name latex python=3.6<br><br><span class="hljs-comment"># 激活环境</span><br>conda activate latex<br><br><span class="hljs-comment"># 安装依赖</span><br>pip install -r requirements.txt<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 每10帧每秒</span><br><span class="hljs-attribute">ffmpeg</span> -i input.mp4 -r <span class="hljs-number">10</span> output%<span class="hljs-number">05</span>d.png<br></code></pre></td></tr></table></figure><p>转换为图片，使用 ffmpeg</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 每10帧每秒</span><br><span class="hljs-attribute">ffmpeg</span> -i input.mp4 -r <span class="hljs-number">10</span> output%<span class="hljs-number">05</span>d.png<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Linux 命令行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux 命令行技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thoughts on the fourth week of blog building</title>
    <link href="/2022/03/19/Thoughts%20on%20the%20fourth%20week%20of%20blog%20building/"/>
    <url>/2022/03/19/Thoughts%20on%20the%20fourth%20week%20of%20blog%20building/</url>
    
    <content type="html"><![CDATA[<h2 id="第四周">第四周</h2><ul><li><p>作业速度有些退后，周六上午干完当周作业，还有许多大型 DDL 没有思考和准备，要提上议程了，下周开始还有基物实验，要把时间利用起来</p></li><li><p>中午在图书馆学着学着不想出去吃饭了，昨天也是晚饭也没吃，以后一定要改掉这种不知从何而来的坏习惯</p></li><li><p>下午在倒腾 gdb 相关的操作，纯靠百度自学，还算学了一些东西，感觉比 Visual Studio 自带的那些调试要好用多了，在命令行里面交互代码着实要简洁明快很多，以后一定要熟练运用 Linux 命令行</p></li><li><p>下午准备看 DSA 时结果被随机抽到去做核酸（概率 <span class="math inline">\(\dfrac{1}{3}\)</span>），四点钟从图书馆出来到西体育馆去，测完发现雪化得差不多了，时间不早也不晚，就回寝室，跟 lsq 扯了会儿皮，决定看一下室友都在看的电影《花束般的恋爱》</p></li><li><p>吃完饭在网站上看电影，有些卡顿，但是完整度还行。</p></li><li><p>觉得前后恋人反差感太强烈了，男主女主之前简直是复制粘贴一般的灵魂伴侣，结果后面迫于双方家长，迫于生活压力，男主转向事业型后对女主的陪伴减少了，以至于男主更在乎公司前辈的离世。渐渐同居屋里两个人的生活有了一堵墙，拖了几年后。终于在一场婚礼之后两人下定决心，回到两人最初相识的地方，他们百感交集——在原来的座位又来了一对新情侣，一字一句仿佛诉说着他们的过去……两人分开前还共处了三个月的时光，看似“开心”地分手，实则是希望给对方美好、体面的回忆。</p><p><img src="https://pic.imgdb.cn/item/623600345baa1a80abf381fa.jpg" style="zoom:75%;" /></p></li><li><p>结局虽然有些感伤，但是实际上是两人的“最优解”了。花束的魅力在于双方可以沉浸在对方暂时的芬芳中无法自拔，但现实外力的介入（水分养料、风吹雨打）也许会摧残掉一切。</p></li><li><p>恋爱结婚看似一样，需要长期的滋润下才能维持经久不衰的芳香吧</p></li><li><p>哎一个没有恋爱过的人看了个电影就跟悟了什么一样。。</p></li><li><p>说正事儿，明天上午高代，有时间看会儿 DSA，下午 SRT 组会，晚上七点到九点有酒井科协的技能培训，十点有科协的线下回忆（真是忙碌的周末 QAQ ）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>随想</category>
      
      <category>里程碑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客建成四周随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gdb to debug</title>
    <link href="/2022/03/18/Program/gdb%20to%20debug/"/>
    <url>/2022/03/18/Program/gdb%20to%20debug/</url>
    
    <content type="html"><![CDATA[<p>先使用编译器生成可执行文件，注意使用 <span class="math inline">\(-g\)</span> 包含调试信息（保留变量名以及函数名方便调试）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g main.c -o main<br>g++ -g main.cpp -o main<br></code></pre></td></tr></table></figure><p>然后使用 <span class="math inline">\(gdb\)</span> 工具进入到调试界面中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb main<br>……………………<br>(gbd) 待输入的命令<br></code></pre></td></tr></table></figure><p>监测单变量的变化（比如说 <span class="math inline">\(tot[1]\)</span> ）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) watch tot[1]//输入监测点名称，watch 代表当 tot[1] 变化时报告<br>(gbd) awatch tot[1]//输入监测点名称，awatch 代表读取和写入 tot[1] 时都会报告<br>Hardware watchpoint 1: tot[1]//输出监测标记信息（可以添加多个监测点）<br>(gdb) run//或者简写 r，运行程序<br></code></pre></td></tr></table></figure><p>每次监测变量改变的时候就会停下来报告改变量，停下来后可以打印当前程序的中间值 <code>print tot[0]</code>（或者 <code>p tot[0]</code>）、单步运行程序 <code>tot[1] += 1</code>、继续运行程序 <code>continue</code>（或者 <code>c</code> ）修改对应变量的值 <code>set variable tot[1] = 1</code></p><p>将所有断点以及监视变量删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) delete<br>Delete all breakpoints? (y or n) y<br></code></pre></td></tr></table></figure><p>查看代码操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">list//展示当前<br>list 5//展示以 5 为中心的代码<br>list 1,20//展示第 1 行到第 20 行的代码（最多展示 30 行代码）<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>gdb 调试方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gdb 调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP-homework-4</title>
    <link href="/2022/03/17/Program/OOP%20homework%204/"/>
    <url>/2022/03/17/Program/OOP%20homework%204/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程第四次作业">面向对象编程第四次作业</h1><p><strong>Object-Oriented Programming <span class="math inline">\(\bullet\)</span> Homework <span class="math inline">\(\mathbf{4}\)</span></strong></p><p>本次作业从模型、验证、可视化三方面，讨论日历设计中公元历法的计算以及对应参考文献，采用特殊日期验证日期以及星期的计算，对照一般日历的输出格式可视化当前月历。<br /><strong>关键词:</strong>公元历法;蔡勒公式;日历;可视化</p><h2 id="模型">模型</h2><h3 id="历法">历法</h3><p>当今国际社会广泛使用的历法为格里高利历（<span class="math inline">\(\mbox{Gregorian calendar}\)</span>），也称基督纪年，乃教皇格里十三世于<span class="math inline">\(1582\)</span>年颁行。其规定，在每4年闰年一次的基础上，对除非能被400整除，所有的世纪年（能被100整除）都不设闰日。</p><p>由此格里历的历年平均长度为365.2425日，接近平均回归年的365.242199074日，即每3300年误差一日。（来源:<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%87%8C%E6%9B%86" class="uri">https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%87%8C%E6%9B%86</a>）每月天数设置为下列整型数组，如果是闰年则及时改变：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> monthDay[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span> &#125;;<br></code></pre></td></tr></table></figure><h3 id="蔡勒公式">蔡勒公式</h3><p>对于星期几的计算，通过同余类的数学推导，可得到下列数学公式： <span class="math display">\[w=\left(\left[\frac{c}{4}\right]-2 c+y+\left[\frac{y}{4}\right]+\left[\frac{13 \times(m+1)}{5}\right]+d-1\right) \operatorname{mod} 7\]</span> 可以通过把1月和2月换算至上一年的13月和14月简化计算，写成函数的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calender::getWeek</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> || m == <span class="hljs-number">2</span>)<br>        m += <span class="hljs-number">12</span>, y--;<br>    <span class="hljs-keyword">return</span> (y + y / <span class="hljs-number">4</span> - y / <span class="hljs-number">100</span> + y / <span class="hljs-number">400</span> + <span class="hljs-number">2</span> * m + <span class="hljs-number">3</span> * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">5</span> + d) % <span class="hljs-number">7</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类的定义">类的定义</h3><p>对包含可视化日历的类定义如下（包含注释），其中使用<span class="math inline">\(\mbox{private}\)</span>对数据进行封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">calender</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> monthDay[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span> &#125;;<br>    <span class="hljs-type">char</span> weekName[<span class="hljs-number">7</span>][<span class="hljs-number">10</span>] = &#123; <span class="hljs-string">&quot;Monday&quot;</span>,<span class="hljs-string">&quot;Tuesday&quot;</span>,<span class="hljs-string">&quot;Wednesday&quot;</span>,<span class="hljs-string">&quot;Thursday&quot;</span>,<span class="hljs-string">&quot;Friday&quot;</span>,<span class="hljs-string">&quot;Saturday&quot;</span>,<span class="hljs-string">&quot;Sunday&quot;</span> &#125;;<br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> month;<br>    <span class="hljs-type">int</span> day;<br>    <span class="hljs-type">int</span> week;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">calender</span>();<span class="hljs-comment">//使用C++类&lt;ctime&gt;中time_t类获取当前时间</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> d)</span></span>;<span class="hljs-comment">//修改时间</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//展示当前年月日以及对应星期</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inquiry</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//询问操作方法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isleap</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span>;<span class="hljs-comment">//判断是否为闰年，如果是返回 true</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<span class="hljs-comment">//向前（或向后）移动 n 天</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getWeek</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>;<span class="hljs-comment">//获取星期数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showCurrentCalender</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//打印当前月历</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="验证">验证</h2><h3 id="初始化">初始化</h3><p>构造实例对象，获得相应初始化，验证确实为当前时间（星期四），截图如下</p><p><img src="https://pic.imgdb.cn/item/62333c215baa1a80ab678469.jpg" /></p><h3 id="验证-1">验证</h3><p>初始化时输入1可自由设置时间，如设置2008年8月8日，其修改后显示为星期五，与百度搜索结果相同；初始化输入2再次输入一个数字可以前进或者倒退天数，采用遍历的方式计算移动后的日期，遍历过程中考虑闰年。</p><p>上述对应输入输出如下</p><p><img src="https://pic.imgdb.cn/item/62333bb15baa1a80ab671f7e.jpg" /></p><h2 id="可视化">可视化</h2><p>参考手机上"日历"的制作方法（截图如下），询问时输入<span class="math inline">\(3\)</span>可以查看当前月历（当前为），使用<span class="math inline">\(\mbox{printf()}\)</span>函数中输出颜色的格式对当前日期进行标定，一目了然。</p><p><img src="https://pic.imgdb.cn/item/62333bb15baa1a80ab671fc2.jpg" style="zoom:25%;" /><img src="https://pic.imgdb.cn/item/62333bb15baa1a80ab671f39.jpg" style="zoom:45%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[40;31mhello world\033[5m&quot;</span>);<br><span class="hljs-comment">//上段代码在控制台打印出红色的hello world，对应解释如下：</span><br><span class="hljs-comment">//40是背景颜色, 31是字体颜色</span><br><span class="hljs-comment">//hello world是字符串. \033[5m是控制码</span><br><span class="hljs-comment">//背景颜色: 40--49  字颜色: 30--39</span><br><span class="hljs-comment">//40: 黑 30: 黑       41: 红 31: 红</span><br><span class="hljs-comment">//42: 绿 32: 绿       43: 黄 33: 黄</span><br><span class="hljs-comment">//44: 蓝 34: 蓝       45: 紫 35: 紫</span><br><span class="hljs-comment">//46: 深绿 36: 深绿 47: 白色 37: 白色</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>面向对象编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象编程作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advanced Algebra HW2</title>
    <link href="/2022/03/16/Math/Advanced%20Linear%20Algebra/HW2/"/>
    <url>/2022/03/16/Math/Advanced%20Linear%20Algebra/HW2/</url>
    
    <content type="html"><![CDATA[<h1 id="largetextcolorbluemboxadvanced-algebra-small-mathbbhwmathrm2-_textcolorblue2022.3.16"><span class="math inline">\(\large\textcolor{blue}{\mbox{Advanced Algebra } \small \mathbb{HW}\mathrm{2}}\ \ \ \ \ \ _\textcolor{blue}{2022.3.16}\)</span></h1><h2 id="small-mboxfour-subspaces">1.2.1<span class="math inline">\(\ \small \mbox{four subspaces}\)</span></h2><p>Prove or find counter examples.</p><ol type="1"><li>For four subspaces, if any three of them are linearly independent, then the four subspaces are linearly independent.</li><li>If subspaces <span class="math inline">\(V_{1}, V_{2}\)</span> are linearly independent, and <span class="math inline">\(V_{1}, V_{3}, V_{4}\)</span> are linearly independent, and <span class="math inline">\(V_{2}, V_{3}, V_{4}\)</span> are linearly independent, then all four subspaces are linearly independent.</li><li>If <span class="math inline">\(V_{1}, V_{2}\)</span> are linearly independent, and <span class="math inline">\(V_{3}, V_{4}\)</span> are linearly independent, and <span class="math inline">\(V_{1}+V_{2}, V_{3}+V_{4}\)</span> are linearly independent, then all four subspaces are linearly independent.</li></ol><hr /><p><span class="math inline">\((1)\)</span> Construct four subspaces below. It is obvious that any three of them are linearly independent, but four subspaces together are linearly dependent. （<span class="math inline">\(\dim \mathbb {R}^{3}=3\)</span>） <span class="math display">\[V_1=\{\begin{bmatrix}k\\0\\0\end{bmatrix}\mid k\in \mathbb{R}\},V_2=\{\begin{bmatrix}0\\k\\0\end{bmatrix}\mid k\in \mathbb{R}\},V_3=\{\begin{bmatrix}0\\0\\k\end{bmatrix}\mid k\in \mathbb{R}\},V_4=\{\begin{bmatrix}k\\k\\k\end{bmatrix}\mid k\in \mathbb{R}\}\]</span> <span class="math inline">\((2)\)</span> Construct four subspaces below. We can prove that each of <span class="math inline">\(V_1,V_2\)</span> and <span class="math inline">\(V_1,V_3,V_4\)</span> and <span class="math inline">\(V_2,V_3,V_4\)</span> are linearly independent. <span class="math display">\[V_1=\{\begin{bmatrix}k\\0\\0\end{bmatrix}\mid k\in \mathbb{R}\},V_2=\{\begin{bmatrix}0\\k\\0\end{bmatrix}\mid k\in \mathbb{R}\},V_3=\{\begin{bmatrix}k\\0\\k\end{bmatrix}\mid k\in \mathbb{R}\},V_4=\{\begin{bmatrix}0\\k\\k\end{bmatrix}\mid k\in \mathbb{R}\}\]</span> However, pick some special vectors from these subspaces and its linear combination are zero <span class="math display">\[1\cdot \begin{bmatrix}1\\0\\0\end{bmatrix}+(-1)\cdot \begin{bmatrix}0\\1\\0\end{bmatrix}+(-1)\begin{bmatrix}1\\0\\1\end{bmatrix}+1\cdot \begin{bmatrix}0\\1\\1\end{bmatrix}=\vec{0}\]</span> <span class="math inline">\((3)\)</span> Reduction to absurdity, assume that four real numbers that not all of them is zero <span class="math display">\[a_1\vec{v}_1+a_2\vec{v}_2+a_3\vec{v}_3+a_4\vec{v}_4=0\]</span> We can proof that <span class="math inline">\(a_1\vec{v}_1+a_2\vec{v}_2\neq 0\)</span>, otherwise according to the independence of <span class="math inline">\(V_1,V_2\)</span> and</p><p><span class="math inline">\(V_3,V_4\)</span> <span class="math inline">\(a_1=a_2=0,a_3=a_4=0\)</span>, so <span class="math inline">\(a_1\vec{v}_1+a_2\vec{v}_2\neq 0,a_3\vec{v}_3+a_4\vec{v}_4\neq 0\)</span></p><p>But <span class="math inline">\(a_1\vec{v}_1+a_2\vec{v}_2\in V_1+V_2,a_3\vec{v}_3+a_4\vec{v}_4\in V_3+V_4\)</span>, so linear combination of <span class="math inline">\(a_1\vec{v}_1+a_2\vec{v}_2\)</span> and</p><p><span class="math inline">\(a_3\vec{v}_3+a_4\vec{v}_4\)</span> can add up to <span class="math inline">\(0\)</span>, which is contrary to the independence of <span class="math inline">\(V_1+V_2.V_3+V_4\)</span></p><p>All in all, the four subspaces must be linearly independence</p><h2 id="small-mboxdecomposition-of-transpose">1.2.2<span class="math inline">\(\ \small \mbox{decomposition of transpose}\)</span></h2><p>Let <span class="math inline">\(V\)</span> be the space of <span class="math inline">\(n \times n\)</span> real matrices. Let <span class="math inline">\(T: V \rightarrow V\)</span> be the transpose operation, i.e., <span class="math inline">\(T\)</span> sends <span class="math inline">\(A\)</span> to <span class="math inline">\(A^{\mathrm{T}}\)</span> for each <span class="math inline">\(A \in V\)</span>. Find a non-trivial <span class="math inline">\(T\)</span>-invariant decomposition of <span class="math inline">\(V\)</span>, and find the corresponding block form of <span class="math inline">\(T\)</span>. (Here we use real matrices for your convenience, but the statement is totally fine for complex matrices and conjugate transpose.)</p><hr /><p>Set <span class="math inline">\(S=\{A\mid A=A^{T},A\in M_{n\times n}\}\)</span>, this decomposition is invariant. Because after transposing any symmetric matrix, the matrix remains itself.</p><p>Set <span class="math inline">\(S&#39;=\{A\mid A=-A^{T},A\in M_{n\times n}\}\)</span>, <span class="math inline">\(A=-A^{T}\Longrightarrow A^{T}=-A=-(A^{T})^{T}\)</span>, so any antisymmetric matrix's transpose is antisymmetric.</p><p>So decompose the linear map of <span class="math inline">\(T\)</span> into <span class="math inline">\(S\)</span> and <span class="math inline">\(S&#39;\)</span>, <span class="math inline">\(\dim S=\dfrac{n(n+1)}{2},\dim S&#39;=\dfrac{n(n-1)}{2}\)</span></p><p>Because any <span class="math inline">\(n\times n\)</span> matrix <span class="math inline">\(B=\dfrac{B+B^{T}}{2}+\dfrac{B-B^{T}}{2}\)</span> , so transpose <span class="math inline">\(T\)</span> can be decomposed</p><p>into <span class="math inline">\(S\)</span> and <span class="math inline">\(S&#39;\)</span> two block form.</p><p><span class="math inline">\(A\to \begin{pmatrix}\frac{A+A^{T}}{2}&amp;0\\0&amp;\frac{A-A^{T}}{2}\end{pmatrix}\)</span> so the corresponding block form of <span class="math inline">\(T\)</span> is <span class="math inline">\(\begin{pmatrix}I&amp;0\\0&amp;-I\end{pmatrix}\)</span></p><h2 id="small-mboxultimate-subspaces">1.2.3<span class="math inline">\(\ \small \mbox{ultimate subspaces }\)</span></h2><p>Let <span class="math inline">\(p(x)\)</span> be any polynomial, and define <span class="math inline">\(p(A)\)</span> in the obvious manner. E.g., if <span class="math inline">\(p(x)=\)</span> <span class="math inline">\(x^{2}+2 x+3\)</span>, then <span class="math inline">\(p(A)=A^{2}+2 A+3 I\)</span>. We fix some <span class="math inline">\(n \times n\)</span> matrix <span class="math inline">\(A\)</span>.</p><ol type="1"><li>If <span class="math inline">\(A B=B A\)</span>, show that <span class="math inline">\(\operatorname{Ker}(B), \operatorname{Ran}(B)\)</span> are both <span class="math inline">\(A\)</span>-invariant subspaces.</li><li>Prove that <span class="math inline">\(A p(A)=p(A) A\)</span>.</li><li>Conclude that <span class="math inline">\(N_{\infty}(A-\lambda I), R_{\infty}(A-\lambda I)\)</span> are both <span class="math inline">\(A\)</span>-invariant for any <span class="math inline">\(\lambda \in \mathbb{C}\)</span>.</li></ol><hr /><p><span class="math inline">\((1)\)</span> For any vector <span class="math inline">\(\vec{v}\in \mbox{Ker}(B),B\vec{v}=\vec{0}\)</span>, so <span class="math inline">\(B(A\vec{v})=BA\vec{v}=AB\vec{v}=0,A\vec{v}\in \mbox{Ker}(B)\)</span></p><p>And for any vector <span class="math inline">\(\vec{v}\in \mbox{Ran}(B),B\vec{x}=\vec{v}\)</span>, so <span class="math inline">\(A\vec{v}=A(B\vec{v})=AB\vec{v}=BA\vec{v}=B(A\vec{v})\)</span></p><p><span class="math inline">\(A\vec{v}\in \mbox{Ran}(B)\)</span>. So <span class="math inline">\(\mbox{Ker}(B)\)</span> and <span class="math inline">\(\mbox{Ran}(B)\)</span> are both <span class="math inline">\(A-\)</span>invariant subspaces</p><p><span class="math inline">\((2)\)</span> Similar to polynomial, set <span class="math inline">\(p(A)=\displaystyle \sum_{i=0}^{n}a_{i}A^{n}\)</span>, so calculate <span class="math inline">\(Ap(A)\)</span><br /><span class="math display">\[Ap(A)=A\displaystyle \sum_{i=0}^{n}a_iA^{n}=\sum_{i=0}^{n}a_{i}A^{n+1}=(\sum_{i=0}^{n}a_{i}A^{n})A=p(A)A\]</span> <span class="math inline">\((3)\)</span> Due to limited dimension <span class="math inline">\(n\)</span> of <span class="math inline">\(A\)</span>, <span class="math inline">\(N_{\infty}(A-\lambda I)\)</span> and <span class="math inline">\(R_{\infty}(A-\lambda I)\)</span> are limited combinations</p><p>of <span class="math inline">\(\mbox{Ker}(A-\lambda I)^{k}\)</span> and <span class="math inline">\(\mbox{Ran}(A-\lambda I)^{k}\)</span> . According to the conclusion from <span class="math inline">\(\small (1)\)</span> and $(2) $</p><p><span class="math inline">\(A(A-\lambda I)=(A-\lambda I)A,A(A-\lambda I)^2=(A-\lambda I)^2A,\cdots ,A(A-\lambda I)^k=(A-\lambda I)^kA\)</span></p><p>so <span class="math inline">\(\forall \ k\in Z\)</span> , <span class="math inline">\(\mbox{Ker}(A-\lambda I)^{k}\)</span> and <span class="math inline">\(\mbox{Ran}(A-\lambda I)^{k}\)</span> are all <span class="math inline">\(A-\)</span>invariant. Add them all together</p><p>So, <span class="math inline">\(N_{\infty}(A-\lambda I), R_{\infty}(A-\lambda I)\)</span> are both <span class="math inline">\(A\)</span>-invariant for any <span class="math inline">\(\lambda \in \mathbb{C}\)</span>.</p><h2 id="small-mboxinterchangeability-and-common-eigenvector">1.2.4<span class="math inline">\(\ \small \mbox{interchangeability and common eigenvector}\)</span></h2><p>Note that any linear map must have at least one eigenvector. (You may try to prove this yourself, but it is not part of this homework.) You may use this fact freely in this problem. Fix any two <span class="math inline">\(n \times n\)</span> square matrices <span class="math inline">\(A, B\)</span>. Suppose <span class="math inline">\(A B=B A\)</span>.</p><ol type="1"><li>If <span class="math inline">\(W\)</span> is an A-invariant subspace, show that <span class="math inline">\(A\)</span> has an eigenvector in <span class="math inline">\(W\)</span>.</li><li>Show that <span class="math inline">\(\operatorname{Ker}(A-\lambda I)\)</span> is always <span class="math inline">\(B\)</span>-invariant for all <span class="math inline">\(\lambda \in \mathbb{C}\)</span>. (Hint: Last problem.)</li><li>Show that <span class="math inline">\(A, B\)</span> has a common eigenvector. (Hint: Last two sub-problem.)</li></ol><hr /><p><span class="math inline">\((1)\)</span> Construct a new linear map from <span class="math inline">\(W\)</span> to <span class="math inline">\(W\)</span> <span class="math display">\[W\longmapsto  W: \vec{w}\longmapsto A\vec{w}\]</span> According to the fact that any linear map must have at least one eigenvector, A has an eigenvector in <span class="math inline">\(W\)</span></p><p><span class="math inline">\((2)\)</span> For any vector <span class="math inline">\(\vec{v}\)</span> from <span class="math inline">\(\mbox{Ker}(A-\lambda I)\)</span>, <span class="math inline">\((A-\lambda I)\vec{v}=0,A\vec{v}=\lambda\vec{v}\)</span>, use <span class="math inline">\(AB=BA\)</span></p><p>Because <span class="math inline">\((A-\lambda I)(B\vec{v})=(AB-\lambda B)\vec{v}=(BA-\lambda B)\vec{v}=B(A-\lambda I)\vec{v}=0\)</span></p><p>So <span class="math inline">\(\mbox{Ker}(A-\lambda I)\)</span> is <span class="math inline">\(B-\)</span>invariant for all <span class="math inline">\(\lambda \in \mathbb{C}\)</span></p><p><span class="math inline">\((3)\)</span> According to <span class="math inline">\(\small (1)\)</span> and <span class="math inline">\(\small (2)\)</span>, there exists at least one eigenvector <span class="math inline">\(\vec{v}\)</span> in <span class="math inline">\(\mbox{Ker}(A-\lambda I)\)</span> that</p><p><span class="math inline">\(B\vec{v}=\lambda_{B}\vec{v}\)</span> And the vector <span class="math inline">\(\vec{v}\)</span> also satisfies that <span class="math inline">\(A\vec{v}=\lambda_{A}\vec{v}\)</span></p><p>So if <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are interchangeable, they must have common eigenvector.</p><p>(<del>maybe a boy and a girl can exchange their mind, they may have common future</del>)</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>高等代数选讲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高代作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thoughts on the third week of blog building</title>
    <link href="/2022/03/13/Thoughts%20on%20the%20third%20week%20of%20blog%20building/"/>
    <url>/2022/03/13/Thoughts%20on%20the%20third%20week%20of%20blog%20building/</url>
    
    <content type="html"><![CDATA[<h2 id="第三周">第三周</h2><p>（发现如果平常写日记的话也许比较无聊，毕竟也就是一些学业上的事情，杂七杂八的，之后周末如果有空，就写个小总结）</p><ul><li><p>上周学业速度还算可以，周五的时候基本把作业都扫掉了，主要周末充实透顶</p></li><li><p>周六上午去科协面试结果自己没看清楚是在晚上，吃了闭门羹</p></li><li><p>不过起得早，从团委会转移到图书馆，北京难得下了一场湿润的雨，空气中终于有了清凉的感觉，图书馆前面的桃花沾着贵如油的雨水，散发着属于春天的气息，有点梦幻般的感觉，凉快的风吹着脸也很舒服……</p></li></ul><p><img src="https://pic.imgdb.cn/item/622da5b15baa1a80ab35bbc2.jpg" style="zoom: 25%;" /></p><ul><li>图书馆没坐一会儿然后就到紫荆园恰饭，商量月底情系母校的事情</li><li>中午睡觉比较久，看了会儿高代，着手整理笔记，晚上科协面试比较成功（<del>也许室友在里面有“裙带关系”？</del>）</li><li>周天上午起来费了好大的劲把快速傅里叶分解的离散矩阵式搞明白，还有高代作业以及 <span class="math inline">\(DSA\)</span> （只能往后拖了）</li><li>下午去看班里打篮球比赛，但因为去打疫苗没看到比赛过程，据说比较轻松，打赢了</li><li>顺利进入校科协，之后跟着副部长室友一起搞好科创活动策划，顺便学些东西</li><li>晚上酒井科协有技能培训，<span class="math inline">\(Linux\)</span> 操作 <span class="math inline">\(C++\)</span> ，去瞅瞅</li></ul>]]></content>
    
    
    <categories>
      
      <category>随想</category>
      
      <category>里程碑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客建成三周随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Complex matrix (Chapter 1)</title>
    <link href="/2022/03/12/Math/Advanced%20Linear%20Algebra/Complex%20matrix%EF%BC%88Chapter%201%EF%BC%89/"/>
    <url>/2022/03/12/Math/Advanced%20Linear%20Algebra/Complex%20matrix%EF%BC%88Chapter%201%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="高等代数选讲第一章笔记">高等代数选讲第一章笔记</h1><h2 id="复矩阵的表示">复矩阵的表示</h2><p>令 <span class="math inline">\(A=\begin{bmatrix}0&amp;-1\\1&amp;0\end{bmatrix}\)</span>，有 <span class="math inline">\(A^2=-I\)</span>，形式化地定义 <span class="math inline">\(a+bi=\begin{bmatrix}a&amp;-b\\b&amp;a\end{bmatrix}\)</span></p><p>满足复数运算的一些性质，例如</p><p><span class="math inline">\(\left[\begin{array}{cc}2 &amp; -3 \\3 &amp; 2 \end{array}\right]\left[\begin{array}{cc}4 &amp; -1 \\1 &amp; 4\end{array}\right]=(2 I+3 A)(4 I+A)=5 I+14 A\)</span></p><p>《从一到无穷大》中有趣的例子：在一个小岛上，从任意起点出发，先走 <span class="math inline">\(x\)</span> 长度到固定点楼房 <span class="math inline">\(A\)</span>，然后右转走 <span class="math inline">\(x\)</span> 长度到 <span class="math inline">\(A&#39;\)</span>，再从起点走 <span class="math inline">\(y\)</span> 长度到固定点雕像 <span class="math inline">\(B\)</span>，然后左转走 <span class="math inline">\(y\)</span> 长度到 <span class="math inline">\(B&#39;\)</span>，取 <span class="math inline">\(A&#39;\)</span> 和 <span class="math inline">\(B&#39;\)</span> 中点为宝藏位置，证明该位置与起点无关。 <span class="math display">\[\begin{gathered}\mbox{Prf}:\text 设起点为\ Z,\ 任取原点构建复平面，有方程\begin{cases}A&#39;-A=-i(A-Z)\\B&#39;-B=i(B-Z)\end{cases}\\\therefore P_{treasure}=\dfrac{A&#39;+B&#39;}{2}=\dfrac{1}{2}(A+B)+\dfrac{i}{2}(B-A)=\mbox{Const}\end{gathered}\]</span></p><h2 id="复正交">“复”正交</h2><p>定义复向量 <span class="math inline">\(\vec{v}\)</span> 和 <span class="math inline">\(\vec{w}\)</span> 点乘为 <span class="math inline">\(0\)</span> 时为其每个分量按照 <span class="math inline">\(a+bi=\begin{bmatrix}a&amp;-b\\b&amp;a\end{bmatrix}\)</span> 方式展开得到 <span class="math inline">\(A,B\)</span> 使得 <span class="math display">\[\begin{bmatrix}0&amp;0\\0&amp;0\end{bmatrix}=A^TB=\begin{bmatrix}a_1&#39;&amp; b_1&#39;&amp;a_2&#39;&amp;b_2&#39;&amp;\cdots &amp;a_n&#39;&amp;b_n&#39;\\-b_1&#39;&amp; a_1&#39;&amp;-b_2&#39;&amp;a_2&#39;&amp;\cdots &amp;-b_n&#39;&amp;a_n&#39;\end{bmatrix}\begin{bmatrix}a_1&amp; -b_1\\b_1&amp;a_1\\\vdots&amp;\vdots\\a_n&amp;-b_n\\b_n&amp;a_n\end{bmatrix}\]</span> 对应 <span class="math inline">\(\vec{v}=\begin{bmatrix}a_1&#39;+ib_1&#39;\\a_2&#39;+ib_2&#39;\\\vdots\\a_n&#39;+ib_n&#39;\end{bmatrix}\)</span> , <span class="math inline">\(\vec{w}=\begin{bmatrix}a_1 +ib_1 \\a_2 +ib_2 \\\vdots\\a_n +ib_n \end{bmatrix}\)</span> 可知 <span class="math inline">\(A^{T}B=0\Longleftrightarrow \bar{\boldsymbol v}^{T}\boldsymbol w=0\)</span></p><p>即<strong>复向量正交</strong>等价于其中一个向量的共轭“点乘”另一向量为 <span class="math inline">\(0\)</span>，如 <span class="math inline">\((1,i)^{T}\)</span> 和 <span class="math inline">\((1,-i)^{T}\)</span></p><p>则定义<strong>复向量的点乘</strong> <span class="math inline">\(\langle\vec{v},\vec{w}\rangle =\bar{\vec{v}}^{T}\vec{w}\)</span>，定义共轭转置 <span class="math inline">\(A^*:=\bar{A}^{T}\)</span></p><p>对复矩阵 <span class="math inline">\(A\in \mathbb{C}_{m\times n}\)</span>，有 <span class="math inline">\(\mbox{Ran}(A)\)</span> 和 <span class="math inline">\(\mbox{Ker}(A^*)\)</span> 相互正交（取元素 <span class="math inline">\(\vec{b}_1\)</span> 和 <span class="math inline">\(\vec{b}_2\)</span> 易证）</p><p>定义<strong>厄米矩阵</strong>：<span class="math inline">\(A=A^{*}\)</span>，如 <span class="math inline">\(A=\left(\begin{array}{cc} 1 &amp; 2+\mathrm{i} \\ 2-\mathrm{i} &amp; 3 \end{array}\right)\)</span>，特征值为实数，特征向量正交</p><p>特征值为实： <span class="math inline">\(\bar{\vec{x}}^{T}A\vec{x}=\lambda\|\vec{x}\|^{2}=(A^T\bar{\vec{x}})^{T}\vec{x}=(\bar{A}\bar{\vec{x}})^{T}\vec{x}=(\bar{\lambda}\bar{\vec{x}})^{T}\vec{x}=\bar{\lambda}\|\vec{x}\|^{2}\Longrightarrow \lambda\in R\)</span></p><p>特征向量正交：令 <span class="math inline">\(A\vec{x}_1=\lambda_1\vec{x}_1,A\vec{x}_2=\lambda_2\vec{x}_2,\lambda_1\neq \lambda_2\)</span> <span class="math display">\[\bar{\vec{x}}_2^TA\vec{x}_1=\lambda_1\langle \vec{x}_2,\vec{x}_1\rangle=(A^{T}\bar{\vec{x}}_2)^{T}\vec{x}_1=(\bar{A}\bar{\vec{x}}_2)^{T}\vec{x}_1=\lambda_2\langle \vec{x}_2,\vec{x}_1\rangle\Longrightarrow \langle \vec{x}_2,\vec{x}_1\rangle=0\]</span> 定义<strong>反厄米矩阵</strong>：<span class="math inline">\(A=-A^*\)</span>，如 <span class="math inline">\(A=\left(\begin{array}{cc} 0 &amp; 2+\mathrm{i} \\ -2+\mathrm{i} &amp; 0 \end{array}\right)\)</span>，特征值为纯虚数，特征向量正交</p><p>（证明同上，前者加入负号使得 <span class="math inline">\(\lambda=-\bar\lambda\)</span>，后者两次负号后依然为正，<span class="math inline">\(\langle \vec{x}_2,\vec{x}_1\rangle=0\)</span>）</p><p>定义<strong>幺正矩阵</strong>（<strong>酉矩阵</strong>）：<span class="math inline">\(A^{-1}=A^{*}\)</span> ，仿照上述方法有 <span class="math inline">\(\lambda\|\vec{x}\|^2=\dfrac{1}{\bar\lambda}\|\vec{x}\|^2\)</span> ，则 <span class="math inline">\(|\lambda|=1\)</span>。</p><p>特征向量正交，幺正矩阵对应不变内积的变换（称为<strong>酉变换</strong>） <span class="math inline">\(\langle \vec{x}_2,\vec{x}_1\rangle=\langle A\vec{x}_2,A\vec{x}_1\rangle\)</span></p><p>定义<strong>正规矩阵</strong>：<span class="math inline">\(AA^*=A^*A\)</span>，将上述矩阵以及对角、实对称、实反对称、正交等矩阵统一其相同的性质 <span class="math inline">\(AA^*=A^*A\)</span></p><h2 id="傅里叶矩阵">傅里叶矩阵</h2><p>单位根 <span class="math inline">\(\omega_n=e^{i\frac{2\pi}{n}}\)</span>，定义傅里叶矩阵 <span class="math inline">\(F_{n}=\begin{pmatrix}1&amp;1&amp;\cdots&amp;1\\1&amp;\omega&amp;\cdots&amp;\omega^{n-1}\\1&amp;\omega^2&amp;\cdots&amp;\omega^{2(n-1)}\\\vdots&amp;\vdots&amp;&amp;\vdots\\1&amp;\omega^{n-1}&amp;\cdots&amp;\omega^{(n-1)^2}\end{pmatrix}\)</span>，为对称阵</p><p>由于 <span class="math inline">\(F_n\)</span> 对角非实，其不是厄米矩阵，该矩阵总满足 <span class="math inline">\(\overline{F_n}F_n=nI\)</span>，对应行列求和有 <span class="math display">\[\displaystyle \sum_{k=1}^{n}\overline{\omega^{ki}}\omega^{kj}=\sum_{k=1}^{n}\omega^{2\pi+k(j-i)}=\begin{cases}\displaystyle\sum_{i=0}^{n}1=n&amp;i=j\\\dfrac{\omega^{j-i}(1-\omega^{n(j-i)} )}{1-\omega^{j-i}}=0&amp;i\neq j\end{cases}\]</span> 令 <span class="math inline">\(F&#39;=\dfrac{F_n}{\sqrt{n}}\)</span> 则有 <span class="math inline">\(\overline{F&#39;}F&#39;=\dfrac{\overline{F}_nF_n}{n}=I\)</span>，<span class="math inline">\(F&#39;=\dfrac{F_n}{\sqrt{n}}\)</span> 为幺正矩阵 <span class="math inline">\((F&#39;)^{-1}=(F&#39;)^{*}\)</span></p><p>对 <span class="math inline">\(f(x)=C_0+C_1e^{ix}+C_2e^{i2x}+\cdots+C_{n-1}e^{i(n-1)x}\)</span>，给定 <span class="math inline">\(f(0),f(\dfrac{2\pi}{n}),\cdots,f(\dfrac{2\pi(n-1)}{n})\)</span></p><p>对应方程为 <span class="math inline">\(F_{n}\begin{pmatrix}C_0\\C_1\\\vdots\\C_{n-1}\end{pmatrix}=\begin{pmatrix}f(0)\\f(\frac{2\pi}{n})\\\vdots\\f(\frac{2\pi(n-1)}{n})\end{pmatrix}\)</span>，得 <span class="math inline">\(\begin{pmatrix}C_0\\C_1\\\vdots\\C_{n-1}\end{pmatrix}=\dfrac{\overline{F_{n}}}{n}\begin{pmatrix}f(0)\\f(\frac{2\pi}{n})\\\vdots\\f(\frac{2\pi(n-1)}{n})\end{pmatrix}\)</span></p><p>快速傅里叶变换（FFT，二十世纪前十算法之一）对傅里叶矩阵 <span class="math inline">\(F_{2n}\)</span> 进行分解（<span class="math inline">\(\omega=e^{i\frac{2\pi}{2n}}\)</span>） <span class="math display">\[PF_{2n}=\begin{bmatrix}I_n&amp; D_n\\I_n&amp;-D_n\end{bmatrix}\begin{bmatrix}F_n&amp;0\\0&amp;F_n\end{bmatrix}\]</span> 其中 <span class="math inline">\(P\)</span> 将所有奇数列放在左侧，所有偶数列放在右侧，<span class="math inline">\(D_n=\mbox{diag}(1,\omega,\cdots,\omega^{n-1})\)</span></p><p>证明：针对 <span class="math inline">\(A=\begin{bmatrix}I_n&amp; D_n\\I_n&amp;-D_n\end{bmatrix}\begin{bmatrix}F_n&amp;0\\0&amp;F_n\end{bmatrix}\)</span> 的第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列（下标从 <span class="math inline">\(0\)</span> 开始）分类讨论有 <span class="math display">\[A(i,j)=\begin{cases}F_n(i,j)=\omega_{n}^{ij}=\omega_{2n}^{2ij}&amp;0\leq i\leq n-1,0\leq j\leq n-1\\F_{n}(i-n,j)=\omega_{n}^{(i-n)j}=\omega_{2n}^{2(i-n)j}&amp; n\leq i\leq 2n-1,0\leq j\leq n-1\\F_{n}(i,j-n)\cdot \omega_{2n}^{i}=\omega_{n}^{i(j-n)}\cdot \omega_{2n}^{i}=\omega_{2n}^{(2j+1)i}&amp; 0\leq i\leq n-1,n\leq j\leq 2n-1\\F_{n}(i-n,j-n)\cdot \omega_{2n}^{i-n}=\omega_{2n}^{(2j+1)(i-n)}&amp; n\leq i\leq 2n-1,0\leq j\leq n-1\end{cases}\]</span> 从而固定 <span class="math inline">\(i\)</span> ，可知将 <span class="math inline">\((0,1,\cdots,2n-1,2n)\)</span> 所有奇数列放在左侧所有偶数列放在右侧后形成 <span class="math display">\[(0,2,\cdots,2n),(1,3,\cdots,2n-1)\]</span> 满足上述 <span class="math inline">\(A(i,j)\)</span> 的要求</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>高等代数选讲</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高等代数选讲笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calculus_A2_notes_Chapter_three（WXF）</title>
    <link href="/2022/03/11/Math/Calculus/Calculus%20A2%20notes%EF%BC%88Chapter%20four%EF%BC%89/"/>
    <url>/2022/03/11/Math/Calculus/Calculus%20A2%20notes%EF%BC%88Chapter%20four%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第四讲-高阶导数与-taylor-公式">第四讲 高阶导数与 Taylor 公式</h2><h4 id="高阶微分">1.高阶微分</h4><p>称 <span class="math inline">\(E \subseteq \mathbb{R}^{m}\)</span> 是一个<strong>开集</strong>，如果任何 <span class="math inline">\(x \in E\)</span> 都是 <span class="math inline">\(E\)</span> 的内点。 设 <span class="math inline">\(f: E \rightarrow \mathbb{R}^{n}\)</span> 在任何 <span class="math inline">\(x \in E\)</span> 处都可微。则 <span class="math display">\[\mathrm{D}^{1} f: x \mapsto \operatorname{D} f(x), \quad E \rightarrow \mathcal{L}\left(\mathbb{R}^{m} ; \mathbb{R}^{n}\right)\]</span> 定义了 <span class="math inline">\(E\)</span> 上一个映射, 其中 <span class="math inline">\(\mathcal{L}\left(\mathbb{R}^{m} ; \mathbb{R}^{n}\right)\)</span> 是由从 <span class="math inline">\(\mathbb{R}^{m}\)</span> 到 <span class="math inline">\(\mathbb{R}^{n}\)</span> 上所有线性映射组成的一个 <span class="math inline">\(m n\)</span> 维向量空间。</p><p>如果 <span class="math inline">\(\mathrm{D}^{1} f\)</span> 连续, 则称 <span class="math inline">\(f\)</span> 是 <strong><span class="math inline">\(\mathscr{C}^{1}\)</span></strong> 的。 如果 <span class="math inline">\(\mathrm{D}^{1} f\)</span> 可微, 则称 <span class="math inline">\(f\)</span> 是<strong>二阶可微</strong>的, 称 <span class="math inline">\(\mathrm{DD}^{1} f(\mathbf{x})\)</span> 为 <span class="math inline">\(f\)</span> 的<strong>二阶导数</strong>, 记 <span class="math display">\[\mathrm{D}^{2}(\mathbf{x})=\mathrm{DD}^{1} f(\mathbf{x}) .\]</span> 如果 <span class="math inline">\(\mathrm{D}^{2} f: E \rightarrow \mathcal{L}\left(\mathbb{R}^{m} ; \mathcal{L}\left(\mathbb{R}^{m} ; \mathbb{R}^{n}\right)\right)\)</span> 连续, 则称 <span class="math inline">\(f\)</span> 是 <strong><span class="math inline">\(\mathscr{C}^{2}\)</span> </strong>的。</p><p>归纳地, 可以定义 <span class="math inline">\(f\)</span> 的 <span class="math inline">\(k\)</span> 阶导数 <span class="math display">\[\mathrm{D}^{k} f(\mathbf{x})=\mathrm{DD}^{k-1} f(\mathbf{x}) \in \mathcal{L}\left(\mathbb{R}^{m} ; \ldots ; \mathcal{L}\left(\mathbb{R}^{m} ; \mathbb{R}^{n}\right)\right.\]</span> 如果 <span class="math inline">\(\mathrm{D}^{k} f\)</span> 是连续的, 则称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathscr{C}^{k}\)</span> 的。 如果对任意 <span class="math inline">\(k\)</span> , <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathscr{C}^{k}\)</span> 的, 则称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathscr{C}^{\infty}\)</span> 的。并有 <span class="math display">\[\mathrm{D}^{k} f(\mathbf{x})\left(\mathbf{v}_{1}, \ldots, \mathbf{v}_{k}\right)=\mathrm{D}\left(\mathrm{D}^{k-1} f(\mathbf{x})\left(\mathbf{v}_{1}, \ldots, \mathbf{v}_{k-1}\right)\right)\left(\mathbf{v}_{k}\right)\]</span> 例：<strong>矩阵求逆</strong> $ $ 函数的高阶导数</p><p>上节课我们知道求逆映射是可微的，且 <span class="math inline">\(\operatorname{D \ inv}\left(A_{0}\right)(B)=-A_{0}^{-1} B A_{0}^{-1}\)</span> 。有 <span class="math display">\[\begin{aligned}&amp; \operatorname{D inv}\left(A+B_{2}\right)\left(B_{1}\right) \\=&amp;-\left(A+B_{2}\right)^{-1} B_{1}\left(A+B_{2}\right)^{-1} \\=&amp;-\left[A^{-1}-A^{-1} B_{2} A^{-1}+o\left(B_{2}\right)\right] B_{1}\left[A^{-1}-A^{-1} B_{2} A^{-1}+o\left(B_{2}\right)\right] \\=&amp; \operatorname{D inv}(A)\left(B_{1}\right)+A^{-1} B_{2} A^{-1} B_{1} A^{-1}+A^{-1} B_{1} A^{-1} B_{2} A^{-1}+o\left(B_{2}\right)\end{aligned}\]</span> 当 <span class="math inline">\(B_2\to0\)</span> 。所以 <span class="math inline">\(\mathrm{D}^{2} \operatorname{inv}(A)\left(B_{1}, B_{2}\right)=A^{-1} B_{2} A^{-1} B_{1} A^{-1}+A^{-1} B_{1} A^{-1} B_{2} A^{-1}\)</span> 。 归纳可知，<span class="math inline">\(\mathrm{inv}\)</span> 是任意阶可微的，即： <span class="math display">\[\begin{aligned}&amp;\mathrm{D}^{k} \operatorname{inv}(A)\left(B_{1}, B_{2}, \ldots, B_{k}\right) \\&amp;=(-1)^{k} \sum_{i_{1}, i_{2}, \ldots, i_{k} \text { 是 } 1,2, \ldots, k \text { 的任意排列 }} A^{-1} B_{i_{1}} A^{-1} B_{i_{2}} \cdots A^{-1} B_{i_{k}} A^{-1}\end{aligned}\]</span> 定理：若 <span class="math inline">\(g \circ f\)</span> 中 <span class="math inline">\(f, g\)</span> 都是 <span class="math inline">\(\mathscr{C}^{r}\)</span> 的, 则 <span class="math inline">\(g \circ f\)</span> 也是 <span class="math inline">\(\mathscr{C}^{r}\)</span> 的。</p><p>证明：数学归纳法和链锁法则。</p><p>定理：（<strong>逆映射</strong>的高阶连续性）若 <span class="math inline">\(\mathscr{C}^{r}\)</span> 映射 <span class="math inline">\(g\)</span> 有可微的逆映射 <span class="math inline">\(g^{-1}\)</span>, 则 <span class="math inline">\(g^{-1}\)</span> 也是 <span class="math inline">\(\mathscr{C}^{r}\)</span> 的。</p><p>证明：由链索法则 <span class="math inline">\(I=\mathrm{D}\left(g \circ g^{-1}\right)(\mathbf{y})=\mathrm{D} g\left(g^{-1}(\mathbf{y})\right) \circ \mathrm{Dg}^{-1}(\mathbf{y})\)</span> 。 所以 <span class="math display">\[\operatorname{D} g^{-1}(\mathbf{y})=\left(\operatorname{D}g\left(g^{-1}(\mathbf{y})\right)\right)^{-1}=\operatorname{inv}\left(\operatorname{D}g\left(g^{-1}(\mathbf{y})\right)\right),\]</span> 高阶可微性由 <span class="math inline">\(\mathrm{inv}\)</span> 的高阶可微性和数学归纳法得到。</p><h4 id="高阶偏导数">2.高阶偏导数</h4><p>以二阶微分为例， <span class="math display">\[\begin{aligned}\mathrm{d}^{2} f\left(x^{1}, \ldots, x^{m}\right) &amp;=\sum_{j=1}^{m} \partial_{j}\left(\sum_{i=1}^{m} \partial_{i} f\left(x^{1}, \ldots, x^{m}\right) \mathrm{d} x^{i}\right) \mathrm{d} x^{j} \\&amp;=\sum_{1 \leq i, j \leq m} \partial_{j} \partial_{i} f\left(x^{1}, \ldots, x^{m}\right) \mathrm{d} x^{i} \otimes \mathrm{d} x^{j} \\&amp;=\sum_{1 \leq i, j \leq m} \partial_{j, i}^{2} f\left(x^{1}, \ldots, x^{m}\right) \mathrm{d} x^{i} \otimes \mathrm{d} x^{j}\end{aligned}\]</span> 上式中 <span class="math inline">\(\mathrm{d} x^{i} \otimes \mathrm{d} x^{j}\)</span> 是一个双线性型符号，满足 <span class="math display">\[\mathrm{d} x^{i} \otimes \mathrm{d} x^{j}(\mathbf{v}, \mathbf{w})=\mathrm{d} x^{i}(\mathbf{v}) \mathrm{d} x^{j}(\mathbf{w})\]</span> 即 <span class="math display">\[\mathrm{d} x^{i} \otimes \mathrm{d} x^{j}\left(\sum_{p=1}^{m} \xi^{p} \mathbf{e}_{p}, \sum_{q=1}^{m} \eta^{q} \mathbf{e}_{q}\right)=\xi^{i} \eta^{j}\]</span> 一般地， <span class="math display">\[\mathrm{d}^{k} f(\mathbf{x})=\sum_{1 \leq i_{1}, \ldots, i_{k} \leq m} \partial_{i_{k}, \ldots, i_{1}}^{k} f(\mathbf{x}) \mathrm{d} x^{i_{1}} \otimes \cdots \otimes \mathrm{d} x^{i_{k}}\]</span> 于是, <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathscr{C}^{k}\)</span> 的当且仅当 <span class="math inline">\(f\)</span> 的所有 <span class="math inline">\(k\)</span> 阶偏导数都是连续函数。 一般而言, 高阶偏导数的求导顺序不能随意交换，但是<font color="red">当 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathscr{C}^{k}\)</span> 函数时，其直到 <span class="math inline">\(k\)</span> 阶的高阶偏导数的值与求导顺序无关</font>。</p><p>符号与写法： <span class="math display">\[\begin{array}{ccc}\hline \text { 符号 } &amp; \text { 传统符号 } &amp; \text { 含义 } \\\hline \partial_{i} f &amp; \frac{\partial f}{\partial x^{i}} &amp; \text { 一阶偏导数 } \\\partial_{\mathbf{v}} f=\partial_{\left(v^{1}, \ldots, v^{m}\right)} f &amp; \frac{\partial f}{\partial \mathbf{v}} &amp; \text { 沿向量 } \mathbf{v} \text { 的导数 } \\\partial_{i_{k}, \ldots, i_{2}, i_{1}}^{k} f &amp; \frac{\partial^{k} f}{\partial x^{i_{k}} \cdots \partial x^{i_{2}} \partial x^{i_{1}}} &amp; k \text { 阶偏导数 } \\\partial_{\left[\alpha_{1}, \ldots, \alpha_{m}\right]}^{|\alpha|} f &amp; \frac{\partial^{\alpha_{1}+\cdots+\alpha_{m}} f}{\partial\left(x^{1}\right)^{\alpha_{1}} \cdots \partial\left(x^{m}\right)^{\alpha_{m}}} &amp; |\alpha| \text { 阶偏导数 }\\ \hline\end{array}\]</span> <span class="math inline">\(\alpha=\left[\alpha_{1}, \ldots, \alpha_{m}\right]\)</span> 是一组非负整数， $||=<em>{1}++</em>{m} $ 。</p><p>当同时出现不同坐标系时, 用 <span class="math inline">\(\partial_{x^{i}} f\)</span> 代替 <span class="math inline">\(\partial_{i} f ;\)</span> 用 <span class="math inline">\(\partial_{x^{i_{k}}, \ldots, x^{i_{2}, x^{i_{1}}} f}^{k} f\)</span> 代替 <span class="math inline">\(\partial_{i_{k}, \ldots, i_{2}, i_{1}}^{k} f\)</span>; 用 <span class="math inline">\(\partial_{\left(x^{1}\right)^{\alpha_{1}}, \ldots,\left(x^{m}\right)^{\alpha_{m}}}^{|\alpha|} f\)</span> 代替 <span class="math inline">\(\partial_{\left[\alpha_{1}, \ldots, \alpha_{m}\right]}^{|\alpha|} f\)</span> 。</p><h5 id="例laplace-方程">例：Laplace 方程</h5><p><strong>Laplace 方程</strong> <span class="math inline">\(\Delta f=0\)</span> 。Laplace 算子 <span class="math inline">\(\Delta=\nabla \cdot \nabla, \nabla\)</span> 是梯度算子。求 Laplace 方程在平面直角坐标系 <span class="math inline">\((x, y)\)</span> 和极坐标系 <span class="math inline">\((r, \theta)\)</span> 下的形式。</p><p>直角坐标系下，<span class="math inline">\(\nabla=\mathbf{e}_{1} \partial_{x}+\mathbf{e}_{2} \partial_{y}\)</span>，因 <span class="math inline">\(\mathbf{e}_{i} \cdot \mathbf{e}_{j}=\left\{\begin{array}{ll}1, &amp; i=j \\ 0, &amp; i \neq j\end{array} \quad \partial_{x} \mathbf{e}_{i}=\partial_{y} \mathbf{e}_{i}=0\right.\)</span> ，有 <span class="math display">\[\begin{aligned}\nabla^{2} &amp;=\left(\mathbf{e}_{1} \partial_{x}+\mathbf{e}_{2} \partial_{y}\right) \cdot\left(\mathbf{e}_{1} \partial_{x}+\mathbf{e}_{2} \partial_{y}\right) \\&amp;=\mathbf{e}_{1} \cdot \mathbf{e}_{1} \partial_{x, x}^{2}+\mathbf{e}_{2} \cdot \mathbf{e}_{2} \partial_{y, y}^{2}=\partial_{x, x}^{2}+\partial_{y, y}^{2}\end{aligned}\]</span> 平面极坐标下，有 <span class="math inline">\(\nabla=\mathbf{e}_{r} \partial_{r}+\dfrac{\mathbf{e}_{\theta}}{r^{2}} \partial_{\theta}\)</span> ，且基向量不再恒定不变： <span class="math display">\[\partial_{r} \mathbf{e}_{r}=0, \quad \partial_{\theta} \mathbf{e}_{r}=\partial_{r} \mathbf{e}_{\theta}=\frac{\mathbf{e}_{\theta}}{r}, \quad \partial_{\theta} \mathbf{e}_{\theta}=-r \mathbf{e}_{r}\]</span> 因此 <span class="math display">\[\begin{aligned}\nabla^{2} f &amp;=\left(\mathbf{e}_{r} \partial_{r}+\frac{\mathbf{e}_{\theta}}{r^{2}} \partial_{\theta}\right) \cdot\left(\mathbf{e}_{r} \partial_{r}+\frac{\mathbf{e}_{\theta}}{r^{2}} \partial_{\theta}\right) f \\&amp;=\partial_{r, r}^{2} f \mathbf{e}_{r} \cdot \mathbf{e}_{r}+\frac{1}{r^{2}} \partial_{r} f \mathbf{e}_{\theta} \cdot \partial_{\theta} \mathbf{e}_{r}+\frac{1}{r^{4}} \partial_{\theta, \theta}^{2} f \mathbf{e}_{\theta} \cdot \mathbf{e}_{\theta} \\&amp;=\partial_{r, r}^{2} f+\frac{1}{r} \partial_{r} f+\frac{1}{r^{2}} \partial_{\theta, \theta}^{2} f\end{aligned}\]</span></p><h5 id="课后练习"><strong>课后练习</strong></h5><p>问题：（分离变量法）求 Laplace 方程形如 <span class="math inline">\(u(r, \theta)=U(r) V(\theta)\)</span> 形式的解。</p><p>代入公式有 <span class="math inline">\(\Delta u=V(\theta)(\partial^2_{r,r}U(r)+\dfrac{1}{r}\partial_r{U(r)})+\dfrac{U(r)}{r^2}\partial_{\theta,\theta}{V(\theta)}=0\)</span> ，或 <span class="math display">\[\frac{1}{U(r)}(r^2\partial^2_{r,r}U(r)+r\partial_r{U(r)})+\frac{1}{V(\theta)}\partial_{\theta,\theta}{V(\theta)}=0\]</span> 由于前两项与后一项没有关联，可以设 <span class="math inline">\(r^2\partial^2_{r,r}U(r)+r\partial_r{U(r)}=CU(r)\)</span>（这是一个欧拉方程），<span class="math inline">\(\partial_{\theta,\theta}{V(\theta)}=-CV(\theta)\)</span> ，解得 <span class="math display">\[\begin{gathered}\begin{gathered}U(r)=k_{1} \cosh (\sqrt{C} \ln r)+ k_{2} \sinh (\sqrt{C} \ln r),\\V(\theta)=k_3\cos(\sqrt{C}\theta)+k_4\sin(\sqrt{C}\theta);\end{gathered}\quad \text{when \ }C&gt;0\\\begin{gathered}U(r)=k_{1} \cos (\sqrt{C} \ln r)+ k_{2} \sin (\sqrt{C} \ln r),\\V(\theta)=k_3\cosh(\sqrt{C}\theta)+k_4\sinh(\sqrt{C}\theta);\end{gathered}\quad \text{when \ }C&lt;0\\U(r)=k_1\ln r+k_2 \ , \ V(\theta)=k_3\theta \ ;\quad \text{when \ }C=0\end{gathered}\]</span></p><p>因此， <span class="math display">\[u(r,\theta)=\left\{\begin{array}{l}(C_1r^C+C_2r^{-C})\cos(C\theta+C_3)\\\cos(C\ln r+C_1)(C_2\mathrm{e}^{C\theta}+C_3\mathrm{e}^{-C\theta})\\C_1(\ln r+C_2)\theta\end{array}\right.\]</span> 问题：试写出在三维柱坐标、球坐标以及任意维数空间中直角坐标系和一般坐标系下Laplace 算子的坐标形式。</p><p>由上节课的结论可知，球坐标下的梯度算子： <span class="math display">\[\nabla =\mathbf{e}_{r}\partial_{r}  +\frac{\mathbf{e}_{\theta}}{r^{2}} \partial_{\theta}  +\frac{\mathbf{e}_\varphi}{r^{2} \sin ^{2} \varphi} \partial_\varphi\]</span> 且有 <span class="math display">\[\begin{gathered}\partial_r\mathbf{e}_r=0,\partial_r\mathbf{e}_\theta=\frac{\mathbf{e}_\theta}{r},\partial_r\mathbf{e}_\varphi=\frac{\mathbf{e}_\varphi}{r}\\ \partial_\theta\mathbf{e}_r=\frac{\mathbf{e}_\theta}{r},\partial_\theta\mathbf{e}_\theta=-r\mathbf{e}_r,\partial_\theta\mathbf{e}_\varphi=\cot\theta\mathbf{e}_\varphi\\ \partial_\varphi\mathbf{e}_r=\frac{\mathbf{e}_\varphi}{r},\partial_\varphi\mathbf{e}_\theta=\cot\theta\mathbf{e}_\varphi,\partial_\varphi\mathbf{e}_\varphi=\begin{bmatrix}-r\sin\theta\cos\varphi\\-r\sin\theta\sin\varphi\\0\end{bmatrix}\end{gathered}\]</span> 故对球坐标系 <span class="math display">\[\begin{aligned}\Delta&amp;=\nabla\cdot\nabla\\&amp;=(\mathbf{e}_{r}\partial_{r}  +\frac{\mathbf{e}_{\theta}}{r^{2}} \partial_{\theta}  +\frac{\mathbf{e}_\varphi}{r^{2} \sin ^{2} \varphi} \partial_\varphi)\cdot(\mathbf{e}_{r}\partial_{r}  +\frac{\mathbf{e}_{\theta}}{r^{2}} \partial_{\theta}  +\frac{\mathbf{e}_\varphi}{r^{2} \sin ^{2} \varphi} \partial_\varphi)\\&amp;=\partial_{r,r}+0+0+\frac{1}{r}\partial_r+\frac{1}{r^2}\partial_{\theta,\theta}+0+\frac{1}{r}\partial_r+\frac{\cot\theta}{r^2}\partial_\theta+\frac{1}{r^2\sin^2\varphi}\partial_{\varphi,\varphi}\\&amp;=\partial_{r,r}+\frac{2}{r}\partial_r+\frac{1}{r^2}\partial_{\theta,\theta}+\frac{\cot\theta}{r^2}\partial_\theta+\frac{1}{r^2\sin^2\varphi}\partial_{\varphi,\varphi}\end{aligned}\]</span></p><h4 id="taylor-展开">3. Taylor 展开</h4><p>设 <span class="math inline">\(f: E \rightarrow \mathbb{R}\)</span> 是一个 <span class="math inline">\(\mathscr{C}^{k}\)</span> 函数。则 <span class="math inline">\(g(t)=f\left(\mathbf{x}_{0}+t \mathbf{v}\right)\)</span> 也是 <span class="math inline">\(\mathscr{C}^{k}\)</span> 函数, 从而 <span class="math display">\[g(t)=g(0)+g^{\prime}(0) t+\cdots+\frac{g^{(k)}(0)}{k !} t^{k}+o\left(t^{k}\right), \quad t \rightarrow 0\]</span> 由链索法则和数学归纳法可得 <span class="math display">\[\begin{aligned}g^{(k)}(t) &amp;=d^{k} f\left(\mathbf{x}_{0}+t \mathbf{v}\right)(\underbrace{\mathbf{v}, \ldots, \mathbf{v})}_{k \text { 个 }}\\&amp;=\sum_{1 \leq i_{1}, \ldots, i_{k} \leq m} \partial_{i_{k}, \ldots, i_{1}}^{k} f\left(\mathbf{x}_{0}+t \mathbf{v}\right) v^{i_{1}} \cdots v^{i_{k}}\end{aligned}\]</span> 所以 <span class="math display">\[f\left(\mathbf{x}_{0}+t \mathbf{v}\right)=f\left(\mathbf{x}_{0}\right)+\sum_{r=1}^{k} \frac{t^{r}}{r !} \sum_{1 \leq i_{1}, \ldots, i_{r} \leq m} \partial_{i_{r}, \ldots, i_{1}}^{r} f\left(\mathbf{x}_{0}\right) v^{i_{1}} \cdots v^{i_{r}}+o\left(t^{k}\right)\]</span> 对 <span class="math inline">\(\mathrm{x}\)</span>, 取 <span class="math inline">\(v=\frac{\mathrm{x}-\mathrm{x}_{0}}{\left\|\mathrm{x}-\mathrm{x}_{0}\right\|}, t=\left\|\mathrm{x}-\mathrm{x}_{0}\right\|\)</span>, 则 <span class="math display">\[\begin{aligned}f(\mathbf{x})=&amp; f\left(\mathbf{x}_{0}\right) \\&amp;+\sum_{r=1}^{k} \frac{1}{r !} \sum_{1 \leq i_{1}, \ldots, i_{r} \leq m} \partial_{i_{r}, \ldots, i_{1}}^{r} f\left(\mathbf{x}_{0}\right)\left(x^{i_{1}}-x_{0}^{i_{1}}\right) \cdots\left(x^{i_{r}}-x_{0}^{i_{r}}\right) \\&amp;+o\left(\left\|\mathbf{x}-\mathbf{x}_{0}\right\|^{k}\right), \quad \mathbf{x} \rightarrow \mathbf{x}_{0}\end{aligned}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>多元微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多元微积分笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP-homework-3</title>
    <link href="/2022/03/10/Program/OOP%20homework%203/"/>
    <url>/2022/03/10/Program/OOP%20homework%203/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程第三次作业">面向对象编程第三次作业</h1><p><strong>Object-Oriented Programming <span class="math inline">\(\bullet\)</span> Homework <span class="math inline">\(\mathbf{3}\)</span></strong></p><p>本次作业报告从模型、验证、分析三个方面，使用<span class="math inline">\(\mbox{Visual Studio 2022}\)</span>编写具有面向对象特性的<span class="math inline">\(\mbox{C++}\)</span>程序，使用继承和组合两种<span class="math inline">\(\mbox{C++}\)</span>面向对象特性，编写了七个类。</p><p>使用单元测试，测算各种图形类中计算周长和面积公式是否正确，使用开源轻量级代码<span class="math inline">\(\mbox{&lt;doctest.h&gt;}\)</span>，采用循环和随机数两种方法判定计算公式，结果在<span class="math inline">\(&lt;10^{-10}\)</span>的误差范围内通过。<br /><strong>关键词</strong>: 继承;组合;图形计算;单元测试</p><h2 id="模型">模型</h2><h3 id="多边形计算">多边形计算</h3><p>针对一般情况（下图为<span class="math inline">\(n=5\)</span>的实例），边长为<span class="math inline">\(l\)</span>的正<span class="math inline">\(n\)</span>多边形，显然周长为边长的<span class="math inline">\(n\)</span>倍，即<span class="math inline">\(C=nl\)</span>。而对于面积<span class="math inline">\(S_\triangle =\dfrac{1}{2}\cdot l\cdot \dfrac{l}{2\tan (\frac{\pi}{n})}=\dfrac{l^2}{4\tan (\frac{\pi}{n})}\)</span>，则正多边形面积为<span class="math inline">\(S=\dfrac{1}{4}n\cot \dfrac{\pi}{n}\cdot l^2\)</span></p><p><img src="https://pic.imgdb.cn/item/622af9d75baa1a80abd271e1.jpg" style="zoom:25%;" /></p><p>而对于圆有熟知的周长<span class="math inline">\(C=2\pi r\)</span>，面积<span class="math inline">\(S=\pi r^2\)</span>。</p><h3 id="继承">继承</h3><p>对于正三角形、正方形、正五边形、正六边形、圆，都可以看作正多边形（圆是一种特殊的正多边形），从而设计父类<span class="math inline">\(\mbox{&lt;polygon.h&gt;}\)</span>，而另外五种几何对象都可以看作正多边形的特殊类，从而另外五种几何对象使用继承的语法，如正三角形的类定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">triangle</span> :<span class="hljs-keyword">public</span> polygon &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">triangle</span>() : <span class="hljs-built_in">polygon</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>) &#123;&#125;<br>        <span class="hljs-built_in">triangle</span>(<span class="hljs-type">double</span> l);<br>        ~<span class="hljs-built_in">triangle</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中委托<span class="math inline">\(\mbox{polygon}\)</span>中的构造函数，并规定边长数为<span class="math inline">\(3\)</span>，在<span class="math inline">\(\mbox{triangle}\)</span>的另一种构造函数中传入边长长度参数，该正三角形确定，从而在该构造函数中，调用<span class="math inline">\(\mbox{polygon.h}\)</span>中计算周长和面积函数将该正三角形确定并输出其周长和面积，其余正多边形的构造基本一样，圆规定边长数目为<span class="math inline">\(-1\)</span>，便于与其他多边形分开，其余代码与正三角形的代码类似。</p><p>父类<span class="math inline">\(\mbox{&lt;polygon.h&gt;}\)</span>的声明见下，其中使用指针字符串输出对应类型，使用上述方法计算周长和面积。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">polygon</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *shapeName[<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;Circle&quot;</span>,<span class="hljs-string">&quot;Triangle&quot;</span>,<span class="hljs-string">&quot;Square&quot;</span>,<span class="hljs-string">&quot;Pentagon&quot;</span>,<span class="hljs-string">&quot;Hexagon&quot;</span>&#125;;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">double</span> length;<br>    <span class="hljs-type">double</span> perimeter;<br>    <span class="hljs-type">double</span> area;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">polygon</span>() :<span class="hljs-built_in">num</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">length</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">perimeter</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">area</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">polygon</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> l = <span class="hljs-number">0</span>) : <span class="hljs-built_in">num</span>(n), <span class="hljs-built_in">length</span>(l),<span class="hljs-built_in">perimeter</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">area</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showShapeName</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getPerimeter</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showData</span><span class="hljs-params">()</span></span>;<br>    ~<span class="hljs-built_in">polygon</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="组合">组合</h3><p>由于需要输出所有图形的总周长和总面积，则使用组合的方式将所有正多边形的类"组装"在一起，定义<span class="math inline">\(\mbox{&lt;shapeFamily.h&gt;}\)</span>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shapeFamily</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        vector&lt;triangle&gt; triangles;<br>        vector&lt;square&gt; squares;<br>        vector&lt;pentagon&gt; pentagons;<br>        vector&lt;hexagon&gt; hexagons;<br>        vector&lt;circle&gt; circles;<br>        <span class="hljs-type">int</span> allNums;<br>        <span class="hljs-type">double</span> perimeterTotal;<br>        <span class="hljs-type">double</span> areaTotal;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">shapeFamily</span>():<span class="hljs-built_in">allNums</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">perimeterTotal</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">areaTotal</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span>;<br>    &#125;;<br></code></pre></td></tr></table></figure><p><span class="math inline">\(\mbox{input()}\)</span>函数按照题目要求进行输入以及更新总周长和总面积。</p><h2 id="验证">验证</h2><h3 id="手动输入测试">手动输入测试</h3><p>手动输入测试中，尽量包含多种情况，并前后进行检验，大致上正确性可以保证。</p><p><img src="https://pic.imgdb.cn/item/622afa085baa1a80abd2b107.jpg" style="zoom: 50%;" /></p><h3 id="自动测试">自动测试</h3><p>使用开源轻量级测试工具<span class="math inline">\(\mbox{&lt;doctest.h&gt;}\)</span>（<a href="https://github.com/doctest/doctest" class="uri">https://github.com/doctest/doctest</a>），代码框架如下。输入数据一种为有序整数，另一种为<span class="math inline">\(\mbox{&lt;ctime.h&gt;}\)</span>生成的随机数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;doctest.h&quot;</span></span><br><span class="hljs-built_in">TEST_CASE</span>(<span class="hljs-string">&quot;testing some special examples&quot;</span>)&#123;<br>    <span class="hljs-built_in">CHECK</span>(<span class="hljs-built_in">funtion</span>() == result);<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，其中一次针对所有子类的单元测试情况如下，由于双精度浮点数存在误差，在测试过程中加入限制条件<span class="math inline">\(&lt;=10^{-10}\)</span>，对于50个自动化单元测试样例均通过。</p><p><img src="https://pic.imgdb.cn/item/622afa2f5baa1a80abd2ddcd.jpg" style="zoom:50%;" /></p><h2 id="分析">分析</h2><h3 id="充分性">充分性</h3><p>对于特定几何对象的周长面积，只能使用三角函数计算的方式，例如对于正五边形，其面积的严格数学表达式为<span class="math inline">\(S=\dfrac{\sqrt{25+10\sqrt{5}}}{4}l^2\)</span>，浮点计算多，容易造成精度上的误差。</p><p>一种想法是使用<strong>蒙特卡洛模拟</strong>的方法，依据大数定律，生成的随机数足够多，面积的误差能够相应缩小。由于时间原因该构想没有实现，但这种求解几何对象面积的方式，对于一些高级曲线<span class="math inline">\(\mathrm{B}-\)</span>样条曲线中相关面积的计算也许可以作为参考。</p><h3 id="程序扩展性">程序扩展性</h3><p>相对于<span class="math inline">\(\mbox{C}\)</span>语言，<span class="math inline">\(\mbox{C++}\)</span>在这种需求较为复杂的情形下代码的复用性体现得更加充分，在结构清晰的基础上，便于后续增加相应的图形扩展和功能扩展。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>面向对象编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象编程作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年女生节</title>
    <link href="/2022/03/07/Girls-Festival/"/>
    <url>/2022/03/07/Girls-Festival/</url>
    
    <content type="html"><![CDATA[<p>祝 <span class="math inline">\(\mbox{yy}\)</span> 姐和微软工的小仙女们美丽可爱，青春永在，和烦恼 <span class="math inline">\(\mbox{say goodbye!}\)</span> 女生节快乐鸭~~</p><p>有剧情，有祝福，有礼物，有表演，有气球……算是很开心的啦~</p><p>据说女生评价挺高的，算是成功地反馈去年的男生节了。</p><p><span class="math inline">\(B\)</span> 站视频如右：<a href="https://www.bilibili.com/video/BV12L4y1M7kJ?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=f7e325a2-7619-413d-afbf-6931de4e9d11&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1646823543&amp;unique_k=CnDa6VS">清华女生节竟是这样过的！</a></p><p>最后被邵美琪唱的《这世界那么多人》洗脑了~~</p><p><img src="https://pic.imgdb.cn/item/6226d80f5baa1a80ab06707f.jpg" style="zoom:20%;" /></p>]]></content>
    
    
    <categories>
      
      <category>节日</category>
      
      <category>女生节</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2022年女生节记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP-Homework-2</title>
    <link href="/2022/03/06/Program/OOP%20Homework%202/"/>
    <url>/2022/03/06/Program/OOP%20Homework%202/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程第二次作业">面向对象编程第二次作业</h1><p><strong>Object-Oriented Programming <span class="math inline">\(\bullet\)</span> Homework <span class="math inline">\(\mathbf{2}\)</span></strong></p><h2 id="模型">模型</h2><h3 id="穷举法">穷举法</h3><p>对输入的正整数<span class="math inline">\(a,b\ (1\leq a,b\leq 10^{9})\)</span>，从两者较小者不断递减，验证是否均整除<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GCDAndLCM::EnumerateGCD</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = (num1 &gt; num2) ? num2 : num1;<br>    <span class="hljs-keyword">while</span> (num1 % ans != <span class="hljs-number">0</span> || num2 % ans != <span class="hljs-number">0</span>)<br>        ans--;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键代码如上，写成单独函数的形式便于测量时间</p><h3 id="欧几里得算法">欧几里得算法</h3><p>对正整数<span class="math inline">\(a,b(a&lt;b)\)</span>，有<span class="math inline">\(\mbox{gcd}(a,b)=\mbox{gcd}(b\%a,a)\)</span>，称为欧几里得算法。</p><p>证明：由带余除法定理，若<span class="math inline">\(b&gt;a\)</span>，则<span class="math inline">\(\exists\  q\in Z,r\in[0,a-1),s.t.\ b=aq+r\)</span>，从而<span class="math inline">\(\mbox{gcd}(a,b\%a)=\mbox{gcd}(a,r)=\mbox{gcd}(a,b-aq)=\mbox{gcd}(a,b)\)</span> 则使用递归法计算两个正整数的最大公约数，关键代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GCDAndLCM::EuclideanGCD</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (num1 &lt; num2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">EuclideanGCD</span>(num2, num1);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">return</span> (num1 % num2 == <span class="hljs-number">0</span>) ? num2 : <span class="hljs-built_in">EuclideanGCD</span>(num2, num1 % num2);<br>&#125;<br></code></pre></td></tr></table></figure><p>当其中一数整除另一数时，返回前者，否则继续辗转相除法，同时不断调整使得前者不小于后者。由数论结论有<span class="math inline">\([a,b]=\dfrac{ab}{(a,b)}\)</span>，从而最小公倍数可求</p><h3 id="类的定义">类的定义</h3><p>本次编程头文件<span class="math inline">\(GCDAndLCM.h\)</span>中类的定义以及对应方法如下，其中输入数据<span class="math inline">\(N\)</span>、输出结果<span class="math inline">\(\mbox{GCD}\)</span>和<span class="math inline">\(\mbox{LCM}\)</span>以及相关的时间放在<span class="math inline">\(\mbox{private}\)</span>内，其余构造函数、析构函数以及输入、方法计算、自动测试、时间测量相关函数头放在<span class="math inline">\(\mbox{public}\)</span>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GCDAndLCM</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-type">int</span> GCD;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> LCM;<br>        <span class="hljs-type">double</span> timeGCD,timeLCM;<br>        <span class="hljs-type">double</span> frequency;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">GCDAndLCM</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> t1 = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> t2 = <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">GCDAndLCM</span>(<span class="hljs-type">const</span> GCDAndLCM&amp; g):<span class="hljs-built_in">a</span>(g.a),<span class="hljs-built_in">b</span>(g.b),<span class="hljs-built_in">GCD</span>(g.GCD),<span class="hljs-built_in">LCM</span>(g.LCM),<span class="hljs-built_in">timeGCD</span>(g.timeGCD),<span class="hljs-built_in">timeLCM</span>(g.timeLCM),<span class="hljs-built_in">frequency</span>(g.frequency) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span></span>;       <span class="hljs-comment">//获取数据存入a,b中</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">EnumerateGCD</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">EuclideanGCD</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getGCDResults</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//计算最大公约数</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getLCMResults</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">//计算最小公倍数</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">singleTest</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//手动输入测试</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">autoTest</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//自动化测试</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inquiry</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//询问测试方法</span><br>        ~<span class="hljs-built_in">GCDAndLCM</span>() &#123;&#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><p>由于若<span class="math inline">\((a,b)=1\)</span>即<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>互素时，<span class="math inline">\([a,b]=a\cdot b\)</span>可以达到<span class="math inline">\(10^{18}\)</span>量级，从而使用<span class="math inline">\(\mbox{long long}\)</span>数据类型存储<span class="math inline">\(\mbox{LCM}\)</span>（最小公倍数）。使用<span class="math inline">\(\mbox{&lt;windows.h&gt;}\)</span>中<span class="math inline">\(QueryPerformanceFrequency(\&amp;F)\longrightarrow frequency = F.QuadPart\)</span>获取使用频率，便于后面高精度计算所用时间。</p><h2 id="验证">验证</h2><p>本实验结合不同情况，编写两种测试，一种为手动输入范围内两个正整数进行测试，输出两种方法对应结果和所需要时间。另一种测试方式为自动测试，使用<span class="math inline">\(\mbox{&lt;ctime&gt;}\)</span>中的随机数<span class="math inline">\(\mbox{rand()}\)</span>相乘，将两种方法计算的结果进行比较、输出结果以及对应时间。</p><h3 id="手动输入测试">手动输入测试</h3><p>在初始询问时输入<span class="math inline">\(\mbox{0}\)</span>进入手动输入测试模式，输入不同的数字输出结果以及消耗时间：</p><p><img src="https://pic.imgdb.cn/item/622a1bb15baa1a80ab53a725.jpg" style="zoom:80%;" /></p><p>可以看出，对于第二种方法，计算时间在<span class="math inline">\(10^{-3}\mbox{ms}\sim 10^{-6}\mbox{s}\)</span>量级，也就是<span class="math inline">\(1\mbox{s}\)</span>内可以至少计算完一百万组数据的最大公约数和最小公倍数，而第一种穷举的方法计算时间随输入数据线性增加。</p><h3 id="自动测试">自动测试</h3><p>在询问时输入<span class="math inline">\(\mbox{1}\)</span>进入自动化测试模式，连续两次使用两个随机数相乘得到<span class="math inline">\(a,b\)</span>，采用两种算法计算对应最大公约数和最小公倍数，比对两者是否相同，输出结果，重复该过程<span class="math inline">\(10\)</span>次，最后输出两种方法时间分别消耗的总时间，以下为某次输出结果。 <span class="math display">\[\small\begin{array}{|c|c|c|}\hline \text { 测试序号 } &amp; \text { 最大公约数 } &amp; \text { 最小公倍数 } \\\hline \# 1 &amp; (130743583,573423651)=17 &amp; {[130743583,573423651]=4410086041687149} \\\hline \# 2 &amp; (369064716,30402746)=2 &amp; {[369064716,30402746]=5610290409055068} \\\hline \# 3 &amp; (594322690,82811424)=2 &amp; {[594322690,82811424]=24608354137205280} \\\hline \# 4 &amp; (104223784,11654964)=4 &amp; {[104223784,11654964]=303681112615944} \\\hline \# 5 &amp; (864568560,349050135)=15 &amp; {[864568560,349050135]=20118518172317040} \\\hline \# 6 &amp; (258643100,230600502)=2 &amp; {[258643100,230600502]=29821614349418100} \\\hline \# 7 &amp; (108403370,193179162)=46 &amp; {[108403370,193179162]=455245047273390} \\\hline \# 8 &amp; (47632487,289415316)=1 &amp; {[47632487,289415316]=13785571276970892} \\\hline \# 9 &amp; (3119375,68440383)=1 &amp; {[3119375,68440383]=213491219720625} \\\hline \# 10 &amp; (251300764,156068087)=1 &amp; {[251300764,156068087]=39220029499118468} \\\hline\end{array}\]</span> <span class="math inline">\(\mbox{All the tests are right! Enumerate algorithm cost 10.941s, Euclidean algorithm cost 3.03e-05s.}\)</span>，与手动输入测试结果基本吻合。</p><h2 id="分析">分析</h2><h3 id="复杂度">复杂度</h3><p>对于穷举法，显然消耗时间正比于数据规模<span class="math inline">\(N\)</span>,从而其时间复杂度为<span class="math inline">\(O(N)\)</span>。</p><p>对于欧几里得算法，每次时间的消耗与<span class="math inline">\(a,b\)</span>的增加并非线性，比如当<span class="math inline">\(a,b\)</span>很大，但<span class="math inline">\(|a-b|=1\)</span>时，计算最大公约数只消耗了两倍的常数时间。则从最坏的时间消耗来看，<span class="math inline">\((N,m)\longrightarrow (m,n)\)</span>，<span class="math inline">\(m&lt; \dfrac{N}{2}\)</span>，则最坏情况下每次数据只能达到减半，时间复杂度为<span class="math inline">\(O(\log N)\)</span>。</p><p>在上述自动化测试中，前者规模<span class="math inline">\(N_1=\dfrac{1}{10}\displaystyle \sum_{i=1}^{i=10}\min(a_i,b_i)\approx 1.1\times 10^{8}\)</span>，后者规模<span class="math inline">\(N_2=\dfrac{1}{20}\displaystyle \sum_{i=1}^{10}(a_i+b_i) \approx 2.4\times 10^{8}\)</span>，在欧几里得算法最坏的情况下，两者理论时间消耗之比<span class="math inline">\(\dfrac{t_1}{t_2}\sim \dfrac{N_1}{\log N_2}\approx 3.95\times 10^{6}\)</span>，与测得数据<span class="math inline">\(\dfrac{t_1}{t_2}=\dfrac{10.941\mbox{s}}{3.03\times 10^{-5}\mbox{s}}\approx 3.61\times 10^{6}\)</span>基本一致。</p><p>显然，穷举法空间复杂度为<span class="math inline">\(O(1)\)</span>，而欧几里得算法由于使用递归，需要存储步骤中的数据，空间复杂度为<span class="math inline">\(O(\log N)\)</span></p><h3 id="优缺点">优缺点</h3><p>从耗时的角度，欧几里得算法远快于穷举法，而且在函数递归调用次数可达<span class="math inline">\(10^{3}\)</span>，在数据规模小于<span class="math inline">\(2^{10^{3}}\approx 10^{300}\)</span>内均不会出现栈溢出的问题。从而欧几里得算法为当前计算最大公约数和最小公倍数的主流算法。</p><h3 id="有效性充分性">有效性、充分性</h3><p>由上述验证可以看出，对于输入数据的绝对最大值<span class="math inline">\(2^{31}-1\)</span>和<span class="math inline">\(2^{31}-2\)</span>，其最小公倍数<span class="math inline">\((2^{31}-1)\cdot (2^{31}-2)= 4.61\times 10^{18}&lt;\max{\mbox{(long long)}}=2^{63}-1=9.22\times 10^{18}\)</span>，输入数据能保证输出结果，保证了充分性。</p><p>有效性不能完全通过遍历验证，因为遍历组合达到<span class="math inline">\(\sim \dfrac{1}{2}\cdot 2^{31}\cdot 2^{31}=2^{61}\)</span>，不可能全部验证通过，但在自动化测试检验以及数学公式的推导下，该程序有效性能够很好地保证。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>面向对象编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象编程作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Visualization-Graphs</title>
    <link href="/2022/03/05/Program/Python-Visualization-Graphs/"/>
    <url>/2022/03/05/Program/Python-Visualization-Graphs/</url>
    
    <content type="html"><![CDATA[<p>从各种库中获取绘制图表的工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> wordcloud <span class="hljs-keyword">import</span> WordCloud, ImageColorGenerator<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">from</span> pickle <span class="hljs-keyword">import</span> TRUE<br><span class="hljs-keyword">import</span> xlwings <span class="hljs-keyword">as</span> xw<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> time<br></code></pre></td></tr></table></figure><p>在第一天获取到每个 <span class="math inline">\(\mbox{sheet}\)</span> 下的每个列表中每个词汇在标题和内容中分别出现的次数后，希望针对这些数据作图，其中饼状图的绘制函数如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#全局颜色变量</span><br>colorsFoxconn = [<span class="hljs-string">&#x27;#FEE9CE&#x27;</span>,<span class="hljs-string">&#x27;#F5D0C7&#x27;</span>,<span class="hljs-string">&#x27;#BEB2BE&#x27;</span>,<span class="hljs-string">&#x27;#6A909D&#x27;</span>,<span class="hljs-string">&#x27;#A8C4E9&#x27;</span>,<span class="hljs-string">&#x27;#DCEDFD&#x27;</span>]<span class="hljs-comment">#颜色全局变量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drawPieGraphs</span>(<span class="hljs-params">list1,list2,title</span>):<br>    <span class="hljs-keyword">if</span> list1 == <span class="hljs-literal">None</span>:<span class="hljs-comment">#如果传入参数为空，则直接返回空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>]=<span class="hljs-string">&#x27;SimHei&#x27;</span><span class="hljs-comment">#设置中文显示</span><br>    plt.figure(figsize=(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>))<span class="hljs-comment">#设置画布大小</span><br>    plt.pie(list2,labels=list1,autopct=<span class="hljs-string">&#x27;%1.1f%%&#x27;</span>,shadow = <span class="hljs-literal">True</span>,colors = colorsFoxconn)<span class="hljs-comment">#list1为项目名称，list2为数量分布</span><br>    plt.title(title)<span class="hljs-comment">#加标题</span><br>    posiGraph = <span class="hljs-string">&#x27;./饼状图/&#x27;</span>  <span class="hljs-comment">#获取保存位置</span><br>    posiGraph +=<span class="hljs-built_in">str</span>(title)<span class="hljs-comment">#保存名称为“标题.jpg”</span><br>    plt.savefig(posiGraph,dpi = <span class="hljs-number">500</span>)<span class="hljs-comment">#dpi代表像素，</span><br></code></pre></td></tr></table></figure><p>柱状图的绘制函数如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">colorsWarm = [<span class="hljs-string">&#x27;#E09E09&#x27;</span>,<span class="hljs-string">&#x27;#B27A63&#x27;</span>,<span class="hljs-string">&#x27;#DCA77B&#x27;</span>,<span class="hljs-string">&#x27;#BD6C41&#x27;</span>,<span class="hljs-string">&#x27;#C1B585&#x27;</span>,<span class="hljs-string">&#x27;#F0DEAF&#x27;</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drawColumnGraphs</span>(<span class="hljs-params">list1,list2,title</span>):<br>    plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>]=<span class="hljs-string">&#x27;SimHei&#x27;</span><span class="hljs-comment">#设置中文显示</span><br>    plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>))<br>    plt.bar(list1,list2,color = colorsWarm,width = <span class="hljs-number">0.66</span>)<span class="hljs-comment">#柱状图函数调用</span><br>    plt.xticks(list1, list1, rotation = -<span class="hljs-number">55</span>)<span class="hljs-comment">#柱状图X轴标定，rotation为旋转角度</span><br>    plt.title(title)<span class="hljs-comment">#柱状图标题标定</span><br>    posiGraph = <span class="hljs-string">&#x27;./柱状图/&#x27;</span><span class="hljs-comment">#存储路径</span><br>    posiGraph +=<span class="hljs-built_in">str</span>(title)<span class="hljs-comment">#保存图片名称和标题相同</span><br>    plt.savefig(posiGraph)<br></code></pre></td></tr></table></figure><p>饼状图和柱状图两者都需要按顺序传入<strong>项目名称、数量分布、标题</strong></p><p>其中，为追求美观，需要对原始数据加以计算和修正，将 <span class="math inline">\(5\%-20\%\)</span> 排序靠后的部分归类为“其他”代码部分有些凌乱，掺杂了一些文件导入的操作，以后传入函数的时候还是尽量减少耦合度具体来说，先计算总和，排序后将后面小量汇总为“其他”，但是数量过多或者过少也需要判断，主要针对饼状图而言。</p><p>词云图的绘制函数如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> wordcloud <span class="hljs-keyword">import</span> WordCloud, ImageColorGenerator<br><br><span class="hljs-comment"># 获取颜色map，以便传入绘制词云函数中，设定文字颜色</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">colormap</span>():<br>  <span class="hljs-keyword">return</span> mpl.colors.LinearSegmentedColormap.from_list(<span class="hljs-string">&#x27;cmap&#x27;</span>, [<span class="hljs-string">&quot;#000080&quot;</span>,<span class="hljs-string">&quot;#6495ED&quot;</span>,<span class="hljs-string">&quot;#778899&quot;</span>,<span class="hljs-string">&quot;#76ACF3&quot;</span>,<span class="hljs-string">&quot;#B588BE&quot;</span>], <span class="hljs-number">256</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_cloud</span>():<br>    getdata =   &#123;<span class="hljs-string">&quot;杨倩&quot;</span>: <span class="hljs-number">510</span>,<span class="hljs-string">&quot;孙颖莎&quot;</span>: <span class="hljs-number">292</span>,<span class="hljs-string">&quot;刘诗雯&quot;</span>: <span class="hljs-number">143</span>,<span class="hljs-string">&quot;许昕&quot;</span>: <span class="hljs-number">173</span>,<span class="hljs-string">&quot;马龙&quot;</span>: <span class="hljs-number">466</span>,<span class="hljs-string">&quot;樊振东&quot;</span>: <span class="hljs-number">298</span>,<span class="hljs-string">&quot;王曼昱&quot;</span>: <span class="hljs-number">153</span>,<span class="hljs-string">&quot;昕雯&quot;</span>: <span class="hljs-number">19</span>,<span class="hljs-string">&quot;中国跳水队&quot;</span>: <span class="hljs-number">120</span>,<span class="hljs-string">&quot;体育&quot;</span>: <span class="hljs-number">15373</span>,<span class="hljs-string">&quot;孫亜楠&quot;</span>: <span class="hljs-number">13</span>,<span class="hljs-string">&quot;全紅嬋&quot;</span>: <span class="hljs-number">11</span>,&#125;<span class="hljs-comment">#给定词频或者通过计算得到词频字典（使用Counter计数器）</span><br>    image = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;background.png&#x27;</span>)  <span class="hljs-comment"># 设置背景轮廓图（在代码所在文件夹）</span><br>    graph = np.array(image)<br>    mask = np.array(image)<br>    wc = WordCloud(width = <span class="hljs-number">1400</span>,height = <span class="hljs-number">800</span>,collocations=<span class="hljs-literal">False</span>,margin=<span class="hljs-number">2</span>,font_path = <span class="hljs-string">&#x27;simkai.ttf&#x27;</span>, background_color =<span class="hljs-string">&#x27;white&#x27;</span>,min_font_size = <span class="hljs-number">0</span>,max_font_size = <span class="hljs-number">2000</span>,mask = mask, max_words = <span class="hljs-number">1000</span>,colormap = colormap())<span class="hljs-comment">#大小、指定字体、背景颜色、字号、颜色map</span><br>    wc.generate_from_frequencies(getdata)  <span class="hljs-comment"># 根据给定词频生成词云</span><br>    image_color = ImageColorGenerator(graph)<br>    plt.imshow(wc)<br>    plt.axis(<span class="hljs-string">&quot;off&quot;</span>)  <span class="hljs-comment"># 不显示坐标轴</span><br>    wc.to_file(<span class="hljs-string">&#x27;图片名称.png&#x27;</span>)  <span class="hljs-comment"># 图片命名</span><br>    file = <span class="hljs-string">r&quot;C:\Users\liuy\Desktop\存放的文件夹&quot;</span><br>    name = <span class="hljs-string">&quot;\图片名称&quot;</span><br>    plt.savefig(file + name)<br></code></pre></td></tr></table></figure><p><span class="math inline">\(\mbox{DNA}\)</span> 图表代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">title,tempJson</span>):<br>    numOfObjects = <span class="hljs-built_in">len</span>(tempJson)<br>    fig1 = plt.figure()<br>    ax1 = fig1.add_subplot(<span class="hljs-number">111</span>)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(tempJson)):<br>        <span class="hljs-keyword">if</span>(tempJson[j] == <span class="hljs-literal">None</span>):<br>            numOfObjects -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> tempJson[j]:<br>            <span class="hljs-keyword">if</span> tempJson[j][key] &gt; <span class="hljs-built_in">max</span>:<br>                <span class="hljs-built_in">max</span> = tempJson[j][key]<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> tempJson[j]:<br>            validFrequency = tempJson[j][key]<br>            posiX = findSection(<span class="hljs-built_in">int</span>(key),yearPoint) / <span class="hljs-number">2.5</span><br>            posiXAll = []<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">7</span>):<br>                posiXAll.append((findSection(yearPoint[<span class="hljs-number">5</span> *k],yearPoint)) / <span class="hljs-number">2.5</span>)<br>            plt.xticks(posiXAll, showData)<br>            rect = plt.Rectangle((posiX, <span class="hljs-number">2</span> + <span class="hljs-number">3.0</span> * (numOfObjects - j)), <span class="hljs-number">0.6</span>, <span class="hljs-number">0.8</span>, color = <span class="hljs-string">&#x27;#00CED1&#x27;</span>,alpha = validFrequency / <span class="hljs-built_in">max</span>)<br>            ax1.add_patch(rect)<br>    posiYAll = []<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(tempJson)):<br>        posiYAll.append(<span class="hljs-number">2</span> + <span class="hljs-number">3</span> * (numOfObjects - j))<br>    plt.yticks(posiYAll,allObjects[i],fontsize = <span class="hljs-number">7</span>)<br>    plt.xlim(<span class="hljs-number">0</span>,<span class="hljs-number">12</span>)<br>    plt.ylim(<span class="hljs-number">0</span>,<span class="hljs-number">4</span> * numOfObjects)<br>    titleName = title + <span class="hljs-string">&quot;报道趋势图&quot;</span><br>    plt.title(titleName)<br>    plt.savefig(<span class="hljs-string">r&quot;C:\Users\liuy\Desktop\DNA图片&quot;</span> + <span class="hljs-string">&quot;\\&quot;</span> + titleName + <span class="hljs-string">&quot;.png&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>针对给定文字段落的词云分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_cloud</span>():<br>    image = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;background.png&#x27;</span>) <br>    graph = np.array(image)<br>    mask = np.array(image)<br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">u&#x27;introduction.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>).read()<br>    wordcloud = WordCloud(font_path=<span class="hljs-string">&#x27;simkai.ttf&#x27;</span>,background_color = <span class="hljs-string">&quot;white&quot;</span>,width = <span class="hljs-number">10000</span>, height = <span class="hljs-number">10000</span>, margin = <span class="hljs-number">2</span>, mask = mask, colormap = colormap()).generate(f)<br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    image_color = ImageColorGenerator(graph)<br>    plt.imshow(wordcloud, interpolation=<span class="hljs-string">&quot;bilinear&quot;</span>)<br>    plt.axis(<span class="hljs-string">&quot;off&quot;</span>)<br>    plt.savefig(<span class="hljs-string">&quot;./&quot;</span>,dpi = <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p>如果需要将离散点转换成曲线</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">X3=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<span class="hljs-number">36</span>,<span class="hljs-number">37</span>,<span class="hljs-number">38</span>,<span class="hljs-number">39</span>,<span class="hljs-number">40</span>,<span class="hljs-number">41</span>,<span class="hljs-number">42</span>,<span class="hljs-number">43</span>,<span class="hljs-number">44</span>,<span class="hljs-number">45</span>,<span class="hljs-number">46</span>,<span class="hljs-number">47</span>,<span class="hljs-number">48</span>,<span class="hljs-number">49</span>,<span class="hljs-number">50</span>];<br>Y3=[<span class="hljs-number">0.704347</span>,<span class="hljs-number">0.703088</span>,<span class="hljs-number">0.701667</span>,<span class="hljs-number">0.700265</span>,<span class="hljs-number">0.699096</span>,<span class="hljs-number">0.698142</span>,<span class="hljs-number">0.696643</span>,<span class="hljs-number">0.695319</span>,<span class="hljs-number">0.694171</span>,<span class="hljs-number">0.693057</span>,<span class="hljs-number">0.692145</span>,<span class="hljs-number">0.690986</span>,<span class="hljs-number">0.690039</span>,<span class="hljs-number">0.688821</span>,<span class="hljs-number">0.687838</span>,<span class="hljs-number">0.687095</span>,<span class="hljs-number">0.686086</span>,<span class="hljs-number">0.685103</span>,<span class="hljs-number">0.684324</span>,<span class="hljs-number">0.683746</span>,<span class="hljs-number">0.6828</span>,<span class="hljs-number">0.682019</span>,<span class="hljs-number">0.681155</span>,<span class="hljs-number">0.68061</span>,<span class="hljs-number">0.679976</span>,<span class="hljs-number">0.679395</span>,<span class="hljs-number">0.678685</span>,<span class="hljs-number">0.678363</span>,<span class="hljs-number">0.677703</span>,<span class="hljs-number">0.677327</span>,<span class="hljs-number">0.676845</span>,<span class="hljs-number">0.676334</span>,<span class="hljs-number">0.675988</span>,<span class="hljs-number">0.675582</span>,<span class="hljs-number">0.675275</span>,<span class="hljs-number">0.674974</span>,<span class="hljs-number">0.674759</span>,<span class="hljs-number">0.674505</span>,<span class="hljs-number">0.674276</span>,<span class="hljs-number">0.674189</span>,<span class="hljs-number">0.674038</span>,<span class="hljs-number">0.673882</span>,<span class="hljs-number">0.673811</span>,<span class="hljs-number">0.67368</span>,<span class="hljs-number">0.673731</span>,<span class="hljs-number">0.673658</span>,<span class="hljs-number">0.673847</span>,<span class="hljs-number">0.673751</span>,<span class="hljs-number">0.673917</span>,<span class="hljs-number">0.674002</span>,<span class="hljs-number">0.674056</span>];<br>p3=polyfit(X3,Y3,<span class="hljs-number">22</span>);<br>x3 = <span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">50</span>;<br>y3 = polyval(p3,x3);<br><span class="hljs-built_in">plot</span>(x3,y3);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>可视化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python 可视化工作经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大风起兮云风扬</title>
    <link href="/2022/03/04/%E5%A4%A7%E9%A3%8E%E8%B5%B7%E5%85%AE%E4%BA%91%E9%A3%9E%E6%89%AC/"/>
    <url>/2022/03/04/%E5%A4%A7%E9%A3%8E%E8%B5%B7%E5%85%AE%E4%BA%91%E9%A3%9E%E6%89%AC/</url>
    
    <content type="html"><![CDATA[<p>周五，没有早八，早上一骑车出门，就感觉风跟自行车过不去。早九的体育课，体育老师一脸笑呵呵，让我们迎着风在一片完全空旷的篮球场里“自由练习”。</p><p>刚投了几个篮（还不如说是偷了几个懒（っ╹◡╹)），眼见枯黄的落叶旋风而起，扶摇直上，嘎吱声伴随着风的呼声，瞬间从篮球场的一侧扫到了篮球场的另一侧，重重地击打在旁边的铁网上，黄沙就比较幸运，穿过铁网的缝隙继续它的旅程，风也许还满足随机性，让枯叶到处碰壁，旁边的自行车倒了一片……篮球肯定是没法打了，<span class="math inline">\(90\)</span> 分钟的体育课上了 <span class="math inline">\(20\)</span> 分钟就散了，骑车回来就看到“百团大战”后的残骸：</p><p><img src="https://pic.imgdb.cn/item/6222f7d25baa1a80ab34acd0.jpg" style="zoom:25%;" /></p><p>回到寝室，关着窗户都能听到风的嘶吼声。朋友圈里到处“挨吹”，还有人眼镜吹掉了……</p><p><img src="https://pic.imgdb.cn/item/6222f8a55baa1a80ab3557b3.jpg" style="zoom:35%;" /></p><p>下午搞了一些收尾工作，晚上听了 杨 <span class="math inline">\(\mbox{Sir}\)</span> 的高代选讲，讲得精彩！笔记先在笔记本上，后面有时间的话再挑选一些重点“信息化”。</p><h3 id="大风起兮云飞扬残叶卷兮百团降">大风起兮云飞扬，残叶卷兮百团降！</h3>]]></content>
    
    
    <categories>
      
      <category>随想</category>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Visualization-Process the Json file</title>
    <link href="/2022/03/03/Program/Python-Visualization-Json-File/"/>
    <url>/2022/03/03/Program/Python-Visualization-Json-File/</url>
    
    <content type="html"><![CDATA[<p>Python 编写工程项目时，对每份代码，编写流程基本都是 <span class="math display">\[\Large \textcolor{black}{调库}\normalsize \Longrightarrow \Large \textcolor{black}{全局变量}\normalsize \Longrightarrow \Large \textcolor{black}{装饰器}\normalsize \Longrightarrow \Large \textcolor{black}{子函数}\normalsize \Longrightarrow\Large \textcolor{black}{主函数}\normalsize\]</span> 只要两者之间具有一定独立性，最好空开两行方便 <span class="math inline">\(\mbox{Debug}\)</span> 。（这个真的是教训啊！！<strong>一定要全局</strong>，编写过程中使用复用性更高的代码，如使用 <span class="math inline">\(\mbox{len()}\)</span> 获取迭代次数，避免数据换了后手动调浪费时间）</p><h2 id="装饰器的使用">装饰器的使用</h2><p>装饰器是为了在输出结果时告知当前运行函数名称，运行时间，方便快速定位 <span class="math inline">\(\mbox{Bug}\)</span> 位置，一个经典装饰器的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">metric</span>(<span class="hljs-params">fn</span>):<br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">fn</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start executing %s&#x27;</span> % (fn.__name__))<br>        start_time = time.time()<br>        result = fn(*args, **kw)<br>        end_time = time.time()<br>        t = <span class="hljs-number">1000</span> * (end_time - start_time)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s executed in %s ms&#x27;</span> % (fn.__name__, t))<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>该装饰器告知开始运行函数、结束运行函数以及运行时间，在每次 <code>def 'name_of_fuction'</code> 前一行加入 <code>@metric</code> 便可以实现装饰器功能</p><h2 id="获取目录下所有文件">获取目录下所有文件</h2><p>由于本次工作数据量庞大（成千上万个文件），从本地特定目录下读取该目录的所有文件，使用 <span class="math inline">\(os\)</span> 库中的 <span class="math inline">\(listdir\)</span> 函数获取目录下的文件名与目录拼接在一起，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_list</span>(<span class="hljs-params">target</span>):<br>    dirs = os.listdir(target)//获取目录下的文件名称并存为列表<br>    file_list = []//初始化空列表<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> dirs://遍历列表中的每一个文件名称<br>         file_list.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;target&#125;</span>/<span class="hljs-subst">&#123;file&#125;</span>&quot;</span>)//加到原来文件目录后面<br>    <span class="hljs-keyword">return</span> file_list//得到一个具有该目录下所有文件位置的列表<br></code></pre></td></tr></table></figure><h2 id="异常处理">异常处理</h2><p>使用 <span class="math inline">\(\mbox{try}\)</span> 和 <span class="math inline">\(\mbox{except}\)</span> 语法，前者后面语句出现错误则跳至 <span class="math inline">\(\mbox{except}\)</span> 处，最好联合输出报错信息 <span class="math inline">\(\mbox{e}\)</span> 以及错误所在文件搭配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e)<br>    //<span class="hljs-built_in">print</span>(file)<br></code></pre></td></tr></table></figure><p>在处理文件时容易发现“前端”的规范化有问题，此时 <span class="math inline">\(\mbox{try-except}\)</span> 的作用体现得更加显著，多次套用异常处理语句即可</p><h2 id="计数器功能">计数器功能</h2><p>导入计数器所在库 <code>from collections import Counter</code>，单个计数器本质上就是单个字典，使用 <code>类名 = Counter()</code> 初始化，之后遇到什么就以字典的形式进行计数（<code>Counter()</code> 内部自动实现了遇到新 <code>key</code> 值计数为 <span class="math inline">\(1\)</span> ，遇到旧 <code>key</code> 值计数器加 <span class="math inline">\(1\)</span> ），由于存在多个、相互独立的列表，在实际运用中使用列表保存多个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">listDics = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(dirLanguage))://从 xlsx 中读取的二维列表(第几列第几个词)<br>    tempDict = Counter()//代表具有计数器功能的空字典<br>    listDics.append(tempDict)//形成字典列表<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> tqdm(file_list)://遍历并打开所有文件<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file,<span class="hljs-string">&quot;r&quot;</span>,encoding = <span class="hljs-string">&quot;utf-8&quot;</span>,errors = <span class="hljs-string">&quot;ignore&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        getTitle = json.load(f)[<span class="hljs-string">&quot;title&quot;</span>]//使用 json.load(f) 载入文件<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(dirLanguage))://对二维列表的每一列<br>            <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> dirLanguage[i]://对应计数每一列<br>                listDict[i][word] += <span class="hljs-number">1</span>//使用字典的方式计数<br><br></code></pre></td></tr></table></figure><h2 id="mboxjson-文件收放自如"><span class="math inline">\(\mbox{json}\)</span> 文件收放自如</h2><p>从上个实例代码中可以看到，使用 <code>json.load(f)</code> 即可以实现读取对应 <span class="math inline">\(\mbox{json}\)</span> 文件的内容，即为 <span class="math inline">\(\mbox{json}\)</span> 文件的读取</p><p>与之相对的为 <span class="math inline">\(\mbox{json}\)</span> 文件的写入，使用 <code>json.dump(写入名称,打开的文件(如f),ensure_ascii = False, indent = 2)</code>，注意打开文件时类型为 <span class="math inline">\(\mbox{w\small+}\)</span> ，为覆盖类型，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./result.json&quot;</span>,<span class="hljs-string">&quot;w+&quot;</span>,encoding = <span class="hljs-string">&quot;utf-8&quot;</span>,errors = <span class="hljs-string">&quot;ignore&quot;</span>) <span class="hljs-keyword">as</span> f:<br>json.dump(title_content,f,ensure_ascii = <span class="hljs-literal">False</span>, indent = <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h2 id="可视化工作中的可视化-mboxtqdm">可视化工作中的可视化（ <span class="math inline">\(\mbox{tqdm}\)</span> ）</h2><p>导入进度条库 <code>from tqdm import tqdm</code> （in Arabic means <em>progress</em>, also in Spanish <em>te quiero demasiado</em> means <em>I love you so much. </em>），在迭代器处加入 <span class="math inline">\(\mbox{tqdm}\)</span> 就可以清晰地看到迭代所处位置，再也不用一直盯着闪烁的光标无脑等待了~~</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> tqdm(file_list):<br></code></pre></td></tr></table></figure><p>在 <span class="math inline">\(\mbox{Python}\)</span> 交互式系统中可以达到这样效果，输入时保证可以需要输入就不会自动运行：</p><p><img src="https://pic.imgdb.cn/item/6224c13c5baa1a80ab7af253.jpg" /></p><h2 id="在大字符串中查找小字符串出现次数">在大字符串中查找小字符串出现次数</h2><p>使用字符串变量内置函数 <span class="math inline">\(str.\mbox{count}\)</span>，直接返回次数。造轮子的事情尽量少做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.count(find_str)<br></code></pre></td></tr></table></figure><h2 id="调试工程能力的体现">调试（工程能力的体现）</h2><p>在编写代码中，尽管“前端”有可能背锅，但大部分的错误还是因为自己总像个小孩子一样“犯傻”，不过 <span class="math inline">\(\mbox{Python}\)</span> 毕竟还是“大人”使用的工具，要学会定位 <span class="math inline">\(\mbox{Bug}\)</span> 的能力：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> IPython <span class="hljs-keyword">import</span> embed<br></code></pre></td></tr></table></figure><p><span class="math inline">\(\mbox{embed}\)</span> 函数有点像 <span class="math inline">\(\mathbf{C}\large艹\)</span> 中的断点调试，但是更好的一点是，在出现错误的地方打上 <span class="math inline">\(\mbox{embed}\)</span> 后程序会在指定的地方停止，同时保留了当前所有的存储变量，向外提供执行任意输入代码的接口，在 <span class="math inline">\(\mbox{embed}\)</span> 之后，<span class="math inline">\(\mbox{print}\)</span> 出当前的存储变量，或者手动输入（也可以多行复制）运行接下来的代码快速找到相应问题。虽然最后来说很多问题都比较弱智，但是就是这些弱智问题的 <span class="math inline">\(\mbox{Debug}\)</span> 很大程度影响了代码编写、维护以及（满足甲方需求）成功运行的总开发时长。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>可视化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python 可视化工作经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calculus_A2_notes_Chapter_three（WXF）</title>
    <link href="/2022/03/02/Math/Calculus/Calculus%20A2%20notes%EF%BC%88Chapter%20three%EF%BC%89/"/>
    <url>/2022/03/02/Math/Calculus/Calculus%20A2%20notes%EF%BC%88Chapter%20three%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="微积分第3讲笔记多元函数的导数与微分">微积分第3讲笔记（多元函数的导数与微分）</h1><p>对于一元函数的导数定义：<span class="math inline">\(f&#39;(x_0)=\lim\limits_{x\to x_0}\dfrac{f(x)-f(x_0)}{x-x_0}\)</span>，对于多元时 <span class="math inline">\(\mathbf{x}-\mathbf{x_0}\)</span> 是向量，无法成为分母。</p><p>解决方法 <span class="math inline">\(1\)</span>：沿向量求导 <span class="math inline">\(\partial _{\mathbf{v}}f(\mathbf{x}^*)=\lim\limits_{t\to 0}\dfrac{f(\mathbf{x}_0+t\mathbf{v})-f(\mathbf{x}_0)}{t}\)</span>，设 <span class="math inline">\(E\subseteq \mathbb{R}^m\)</span>，若 <span class="math inline">\(\exists\ \delta &gt;0,s.t.\forall \ \mathbf{x}\in \mathbb{R}^m,\|\mathbf{x}-\mathbf{x_0}\|&lt;\delta\Longrightarrow \mathbf{x}\in E\)</span>，称 <span class="math inline">\(\mathbf{x}_0\)</span> 为内点</p><p>对经过 $x^* $ 处斜率为 <span class="math inline">\(\vec{v}\)</span> 的任意曲线均成立 <span class="math inline">\(\partial_{\vec{v}} f(x^*)=Const,\ \mbox{for any curve }\)</span></p><p><strong>方向导数</strong>：（将 <span class="math inline">\(\vec{v}\)</span> 单位化，<strong>将导数定义在像空间</strong>） <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathbf{x}^*\)</span> 处沿着单位向量 <span class="math inline">\(\mathbf{v}\)</span> 所在方向的方向导数为 <span class="math display">\[\lim _{t \rightarrow 0^{+}} \frac{f\left(\mathbf{x}^{*}+t \mathbf{v}\right)-f\left(\mathbf{x}^{*}\right)}{t}=\lim _{\mathbf{x} \rightarrow \mathbf{x}^{*}} \frac{f(\mathbf{x})-f\left(\mathbf{x}^{*}\right)}{\left\|\mathbf{x}-\mathbf{x}^{*}\right\|}\]</span> 解决方法 <span class="math inline">\(1&#39;\)</span>：偏导数，<span class="math inline">\(\dfrac{\partial }{\partial x^{k}}f(x^{1},x^2,\cdots,x^{m})\)</span>，<span class="math inline">\(x=x^1\mathbf{v}_1+\cdots x^m\mathbf{v}_m\)</span>，则记 <span class="math display">\[\partial_{k} f\left(\mathbf{x}^{*}\right)=\frac{\partial f}{\partial x^{k}}\left(\mathbf{x}^{*}\right)=\partial_{\mathbf{v}_{k}} f\left(\mathbf{x}^{*}\right)=\lim _{t \rightarrow 0} \frac{f\left(\mathbf{x}^{*}+t \mathbf{v}_{k}\right)-f\left(\mathbf{x}^{*}\right)}{t}\]</span> 为 $f $ 在 <span class="math inline">\(x^*\)</span> 处对坐标架 <span class="math inline">\(x^{k}\)</span> 的偏导数</p><p>偏导数只能代表函数极少一部分性质（构造十字架“高高在上”，其余函数值在下方，该十字架在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 方向上偏导数都是 <span class="math inline">\(0\)</span> ，但是该十字架在交叉处不可导）</p><p>有一般情况下，<strong>坐标系是局部的、非线性的坐标系</strong></p><p>解决方法 <span class="math inline">\(2\)</span>：多元函数的原像空间是多维空间，多维空间并不是一些一维空间的简单汇集，其包含了无穷多个一维空间，且是无穷多个一维空间的有机结合</p><p>引入<strong>映射的可微性与微分</strong>（<strong>将导数定义为连接原空间和像空间的法则</strong>） ：设 <span class="math inline">\(E \subseteq \mathbb{R}^{m}, \mathrm{x}^{*}\)</span> 是 <span class="math inline">\(E\)</span> 的一个内点。 称 <span class="math inline">\(f: E \rightarrow \mathbb{R}^{p}\)</span> 在 <span class="math inline">\(\mathrm{x}^{*}\)</span> 处可微，如果存在线性映射 <span class="math inline">\(L: \mathbb{R}^{m} \rightarrow \mathbb{R}^{p}\)</span> (称为 <span class="math inline">\(f: E \rightarrow \mathbb{R}^{p}\)</span> 在 <span class="math inline">\(\mathbf{x}^{*}\)</span> 处的导数或微分, 记为 <span class="math inline">\(\mathrm{D} f\left(\mathbf{x}^{*}\right)\)</span> ）使得 <span class="math display">\[f\left(\mathbf{x}^{*}+\mathbf{v}\right)=f\left(\mathbf{x}^{*}\right)+L(\mathbf{v})+o(\|\mathbf{v}\|), \quad \mathbf{v} \rightarrow \mathbf{0} .\]</span> <span class="math inline">\(\left(p=1\right.\)</span> 时更常称为微分, 记为 <span class="math inline">\(\left.\mathrm{d} f\left(\mathbf{x}^{*}\right)\right)\)</span></p><p><strong>例</strong>：证明 <span class="math inline">\(\mbox{inv}:\mathcal{G L}(m) \rightarrow \mathcal{G L}(m), \quad \operatorname{inv}(A)=A^{-1}\)</span> 是可微映射，并求其微分。</p><p>由 <span class="math inline">\(\mbox{inv}(I-B)=I+C=I+B+CB\)</span>，其中 <span class="math inline">\(\|CB\|\leq \dfrac{\|B\|^2}{1-\|B\|}\to o(B)\)</span></p><p>则 <span class="math inline">\(\mbox{inv}(A_0+B)=(A_0(I+A_0^{-1}B))^{-1}=(I+A_0^{-1}B)^{-1}A_0^{-1}=(I-A_0^{-1}B+o(B))A_0^{-1}\)</span></p><p>从而其可微， <span class="math inline">\(\mbox{Dinv}(A_0)(B)=-A_0^{-1}BA_0^{-1}\)</span></p><p><span class="math inline">\(dx,dy,dz\)</span> 本质上是坐标线性函数，对于空间中任意一组基，<span class="math inline">\(\mathbf{v}_{1},\cdots ,\mathbf{v}_{m}\)</span>，取 <span class="math inline">\(\mathbf{v}^{*1},\cdots ,\mathbf{v}^{*m}\)</span> 为 <span class="math inline">\(\mathbf{v}_{1},\cdots ,\mathbf{v}_{m}\)</span> 的对偶基 <span class="math inline">\(\mathbf{v}^{*k}:\boldsymbol R^{m}\to \boldsymbol R\)</span> 为线性函数</p><p>可以推出 <span class="math inline">\(df(\mathbf{x}^*)=(\partial _1f\quad \cdots\quad \partial _mf)\begin{pmatrix}dx^1\\\vdots\\dx^{m}\end{pmatrix}\)</span></p><p>对于 <span class="math inline">\(df=\dfrac{\partial f}{\partial x}dx+\dfrac{\partial f}{\partial y}dy+\dfrac{\partial f}{\partial z}dz\)</span>，本质上是 <span class="math inline">\(df\)</span> 这个坐标函数可以写成 <span class="math inline">\(dx,dy,dz\)</span> 这三个坐标函数的线性组合</p><p>对行列式函数微分有 <span class="math inline">\(D \det(A)(B) = \tr(A^*B)\)</span>， <span class="math inline">\(\det(A+B)=\det(A)+\tr(A^*B),B\to 0\)</span></p><p>则定义 <span class="math inline">\(e\)</span> 的矩阵幂 <span class="math inline">\(e^{A}:=\displaystyle \sum_{n=0}^{\infty}\dfrac{A^n}{n!}\)</span>，考虑行列式函数 <span class="math inline">\(f(t)=\det (e^{tA})\)</span> <span class="math display">\[\dfrac{df(t)}{dt}=\lim\limits_{\Delta t \to 0}\dfrac{\det(e^{(t+\Delta t)A})-\det(e^{tA})}{\Delta t}=\lim\limits_{\Delta t \to 0}\dfrac{\det(e^{tA})\cdot (\det(e^{\Delta tA})-1)}{\Delta t}\]</span> 而 <span class="math inline">\(\det(e^{\Delta t A})\approx \det(I+\Delta tA)=1+\tr(A)\Delta t,\Delta t\to 0\)</span>，即 <span class="math inline">\(\det&#39;(e^{\Delta tA})=\tr(A)\)</span></p><p>则 <span class="math inline">\(\displaystyle \dfrac{df(t)}{dt}=\tr(A)\cdot \det(e^{tA})=\tr(A)f(t)\)</span>，该微分方程解为 <span class="math inline">\(f(t)=\det(e^{tA})=e^{t\tr(A)}\)</span></p><p>对极坐标 <span class="math inline">\(\begin{pmatrix}dx\\dy\end{pmatrix}=\hat{\rho}\begin{pmatrix}\cos \theta\\\sin \theta\end{pmatrix}+\rho \hat{\theta}\begin{pmatrix}-\sin \theta\\\cos \theta\end{pmatrix}\)</span>，代表坐标架的变换，这两个方向是正交的，但是长度不是单位的，有 <span class="math display">\[\mathbf{e}_{r}=\left[\begin{array}{c}\cos \theta \\\sin \theta\end{array}\right]\quad \mathbf{e}_{\theta}=\left[\begin{array}{c}-r \sin \theta \\r \cos \theta\end{array}\right]\]</span> <img src="../../../../../../AppData/Roaming/Typora/typora-user-images/image-20220307105416871.png" alt="image-20220307105416871" style="zoom:25%;" /></p><p>微分的形式不变性：对任意坐标系，<span class="math inline">\(du=\displaystyle \sum_{j=1}^{m}\partial _{x^{j}}udx^j=\displaystyle \sum_{j=1}^{m}\partial _{y^{j}}udy^j\)</span></p><p>梯度的定义：先对可以几何直观现实的情况：设<span class="math inline">\(L:\mathbb{R}^{m}\to R\)</span> 为线性映射，若 <span class="math inline">\(\forall \ \vec{v}\in \mathbb{R}^m\)</span>，都有 <span class="math inline">\(L(\vec{v})=\langle\vec{v}, \nabla L\rangle\)</span></p><p><img src="https://pic.imgdb.cn/item/622582ca5baa1a80abd6b01f.jpg" style="zoom:30%;" /></p><p>如图，由于已经规定 <span class="math inline">\(L\)</span> 是线性映射，其图像必然是 <span class="math inline">\(m+1\)</span> 维空间中的一个 <span class="math inline">\(m\)</span> 维“平面”。现取此“平面”与自变量“平面”（同样是 <span class="math inline">\(m\)</span> 维空间）的 <span class="math inline">\(m-1\)</span> “交线”，此“交线”也自然是“直线”。由于此 <span class="math inline">\(m-1\)</span> 维”交线“在 <span class="math inline">\(m\)</span> 维自变量空间中，在该空间中必然只有唯一一个方向与其垂直。<span class="math inline">\(\nabla L\)</span> 就在这个方向。由几何学可以知道，图像上任意一点的高度，等于其在自变量空间的投影向量与 <span class="math inline">\(\nabla L\)</span> 的内积与 <span class="math inline">\(\nabla L\)</span> 点对应的高度的乘积。</p><p><strong>可微函数的梯度</strong>：设 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathbf{x}^{*} \in E\)</span> 处可微, 称 <span class="math inline">\(\mathrm{d} f\left(\mathbf{x}^{*}\right)\)</span> 的梯度为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathbf{x}^{*} \in E\)</span> 处的梯度, 记为 <span class="math inline">\(\nabla f\left(\mathbf{x}^{*}\right)\)</span>, 即对任意向量 <span class="math inline">\(\mathbf{v}\)</span>, <span class="math display">\[\partial_{\mathbf{v}} f\left(\mathbf{x}^{*}\right)=\left\langle\mathbf{v}, \nabla f\left(\mathbf{x}^{*}\right)\right\rangle\]</span> 对以 <span class="math inline">\(\mathbf{v}_{1}, \ldots, \mathbf{v}_{m}\)</span> 为基的内积空间，要想求 <span class="math inline">\(\nabla f\left(\mathbf{x}^{*}\right)\)</span> 在这组基底下的坐标。设</p><p><span class="math display">\[\nabla f\left(\mathbf{x}^{*}\right)=c^{1} \mathbf{v}_{1}+\cdots+c^{m} \mathbf{v}_{m}, \quad \mathbf{v}=\xi^{1} \mathbf{v}_{1}+\cdots+\xi^{m} \mathbf{v}_{m}\]</span> 这里 <span class="math inline">\(\mathbf v\)</span> 是任意向量。则有 <span class="math inline">\(\left\langle\mathbf{v}, \nabla f\left(\mathbf{x}^{*}\right)\right\rangle=\sum_{1 \leq i, j \leq m} \xi^{i}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle c^{j}=\left(\xi^{1}, \ldots, \xi^{m}\right)\left(\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle\right)_{m \times m}\left(\begin{array}{c}c^{1} \\ \vdots \\ c^{m}\end{array}\right)\)</span> <span class="math inline">\(\mathrm{d} f\left(\mathbf{x}^{*}\right) \mathbf{v}=\partial_{1} f\left(\mathbf{x}^{*}\right) \xi^{1}+\cdots+\partial_{m} f\left(\mathbf{x}^{*}\right) \xi^{m}=\left(\xi^{1}, \ldots, \xi^{m}\right)\left(\begin{array}{c}\partial_{1} f\left(\mathbf{x}^{*}\right) \\ \vdots \\ \partial_{m} f\left(\mathbf{x}^{*}\right)\end{array}\right)\)</span></p><p>由梯度定义知以上两式应对任意 <span class="math inline">\(\xi^{1}, \ldots, \xi^{m}\)</span> 恒等, 所以 <span class="math display">\[\left(\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle\right)_{m \times m}\left(\begin{array}{c}c^{1} \\\vdots \\c^{m}\end{array}\right)=\left(\begin{array}{c}\partial_{1} f\left(\mathbf{x}^{*}\right) \\\vdots \\\partial_{m} f\left(\mathbf{x}^{*}\right)\end{array}\right)\]</span> 因此梯度的表达式： <span class="math display">\[\begin{aligned}\nabla f\left(\mathbf{x}^{*}\right) &amp;=\left(\mathbf{v}_{1}, \ldots, \mathbf{v}_{m}\right)\left(\begin{array}{c}c^{1} \\\vdots \\c^{m}\end{array}\right)=\left(\mathbf{v}_{1}, \ldots, \mathbf{v}_{m}\right)\left(\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle\right)_{m \times m}^{-1}\left(\begin{array}{c}\partial_{1} f\left(\mathbf{x}^{*}\right) \\\vdots \\\partial_{m} f\left(\mathbf{x}^{*}\right)\end{array}\right) \\&amp;=\sum_{i, j} g^{i j} \partial_{j} f \mathbf{v}_{i} \end{aligned}\]</span> 其中 <span class="math inline">\(\left(g^{i j}\right)_{m \times m}=\left(\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle\right)_{m \times m}^{-1}\)</span> ，为度量矩阵的逆。对于一般的 <span class="math inline">\(x,y,z\)</span> 坐标系，为单位矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>多元微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多元微积分笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calculus note for Chapter two</title>
    <link href="/2022/02/28/Math/Calculus/Calculus%20A2%20notes%20%EF%BC%88Chapter%20two%EF%BC%89/"/>
    <url>/2022/02/28/Math/Calculus/Calculus%20A2%20notes%20%EF%BC%88Chapter%20two%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="微积分笔记第二讲多元函数的极限">微积分笔记第二讲（多元函数的极限）</h1><p><strong>聚点</strong>：设 <span class="math inline">\(E\subseteq\mathbb{R}^{m}\)</span>，若 <span class="math inline">\(\forall \ \delta &gt; 0 ,\exists \ \mathbf{x}\in E,s.t.\|\mathbf{x}-\mathbf{x}^*\|&lt;\delta\)</span>，称 <span class="math inline">\(\mathbf{x}^*\)</span> 为 <span class="math inline">\(E\)</span> 的一个聚点。</p><p><strong>多元函数极限</strong>：设 <span class="math inline">\(\mathbf{x}^*\)</span> 为 <span class="math inline">\(E\)</span> 的一个聚点，对 <span class="math inline">\(A\in \mathbb{R}^p\)</span> 和映射 <span class="math inline">\(f:E\to \mathbb{R}^p\)</span>，有 <span class="math inline">\(\lim\limits_{\mathbf{x}\to \mathbf{x}^*}f(\mathbf{x})=A\)</span>，有 <span class="math display">\[\forall \varepsilon&gt;0, \exists \delta_{\varepsilon}&gt;0, s.t. \forall \mathbf{x} \in E, \textcolor{red}{0&lt;}\left\|\mathbf{x}-\mathbf{x}^{*}\right\|&lt;\delta_{\varepsilon} \Rightarrow\|f(\mathbf{x})-A\|&lt;\varepsilon \text {. }\]</span> <span class="math inline">\(\mathbf{x}^*\)</span> 甚至可以不再定义域内，依靠其他 <span class="math inline">\(\mathbf{x}\)</span> 逼近</p><p><strong>复合极限</strong>：（极限复杂度大于连续）<span class="math inline">\(\mathbf{a}\)</span> 和 <span class="math inline">\(\mathbf{b}\)</span> 分别为 <span class="math inline">\(E\)</span> 和 <span class="math inline">\(F\)</span> 的聚点，有 <span class="math inline">\(\lim\limits_{\mathbf{x}\to \mathbf{a}}=\mathbf{b}\)</span>，只有两种情况有 <span class="math inline">\(\lim\limits_{\mathbf{y}\to \mathbf{b}}g(f(\mathbf{x}))=A\)</span> <span class="math display">\[\begin{cases}g\ 在\ \mathbf{b} \ 连续, A=g(\mathbf{b})\\\lim\limits_{y\to \mathbf{b}}g(y)=A,且\ \textcolor{red}{f(\mathbf{x})\neq \mathbf{b},当\ \mathbf{x}\to \mathbf{a}}\end{cases}\]</span> 也就是要保证 <span class="math inline">\(g\)</span> 在 <span class="math inline">\(\mathbf{b}\)</span> 处不能“乱跳”</p><p><strong>例</strong>：求极限 <span class="math inline">\(\lim\limits_{(x,y)\to (0,0)}\dfrac{\ln(1+x^2+y^2)}{x^2+y^2}\)</span>，就只需要考虑 <span class="math inline">\(g(\rho)=\dfrac{\ln(1+\rho)}{\rho}\)</span>，有 <span class="math inline">\(\lim\limits_{\rho\to 0}g(\rho)=1\)</span>，且有 <span class="math inline">\(\rho=f(x,y)=x^2+y^2\neq0\)</span>，从而极限为 <span class="math inline">\(1\)</span></p><p><strong>例</strong>：求极限 <span class="math inline">\(\lim\limits_{(x,y)\to (1,0)}(x+y)^{\frac{x+y+1}{x+y-1}}\)</span>，有底数大于等于零以及分母不为 <span class="math inline">\(0\)</span>，考虑 <span class="math inline">\(g(z)=(1+z)^{\frac{z+2}{z}}\)</span>，且 <span class="math inline">\(f(z)=x+y-1\neq0\)</span>，<span class="math inline">\(\lim\limits_{z\to 0}g(z)=e^2\)</span>，从而极限为 <span class="math inline">\(e^2\)</span></p><p><strong>例</strong>：求极限 <span class="math inline">\(\lim\limits_{(x,y)\to (0,0)}x^y\)</span> ，令 <span class="math inline">\(x^{y}=e^{y\ln x}\)</span> ，该函数在定义域内处处连续，若构造一种 <span class="math inline">\(y=\dfrac{-1}{|\ln x|^{\alpha}}\)</span>，代入有 <span class="math display">\[\lim _{x \rightarrow 0^{+}} x^{\frac{-1}{|\ln x|^{\alpha}}}= \begin{cases}\mathrm{e}, &amp; \alpha=1 \\ +\infty, &amp; 0&lt;\alpha&lt;1 ; \\ 1, &amp; \alpha&gt;1\end{cases}\]</span> <strong>例</strong>：讨论极限 <span class="math inline">\(\lim\limits_{(x,y)\to (0,0)}\dfrac{2xy}{x^2+y^2}\)</span>，沿着曲线 <span class="math inline">\(y=Cx^{\alpha}(\alpha&gt;0,C\neq 0)\)</span></p><p>代入有 <span class="math display">\[\lim _{\left(x, C x^{\alpha}\right) \rightarrow(0,0)} \frac{2 x C x^{\alpha}}{x^{2}+C^{2} x^{2 \alpha}}= \begin{cases}0, &amp; \alpha&gt;0, \alpha \neq 1 \\ \dfrac{2 C}{1+C^{2}}, &amp; \alpha=1\end{cases}\]</span> 从而极限不存在，但其<strong>累次极限</strong>存在，且<strong>两种累次极限相等</strong> <span class="math display">\[\lim\limits_{x\to 0}\lim\limits_{y\to 0}\dfrac{2xy}{x+y^2}=\lim\limits_{y\to 0}\lim\limits_{x\to 0}\dfrac{2xy}{x+y^2}=0\]</span> <strong>例</strong>：讨论极限 <span class="math inline">\(\lim\limits_{(x,y)\to (0,0)}\dfrac{x^2+y^2}{x+y}\)</span>，沿着曲线 <span class="math inline">\(y=-x+Cx^{\alpha}(\alpha&gt;0,C\neq 0)\)</span>，这样将分母成为一个单独的项，有 <span class="math display">\[\lim _{\left(x,-x+C x^{\alpha}\right) \rightarrow(0,0)} \frac{x^{2}+\left(-x+C x^{\alpha}\right)^{2}}{C x^{\alpha}}= \begin{cases}\infty, &amp; \alpha&gt;2 \\ \frac{2}{C}, &amp; \alpha=2 \\ 0, &amp; 0&lt;\alpha&lt;2\end{cases}\]</span> 按一般思想应该是 <span class="math inline">\(0\)</span>，但是 <span class="math inline">\((x,y)\)</span> 的趋势可以任意构造，从而<strong>重极限</strong>不能直接借助一元微积分的经验，若分成多次过程，则称为<strong>累次极限</strong></p><p><strong>例</strong>：求极限 <span class="math inline">\(\lim\limits_{x\to 0,y\to \infty}(1+x)^{\frac{y+1}{xy}}\)</span>，代换 <span class="math inline">\(u=\dfrac{1}{y}\)</span>，有 <span class="math inline">\(x\to 0,y\to \infty\)</span>，当且仅当 <span class="math inline">\(x\to 0,u\to 0\)</span>，从而 <span class="math display">\[\lim\limits_{x\to 0,y\to \infty}(1+x)^{\dfrac{y+1}{xy}}=\lim\limits_{x,u\to 0}e^{\dfrac{\ln (1+x)}{x}\cdot \dfrac{1+u}{1}}=e^{1}=e\]</span> <strong>例</strong>：讨论 <span class="math inline">\(f(x,y)=\dfrac{x^2-y^2}{x^2+y^2}\)</span> 极限，其重极限不存在 ，这是由于 <span class="math inline">\(\lim\limits_{(x,kx)\to (0,0)}\dfrac{x^2-y^2}{x^2+y^2}=\dfrac{1-k^2}{1+k^2}\)</span> ，而两种累次极限不同 <span class="math inline">\(\lim\limits_{x\to 0}\lim\limits_{y\to 0}\dfrac{x^2-y^2}{x^2+y^2}=1,\lim\limits_{y\to 0}\lim\limits_{x\to 0}\dfrac{x^2-y^2}{x^2+y^2}=-1\)</span></p><p><strong>例</strong>：设 <span class="math inline">\(E=\{(x,y)\in \mathbb{R}^2 \mid \dfrac{|x|}{2}\leq |y|\leq 2|x|\},f:E\to R,f(x,y)=1\)</span>，二重极限存在 <span class="math inline">\(\lim\limits_{(x,y)\to (0,0)}f(x,y)=1\)</span>，但是 <span class="math inline">\(\lim\limits_{x\to 0}\lim\limits_{y\to 0}f(x,y)\)</span> 和 <span class="math inline">\(\lim\limits_{y\to 0}\lim\limits_{x\to 0}f(x,y)\)</span> 都不存在（无法定义）</p><p>更一般地，<strong>能交换顺序的极限都需要满足一定条件</strong>（累次极限、积分和求导）</p><p><strong>定理</strong>：如果 <span class="math inline">\(\lim\limits _{(x, y) \rightarrow(a, b)} f(x, y)\)</span> 和累次极限 <span class="math inline">\(\lim\limits _{y \rightarrow b} \lim\limits _{x \rightarrow a} f(x, y)\)</span> 都存在, 则二者的值相等。</p><p><strong>大 <span class="math inline">\(O\)</span> 和小 <span class="math inline">\(o\)</span> </strong>：（大 <span class="math inline">\(O\)</span> 是用一个常数“管制”，小 <span class="math inline">\(o\)</span> 可以用任意小的 <span class="math inline">\(\epsilon\)</span> “管制”）</p><p><strong>当 <span class="math inline">\(\mathbf{x}\to \mathbf{a}\)</span> 时，<span class="math inline">\(f=O(g)\)</span></strong>：存在 <span class="math inline">\(a\)</span> 的去心领域 <span class="math inline">\(U\)</span> 和常数 <span class="math inline">\(M&gt;0\)</span>，使得 <span class="math inline">\(\mathbf{x}\in U\)</span>，都有 <span class="math inline">\(\|f(\mathbf{x}\|\leq M\|g(\mathbf{x})\|\)</span></p><p><strong>当 <span class="math inline">\(\mathbf{x}\to \mathbf{a}\)</span> 时，<span class="math inline">\(f=o(g)\)</span></strong>：对 <span class="math inline">\(\forall \ \epsilon &gt;0\)</span>，存在 <span class="math inline">\(a\)</span> 的去心领域 <span class="math inline">\(U_\epsilon\)</span> ，使得 <span class="math inline">\(\mathbf{x}\in U\)</span>，都有 <span class="math inline">\(\|f(\mathbf{x}\|\leq \epsilon\|g(\mathbf{x})\|\)</span></p><p><strong>当 <span class="math inline">\(\mathbf{x}\to \mathbf{a}\)</span> 时，<span class="math inline">\(f,g\)</span> 同阶</strong>：<span class="math inline">\(f=O(g)\)</span> 且 <span class="math inline">\(g=O(f)\)</span></p><p><strong>当 <span class="math inline">\(\mathbf{x}\to \mathbf{a}\)</span> 时，<span class="math inline">\(f,g\)</span> 等价</strong>：<span class="math inline">\(g=f+o(f)\)</span></p><p>范数等价性可以表述为：对 <span class="math inline">\(\forall \ \|\cdot\|\)</span>，<span class="math inline">\(\|\mathbf{x}\|=O(\|\mathbf{x}\|_{\infty}),\|\mathbf{x}\|_{\infty}=O(\|\mathbf{x}\|\)</span></p><p><span class="math inline">\(\mathbb{R}^{m}\)</span> 上的所有范数都是同阶的</p><p>所有 <span class="math inline">\(k-\)</span>重线性映射 <span class="math inline">\(L\)</span>，都是一个 <span class="math inline">\(k-\)</span>次性，教材上使用 <span class="math inline">\(\lim\limits_{\rho\to 0}\dfrac{f(\mathbf{x})}{\rho^{k}}=C\neq0\)</span> 会出现问题</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>多元微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多元微积分笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thoughts on the first week of blog building</title>
    <link href="/2022/02/27/Thoughts%20on%20the%20first%20week%20of%20blog%20building/"/>
    <url>/2022/02/27/Thoughts%20on%20the%20first%20week%20of%20blog%20building/</url>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(2022\)</span> 年 <span class="math inline">\(2\)</span> 月 <span class="math inline">\(21\)</span> 日开始建成该博客，当前建成博客刚好一周，也算是<strong>一周纪念日</strong>。虽然还有很多东西需要优化，内容也需要多样化。感谢 <a href="https://zhaochenyang20.github.io/">学长</a> 给予我许多帮助，他列出如下清单，当前进度 <span class="math inline">\(3/9\)</span>，希望这学期完了之后把这些东西一一配好。</p><ul class="task-list"><li><input type="checkbox" disabled="" checked="" />设置密码</li><li><input type="checkbox" disabled="" checked="" />设置主题</li><li><input type="checkbox" disabled="" />设置置顶</li><li><input type="checkbox" disabled="" checked="" />设置数学公式</li><li><input type="checkbox" disabled="" checked="" />设置 <span class="math inline">\(\mbox{tags}\)</span></li><li><input type="checkbox" disabled="" checked="" />设置分类</li><li><input type="checkbox" disabled="" />设置访客地图</li><li><input type="checkbox" disabled="" checked="" />添加友链</li><li><input type="checkbox" disabled="" />添加 <span class="math inline">\(\mbox{about,utool}\)</span></li></ul><p>周末跟着学长 <span class="math inline">\(\mbox{process}\)</span> 了一些 <span class="math inline">\(\mbox{data}\)</span>，之后有时间的话把当中一些 <span class="math inline">\(\mbox{tricks}\)</span> 整理一下丢在昨天的博客里，现在首要任务是把“甲方”的图表拿出来。感觉把 <span class="math inline">\(\mbox{Python}\)</span> 运用到实际 <span class="math inline">\(\mbox{Project}\)</span> 当中收获和进步是很快的，这是无论做多少次小作业都学不到的。每次 <span class="math inline">\(\mbox{Error}\)</span> 的修正，每次 <span class="math inline">\(\mbox{Debug}\)</span> 的探索，每次 <span class="math inline">\(\mbox{Except}\)</span> 的处理，都让我增长不少。</p><p>周六早上开班会，为我们班集体的出色点赞！虽然我们班来自不同方向，但是我们也能凝聚在一起，共同交流进步。中午和下午写 <span class="math inline">\(\mbox{OOP}\)</span>，晚上吃了听涛园<strong>咖喱味的麻辣香锅</strong>，属实可口！然后晚上到三教和“甲方”交流，调环境，写 <span class="math inline">\(\mbox{Python}\)</span>，跑代码，终于赶在三教闭馆前搞定。</p><p>周日早八起来打乒乓，还比较冷，回来洗完澡后码代码，把 <span class="math inline">\(102\)</span> 张图表批量做出来了，出去吃午饭还比较暖和，下午睡了好一会儿，感觉还比较舒服。</p><p>博客的建立就是跟着学长学的，最开始以为就是传传文章就完了，但说真的，博客有很好的督促效果，自带 <span class="math inline">\(\mbox{push}\)</span> 属性，这一周的学习生活变得非常有规律，提前做完了好多事情，方便自主探索和课外拓展，相信这个博客能够一直更新下去，默默地守护着一些宝贵的回忆吧。</p><p>说起来也快到三月了，路边还有些许冰没有融化，但阳光还是比较明媚，从去年冬天到现在，寝室门外的树木一直光秃秃的，<strong>“春天还会远吗？”</strong>。从小生长在南方，也许没有真正地体会到万物复苏，也许没有真正看到无数生命在身边从无到有蓬勃生长的样子，希望自己也能像种子一样，顶住破土的压力，向上成长。</p>]]></content>
    
    
    <categories>
      
      <category>随想</category>
      
      <category>里程碑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客建成一周随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP-Homework-1</title>
    <link href="/2022/02/26/Program/OOP%20Homework%201/"/>
    <url>/2022/02/26/Program/OOP%20Homework%201/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程第一次作业">面向对象编程第一次作业</h1><p><strong>Object-Oriented Programming <span class="math inline">\(\bullet\)</span> Homework <span class="math inline">\(\mathbf{1}\)</span></strong></p><h2 id="摘要">摘要</h2><p>本次作业报告从模型、验证、复杂度分析三个层面，使用<span class="math inline">\(\mbox{Visual~Studio~2022}\)</span>编写具有面向对象特性的<span class="math inline">\(\mbox{C}++\)</span>程序，使用两种不同的算法，并实现了单一测试和自动化测试，同时记录对应消耗的时间。</p><p>结合数据规模<span class="math inline">\(10^{9}\)</span>，在自动化测试中，利用时间复杂度，对测得的消耗时间进行线性回归，预测了下组数据计算完成所需要的总时间，与实际测得时间吻合，并估计所有数据点<span class="math inline">\((10^{9})\)</span>全部测试完成所需要的时间（<span class="math inline">\(20\)</span>年左右）。 <strong>关键词:</strong> <span class="math inline">\(\mbox{OOP}\)</span>;模拟;高斯求和;复杂度分析;线性回归</p><h2 id="模型">模型</h2><h3 id="模拟求和">模拟求和</h3><p>对输入的正整数<span class="math inline">\(N(1\leq N\leq 10^{9})\)</span>，从最小的偶数<span class="math inline">\(2\)</span>开始遍历求和，直到大于<span class="math inline">\(N\)</span>为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Sum = <span class="hljs-number">0</span>;             <span class="hljs-comment">//初始化Sum为0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i+=<span class="hljs-number">2</span>)<span class="hljs-comment">//遍历每一个数</span><br>    Sum += i;<br></code></pre></td></tr></table></figure><p>计算不超过<span class="math inline">\(N\)</span>所有偶数之和的关键代码如上，注意由于<span class="math inline">\(\mbox{Sum}\)</span>不断地被修改，每次计算前均将其初始化为<span class="math inline">\(0\)</span></p><h3 id="高斯求和">高斯求和</h3><p>对上限<span class="math inline">\(10^{9}\)</span>，利用高斯求和法 <span class="math display">\[\displaystyle \sum_{i=1}^{5\times 10^{8}}2i=2\cdot \dfrac{i(i+1)}{2}\big |_{i=5\times 10^{8}}\approx 2.5\times 10^{17}\gg \mbox{max of (}\textcolor{blue}{int})\approx 2.147\times 10^{9}\]</span> 从而存储结果<span class="math inline">\(\mbox{Sum}\)</span>应选用<span class="math inline">\(\textcolor{blue}{long\ long}\)</span>数据类型，对输入数据<span class="math inline">\(\mbox{N}\)</span>分奇偶两种情况 <span class="math display">\[\mbox{Sum}=\begin{cases}\mbox{N is odd},\displaystyle \sum_{i=1}^{\frac{N-1}{2}}2i=\dfrac{N-1}{2}\cdot (\dfrac{N-1}{2}+1)=\dfrac{(N-1)(N+1)}{4}\\\mbox{N is even},\displaystyle \sum_{i=1}^{\frac{N}{2}}2i=\dfrac{N}{2}\cdot (\dfrac{N}{2}+1)=\dfrac{N(N+2)}{4}\end{cases}\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Sum = <span class="hljs-number">0</span>;             <span class="hljs-comment">//初始化Sum为0</span><br><span class="hljs-keyword">if</span> (N &amp; <span class="hljs-number">1</span>)<br>    Sum = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(N - <span class="hljs-number">1</span>) * (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(N + <span class="hljs-number">1</span>) / <span class="hljs-number">4</span>;<br><span class="hljs-keyword">else</span><br>    Sum = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)N * (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(N + <span class="hljs-number">2</span>) / <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>第二种方法对应关键代码如上，其中<span class="math inline">\(\mbox{if (N \&amp; 1)}\)</span>使用"与"的方法判断<span class="math inline">\(N\)</span>二进制表示的结尾数字，若为<span class="math inline">\(1\)</span>，则为奇数，对应第一种情况，反之亦然。</p><h3 id="类的定义">类的定义</h3><p>本次编程头文件<span class="math inline">\(SumOfEvenLessThanN.h\)</span>中类的定义以及对应方法如下，其中将输入数据<span class="math inline">\(N\)</span>和输出结果<span class="math inline">\(\mbox{Sum}\)</span>以及相关的时间放在<span class="math inline">\(\mbox{private}\)</span>内，其余构造函数、析构函数以及输入、方法计算、自动测试、预测时间相关函数头放在<span class="math inline">\(\mbox{public}\)</span>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SumOfEvenLessThanN</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> N;      <span class="hljs-comment">//输入数据</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> Sum;  <span class="hljs-comment">//输出结果</span><br>        <span class="hljs-type">bool</span> IsFirst;   <span class="hljs-comment">//是否使用第一种方法</span><br>        <span class="hljs-type">double</span> FirstTime;   <span class="hljs-comment">//法一需要的时间</span><br>        <span class="hljs-type">double</span> SecondTime;  <span class="hljs-comment">//法二需要的时间</span><br>        <span class="hljs-type">double</span> timelist[<span class="hljs-number">1000</span>];  <span class="hljs-comment">//时间列表</span><br>        <span class="hljs-type">double</span> LogSumOfSquareN[<span class="hljs-number">1000</span>];  <span class="hljs-comment">//对数基准</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">double</span> LastLogSumOfSquareN = <span class="hljs-number">18</span> * <span class="hljs-built_in">log</span>(<span class="hljs-number">10</span>);    <span class="hljs-comment">//预测所有时间对数常数</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">SumOfEvenLessThanN</span>();   <span class="hljs-comment">//构造函数</span><br>        ~<span class="hljs-built_in">SumOfEvenLessThanN</span>() &#123;&#125;<span class="hljs-comment">//析构函数</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Input</span><span class="hljs-params">()</span></span>;       <span class="hljs-comment">//输入</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FirstMethod</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//法一</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SecondMethod</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//法二</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowData</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//输出</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SingleTest</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//单点测试</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AutoTest</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//自动测试</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PredictCostTime</span><span class="hljs-params">(<span class="hljs-type">double</span> list[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> st)</span></span>;     <span class="hljs-comment">//预测下次运行时间</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowYearsOfTestAll</span><span class="hljs-params">(<span class="hljs-type">double</span> second)</span></span>;     <span class="hljs-comment">//预测计算所有数据需要花的时间</span><br>    &#125;;<br></code></pre></td></tr></table></figure><p>预测时间部分运用线性回归，对于样本<span class="math inline">\(\mbox{(x,y)}\)</span>​，其线性拟合公式如下： <span class="math display">\[\left\{\begin{array}{l}\hat{b}=\frac{\displaystyle \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)\left(y_{i}-\bar{y}\right)}{\displaystyle \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}}=\frac{\displaystyle \sum_{i=1}^{n} x_{i} y_{i}-n \bar{x} \bar{y}}{\displaystyle \sum_{i=1}^{n} x_{i}^{2}-n \bar{x}^{2}} \\\hat{a}=\bar{y}-\hat{b} \bar{x} .\end{array}\right.\]</span></p><h2 id="验证">验证</h2><p>本实验结合不同情况，编写两种测试，一种为输入<span class="math inline">\(1\sim 1\times 10^{9}\)</span>中某个整数进行测试，输出两种方法对应结果和所需要时间。另一种测试方式为自动测试，以<span class="math inline">\(10^{4}\)</span>为步长，将两种方法计算的结果进行比较并输出结果，截图如下：</p><h3 id="单点测试">单点测试</h3><p>在初始询问时输入<span class="math inline">\(\mbox{no}\)</span>进入单点测试模式，输入不同的数字给出对应结果：</p><p><img src="https://pic.imgdb.cn/item/622a1c305baa1a80ab53f38b.jpg" style="zoom:80%;" /></p><p>可以看出，对于第二种方法，计算时间<span class="math inline">\(&lt;0.001\mbox{s}\)</span>，几乎认为不占总时间。第一种方法计算时间随输入数据增加。</p><h3 id="自动测试">自动测试</h3><p>在初始询问时输入<span class="math inline">\(\mbox{yes}\)</span>进入自动化测试模式，以<span class="math inline">\(10^{4}\)</span>为步长使用两种方法判断对应结果是否相同，当计算结果相同时，对应输出<span class="math inline">\(\mbox{Right!}\)</span>，同时记录对应消耗的总时间进行进行对数线性拟合。</p><p>某次运行在控制台获取的部分数据如下表格所示，可以看出拟合预测下次时间与实际测得总时间基本吻合，误差在<span class="math inline">\(0.5\mbox{s}\)</span>之内，预测计算完成所有数据<span class="math inline">\((10^{9})\)</span>需要总时间稳定在<span class="math inline">\(18\)</span>年到<span class="math inline">\(21\)</span>年，基本不可能完成（笔记本平均寿命为<span class="math inline">\(10\)</span>年）。 <span class="math display">\[\small\begin{array}{|c|c|c|c|c|}\hline \text { 数据范围 } &amp; \text { 结果 } &amp; \text { 总时间 } &amp; \text { 预测下次时间 } &amp; \text { 预测计算完成 } 10^{9} \text { 需要总时间 } \\\hline 200000-210000 &amp; \text { Right! } &amp; 20.087 \mathrm{~s} &amp; 21.764 \mathrm{~s} &amp; 18 \text { years } 5 \text { months } 29 \text { days } 2.20994 \text { hours } \\\hline 210000-220000 &amp; \text { Right! } &amp; 22.086 \mathrm{~s} &amp; 23.871 \mathrm{~s} &amp; 18 \text { years } 10 \text { months } 8 \text { days } 20.2604 \text { hours } \\\hline 220000-230000 &amp; \text { Right! } &amp; 24.206 \mathrm{~s} &amp; 26.078 \mathrm{~s} &amp; 19 \text { years } 1 \text { months } 29 \text { days } 20.2625 \text { hours } \\\hline 230000-240000 &amp; \text { Right! } &amp; 26.409 \mathrm{~s} &amp; 28.383 \mathrm{~s} &amp; 19 \text { years } 5 \text { months } 8 \text { days } 21.9619 \text { hours } \\\hline 240000-250000 &amp; \text { Right! } &amp; 28.712 \mathrm{~s} &amp; 30.787 \mathrm{~s} &amp; 19 \text { years } 8 \text { months } 4 \text { days } 11.7022 \text { hours } \\\hline 250000-260000 &amp; \text { Right! } &amp; 31.102 \mathrm{~s} &amp; 33.287 \mathrm{~s} &amp; 19 \text { years } 10 \text { months } 16 \text { days } 4.11791 \text { hours } \\\hline 260000-270000 &amp; \text { Right! } &amp; 33.622 \mathrm{~s} &amp; 35.889 \mathrm{~s} &amp; 20 \text { years } 0 \text { months } 17 \text { days } 22.2443 \text { hours } \\\hline 270000-280000 &amp; \text { Right! } &amp; 36.225 \mathrm{~s} &amp; 38.590 \mathrm{~s} &amp; 20 \text { years } 8 \text { months } 16 \text { days } 23.5517 \text { hours } \\\hline 280000-290000 &amp; \text { Right! } &amp; 38.924 \mathrm{~s} &amp; 41.391 \mathrm{~s} &amp; 21 \text { years } 4 \text { months } 8 \text { days } 22.0112 \text { hours } \\\hline 290000-300000 &amp; \text { Right! } &amp; 41.732 \mathrm{~s} &amp; 44.291 \mathrm{~s} &amp; 21 \text { years } 2 \text { months } 26 \text { days } 2.99112 \text { hours } \\\hline 300000-310000 &amp; \text { Right! } &amp; 44.613 \mathrm{~s} &amp; 47.290 \mathrm{~s} &amp; 20 \text { years } 7 \text { months } 5 \text { days } 19.2841 \text { hours } \\\hline 310000-320000 &amp; \text { Right! } &amp; 47.605 \mathrm{~s} &amp; 50.388 \mathrm{~s} &amp; 20 \text { years } 8 \text { months } 10 \text { days } 14.1711 \text { hours } \\\hline 320000-330000 &amp; \text { Right! } &amp; 50.826 \mathrm{~s} &amp; 53.597 \mathrm{~s} &amp; 20 \text { years } 9 \text { months } 24 \text { days } 0.428567 \text { hours } \\\hline 330000-340000 &amp; \text { Right! } &amp; 53.963 \mathrm{~s} &amp; 56.900 \mathrm{~s} &amp; 20 \text { years } 10 \text { months } 26 \text { days } 18.043 \text { hours } \\\hline 340000-350000 &amp; \text { Right! } &amp; 57.171 \mathrm{~s} &amp; 60.296 \mathrm{~s} &amp; 20 \text { years } 11 \text { months } 18 \text { days } 15.4001 \text { hours } \\\hline 350000-360000 &amp; \text { Right! } &amp; 60.495 \mathrm{~s} &amp; 63.786 \mathrm{~s} &amp; 20 \text { years } 12 \text { months } 3 \text { days } 5.2781 \text { hours } \\\hline 360000-370000 &amp; \text { Right! } &amp; 63.897 \mathrm{~s} &amp; 67.369 \mathrm{~s} &amp; 21 \text { years } 0 \text { months } 5 \text { days } 14.4397 \text { hours } \\\hline 370000-380000 &amp; \text { Right! } &amp; 67.423 \mathrm{~s} &amp; 71.048 \mathrm{~s} &amp; 21 \text { years } 0 \text { months } 8 \text { days } 20.6017 \text { hours } \\\hline 380000-390000 &amp; \text { Right! } &amp; 71.036 \mathrm{~s} &amp; 74.822 \mathrm{~s} &amp; 21 \text { years } 0 \text { months } 8 \text { days } 4.89934 \text { hours } \\\hline 390000-400000 &amp; \text { Right! } &amp; 74.737 \mathrm{~s} &amp; 78.690 \mathrm{~s} &amp; 20 \text { years } 8 \text { months } 3 \text { days } 22.6821 \text { hours } \\\hline\end{array}\]</span></p><h2 id="分析">分析</h2><h3 id="复杂度">复杂度</h3><p>对于模拟求和法，由于每次加法为常数时间，需要计算次数大约为输入数据的一半，从而时间复杂度为<span class="math inline">\(O(\dfrac{N}{2})\sim O(n)\)</span>，而高斯求和法只涉及两次加减法和两次除法，其时间复杂度为<span class="math inline">\(O(2)+O(2)=O(1)\)</span>。两者空间复杂度均为<span class="math inline">\(O(1)\)</span>。</p><p>从实际测量的时间来看，两者的差异也是显著的，对于最大的数据点，前者耗时<span class="math inline">\(1\sim 2\)</span>秒，后者几乎不耗时。</p><h3 id="优缺点">优缺点</h3><p>显然，从耗时的角度，高斯求和法远远快于模拟求和法。但是从代码编写的角度来看，前者容易编写和维护，后者由于对奇数和偶数的情况需要分类讨论，增加推导数学公式难度，也不便于调试。</p><p>从而对于需要高性能计算的软件构件库，高斯求和法更加适合；若软件构件库数据规模量较小，则便于编写和维护的模拟求和法更加适合。</p><h3 id="线性拟合过程">线性拟合过程</h3><p>由于<span class="math inline">\(t_{\mbox{高斯}}\ll t_{\mbox{模拟}}\)</span>，则总时间由后者决定，又由于时间复杂度为<span class="math inline">\(O(n)\)</span>，则对于步长<span class="math inline">\(a=10^{4}\)</span>来说，总时间消耗为常数时间乘上<span class="math inline">\(\displaystyle \sum_{i=1}^{an}i=\dfrac{an(an+1)}{2}\sim \dfrac{a^2}{2}n^2\)</span>，即正比于<span class="math inline">\(n^2\)</span> <span class="math display">\[T\sim An^2\Longrightarrow \ln T=\ln A +k\ln (n^2)\]</span> 将<span class="math inline">\(\ln (n^2)\)</span>看作自变量<span class="math inline">\(x\)</span>，<span class="math inline">\(ln T\)</span>看作因变量，进行线性拟合，若输出<span class="math inline">\(k\)</span>，可以发现<span class="math inline">\(k\longrightarrow 1\)</span>，与理论相吻合，并用获得的<span class="math inline">\(\ln A\)</span>和<span class="math inline">\(k\)</span>预测<span class="math inline">\(n+1\)</span>组的时间以及<span class="math inline">\(n=10^{9}\)</span>的时间，结果在"预测"部分已经体现。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>面向对象编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象编程作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Concrete Mathematics Chapter one note</title>
    <link href="/2022/02/25/Math/Concrete%20Mathematics%20Chapter%20one%20note/"/>
    <url>/2022/02/25/Math/Concrete%20Mathematics%20Chapter%20one%20note/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-1-recurrent-problem">Chapter 1 Recurrent problem</h1><p>For <strong>Hanoi problem</strong>, consider the largest disk must be moved when the <span class="math inline">\(n-1\)</span> disks on it were moved. And once <span class="math inline">\(T_{n-1}\)</span> times are down, we must at least move the largest one once and do another <span class="math inline">\(T_{n-1}\)</span> times to make it. Hence: <span class="math display">\[T_{n}\geq2T_{n-1}+1\]</span> Apparently we can give a structure to suit this <span class="math inline">\(T_n\)</span> , so recurrence <span class="math inline">\(T_n=2T_{n-1}+1\)</span>, then <span class="math inline">\(T_n=2^n-1\)</span></p><p>For <strong>Lines-in-the-plane problem</strong>, consider nth line can intersect <span class="math inline">\(n-1\)</span> common points, and these points divide this line into <span class="math inline">\(n\)</span> parts, each part gives one more region. Hence: <span class="math display">\[L_n\leq L_{n-1}+n\]</span> Combined with boundary value, so <span class="math inline">\(L_n=\dfrac{n(n+1)}{2}+1\\\)</span></p><p>For <strong>Zigs-in-the-plane problem</strong>, if extend the sharp side, we have <span class="math inline">\(Z&#39;_{n}=L_{2n}=2n^2+n+1\)</span>, but because of the sharps, the ideal situation is each sharp lose two regions. So <span class="math inline">\(Z_n=Z&#39;_{n}-2\cdot n=2n^2-n+1\)</span></p><p>For <strong>Josephus problem</strong>, assume the order of the death is <span class="math inline">\(2\)</span>. Consider <span class="math inline">\(1,2,\dots ,2n\)</span>, after first round the circle leave <span class="math inline">\(1,3,\cdots ,2n-1\)</span>, and each correspond to the n-people situation, hence: <span class="math display">\[J_{2n}=2J_{n}-1\]</span> This equation gives that <span class="math inline">\(J_{2^n}\equiv1\)</span>, when the number of people is the power of <span class="math inline">\(2\)</span>, the first guy is lucky. And consider <span class="math inline">\(1,2,\cdots ,2n,2n+1\)</span>, after first round it remains <span class="math inline">\(3,5,\cdots ,2n+1\)</span>, each correspond to the n-people situation, hence:</p><p><span class="math display">\[J_{2n+1}=2J_{n}+1\]</span> And define <span class="math inline">\(m\triangleq \lfloor log_2 n\rfloor\)</span> , so <span class="math inline">\(l\triangleq n-2^m\in[0,\dfrac{n}{2})\)</span>, and after <span class="math inline">\(l\)</span> times the number is power of 2 and the first guy that is currently pointed is lucky. Hence: <span class="math display">\[J_{n}=2l+1=2(n-2^{\lfloor log_2 n \rfloor})+1\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">BinarySolutionToJosephusTwo</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a)</span> </span>&#123;<span class="hljs-comment">//time complexity O(logn)</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> A = a;<br>    <span class="hljs-keyword">while</span> ((A &amp; (A - <span class="hljs-number">1</span>)) != <span class="hljs-number">0</span>)<span class="hljs-comment">//get the first 1</span><br>        A &amp;= (A - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> ((a - A) &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>To generalize it, we assume that <span class="math inline">\(f(j)=\alpha_j(1\leq j&lt;d)\)</span> and <span class="math display">\[f(dn+j)=cf(n)+\beta_j(0\leq j\]</span> Use base system, the result is: <span class="math display">\[f((b_mb_{m-1}\cdots b_1b_0)_d)=(\alpha_{b_m}\beta_{b_{m-1}}\beta_{b_{m-2}}\cdots \beta_{b_1}\beta_{b_0})_c\]</span> Beautiful proof of <strong>AGM</strong>(Arithmetic-Geometric-Mean inequality), let <span class="math inline">\(P(n)\)</span> means when there are n numbers is true: <span class="math display">\[P(2)\ is\ true ,P(n)\to P(n-1),P(n)\ and \ P(2)\to P(2n)\]</span> <strong>repertoire method</strong>: Use undetermined function method to solve recurrent problem, for instance <span class="math display">\[\begin{aligned}&amp;R_{0}=\alpha \\&amp;R_{n}=2R_{n-1}+\beta n+\gamma\end{aligned}\]</span> Set <span class="math inline">\(R_{n}=A(n) \alpha+B(n) \beta+C(n) \gamma\)</span>, use some special situations to get <span class="math inline">\(A(n),B(n),C(n)\)</span> <span class="math display">\[\begin{cases}R_{n}=1\Longrightarrow \alpha=1,\gamma=-1,\beta=0\Longrightarrow A(n)-C(n)=1\\R_{n}=n\Longrightarrow \alpha=0,n=2\cdot (n-1)+\beta n+\gamma,\beta=-1,\gamma=2\Longrightarrow2C(n)-B(n)=n\\R_{n}=2^n\Longrightarrow \alpha=1,2^n=2\cdot 2^{n-1}+\beta n+\gamma\Longrightarrow\beta=\gamma=0\Longrightarrow A(n)=2^{n}\end{cases}\]</span> Solution <span class="math inline">\(\begin{cases}A(n)=2^n\\B(n)=2^{n+1}-n-2\\C(n)=2^{n}-1\end{cases}\)</span>, then <span class="math inline">\(R_{n}=(\alpha+2\beta+\gamma)2^{n}-\beta n-(2\beta+\gamma)\)</span></p><p><span class="math inline">\(n\)</span> planes divide the three dimensions space into <span class="math inline">\(\large C_{n}^{0}+C_{n}^{1}+C_{n}^{2}+C_{n}^{3}\)</span> pieces at most.</p><p>consider <span class="math inline">\(T_{n}\)</span> and <span class="math inline">\(T_{n-1}\)</span>, the pieces that are added is <span class="math inline">\(n-1\)</span> lines that cut the new plane, so that <span class="math display">\[T_{n}=T_{n-1}+\large C_{n-1}^{0}+C_{n-1}^{1}+C_{n-1}^{2}\]</span> So we can guess that when the super-plane is <span class="math inline">\(d-1\)</span> dimensions, then <span class="math inline">\(n\)</span> super-planes cut the <span class="math inline">\(d\)</span> dimensions space into <span class="math inline">\(\displaystyle \sum_{k=0}^{d}\large C_{n}^{i}\)</span> pieces at most.</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>具体数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>具体数学笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calculus_A2_notes_Chapter_one（WXF）</title>
    <link href="/2022/02/23/Math/Calculus/Calculus%20A2%20notes%EF%BC%88first%20week%EF%BC%89/"/>
    <url>/2022/02/23/Math/Calculus/Calculus%20A2%20notes%EF%BC%88first%20week%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="微积分笔记第一讲多元函数的连续性">微积分笔记第一讲（多元函数的连续性）</h1><p>函数图像：对应规则，公式，图像（二元函数需要使用三维空间），等值集</p><p>函数值/映射的像可以是数、点、向量等等</p><p>连续性（局部可以使用常值近似），可微性质（局部可以使用线性逼近）</p><p>例：欧式空间 <span class="math inline">\(R^n\)</span> 中三个点 <span class="math inline">\(P_1,P_2,P_3\)</span> 确定的三角形面积函数 <span class="math inline">\(S(P_1,P_2,P_3)\)</span> 多元函数，对内积产生的 <span class="math inline">\(\cos \theta\)</span> 计算 <span class="math display">\[\begin{gathered}S(P_{1}, P_{2}, P_{3})=\frac{1}{2}|P_{2}-P_{1}||P_{3}-P_{1}| \sin \theta=\frac{1}{2}|P_{2}-P_{1}||P_{3}-P_{1}| \sqrt{1-\cos ^{2} \theta} \\=\frac{1}{2}|P_{2}-P_{1}||P_{3}-P_{1}| \sqrt{1-(\frac{(P_{2}-P_{1}) \cdot(P_{3}-P_{1})}{|(P_{2}-P_{1})| \cdot|(P_{3}-P_{1})|})^{2}} \\=\frac{1}{2} \sqrt{\operatorname{det}(\begin{array}{cc}\langle P_{2}-P_{1}, P_{2}-P_{1}\rangle &amp; \langle P_{2}-P_{1}, P_{3}-P_{1}\rangle \\\langle P_{2}-P_{1}, P_{3}-P_{1}\rangle &amp; \langle P_{3}-P_{1}, P_{3}-P_{1}\rangle\end{array})}\end{gathered}\]</span> 使用固定两点，另外一点在一个椭圆上移动可知，当这个点在固定点中垂线上的时候三角形面积最大，有两边长度相等，更换固定点得，<strong>周长一定的三角形为等边三角形时最大</strong>。该论证有一定问题，<strong>没有证明有最大值</strong>的情况。固定 <span class="math inline">\(P_1\)</span> 为原点，考虑所有周长小于等于 <span class="math inline">\(L\)</span> 的集合 <span class="math display">\[K=\{(P_{2}, P_{3}) \in \mathbb{R}^{2} \times \mathbb{R}^{2} \mid\|P_{2}\|+\|P_{3}\|+\|P_{2}-P_{3}\| \leq L\}\]</span> 则 <span class="math inline">\(K\)</span> 是有界闭集，从而 <span class="math inline">\(S(P_{2}, P_{3})\)</span> 在 <span class="math inline">\(K\)</span> 上取得最大值 <span class="math inline">\(S(P_{2}^{*}, P_{3}^{*})\)</span> 。假若 <span class="math display">\[\|P_{2}^{*}\|+\|P_{3}^{*}\|+\|P_{2}^{*}-P_{3}^{*}\|&lt;L\]</span> 取 <span class="math inline">\(\lambda=\dfrac{L}{\|P_{2}^{*}\|+\|P_{3}^{*}\|+\|P_{2}^{*}-P_{3}^{*}\|}, P_{k}^{&#39;}=\lambda P_{k}^{*}\)</span>，显然面积变成原来的 <span class="math inline">\(\lambda^2\)</span> 倍。这与 <span class="math inline">\(S(P_{2}^{*}, P_{3}^{*})\)</span> 是最大值矛盾。因此</p><p><span class="math display">\[\left\|P_{2}^{*}\right\|+\left\|P_{3}^{*}\right\|+\left\|P_{2}^{*}-P_{3}^{*}\right\|=L\]</span> 上标为维数的区分，下标为同一维数不同点的区分，对 <span class="math inline">\(P_{1},P_{2},P_{3}\)</span> 中 <span class="math inline">\(\mathbf x_{1,2,3}^j\)</span> <span class="math display">\[S(P_1,P_2,P_3)=\frac{1}{2} \sqrt{\sum_{1\leq i&lt;j \leq n}\left|\begin{array}{cc}\mathbf x_{2}^{i}-\mathbf x_{1}^{i} &amp; \mathbf x_{3}^{i}-\mathbf x_{1}^{i} \\ \mathbf x_{2}^{j}-\mathbf x_{1}^{i} &amp; \mathbf x_{3}^{j}-\mathbf x_{1}^{j}\end{array}\right|^{2}}=\frac{1}{2} \sqrt{\sum_{1\leq i&lt;j \leq n}\left|\begin{array}{ccc}1&amp;1&amp;1\\ \mathbf x_{1}^{i} &amp; \mathbf x_{2}^{i} &amp; \mathbf x_{3}^{i} \\ \mathbf x_{1}^{j} &amp; \mathbf x_{2}^{j} &amp; \mathbf x_{3}^{j}\end{array}\right|^{2}}\]</span> <strong>（向量值）函数：</strong>映射 <span class="math inline">\(f:A\to R^{\ p}\)</span>，<span class="math inline">\(f(\mathbf x)=(f^1(\mathbf x),f^2(\mathbf x),\cdots,f^p(\mathbf x))\)</span></p><p>其中 <span class="math inline">\(f^{k}:A\to R\)</span> 是函数，将 <span class="math inline">\(f(\mathbf x)\in R^{p}\)</span> 映射后的向量“作用点”附着于<span class="math inline">\(\mathbf x\)</span> 处，称为<strong>数量场</strong>（物理中称为<strong>纯量场</strong>）</p><p><strong>等值集</strong>：<span class="math inline">\(\Sigma_{\mathbf{y}}=f^{-1}(\mathbf{y})=\{\mathbf{\mathbf x} \in A \mid {f(\mathbf{\mathbf x})}=\mathbf{y}\}\)</span></p><p>微积分的一个目标是通过局部线性近似来研究函数，所以需要空间是向量空间（线性空间）或者局部近似的空间（微分流形）</p><p><strong>距离</strong>，满足对称，正定，三角形不等式，可以度量两个点的远近程度。： <span class="math display">\[\begin{gathered}\text { (对称) } \quad d(\mathbf{x}, \mathbf{y})=d(\mathbf{y}, \mathbf{x}) \\\text { (正定) } \quad d(\mathbf{x}, \mathbf{y}) \geq 0, \forall \mathbf{x}, \mathbf{y} \in R^{m}, d(\mathbf{x}, \mathbf{y})=0 \Longleftrightarrow \mathbf{x}=\mathbf{y} \\\text { (三角形不等式) } \quad \forall \mathbf{x}, \mathbf{y}, \mathbf{z} \in R^{m}, d(\mathbf{x}, \mathbf{y}) \leq d(\mathbf{x}, \mathbf{z})+d(\mathbf{z}, \mathbf{y})\end{gathered}\]</span> 若 <span class="math inline">\(d(\mathbf x+\mathbf z,\mathbf y+\mathbf z)=d(\mathbf x,\mathbf y),\forall \mathbf x,\mathbf y,\mathbf z\in R^m\)</span>，称为距离 <span class="math inline">\(d\)</span> 是<strong>平移不变</strong>的</p><p><strong>范数</strong>，满足正定，三角形不等式，正齐次性，范数可以度量向量的“长度”： <span class="math display">\[\begin{gathered}(\text { 正定 }) \quad\|\mathbf{x}\| \geq 0, \forall \mathbf{x} \in R^{m},\|\mathbf{x}\|=0 \Longleftrightarrow \mathbf{x}=0 \\\text { (三角形不等式) } \quad \forall \mathbf{x}, y, z \in R^{m},\|\mathbf{x}+y\| \leq\|\mathbf{x}\|+\|y\| \\\text { (正齐次性) } \quad \forall \mathbf{x} \in R^{m}, \forall \lambda \in R,\|\lambda \mathbf{x}\|=|\lambda|\|\mathbf{x}\|\end{gathered}\]</span> 范数和凸集一一对应 <span class="math inline">\(\{x\mid \|x\|\leq 1\}\Longleftrightarrow 凸\)</span></p><p><strong>内积</strong>，满足对称，正定，双线性： <span class="math display">\[\begin{gathered}\text { (对称) } \quad\langle\mathbf{x}, \mathbf{y}\rangle=\langle\mathbf{y}, \mathbf{x}\rangle \\\text { (正定) } \quad\langle\mathbf{x}, \mathbf{x}\rangle \geq 0, \forall x \in R^{m},\langle\mathbf{x}, \mathbf{x}\rangle=0 \Longleftrightarrow \mathbf{x}=0 \\\text { (双线性) } \quad \forall \mathbf{x}, \mathbf{y}, \mathbf{z} \in R^{m},\langle\lambda \mathbf{x}+\mu \mathbf{y}\rangle=\lambda\langle\mathbf{x}\rangle+\mu\langle\mathbf{y}\rangle\end{gathered}\]</span> 代表方向长度，可以计算面积体积之类的度量</p><p><strong>p-范数</strong>：<span class="math inline">\(\displaystyle \|\mathbf{\mathbf x}\|_{p}=\left(\sum_{i=1}^{m}\left|\mathbf x^{i}\right|^{p}\right)^{\frac{1}{p}}\)</span>，对应可以定义一个平移不变的距离 <span class="math inline">\(\displaystyle \|d_{p}(\mathbf x,\mathbf y)\|=\left(\sum_{i=1}^{m}\left|\mathbf x^{i}-\mathbf y^{i}\right|^{p}\right)^{\frac{1}{p}}\)</span>，当</p><p><span class="math inline">\(p=2\)</span> 时，为欧几里得距离；当 <span class="math inline">\(p=1\)</span> 时为<strong>曼哈顿距离</strong>或<strong>出租车距离</strong>；当 <span class="math inline">\(p\to +\infty\)</span> 时，</p><p><span class="math inline">\(d_{p}(\mathbf x,\mathbf y)\to \underset{1\leq i\leq m}{max}|{\mathbf x^i-\mathbf y^i}|=d_{\infty}(\mathbf x,\mathbf y)\)</span>，对范数也可定义无穷范数 <span class="math inline">\(\|\mathbf x\|_{\infty}=\underset{1\leq i\leq m}{\max}|x^{i}|\)</span></p><p>图一展示了 <span class="math inline">\(p\geq 1\)</span> 的情形，对应凸集；图二展示了 <span class="math inline">\(p&lt;1\)</span> 的情形，对应凹集</p><p><img src="https://pic.imgdb.cn/item/6216283c2ab3f51d91032dd2.jpg" title="图一" style="zoom:45%;" /><img src="https://pic.imgdb.cn/item/621349b82ab3f51d91dbbfb3.png" title="图二" style="zoom:33%;" /></p><p><span class="math inline">\(\|\mathbf{\mathbf x}\|_{\infty} \leq\|\mathbf{\mathbf x}\|_{p} \leq m^{\frac{1}{p}}\|\mathbf{\mathbf x}\|_{\infty}\)</span>，在有限维空间下，对 <span class="math inline">\(R^m\)</span> 的任意范数均有 <span class="math display">\[\begin{aligned}\|\mathbf{\mathbf x}\| &amp;=\left\|\mathbf x^{1} \mathbf{e}_{1}+\cdots+\mathbf x^{m} \mathbf{e}_{m}\right\| \leq \left|\mathbf x^{1}\right|\left\|\mathbf{e}_{1}\right\|+\cdots+\left|\mathbf x^{m}\right|\left\|\mathbf{e}_{m}\right\| \\ &amp; \leq \max_{1\leq k \leq m}\left|\mathbf x^{k}\right|\left(\left\|\mathbf{e}_{1}\right\|+\cdots+\left\|\mathbf{e}_{m}\right\|\right|=M\|\mathbf{\mathbf x}\|_{\infty} . \end{aligned}\]</span> 则通过 <span class="math inline">\(\mbox{Cauchy}\)</span> 收敛准则可知，在 <span class="math inline">\(\mathbb{R}^{m}\)</span> 中，有界，收敛，极限这些概念与范数的选取无关。可以任意选取范数验证相关 <span class="math inline">\(\epsilon -\delta\)</span> 语言</p><p><strong>多元函数连续</strong>：设 <span class="math inline">\(E\subseteq R^m,\forall \ \epsilon &gt;0,\exists \ \delta_{\epsilon}&gt;0,s.t.\mathbf x\in E,\|\mathbf x-\mathbf a\|&lt;\delta_{\epsilon}\Longrightarrow \|f(\mathbf x)-f(\mathbf a)|&lt;\epsilon\)</span></p><p>则称 <span class="math inline">\(f:E\to R^n\)</span> 在 <span class="math inline">\(\mathbf a\in E\)</span> 处连续</p><p>常值映射，两个连续函数的复合映射，线性映射，<span class="math inline">\(k-\)</span>重线性映射都是连续映射</p><p>例：<strong>任何双线性映射 <span class="math inline">\(B\)</span>：<span class="math inline">\(\mathbb{R}^{m} \times \mathbb{R}^{n} \rightarrow \mathbb{R}^{p}\)</span> 都是连续映射</strong>。对两空间的基底和多元函数放缩得 <span class="math display">\[\begin{aligned}\|B(\mathbf{x}, \mathbf{y})\| &amp;=\left\|\sum_{i, j} x^{i} y^{j} B\left(\mathbf{e}_{i}, \mathbf{f}_{j}\right)\right\| \leq \sum_{i, j} \mid x^{i}\left\|y^{j}\right\| B\left(\mathbf{e}_{i}, \mathbf{f}_{j}\right) \| \\ &amp; \leq\|\mathbf{x}\|_{\infty}\|\mathbf{y}\|_{\infty} \sum_{i, j}\left\|B\left(\mathbf{e}_{i}, \mathbf{f}_{j}\right)\right\|=M\|\mathbf{x}\|_{\infty}\|\mathbf{y}\|_{\infty} \end{aligned}\]</span> 从而替换为无穷范数得 <span class="math display">\[\begin{aligned}&amp;\left\|B(\mathbf{x}, \mathbf{y})-B\left(\mathbf{x}_{0}, \mathbf{y}_{0}\right)\right\| \\\leq &amp;\left\|B\left(\mathbf{x}-\mathbf{x}_{0}, \mathbf{y}-\mathbf{y}_{0}\right)\right\|+\left\|B\left(\mathbf{x}-\mathbf{x}_{0}, \mathbf{y}_{0}\right)\right\|+\left\|B\left(\mathbf{x}_{0}, \mathbf{y}-\mathbf{y}_{0}\right)\right\| \\\leq &amp; M\left(\left\|\mathbf{x}-\mathbf{x}_{0}\right\|_{\infty}\left\|\mathbf{y}-\mathbf{y}_{0}\right\|_{\infty}+\left\|\mathbf{x}-\mathbf{x}_{0}\right\|_{\infty}\left\|\mathbf{y}_{0}\right\|_{\infty}+\left\|\mathbf{x}_{0}\right\|_{\infty}\left\|\mathbf{y}-\mathbf{y}_{0}\right\|_{\infty}\right) .\end{aligned}\]</span> 对任意 <span class="math inline">\(\varepsilon&gt;0\)</span>, 当 <span class="math display">\[\max \left\{\left\|\mathbf{x}-\mathbf{x}_{0}\right\|_{\infty},\left\|\mathbf{y}-\mathbf{y}_{0}\right\|_{\infty}\right\}&lt;\frac{\varepsilon}{\varepsilon+3 M\left(1+\left\|\mathbf{y}_{0}\right\|_{\infty}+\left\|\mathbf{x}_{0}\right\|_{\infty}\right)}\]</span> 时, <span class="math inline">\(\left\|B(\mathbf{x}, \mathbf{y})-B\left(\mathbf{x}_{0}, \mathbf{y}_{0}\right)\right\|&lt;\varepsilon_{0}\)</span> 所以 <span class="math inline">\(B\)</span> 是连续映射。</p><p><strong>有界闭集上的连续映射</strong>：称 <span class="math inline">\(E \subseteq \mathbb{R}^{m}\)</span> 是一个闭子集, 如果点列 <span class="math inline">\(\left\{\mathbf {x}_{n}\right\}\)</span> 满足对任意 <span class="math inline">\(n \geq 1\)</span>, <span class="math inline">\(\mathbf{x}_{n} \in E\)</span>, 且 <span class="math inline">\(\lim\limits_{n\to+\infty}\mathbf{x}_{n}=\mathbf{x}^{*}\)</span>, 则 <span class="math inline">\(\mathbf{x}^{*} \in E\)</span> 。(E对极限封闭)</p><p>对称线性变换的特征值和特征向量，<strong>对称</strong>：<span class="math inline">\(\langle Ax,y \rangle=\langle x,Ay \rangle\)</span>（内积可置换性）</p><p><span class="math inline">\(\mathbf{v}_1\)</span> 对应最大值，任取与 <span class="math inline">\(\mathbf{v}_1\)</span> 正交的单位向量 <span class="math inline">\(\mathbf{u}\in K\)</span>，则考虑 <span class="math inline">\(g(\theta)=f(\cos \theta\mathbf{v}_1+\sin \theta\mathbf{u})\)</span> <span class="math display">\[\begin{aligned}g(\theta) &amp;=\left\langle A\left(\cos \theta \mathbf{v}_{1}+\sin \theta \mathbf{u}\right), \cos \theta \mathbf{v}_{1}+\sin \theta \mathbf{u}\right\rangle \\&amp;=\cos ^{2} \theta f\left(\mathbf{v}_{1}\right)+\sin ^{2} \theta f(\mathbf{u})+2 \sin \theta \cos \theta\left\langle A \mathbf{v}_{1}, \mathbf{u}\right\rangle \\&amp;=g(0)+2 \theta\left\langle A \mathbf{v}_{1}, \mathbf{u}\right\rangle+o(\theta), \quad \theta \rightarrow 0\end{aligned}\]</span> <span class="math inline">\(g&#39;(0)=2\langle A \mathbf{v}_{1}, \mathbf{u}\rangle=0\)</span></p><p>由于行列式函数连续，从而对任意可逆实数方阵 <span class="math inline">\(A\)</span>，总存在 <span class="math inline">\(\delta(A)&gt;0\)</span>，当 <span class="math inline">\(\|A-B\|&lt;\delta\)</span> 时，<span class="math inline">\(B\)</span> 也可逆</p><p>对行列式函数是连续的，非零量“微扰”后也为非零量，进而可逆</p><p>压缩映射原理（地图纸和现实世界存在唯一的点恰好不动）：设 <span class="math inline">\(E \subseteq \mathbb{R}^{m}\)</span> 是一个闭子集, 映射 <span class="math inline">\(f: E \rightarrow \mathbb{R}^{m}\)</span> 满足 <span class="math inline">\(f(E) \subseteq E\)</span>, 且存在常数 <span class="math inline">\(0&lt;\lambda&lt;1\)</span> 使得 <span class="math display">\[\|f(\mathbf{x})-f(\mathbf{y})\| \leq \lambda\|\mathbf{x}-\mathbf{y}\|, \quad \forall\  \mathbf{x}, \mathbf{y} \in E .\]</span> 则存在唯一的 <span class="math inline">\(\mathbf{x}^{*} \in E\)</span> 使得: <span class="math inline">\(f\left(\mathbf{x}^{*}\right)=\mathbf{x}^{*}\)</span>, 且对任意 <span class="math inline">\(\mathbf{x} \in E\)</span>, 迭代点列 <span class="math inline">\(\mathbf{x}_{n}=f^{n}(\mathbf{x})\)</span> 收敛到 <span class="math inline">\(\mathbf{x}^{*}\)</span> <span class="math display">\[\begin{aligned}\left\|\mathbf{x}_{n+p}-\mathbf{x}_{n}\right\| &amp; \leq \sum_{k=1}^{p}\left\|\mathbf{x}_{n+k}-\mathbf{x}_{n+k-1}\right\| \leq \sum_{k=1}^{p} \lambda^{n+k-1}\|f(\mathbf{x})-\mathbf{x}\|\leq \frac{\lambda^{n}}{1-\lambda}\|f(\mathbf{x})-\mathbf{x}\|\end{aligned}\]</span> 所以 <span class="math inline">\(\left\{\mathbf{x}_{n}\right\}\)</span> 是 Cauchy 列, 从而存在 <span class="math inline">\(\mathbf{x}^{*} \in \mathbb{R}^{m}\)</span> 使得 <span class="math inline">\(\lim\limits_{n \rightarrow+\infty} \mathbf{x}_{n}=\mathbf{x}^{*}\)</span> 。 因为 <span class="math inline">\(E\)</span> 是闭集, 所以 <span class="math inline">\(\mathbf{x}^{*} \in E\)</span> 。 <span class="math display">\[\begin{aligned}\left\|f\left(\mathbf{x}^{*}\right)-\mathbf{x}^{*}\right\| &amp; \leq\left\|f\left(\mathbf{x}^{*}\right)-f\left(\mathbf{x}_{n}\right)\right\|+\left\|f\left(\mathbf{x}_{n}\right)-\mathbf{x}^{*}\right\| \\&amp; \leq \lambda\left\|\mathbf{x}^{*}-\mathbf{x}_{n}\right\|+\left\|\mathbf{x}_{n+1}-\mathbf{x}^{*}\right\| \rightarrow 0, \quad n \rightarrow+\infty\end{aligned}\]</span> 所以 <span class="math inline">\(f\left(\mathbf{x}^{*}\right)=\mathbf{x}^{*}\)</span> 。让最初的不等式中 <span class="math inline">\(p \rightarrow+\infty\)</span>, 得到 <span class="math display">\[\left\|\mathbf{x}^{*}-\mathbf{x}_{n}\right\| \leq \frac{\lambda^{n}}{1-\lambda}\|f(\mathbf{x})-\mathbf{x}\|_{\circ}\]</span> 证明<strong>矩阵求逆是连续映射</strong>：</p><blockquote><p>引理：只要 <span class="math inline">\(\|B\|&lt;1\)</span>，有 <span class="math inline">\(I-B\)</span> 可逆，且有 <span class="math inline">\(\|(I-B)^{-1}-I\|\leq \dfrac{\|B\|}{1-\|B\|}\)</span></p><p>对 <span class="math inline">\((I-B)(I+C)=I\Longrightarrow C=B+BC\)</span>，考虑映射 <span class="math inline">\(f(C)=B+BC\)</span>，其满足压缩映射（<span class="math inline">\(\|B\|=\lambda&lt;1\)</span>） <span class="math display">\[\|f(C_1)-f(C_2)\|=\|B(C_1-C_2)\|\leq \|B\|\|C_1-C_2\|\]</span> 从而 <span class="math inline">\(\exists\ ! \ C_0,s.t.C=B+BC\)</span>，<span class="math inline">\(I-B\)</span> 可逆，且有 <span class="math display">\[\begin{gathered}\|C\|=\|B+BC\|\leq \|B\|\|I+C\|\leq\|B\|(1+\|C\|)\quad\\ \|(I-B)^{-1}-I\|\leq \dfrac{\|B\|}{1-\|B\|}\therefore\ A\ 可逆\ \mbox{and}\  \|\small \Delta \normalsize A\|&lt;\dfrac{1}{\|A^{-1}\|}\Longrightarrow A+\small \Delta \normalsize A\ 可逆\end{gathered}\]</span></p></blockquote><p>对于小扰动，总能被 <span class="math inline">\(\|\small \Delta \normalsize A\|\)</span> 控制，从而求逆是连续映射 <span class="math display">\[\begin{gathered}\left\|(A+\Delta A)^{-1}-A^{-1}\right\|=\left\|\left(I+A^{-1} \Delta A\right)^{-1} A^{-1}-A^{-1}\right\| \\ \leq\left\|A^{-1}\right\|\left\|\left(I+A^{-1} \Delta A\right)^{-1}-I\right\|\leq \frac{\left\|A^{-1}\right\|^{2}\|\Delta A\|}{1-\left\|A^{-1}\right\|\|\Delta A\|}\end{gathered}\]</span> <strong>道路连通集</strong>：对任意 <span class="math inline">\(\mathbf{x}, \mathbf{y} \in E\)</span>, 存在连续映射 <span class="math inline">\(f:[0,1] \rightarrow \mathbb{R}^{m}\)</span> 使得 <span class="math inline">\(f(0)=\mathbf{x}, f(1)=\mathbf{y}\)</span>, 且对任意 $0 t , f(t) E $，下图均为道路连通集</p><p>​ <img src="https://pic.imgdb.cn/item/6215cc2f2ab3f51d9124d06a.jpg" style="zoom:50%;" /> <img src="https://pic.imgdb.cn/item/6215cb562ab3f51d9122e1d1.png" style="zoom:50%;" /></p><p>例：<span class="math inline">\(m\)</span> 阶可逆矩阵的全体不是道路连通的。由于 <span class="math inline">\(\det\)</span> 是连续函数，有 <span class="math inline">\(\det I=1,\det (-\mathbf{e}_1,\mathbf{e}_2,\cdots,\mathbf{e}_m)=-1\)</span></p><p>两者一定经过 <span class="math inline">\(0\)</span>（不可逆），从而不是连续函数</p><p>对平面上的点，使用字典序 <span class="math inline">\(\begin{cases}x_1&gt;x_2\\y_1&gt;y_2,\mbox{when}\  x_1=x_2\end{cases}\)</span>，<span class="math inline">\(Abel&gt;Direclet\)</span></p><p>二维或者更高维数线性空间中不存在一个全序，使得它空间中由范数给出的拓扑相容。只有一维数轴是满足的。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>多元微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多元微积分笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ComputerSystem note for the first class</title>
    <link href="/2022/02/21/Computer%20system%20note%EF%BC%88first%20week%EF%BC%89/"/>
    <url>/2022/02/21/Computer%20system%20note%EF%BC%88first%20week%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="classification-of-cs">Classification of CS</h1><ul><li>Theory</li><li>Algorithms for specific area</li><li>Build systems: hackers trying to write interesting software</li></ul><h2 id="problems-occured">Problems occured</h2><p><strong>Emergent properties</strong>: when combined together, problem exists. <span class="math inline">\(112bytes\to250bytes\)</span></p><p><strong>Propagation of Effects</strong>: Small mistake effect the whole.</p><p><strong>Incommensurate Scaliing</strong>: Non-linear extension. Equaling enlarge the animal is wrong. Ipv4-&gt;Ipv6</p><p><strong>Trade-offs</strong>: Waterbed effect</p><h2 id="solutions">Solutions</h2><ol type="1"><li><strong>Modularity</strong>: <span class="math inline">\(\mbox{Bugcount}\sim N,\mbox{Dugtime}\sim N^2\)</span>，</li></ol><p>if have <span class="math inline">\(k\)</span> modules, then <span class="math inline">\(\mbox{Bugtime }\sim(\dfrac{N}{k})^2\cdot k=\dfrac{N^2}{k}\)</span></p><ol start="2" type="1"><li><p><strong>Abstraction</strong>: <span class="math inline">\(\begin{cases}natural\  and\  effective\\fewer \ interactions\end{cases}\)</span> strong boundaries. E.g: OOP, Client and service, Virtualization</p></li><li><p><strong>Layering</strong>: only interact with the same layer and the layer under or on it. OSI seven layers <span class="math inline">\(\to\)</span> TCP/IP</p></li></ol><p>CPU,Chip <span class="math inline">\(\to\)</span> ISA <span class="math inline">\(\to\)</span> Software <span class="math inline">\(\large \mbox{decouple}\)</span></p><ol start="4" type="1"><li><strong>Hierachy</strong>: small systems make up the larger one.</li></ol><p>Design for iteration</p><p>Waterfall to Agile model</p><p><strong>麻省理工法（好事）</strong>：简化、正确、持续、完整，样样都好 <span class="math inline">\(LISP\)</span> 系统，大型系统、“宝石”系统</p><p><strong>新泽西方法（坏事亦好）</strong>：<span class="math inline">\(\large\begin{cases}简洁:\ 实现&gt;连接\\正确性: \ 简洁&gt;准确\\持续:\ 简洁&gt;持续,\ 减少引入不常见情形\\完整:\ 简洁&gt;完整,(\ \exists \ 简洁\ )\ 完整&gt;持续\end{cases}\)</span> <span class="math inline">\(\mbox{Unix}/C\)</span> 为典型，<strong>通用性</strong>强</p><p>对于 <span class="math inline">\(PC\)</span> 机故障，<span class="math inline">\(MIT\)</span> 工程师函数实现简单，连接困难；<span class="math inline">\(Unix\)</span> 工程师采用随机报错的方式解决问题</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>计算机系统研讨</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统研讨笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calculus-A2-homework-for-Chapter-one（made in winter vacation in 2022）</title>
    <link href="/2022/02/20/Math/Calculus/Calculus%20A2%20homework%20for%20Chapter%20one%EF%BC%88made%20in%20winter%20vacation%EF%BC%89/"/>
    <url>/2022/02/20/Math/Calculus/Calculus%20A2%20homework%20for%20Chapter%20one%EF%BC%88made%20in%20winter%20vacation%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="微积分wxf第一章作业">微积分WXF第一章作业</h1><h2 id="习题1.7">习题1.7</h2><h4 id="section">1(1)</h4><p>解：抛物面方程 <span class="math inline">\(f(x,y,z)=x^2+y^2-z=0\)</span> 求其一阶偏导得到切平面方程 <span class="math display">\[z=5+\dfrac{\partial z}{\partial x}(x-1)+\dfrac{\partial z}{\partial y}(y-2)=5+2(x-1)+4(y-2)=2x+4y-5\]</span> 法线方程为 <span class="math display">\[\dfrac{x-1}{2}=\dfrac{y-2}{4}=\dfrac{z-5}{-1}\]</span> #### 1(2)</p><p>解：曲面方程 <span class="math inline">\(f(x,y,z)=(2a^2-z^2)x^2-a^2y^2=0\)</span>，代入一阶导得切平面方程 <span class="math display">\[\dfrac{\partial f}{\partial x}(x-a)+\dfrac{\partial f}{\partial y}(y-a)+\dfrac{\partial f}{\partial z}(z-a)=2a^3(x-a)-2a^3(y-a)-2a^3(z-a)=0\]</span> 整理得 <span class="math inline">\(x-y-z+a=0\)</span> 为切平面方程，法线方程为</p><p><span class="math display">\[\dfrac{x-a}{1}=\dfrac{y-a}{-1}=\dfrac{z-a}{-1}\]</span></p><h4 id="section-1">1(5)</h4><p>解：对于 <span class="math inline">\(u,v\)</span> 两个参数求偏导得对应参数切向量 <span class="math display">\[\vec{l}_u=(\dfrac{\partial x}{\partial u},\dfrac{\partial y}{\partial u},\dfrac{\partial z}{\partial u})=(1,2u,3u^2)=(1,2,3)\\\vec{l}_v=(\dfrac{\partial x}{\partial v},\dfrac{\partial y}{\partial v},\dfrac{\partial z}{\partial v})=(1,2v,3v^2)=(1,4,12)\\\]</span> 从而法向量为 <span class="math inline">\(\vec{n}=\vec{l}_u\times \vec{l}_v=(12,-9,2)\)</span>，故法平面方程 <span class="math display">\[12(x-2)-9(y-5)+2(z-9)=0\]</span> 法线方程 <span class="math display">\[\dfrac{x-2}{12}=\dfrac{y-5}{-9}=\dfrac{z-9}{2}\]</span></p><h4 id="section-2">5</h4><p>解：对两个曲面 <span class="math inline">\(f(x,y,z)=x^2+y^2+z^2-6=0\)</span> 和 <span class="math inline">\(g(x,y,z)=x+y+z=0\)</span> 分别求解法向量 <span class="math display">\[\vec{n}_1=(\dfrac{\partial f}{\partial x},\dfrac{\partial f}{\partial y},\dfrac{\partial f}{\partial z})=(2x,2y,2z)=(2,-4,2)\\\vec{n}_2=(\dfrac{\partial g}{\partial x},\dfrac{\partial g}{\partial y},\dfrac{\partial g}{\partial z})=(1,1,1)\]</span> 从而曲线的切线方向向量和切平面的法向量均为 <span class="math display">\[\vec{n}=\vec{l}=\vec{n}_1\times\vec{n}_2=(-6,0,6)\]</span> 则切线方程为 <span class="math inline">\(\dfrac{x-1}{1}=\dfrac{z-1}{-1},y=-2\)</span>，切平面为 <span class="math inline">\(-(x-1)+(z-1)=0\)</span>，即 <span class="math inline">\(x=z\)</span></p><h4 id="section-3">7</h4><p>证明：曲面 <span class="math inline">\(f(x,y,z)=0\)</span> 在 <span class="math inline">\((x_0,y_0,z_0)\)</span> 处单位法向量 <span class="math display">\[\vec{n_0}=\dfrac{(\dfrac{\partial f}{\partial x},\dfrac{\partial f}{\partial y},\dfrac{\partial f}{\partial z})}{\sqrt{(\dfrac{\partial f}{\partial x})^2+(\dfrac{\partial f}{\partial y})^2+(\dfrac{\partial f}{\partial z})^2}}\]</span> 从而切平面 <span class="math inline">\(\boldsymbol \alpha\)</span> 方程为 <span class="math display">\[\vec{n_0}\cdot (x-x_0,y-y_0,z-z_0))=0\]</span> 对给定的切平面内一条直线，设其单位方向向量为 <span class="math inline">\(\vec{l}\)</span>，可知 <span class="math inline">\(\vec{l}\in\boldsymbol \alpha\)</span>，从而 <span class="math inline">\(\vec{l}\perp\vec{n_0}\)</span>，构造平面 <span class="math inline">\(\boldsymbol \beta\)</span> 以及空间曲线 <span class="math inline">\(S\)</span> <span class="math display">\[\vec{n_1}=\vec{l}\times \vec{n_0},\vec{n_1}\cdot (x-x_0,y-y_0,z-z_0)=0\]</span></p><p><span class="math display">\[S:\begin{equation}\left\{        \begin{array}{}        f(x,y,z)=0\\        \vec{n_1}\cdot (x-x_0,y-y_0,z-z_0)=0\\        \end{array}\right.\end{equation}\]</span></p><p>该曲线在 <span class="math inline">\((x_0,y_0,z_0)\)</span> 处的切线垂直两个曲面在该处的法向量，即 <span class="math display">\[\vec{l_t}=\vec{n_0}\times \vec{n_1}=\vec{n_0}\times(\vec{l}\times\vec{n_0})=(\vec{n_0}\cdot \vec{n_0})\vec{l}-(\vec{n_0}\cdot \vec{l})\vec{n_0}=1\cdot \vec{l}-0=\vec{l}\]</span> 其切线方向向量与原直线相同，且两者经过同一点 <span class="math inline">\((x_0,y_0,z_0)\)</span> ，结论得证</p><h2 id="习题1.8">习题1.8</h2><h4 id="section-4">1(3)</h4><p><span class="math display">\[\dfrac{\partial u}{\partial x}=\dfrac{1}{1+x+y+z}=1,\dfrac{\partial u}{\partial y}=\dfrac{1}{1+x+y+z}=1,\dfrac{\partial u}{\partial z}=\dfrac{1}{1+x+y+z}=1\]</span> 且有 <span class="math inline">\(Hesse\)</span> 矩阵为 <span class="math display">\[\begin{bmatrix}    \dfrac{\partial ^2 u}{\partial x^2} &amp;\dfrac{\partial ^2 u}{\partial x\partial y}&amp;\dfrac{\partial ^2 u}{\partial x\partial z}\\    \dfrac{\partial ^2 u}{\partial y\partial x} &amp;\dfrac{\partial ^2 u}{\partial y^2}&amp;\dfrac{\partial ^2 u}{\partial y\partial z}\\    \dfrac{\partial ^2 u}{\partial z\partial x}&amp;\dfrac{\partial ^2 u}{\partial z\partial y}&amp;\dfrac{\partial ^2 u}{\partial z^2}\end{bmatrix}=\dfrac{-1}{(1+x+y+z)^2}\cdot \begin{bmatrix}     1 &amp;1 &amp;1\\1 &amp;1 &amp;1\\1 &amp;1 &amp;1\\\end{bmatrix}=\begin{bmatrix}     -1 &amp;-1 &amp;-1\\-1 &amp;-1 &amp;-1\\-1 &amp;-1 &amp;-1\\\end{bmatrix}\]</span> 则其展开为 <span class="math display">\[u=0+x+y+z-\dfrac{1}{2}x^2-\dfrac{1}{2}y^2-\dfrac{1}{2}z^2-2(\dfrac{1}{2}xy+\dfrac{1}{2}xz+\dfrac{1}{2}yz)+o(x^2+y^2+z^2)\]</span> 则带有二阶 <span class="math inline">\(Peano\)</span> 余项的 <span class="math inline">\(Taylor\)</span> 公式为 <span class="math display">\[u=(x+y+z)-\dfrac{1}{2}(x+y+z)^2+o(x^2+y^2+z^2)\]</span></p><p>带有 <span class="math inline">\(Larange\)</span> 余项的 <span class="math inline">\(Taylor\)</span> 公式为 <span class="math display">\[u=x+y+z-\dfrac{1}{2}(\psi+\eta+\alpha)^2\ \ where\ \psi,\eta,\alpha\in[0,1]\]</span></p><h4 id="section-5">2(1)</h4><p>解：<span class="math inline">\(z=x^y\)</span>，有一阶导： <span class="math display">\[\dfrac{\partial z}{\partial x}=y\cdot x^{y-1}=1,\dfrac{\partial z}{\partial y}=\ln (x)\cdot x^y=0\]</span> 二阶导： <span class="math display">\[\dfrac{\partial^2 z}{\partial x^2}=y(y-1)\cdot x^{y-2}=0,\dfrac{\partial ^2 z}{\partial y^2}=\ln ^2(x)\cdot x^y=0,\dfrac{\partial ^2 z}{\partial x\partial y}=x^{y-1}+y\ln x\cdot x^{y-1}=1\]</span> 三阶导： <span class="math display">\[\dfrac{\partial ^3 z}{\partial x^3}=0,\dfrac{\partial ^3 z}{\partial x^2\partial y}=(y-1)x^{y-1}+y\cdot x^{y-2}+y(y-1)\ln x\cdot x^{y-2}=1\]</span></p><p><span class="math display">\[\dfrac{\partial ^3 z}{\partial x\partial y^2}=2\dfrac{\ln x}{x}\cdot x^y+y\ln ^2(x)\cdot x^{y-1}=0,\dfrac{\partial ^3 z}{\partial y^3}=\ln^3 (x)\cdot x^{y}=0\]</span></p><p>从而展开有 <span class="math display">\[z=1+(\dfrac{\partial }{\partial x}+\dfrac{\partial }{\partial y})z+\dfrac{1}{2!}(\dfrac{\partial }{\partial x}+\dfrac{\partial }{\partial y})^2z+\dfrac{1}{3!}(\dfrac{\partial }{\partial x}+\dfrac{\partial }{\partial y})^3z\\ =1+(x-1)+(x-1)(y-1)+\dfrac{1}{2}(x-1)^2(y-1)\]</span> 代入计算有 <span class="math display">\[1.1^{1.02}=1.1+0.1\cdot 0.02+\dfrac{1}{2}\cdot 0.01\cdot0.02=1.1021\]</span> 这与实际值 <span class="math inline">\(1.1^{1.02}\approx1.1020988237128237\)</span>，相对误差为 <span class="math inline">\(-1.07\cdot 10^{-6}\)</span></p><h4 id="section-6">2(2)</h4><p>解：<span class="math inline">\(z=\dfrac{cosx}{cosy}\)</span>，有一阶导： <span class="math display">\[\dfrac{\partial z}{\partial x}=\dfrac{-sinx}{cosy}=0,\dfrac{\partial z}{\partial y}=\dfrac{cosx\cdot siny}{cos^2y}=0\]</span> 二阶导： <span class="math display">\[\dfrac{\partial^2 z}{\partial x^2}=\dfrac{-cosx}{cosy}=-1,\dfrac{\partial ^2 z}{\partial y^2}=cosx\cdot \dfrac{cos^2y+2sin^2y}{cos^3y}=1,\dfrac{\partial ^2 z}{\partial x\partial y}=\dfrac{-sinx\cdot siny}{cos^2y}=0\]</span> 从而展开有 <span class="math display">\[z=1+(\dfrac{\partial }{\partial x}+\dfrac{\partial }{\partial y})z+\dfrac{1}{2!}(\dfrac{\partial }{\partial x}+\dfrac{\partial }{\partial y})^2z=1+\dfrac{1}{2}(-1)\cdot x^2+\dfrac{1}{2}y^2=1+\dfrac{1}{2}(y^2-x^2)\]</span></p><h4 id="section-7">2(3)</h4><p>解：<span class="math inline">\(z=e^{-x}\ln(1+y)\)</span>，有一阶导： <span class="math display">\[\dfrac{\partial z}{\partial x}=-e^{-x}\ln(1+y)=0,\dfrac{\partial z}{\partial y}=e^{-x}\cdot \dfrac{1}{1+y}=1\]</span> 二阶导： <span class="math display">\[\dfrac{\partial^2 z}{\partial x^2}=e^{-x}\ln(1+y)=0,\dfrac{\partial ^2 z}{\partial y^2}=-e^{-x}\cdot \dfrac{1}{(1+y)^2}=-1,\dfrac{\partial ^2 z}{\partial x\partial y}=-e^{-x}\cdot \dfrac{1}{1+y}=-1\]</span> 从而展开有 <span class="math display">\[z=1+(\dfrac{\partial }{\partial x}+\dfrac{\partial }{\partial y})z+\dfrac{1}{2!}(\dfrac{\partial }{\partial x}+\dfrac{\partial }{\partial y})^2z=y+\dfrac{1}{2}(-y^2-2\cdot xy)=\dfrac{1}{2}y(2-y-2x)\]</span></p><h2 id="习题1.9">习题1.9</h2><h4 id="section-8">1(2)</h4><p>对二元函数变形有 <span class="math display">\[u=e^{2x}(x+y^2+2y)=e^{2x}(y+1)^2+e^{2x}(x-1)\geq0+g(x)\]</span> 其中一元函数 <span class="math inline">\(g(x)\)</span> 有 <span class="math display">\[\dfrac{dg(x)}{dx}=e^{2x}(2x-2+1)=e^{2x}(2x-1)\]</span> 当<span class="math inline">\(x\in(-\infty,\dfrac{1}{2})\)</span>时，<span class="math inline">\(g(x)\)</span>单调递增，<span class="math inline">\(x\in(\dfrac{1}{2}，+\infty)\)</span>时，<span class="math inline">\(g(x)\)</span>单调递减</p><p>从而 <span class="math inline">\((\dfrac{1}{2},-1)\)</span> 为原函数的最小值，则对 <span class="math inline">\((\dfrac{1}{2},-1)\)</span> 领域的点集均有 <span class="math inline">\(u(x,y)\geq u(\dfrac{1}{2},-1)=-\dfrac{1}{2}e\)</span></p><p>则 <span class="math inline">\((\dfrac{1}{2},-1)\)</span> 为极小值点，极小值为 <span class="math inline">\(-\dfrac{1}{2}e\)</span></p><h4 id="section-9">1(3)</h4><p>由对该三元函数求一阶导得 <span class="math display">\[\dfrac{\partial u}{\partial x}=cosx-cos(x+y+z),\dfrac{\partial u}{\partial y}=cosy-cos(x+y+z),\dfrac{\partial u}{\partial z}=cosz-cos(x+y+z)\]</span> 当三者均为 <span class="math inline">\(0\)</span> 时有 <span class="math display">\[cosx=cosy=cosz=cos(x+y+z),x,y,z\in[0,{\pi}]\]</span> 由于 <span class="math inline">\(cosx\)</span> 函数在 <span class="math inline">\([0,\pi]\)</span> 区间上是单调的，从而 <span class="math inline">\(x=y=z\)</span>，代入三倍角公式有 <span class="math display">\[cosx=cos(3x)=-3cosx+4cos^3x\]</span> 求二阶导 <span class="math display">\[\dfrac{\partial ^2 u}{\partial x^2}=-sinx+sin(x+y+z),\dfrac{\partial ^2 u}{\partial x \partial y}=sin(x+y+z),\dfrac{\partial ^2 u}{\partial x\partial z}=sin(x+y+z)\\\dfrac{\partial ^2 u}{\partial ^2y}=-siny+sin(x+y+z),\dfrac{\partial ^2 u}{\partial y\partial z}=sin(x+y+z),\dfrac{\partial ^2 u}{\partial z^2}=-sinz+sin(x+y+z)\\\]</span> 解得 <span class="math inline">\(x=0\ 或\ \dfrac{\pi}{2}\)</span>，而当 <span class="math inline">\(x=0\)</span> 为边界点，不可能为极值点，代入 <span class="math inline">\(x=\dfrac{\pi}{2}\)</span> 计算 <span class="math inline">\(Hesse\)</span> 矩阵有 <span class="math display">\[x=\dfrac{\pi}{2},\begin{bmatrix}    \dfrac{\partial ^2 u}{\partial x^2} &amp;\dfrac{\partial ^2 u}{\partial x\partial y}&amp;\dfrac{\partial ^2 u}{\partial x\partial z}\\    \dfrac{\partial ^2 u}{\partial y\partial x} &amp;\dfrac{\partial ^2 u}{\partial y^2}&amp;\dfrac{\partial ^2 u}{\partial y\partial z}\\    \dfrac{\partial ^2 u}{\partial z\partial x}&amp;\dfrac{\partial ^2 u}{\partial z\partial y}&amp;\dfrac{\partial ^2 u}{\partial z^2}\end{bmatrix}=\begin{bmatrix}-2&amp;-1&amp;-1\\-1&amp;-2&amp;-1\\-1&amp;-1&amp;-2\end{bmatrix}\]</span> 计算该矩阵的特征值 <span class="math display">\[\det(\boldsymbol H-\lambda \boldsymbol I)=\begin{vmatrix}-2-\lambda&amp;-1&amp;-1\\-1&amp;-2-\lambda&amp;-1\\-1&amp;-1&amp;-2-\lambda\end{vmatrix}=-(\lambda+1)^2(\lambda+4)，\lambda_1=\lambda_2=-1,\lambda_3=-4\]</span> 从而 <span class="math inline">\(\boldsymbol H\)</span> 矩阵负定，从而 <span class="math inline">\(u(x,y,z)=sinx+siny+sinz-sin(x+y+z)\)</span> 在 <span class="math inline">\((\dfrac{\pi}{2},\dfrac{\pi}{2},\dfrac{\pi}{2})\)</span> 有极大值 <span class="math inline">\(4\)</span></p><blockquote><p>其实该函数 <span class="math inline">\(u(x,y,z)=sinx+siny+sinz-sin(x+y+z)\leq1+1+1+1=4\)</span> 且可以取到</p><p>对应的点为 <span class="math inline">\((\dfrac{\pi}{2},\dfrac{\pi}{2},\dfrac{\pi}{2})\)</span> 在区间内，从而有极大值（最大值）4</p></blockquote><h4 id="section-10">2</h4><p>解：由 <span class="math inline">\(f(x,y,z)=2x^2+2y^2+z^2+8xz-z+8=0\)</span>，全微分有</p><p><span class="math display">\[df=4xdx+4ydy+2zdz+8(xdz+zdx)-dz=0\]</span> 计算一阶偏导数得 <span class="math display">\[\dfrac{\partial z}{\partial x}=-\dfrac{4x+8z}{2z+8x-1},\dfrac{\partial z}{\partial y}=-\dfrac{4y}{2z+8x-1},\]</span> 两者等于 <span class="math inline">\(0\)</span> 时得 <span class="math display">\[\begin{equation}\left\{        \begin{array}{}        x+2z=0&amp;\\        4y=0&amp;\\        f(x,y,z)=0&amp;\\        \end{array}\right.\end{equation}\]</span> 解得 <span class="math inline">\((x,y,z)=(-2,0,1)\ 或\ (\dfrac{16}{7},0,-\dfrac{8}{7})\)</span></p><p>代入一阶导等于 <span class="math inline">\(0\)</span> ，简化计算 <span class="math inline">\(Hesse\)</span> 矩阵得 <span class="math display">\[\dfrac{\partial ^2z}{\partial x^2}=\dfrac{56z+4}{(2z+8x-1)^2}+\dfrac{-56x+8}{(2z+8x-1)^2}\dfrac{\partial z}{\partial x}=\dfrac{56z+4}{(2z+8x-1)^2}\\\dfrac{\partial ^2z}{\partial y^2}=\dfrac{-4}{(2z+8x-1)}+\dfrac{32y}{(2z+8x-1)^2}\dfrac{\partial x}{\partial y}=\dfrac{-4}{(2z+8x-1)}\\\dfrac{\partial ^2z}{\partial y\partial x}=\dfrac{\partial }{\partial y}(-\dfrac{4x+8z}{2z+8x-1})=\dfrac{56z+4}{(2z+8x-1)^2}\dfrac{\partial x}{\partial y}=0\]</span> 代入 <span class="math inline">\((-2,0,1)\)</span> 点计算 <span class="math inline">\(Hesse\)</span> 矩阵，该矩阵为正定矩阵 <span class="math display">\[\begin{bmatrix}\dfrac{\partial ^2z}{\partial x^2}&amp;\dfrac{\partial ^2z}{\partial x\partial y}\\\dfrac{\partial ^2z}{\partial y\partial x}&amp;\dfrac{\partial ^2z}{\partial y^2}\end{bmatrix}=\begin{bmatrix}\dfrac{4}{15}&amp;0\\0&amp;\dfrac{4}{15}\end{bmatrix}\]</span></p><p>代入 <span class="math inline">\((\dfrac{16}{7},0,-\dfrac{8}{7})\)</span> 点计算 <span class="math inline">\(Hesse\)</span> 矩阵，该矩阵为负定矩阵 <span class="math display">\[\begin{bmatrix}\dfrac{\partial ^2z}{\partial x^2}&amp;\dfrac{\partial ^2z}{\partial x\partial y}\\\dfrac{\partial ^2z}{\partial y\partial x}&amp;\dfrac{\partial ^2z}{\partial y^2}\end{bmatrix}=\begin{bmatrix}-\dfrac{4}{15}&amp;0\\0&amp;-\dfrac{4}{15}\end{bmatrix}\]</span> 从而 <span class="math inline">\(z=z(x,y)\)</span> 有极大值 <span class="math inline">\(-\dfrac{8}{7}\)</span>，有极小值 <span class="math inline">\(1\)</span></p><blockquote><p>该曲面为双叶双曲面，图像如下，可以看出极大值在下方，极小值在上方</p></blockquote><p><img src="https://pic.imgdb.cn/item/620d29d22ab3f51d91ed448e.jpg" style="zoom:67%;" /></p><h4 id="section-11">4(1)</h4><p>解：由 <span class="math inline">\(z(x,y)=(x^2+2y^2)e^{-x^2-y^2}\)</span> 求一阶导 <span class="math display">\[\dfrac{\partial z}{\partial x}=(2x+(x^2+2y^2)\cdot (-2x))e^{-x^2-y^2}=2x(1-x^2-2y^2)e^{-x^2-y^2}\\\dfrac{\partial z}{\partial y}=(4y+(x^2+2y^2)\cdot (-2y))e^{-x^2-y^2}=2y(2-x^2-2y^2)e^{-x^2-y^2}\]</span> 当 <span class="math inline">\(\dfrac{\partial z}{\partial x}=\dfrac{\partial z}{\partial y}=0\)</span> 解得 <span class="math inline">\((x,y)=(0,0),(0,1),(0,-1),(1,0),(-1,0)\)</span> ，计算 <span class="math inline">\(Hesse\)</span> 矩阵得 <span class="math display">\[\begin{bmatrix}\dfrac{\partial ^2z}{\partial x^2}&amp;\dfrac{\partial ^2z}{\partial x\partial y}\\\dfrac{\partial ^2z}{\partial y\partial x}&amp;\dfrac{\partial ^2z}{\partial y^2}\end{bmatrix}=e^{-x^2-y^2}\begin{bmatrix}2(1-5x^2-2y^2-2x^2(x^2+2y^2))&amp;-4xy(3-x^2-2y^2)\\-4xy(3-x^2-2y^2)&amp;2(2-x^2-10y^2+2y^2(x^2+2y^2))\end{bmatrix}\]</span> 代入分别计算得 <span class="math display">\[\boldsymbol H_1=\begin{bmatrix}2&amp;0\\0&amp;4 \end{bmatrix},\boldsymbol H_2=\begin{bmatrix}-2&amp;0\\0&amp;-8 \end{bmatrix},\boldsymbol H_3=\begin{bmatrix}-2&amp;0\\0&amp;-8 \end{bmatrix},\boldsymbol H_4=\begin{bmatrix}-8&amp;0\\0&amp;2 \end{bmatrix},\boldsymbol H_5=\begin{bmatrix}-8&amp;0\\0&amp;2 \end{bmatrix},\]</span> 由对角矩阵的特征值即为对角元得只有 <span class="math inline">\(\boldsymbol H_1,\boldsymbol H_2\)</span> 满足条件，两者分别为正定矩阵和负定矩阵，则</p><p>当 <span class="math inline">\(x=y=0\)</span> 时，函数取极小值 <span class="math inline">\(0\)</span>，且 <span class="math inline">\(0\)</span> 为最小值；当 <span class="math inline">\(x=0,y=\pm 1\)</span> 时，函数取极大值，最大值为 <span class="math inline">\(\dfrac{2}{e}\)</span></p><blockquote><p>由于多元函数连续可导，可以代入五组解后求最大值最小值</p><p>也可以直接放缩，<span class="math inline">\(u(x,y)\geq0\)</span>，<span class="math inline">\(u(x,y)=2(x^2+y^2)e^{-x^2-y^2}-y^2e^{-x^2-y^2}\leq2\rho^2e^{-\rho^2}\leq\dfrac{2}{e}\)</span>，得解</p></blockquote><h4 id="section-12">4(2)</h4><p>解：对 <span class="math inline">\(z(x,y)=xy(4-x-y)\)</span> 求一阶导 <span class="math display">\[\dfrac{\partial z}{\partial x}=y(4-x-y)-xy=y(4-2x-y)\\\dfrac{\partial z}{\partial y}=x(4-x-y)-xy=x(4-x-2y)\\\]</span> 当 <span class="math inline">\(\dfrac{\partial z}{\partial x}=\dfrac{\partial z}{\partial y}=0\)</span> 时解得 <span class="math inline">\(x=y=\dfrac{4}{3}\)</span>，计算 <span class="math inline">\(Hesse\)</span> 矩阵得 <span class="math display">\[\boldsymbol H=\begin{bmatrix}\dfrac{\partial ^2z}{\partial x^2}&amp;\dfrac{\partial ^2z}{\partial x\partial y}\\\dfrac{\partial ^2z}{\partial y\partial x}&amp;\dfrac{\partial ^2z}{\partial y^2}\end{bmatrix}=\begin{bmatrix}-2y&amp;4-2x-2y\\4-2x-2y&amp;-2x\end{bmatrix}=\begin{bmatrix}-\dfrac{8}{3}&amp;-\dfrac{4}{3}\\-\dfrac{4}{3}&amp;-\dfrac{8}{3}\\\end{bmatrix}\]</span> 计算其特征值有 <span class="math display">\[\det(\boldsymbol H-\lambda\boldsymbol I)=\begin{bmatrix}-\dfrac{8}{3}-\lambda&amp;-\dfrac{4}{3}\\-\dfrac{4}{3}&amp;-\dfrac{8}{3}-\lambda\\\end{bmatrix}=(\lambda+\dfrac{8}{3})^2-\dfrac{16}{9}=0\]</span> 解得 <span class="math inline">\(\lambda_1=-\dfrac{4}{3},\lambda_2=-4\)</span>，从而 <span class="math inline">\(\boldsymbol H\)</span> 为负定矩阵，对应极大值点，有 <span class="math inline">\(z(\dfrac{4}{3},\dfrac{4}{3})=\dfrac{64}{27}\)</span>，代入边界点计算 <span class="math display">\[y=0\to z(x,0)=0\\x=1\to z(1,y)=y(3-y),y\in[0,5],y(3-y)\in[-10,\dfrac{9}{4}]\\x+y=6\to z(x,6-x)=-2x(6-x),x\in[1,6],-2x(6-x)\in[-18,0]\]</span> 从而 <span class="math inline">\(z(x,y)=xy(4-x-y)\)</span> 的最大值为 <span class="math inline">\(\dfrac{64}{27}\)</span>，最小值为 <span class="math inline">\(-18\)</span></p><h4 id="section-13">14</h4><p>解：设二次多项式曲线为 <span class="math inline">\(\hat{y}=ax^2+bx+c\)</span> ，有距离平方和为 <span class="math display">\[f(a,b,c)=\sum_i|d|^2=\sum_i(ax_i^2+bx_i+c-y_i)^2\]</span> 调整 <span class="math inline">\(a,b,c\)</span> 三个参数使得函数值最小，则对三参数求偏导等于 <span class="math inline">\(0\)</span> <span class="math display">\[\dfrac{\partial f}{\partial a}=2\sum_ix_i^2(ax_i^2+bx_i+c-y_i)=0\\\dfrac{\partial f}{\partial b}=2\sum_ix_i(ax_i^2+bx_i+c-y_i)=0\\\dfrac{\partial f}{\partial c}=2\sum_i(ax_i^2+bx_i+c-y_i)=0\\\]</span> 写成矩阵的形式有 <span class="math display">\[\begin{bmatrix}\sum_i x_i^4&amp;\sum_i x_i^3&amp;\sum_i x_i^2\\\sum_i x_i^3&amp;\sum_i x_i^2&amp;\sum_i x_i\\\sum_i x_i^2&amp;\sum_i x_i&amp;\sum_i 1\end{bmatrix}\begin{bmatrix}a\\b\\c\end{bmatrix}=\begin{bmatrix}\sum_i x_i^2y_i\\\sum_i x_iy_i\\\sum_i y_i\\\end{bmatrix}\]</span> 代入数据得 <span class="math display">\[\begin{bmatrix}979&amp;225&amp;55\\225&amp;55&amp;15\\55&amp;15&amp;5\end{bmatrix}\begin{bmatrix}a\\b\\c\end{bmatrix}=\begin{bmatrix}370.8\\94\\28\end{bmatrix}\]</span> 高斯消元解得 <span class="math inline">\((a,b,c)=(\dfrac{1}{5},-\dfrac{1}{5},4)\)</span>，即 <span class="math inline">\(\hat{y}=\dfrac{1}{5}x^2-\dfrac{1}{5}x+4\)</span>，作图如下</p><p>代入 <span class="math inline">\(x=12\)</span> 得 <span class="math inline">\(\hat{y}=30.4\)</span> ，由此估计12月份的营业额为 <span class="math inline">\(30.4\)</span> 百万元</p><p><img src="https://pic.imgdb.cn/item/620d29d22ab3f51d91ed4493.png" style="zoom:80%;" /></p><h2 id="第一章总复习题">第一章总复习题</h2><h4 id="section-14">16</h4><p>证明：在约束条件 <span class="math inline">\(g(x,y)=xy-1=0\)</span> 下求 <span class="math inline">\(f(x,y)=\dfrac{1}{p}x^p+\dfrac{1}{q}y^q\)</span> 的最小值，作 <span class="math inline">\(Lagrange\)</span> 函数 <span class="math display">\[L=\dfrac{1}{p}x^p+\dfrac{1}{q}y^q+\lambda(xy-1)\]</span> 则计算偏导数等于 <span class="math inline">\(0\)</span> 得 <span class="math display">\[\dfrac{\partial L}{\partial x}=x^{p-1}+\lambda y=0,\dfrac{\partial L}{\partial y}=y^{q-1}+\lambda x=0\]</span> 有 <span class="math inline">\(\lambda=-\dfrac{x^{p-1}}{y}=-\dfrac{y^{q-1}}{x}\)</span>，得 <span class="math inline">\(x^{p}=y^{q}=y^{-p}\)</span>，由于 <span class="math inline">\(p,q&gt;0\)</span> 则此时 <span class="math inline">\(x=y=1\)</span> 最小值为 <span class="math inline">\(\dfrac{1}{p}+\dfrac{1}{q}\)</span></p><p>令 <span class="math inline">\(X=\dfrac{x}{(xy)^{\frac{1}{p}}},Y=\dfrac{y}{(xy)^{\frac{1}{q}}}\)</span> 有 <span class="math inline">\(XY=1\)</span> 则由上述结论有 <span class="math inline">\(\dfrac{1}{p}X^p+\dfrac{1}{q}Y^q\geq\dfrac{1}{p}+\dfrac{1}{q}=1\)</span></p><p>回代得到 <span class="math inline">\(Young\)</span> 不等式 <span class="math inline">\(\dfrac{1}{p}x^p+\dfrac{1}{q}y^q\geq xy\)</span></p><h4 id="section-15">17</h4><p>由二维欧式空间距离定义，先固定 <span class="math inline">\(f(x,y)\)</span> 上的点 <span class="math inline">\((a,b)\)</span> ，变化 <span class="math inline">\(g(x,y)\)</span> 曲线上的点，作 <span class="math inline">\(Lagrange\)</span> 函数 <span class="math display">\[d=\sqrt{(x-a)^2+(y-b)^2}，L=\sqrt{(x-a)^2+(y-b)^2}+\lambda g(x,y)\]</span> 对 <span class="math inline">\(x,y\)</span> 求偏导数有 <span class="math display">\[\dfrac{\partial L}{\partial x}=\dfrac{x-a}{\sqrt{(x-a)^2+(y-b)^2}}+\lambda\dfrac{\partial g}{\partial x}=0\\\dfrac{\partial L}{\partial y}=\dfrac{y-b}{\sqrt{(x-a)^2+(y-b)^2}}+\lambda\dfrac{\partial g}{\partial y}=0\]</span> 消去 <span class="math inline">\(\lambda\)</span> 得 <span class="math inline">\(\dfrac{x-a}{y-b}=\dfrac{\dfrac{\partial g}{\partial x}}{\dfrac{\partial g}{\partial y} }=\dfrac{a-c}{b-d}\)</span>，由对称性得对 <span class="math inline">\(f(x,y)=0\)</span> 也成立，即 <span class="math inline">\(\dfrac{a-c}{b-d}=\dfrac{\dfrac{\partial g}{\partial x}}{\dfrac{\partial g}{\partial y}}=\dfrac{\dfrac{\partial f}{\partial x}}{\dfrac{\partial f}{\partial y}}\)</span></p><p>对椭圆 <span class="math inline">\(x^2+2xy+5y^2-16y=0\)</span> 和 <span class="math inline">\(x-y-8=0\)</span> 代入有方程组 <span class="math display">\[\begin{equation}\left\{        \begin{array}{}        \dfrac{a-c}{b-d}=\dfrac{2a+2b}{2a+10b-16}=-1\\        a^2+2ab+5b^2-16b=0\\        c-d-8=0        \end{array}\right.\end{equation}\]</span> 解得 <span class="math inline">\((a,b,c,d)=(-2+3\sqrt{2},2-\sqrt{2},4+\sqrt{2},-4+\sqrt{2}),(-2-3\sqrt{2},2+\sqrt{2},4-\sqrt{2},-4-\sqrt{2})\)</span></p><p>计算最小值有 <span class="math inline">\(d_{min}=6\sqrt{2}-4\)</span></p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
      <category>多元微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多元微积分作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
